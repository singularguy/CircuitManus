--- START: CircuitManusCore.py ---

# @FileName: circuitmanus.py
# @Version: V1.0.0 - 核心电路交互逻辑与DuckDuckGo搜索工具集 (深化修复ToolExecutor异步调用新)
# @Author: 您的专属程序员 (致力于构建稳定、清晰、可扩展的智能助手核心)
# @Date: [当前日期] - 深化修复ToolExecutor对异步工具的调用，确保协程被正确await。
# @License: MIT License
# @Description:
# ==============================================================================================
#  Manus 系统 V1.0.0 技术实现说明 (附带11个工具)
# ==============================================================================================
# (V1.0.0 变更日志:
#  - 针对ToolExecutor中异步工具返回协程对象而非执行结果的问题，进行了更直接的await调用修复。
#  - 强化日志，在ToolExecutor调用工具前后打印更多关于工具方法类型和返回类型的信息。
#  - 确保duckduckgo_search_tool的返回结构在所有路径下都符合预期。)
# ==============================================================================================

# --- 基础库导入 ---
import re
import os
import json
import time
import logging
import sys
import asyncio
import traceback
import inspect
import functools
from datetime import datetime, timezone
from typing import List, Dict, Any, Optional, Tuple, Set, Union, Callable, Awaitable
from uuid import uuid4
from zhipuai import ZhipuAI
import httpx
from duckduckgo_search import DDGS

# --- 全局异步事件循环 ---
try:
    loop = asyncio.get_running_loop()
except RuntimeError:
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

# --- 日志系统配置 ---
LOG_DIR = "WebUIAgentLogs"
try:
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)
except OSError as e:
    sys.stderr.write(f"严重错误: 无法创建日志目录 '{LOG_DIR}'. 错误信息: {e}\n")
    sys.stderr.write("文件日志功能可能不可用。程序将仅使用控制台日志继续运行。\n")

current_time_for_log = datetime.now()
# 更新日志文件名以反映版本
log_file_name = os.path.join(
    LOG_DIR,
    f"agent_log_v1_1_3_async_call_fix_{current_time_for_log.strftime('%Y%m%d_%H%M%S')}_{current_time_for_log.microsecond // 1000:03d}_P{os.getpid()}.log"
)

log_format = '%(asctime)s - %(name)s - %(levelname)s [%(module)s.%(funcName)s:%(lineno)d] - %(message)s'

console_handler = logging.StreamHandler(sys.stderr)
console_handler.setLevel(logging.DEBUG)
console_handler.setFormatter(logging.Formatter(log_format))

root_logger = logging.getLogger()
root_logger.setLevel(logging.DEBUG)
root_logger.addHandler(console_handler)

logger = logging.getLogger(__name__)

try:
    file_handler = logging.FileHandler(log_file_name, mode='a', encoding='utf-8')
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(logging.Formatter(log_format))
    root_logger.addHandler(file_handler)
    logger.info(f"文件日志配置成功。日志消息也将保存至: {os.path.abspath(log_file_name)}")
except Exception as e:
    logger.error(f"严重错误: 配置日志文件到 '{log_file_name}' 失败。错误信息: {e}", exc_info=True)
    logger.error("Agent 将仅使用控制台日志继续运行。")

logging.getLogger("zhipuai").setLevel(logging.WARNING)
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("duckduckgo_search").setLevel(logging.WARNING)


# --- 电路元件数据类 ---
class CircuitComponent:
    __slots__ = ['id', 'type', 'value']
    def __init__(self, component_id: str, component_type: str, value: Optional[str] = None):
        if not isinstance(component_id, str) or not component_id.strip():
            raise ValueError("元件 ID 必须是有效的非空字符串。")
        if not isinstance(component_type, str) or not component_type.strip():
            raise ValueError("元件类型必须是有效的非空字符串。")
        
        self.id: str = component_id.strip().upper()
        self.type: str = component_type.strip()
        self.value: Optional[str] = str(value).strip() if value is not None and str(value).strip() else None

    def __str__(self) -> str:
        value_str = f" (值: {self.value})" if self.value else ""
        return f"元件: {self.type} (ID: {self.id}){value_str}"

    def __repr__(self) -> str:
        return f"CircuitComponent(id='{self.id}', type='{self.type}', value={repr(self.value)})"

    def to_dict(self) -> Dict[str, Any]:
        return {"id": self.id, "type": self.type, "value": self.value}

# --- 电路实体类 ---
class Circuit:
    def __init__(self):
        logger.info("[Circuit] 初始化电路实体...")
        self.components: Dict[str, CircuitComponent] = {}
        self.connections: Set[Tuple[str, str]] = set()
        self._component_counters: Dict[str, int] = {
            'R': 0, 'L': 0, 'B': 0, 'S': 0, 'C': 0, 'V': 0, 'G': 0, 'U': 0, 'O': 0,
            'I': 0, 'A': 0, 'D': 0, 'P': 0, 'F': 0, 'H': 0,
            'T': 0, 'N': 0, 'IN': 0, 'OUT': 0,
            'SRCH': 0 
        }
        logger.info("[Circuit] 电路实体初始化完成。")

    def add_component(self, component: CircuitComponent):
        if component.id in self.components:
            raise ValueError(f"元件 ID '{component.id}' 已被占用。")
        self.components[component.id] = component
        logger.debug(f"[Circuit] 元件 '{component.id}' ({component.type}) 已添加到电路。")

    def remove_component(self, component_id: str) -> Tuple[Dict[str, Any], int]:
        comp_id_upper = component_id.strip().upper()
        if comp_id_upper not in self.components:
            raise ValueError(f"元件 '{comp_id_upper}' 在电路中不存在。")
        
        removed_component_details = self.components[comp_id_upper].to_dict()
        del self.components[comp_id_upper]
        
        connections_to_remove = {conn for conn in self.connections if comp_id_upper in conn}
        removed_connections_count = len(connections_to_remove)
        for conn in connections_to_remove:
            self.connections.remove(conn)
            logger.debug(f"[Circuit] 移除了涉及元件 '{comp_id_upper}' 的连接 {conn}。")
        
        logger.debug(f"[Circuit] 元件 '{comp_id_upper}' 及其相关 {removed_connections_count} 个连接已从电路中移除。")
        return removed_component_details, removed_connections_count


    def connect_components(self, id1: str, id2: str) -> bool:
        id1_upper = id1.strip().upper()
        id2_upper = id2.strip().upper()
        if id1_upper == id2_upper: raise ValueError(f"不能将元件 '{id1_upper}' 连接到它自己。")
        if id1_upper not in self.components: raise ValueError(f"元件 '{id1_upper}' 在电路中不存在。")
        if id2_upper not in self.components: raise ValueError(f"元件 '{id2_upper}' 在电路中不存在。")
        
        connection = tuple(sorted((id1_upper, id2_upper)))
        if connection in self.connections:
             logger.warning(f"[Circuit] 连接 '{id1_upper}' <--> '{id2_upper}' 已存在。")
             return False
        self.connections.add(connection)
        logger.debug(f"[Circuit] 添加了连接: {id1_upper} <--> {id2_upper}。")
        return True

    def disconnect_components(self, id1: str, id2: str) -> bool:
        id1_upper = id1.strip().upper()
        id2_upper = id2.strip().upper()
        connection = tuple(sorted((id1_upper, id2_upper)))
        if connection not in self.connections:
             logger.warning(f"[Circuit] 连接 '{id1_upper}' <--> '{id2_upper}' 不存在,无需断开。")
             return False
        self.connections.remove(connection)
        logger.debug(f"[Circuit] 断开了连接: {id1_upper} <--> {id2_upper}。")
        return True

    def get_state_description(self) -> str:
        logger.debug("[Circuit] 正在生成电路状态描述...")
        num_components = len(self.components)
        num_connections = len(self.connections)

        if num_components == 0 and num_connections == 0:
            return "【当前电路状态】: 电路为空。"

        desc_lines = ["【当前电路状态】:"]
        desc_lines.append(f"  - 元件 ({num_components}):")
        if self.components:
            sorted_ids = sorted(self.components.keys())
            for cid in sorted_ids:
                desc_lines.append(f"    - {str(self.components[cid])}")
        else:
            desc_lines.append("    (无)")

        desc_lines.append(f"  - 连接 ({num_connections}):")
        if self.connections:
            sorted_connections = sorted(list(self.connections))
            for c1, c2 in sorted_connections:
                desc_lines.append(f"    - {c1} <--> {c2}")
        else:
            desc_lines.append("    (无)")

        description = "\n".join(desc_lines)
        logger.debug("[Circuit] 电路状态描述生成完毕。")
        return description

    def generate_component_id(self, component_type: str) -> str:
        logger.debug(f"[Circuit] 正在为类型 '{component_type}' 生成唯一 ID...")
        type_map = {
            "resistor": "R", "电阻": "R", "capacitor": "C", "电容": "C",
            "battery": "B", "电池": "B", "voltage source": "V", "voltage": "V",
            "电压源": "V", "电压": "V", "led": "L", "发光二极管": "L", "switch": "S",
            "开关": "S", "ground": "G", "地": "G", "ic": "U", "chip": "U", "芯片": "U",
            "集成电路": "U", "inductor": "I", "电感": "I", "current source": "A",
            "电流源": "A", "diode": "D", "二极管": "D", "potentiometer": "P", "电位器": "P",
            "fuse": "F", "保险丝": "F", "header": "H", "排针": "H",
            "terminal": "T", "端子": "T", "connection point": "P", "连接点": "P",
            "node": "N", "节点": "N",
            "input": "IN", "输入": "IN", "output": "OUT", "输出": "OUT",
            "search_record": "SRCH", "搜索记录": "SRCH", 
            "component": "O", "元件": "O",
        }

        for code in type_map.values():
            if code not in self._component_counters:
                 self._component_counters[code] = 0

        cleaned_type = component_type.strip().lower()
        type_code = "O"
        best_match_len = 0

        if cleaned_type == "input": type_code = "IN"
        elif cleaned_type == "output": type_code = "OUT"
        elif cleaned_type == "ground" or cleaned_type == "地": type_code = "G"
        else:
            for keyword, code in type_map.items():
                if keyword in cleaned_type and len(keyword) > best_match_len:
                    type_code = code
                    best_match_len = len(keyword)

        if type_code == "O" and cleaned_type not in ["component", "元件"]:
             logger.warning(f"[Circuit] 未找到类型 '{component_type}' 的特定前缀,将使用通用前缀 'O'。")

        MAX_ID_ATTEMPTS = 10000
        for attempt in range(MAX_ID_ATTEMPTS):
            self._component_counters[type_code] += 1
            gen_id = f"{type_code}{self._component_counters[type_code]}"
            if gen_id not in self.components:
                logger.debug(f"[Circuit] 生成唯一 ID: '{gen_id}' (尝试 {attempt + 1})。")
                return gen_id
            logger.debug(f"[Circuit] ID '{gen_id}' 已存在,尝试下一个。(尝试 {attempt + 1})。")

        raise RuntimeError(f"未能为类型 '{component_type}' (代码 '{type_code}') 生成唯一 ID ({MAX_ID_ATTEMPTS} 次尝试后)。")

    def clear(self):
        logger.info("[Circuit] 正在清空电路状态...")
        comp_count = len(self.components)
        conn_count = len(self.connections)

        self.components = {}
        self.connections = set()
        self._component_counters = {k: 0 for k in self._component_counters}

        logger.info(f"[Circuit] 电路状态已清空 (移除了 {comp_count} 个元件, {conn_count} 个连接,并重置了所有 ID 计数器)。")

# --- 工具注册装饰器 ---
def register_tool(description: str, parameters: Dict[str, Any]):
    def decorator(func):
        func._tool_schema = {"description": description, "parameters": parameters}
        func._is_tool = True
        # functools.wraps is important to preserve metadata, especially for inspect.iscoroutinefunction
        @functools.wraps(func)
        async def async_wrapper(*args, **kwargs): # if original func is async
            return await func(*args, **kwargs)
        
        @functools.wraps(func)
        def sync_wrapper(*args, **kwargs): # if original func is sync
            return func(*args, **kwargs)

        if inspect.iscoroutinefunction(func):
            return async_wrapper
        else:
            return sync_wrapper
    return decorator

# --- 模块化组件: MemoryManager (记忆管理器) ---
class MemoryManager:
    def __init__(self, max_short_term_items: int = 30, max_long_term_items: int = 200):
        logger.info("[MemoryManager] 初始化记忆模块...")
        if max_short_term_items <= 1:
            raise ValueError("参数 'max_short_term_items' 必须大于 1。")

        self.max_short_term_items = max_short_term_items
        self.max_long_term_items = max_long_term_items
        self.short_term: List[Dict[str, Any]] = []
        self.long_term: List[str] = []
        self.circuit: Circuit = Circuit()

        logger.info(f"[MemoryManager] 记忆模块初始化完成。短期记忆上限: {max_short_term_items} 条, 长期记忆上限: {max_long_term_items} 条。")

    def add_to_short_term(self, message: Dict[str, Any]):
        logger.debug(f"[MemoryManager] 添加消息到短期记忆 (Role: {message.get('role', 'N/A')})。当前数量: {len(self.short_term)}。")
        self.short_term.append(message)
        current_size = len(self.short_term)
        if current_size > self.max_short_term_items:
            logger.debug(f"[MemoryManager] 短期记忆超限 ({current_size}/{self.max_short_term_items}),执行修剪...")
            items_to_remove_count = current_size - self.max_short_term_items
            non_system_indices = [i for i, msg in enumerate(self.short_term) if msg.get("role") != "system"]
            num_to_actually_remove = min(items_to_remove_count, len(non_system_indices))

            if num_to_actually_remove > 0:
                indices_to_remove_set = set(non_system_indices[:num_to_actually_remove])
                removed_roles = [self.short_term[i].get('role', 'N/A') for i in sorted(list(indices_to_remove_set))]
                new_short_term = [msg for i, msg in enumerate(self.short_term) if i not in indices_to_remove_set]
                self.short_term = new_short_term
                logger.info(f"[MemoryManager] 短期记忆修剪完成,移除了 {num_to_actually_remove} 条最旧的非系统消息 (角色: {removed_roles})。")
            elif items_to_remove_count > 0:
                 logger.warning(f"[MemoryManager] 短期记忆超限 ({current_size}/{self.max_short_term_items}) 但未能找到足够的非系统消息进行移除。")
        logger.debug(f"[MemoryManager] 添加后短期记忆数量: {len(self.short_term)}。")

    def add_to_long_term(self, knowledge_snippet: str):
        MAX_SNIPPET_LENGTH = 10000
        if len(knowledge_snippet) > MAX_SNIPPET_LENGTH:
            logger.warning(f"[MemoryManager] 尝试添加的长期记忆片段过长 ({len(knowledge_snippet)} 字符),已截断为 {MAX_SNIPPET_LENGTH} 字符。")
            knowledge_snippet = knowledge_snippet[:MAX_SNIPPET_LENGTH] + "... (已截断)"

        logger.debug(f"[MemoryManager] 添加知识到长期记忆: '{knowledge_snippet[:1000]}{'...' if len(knowledge_snippet) > 100 else ''}'。当前数量: {len(self.long_term)}。")
        self.long_term.append(knowledge_snippet)
        if len(self.long_term) > self.max_long_term_items:
            removed_snippet = self.long_term.pop(0)
            logger.info(f"[MemoryManager] 长期记忆超限 ({self.max_long_term_items}), 移除最旧知识: '{removed_snippet[:50]}...'。")
        logger.debug(f"[MemoryManager] 添加后长期记忆数量: {len(self.long_term)}。")

    def get_circuit_state_description(self) -> str:
        return self.circuit.get_state_description()

    def get_memory_context_for_prompt(self, recent_long_term_count: int = 7) -> str:
        logger.debug("[MemoryManager] 正在格式化记忆上下文用于 Prompt...")
        circuit_desc = self.get_circuit_state_description()
        long_term_str = ""
        if self.long_term:
            actual_count = min(recent_long_term_count, len(self.long_term))
            if actual_count > 0:
                recent_items = self.long_term[-actual_count:]
                long_term_str = "\n\n【近期经验总结 (仅显示最近 N 条,按时间倒序排列,最新在前)】\n" + "\n".join(f"- {item}" for item in reversed(recent_items))
                logger.debug(f"[MemoryManager] 已提取最近 {len(recent_items)} 条长期记忆 (倒序)。")
        long_term_str += "\n(注: 当前仅使用最近期记忆,未来版本将实现基于相关性的检索。)"
        context = f"{circuit_desc}{long_term_str}".strip()
        logger.debug(f"[MemoryManager] 记忆上下文 (电路+长期) 格式化完成。")
        return context

# --- 模块化组件: LLMInterface (LLM 交互接口) ---
class LLMInterface:
    def __init__(self, agent_instance: 'CircuitAgent', model_name: str = "glm-z1-flash", default_temperature: float = 0.01, default_max_tokens: int = 8190):
        logger.info(f"[LLMInterface V1.0.0] 初始化 LLM 接口,目标模型: {model_name}。")
        if not agent_instance or not hasattr(agent_instance, 'api_key'):
             raise ValueError("LLMInterface 需要一个包含 'api_key' 属性的 Agent 实例。")
        self.agent_instance = agent_instance
        api_key = self.agent_instance.api_key
        if not api_key: raise ValueError("智谱 AI API Key 不能为空。")
        try:
            self.client = ZhipuAI(api_key=api_key)
            logger.info("[LLMInterface V1.0.0] 智谱 AI 客户端初始化成功。")
        except Exception as e:
            logger.critical(f"[LLMInterface V1.0.0] 初始化智谱 AI 客户端失败: {e}", exc_info=True)
            raise ConnectionError(f"初始化智谱 AI 客户端失败: {e}") from e

        self.model_name = model_name
        self.default_temperature = default_temperature
        self.default_max_tokens = default_max_tokens
        logger.info(f"[LLMInterface V1.0.0] LLM 接口初始化完成 (模型: {model_name}, 温度: {default_temperature}, 最大Token数: {default_max_tokens}, 流式输出: False)。")

    async def call_llm(self, messages: List[Dict[str, Any]], execution_phase: str, status_callback: Optional[Callable[[Dict], Awaitable[None]]] = None) -> Any:
        call_args = {
            "model": self.model_name,
            "messages": messages,
            "temperature": self.default_temperature,
            "max_tokens": self.default_max_tokens,
            "stream": False,
        }

        logger.info(f"[LLMInterface V1.0.0] 准备异步调用 LLM ({self.model_name}, 阶段: {execution_phase}, 期望输出格式: <think> 标签后跟 JSON)...")
        logger.debug(f"[LLMInterface V1.0.0] 发送的消息条数: {len(messages)}。")
        if logger.isEnabledFor(logging.DEBUG) and len(messages) > 0:
             try:
                 messages_content_for_log = []
                 for m_idx, m in enumerate(messages):
                     role = m.get("role")
                     content = str(m.get("content",""))
                     if role == "system":
                         content_preview = content[:10000] + ("..." if len(content) > 10000 else "")
                     else:
                         content_preview = content[:1000] + ("..." if len(content) > 200 else "")
                     messages_content_for_log.append({"index": m_idx, "role": role, "content_preview_length": len(content), "content_preview": content_preview})
                 messages_summary = json.dumps(messages_content_for_log, ensure_ascii=False, indent=2)
                 logger.debug(f"[LLMInterface V1.0.0] 发送给 LLM 的消息列表 (预览):\n{messages_summary}")
             except Exception as e_json:
                 logger.debug(f"[LLMInterface V1.0.0] 无法序列化消息列表进行调试日志: {e_json}")

        request_id_to_send = self.agent_instance.current_request_id if hasattr(self.agent_instance, 'current_request_id') else None
        if status_callback:
            await status_callback({
                "type": "llm_communication_status",
                "request_id": request_id_to_send,
                "llm_phase": execution_phase,
                "status": "started",
                "message": f"正在与智能大脑 ({self.model_name}) 沟通 ({execution_phase})..."
            })

        response = None
        try:
            start_time = time.monotonic()
            response = await asyncio.to_thread(self.client.chat.completions.create, **call_args)
            duration = time.monotonic() - start_time
            logger.info(f"[LLMInterface V1.0.0] LLM 异步调用成功。耗时: {duration:.3f} 秒。")
            if status_callback:
                await status_callback({
                    "type": "llm_communication_status",
                    "request_id": request_id_to_send,
                    "llm_phase": execution_phase,
                    "status": "completed",
                    "message": f"与智能大脑 ({self.model_name}) 沟通完成 ({execution_phase})。",
                    "details": {"duration_seconds": duration}
                })

            if response:
                if response.usage: logger.info(f"[LLMInterface V1.0.0] Token 统计: Prompt={response.usage.prompt_tokens}, Completion={response.usage.completion_tokens}, Total={response.usage.total_tokens}")
                if response.choices:
                    finish_reason = response.choices[0].finish_reason
                    logger.info(f"[LLMInterface V1.0.0] 完成原因: {finish_reason}")
                    if finish_reason == 'length': logger.warning("[LLMInterface V1.0.0] LLM 响应因达到最大 token 限制而被截断！这可能导致输出不完整！")
                    raw_llm_content = response.choices[0].message.content
                    logger.debug(f"[LLMInterface V1.0.0] LLM 原始响应内容 (完整):\n{raw_llm_content}")
                else:
                    logger.warning("[LLMInterface V1.0.0] LLM 响应中缺少 'choices' 字段。")
            else:
                 logger.error("[LLMInterface V1.0.0] LLM API 调用返回了 None！")
                 raise ConnectionError("LLM API call returned None.")
            return response
        except Exception as e:
            logger.error(f"[LLMInterface V1.0.0] LLM API 异步调用失败: {e}", exc_info=True)
            if status_callback:
                 await status_callback({
                    "type": "llm_communication_status",
                    "request_id": request_id_to_send,
                    "llm_phase": execution_phase,
                    "status": "error",
                    "message": f"与智能大脑 ({self.model_name}) 沟通失败 ({execution_phase})。",
                    "details": {"error": str(e), "error_type": type(e).__name__}
                 })
            raise

# --- 模块化组件: OutputParser (输出解析器) ---
class OutputParser:
    def __init__(self, agent_tools_registry: Optional[Dict[str, Dict[str, Any]]] = None):
        logger.info("[OutputParser] 初始化输出解析器 (适配 ManusLLMResponse-V1.0.0 CamelCase JSON结构,提取 <think> 标签,增强布尔解析)。")
        self.agent_tools_registry = agent_tools_registry if agent_tools_registry else {}

    def _validate_tool_arguments(self, tool_name: str, tool_arguments: Dict[str, Any], tool_call_id: str) -> List[Dict[str, str]]:
        validation_errors: List[Dict[str, str]] = []
        if not self.agent_tools_registry or tool_name not in self.agent_tools_registry:
            validation_errors.append({
                "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolName",
                "issue_description": f"工具 '{tool_name}' 未在 Agent 的注册表中找到。"
            })
            return validation_errors

        tool_schema = self.agent_tools_registry[tool_name]
        param_schema_props = tool_schema.get("parameters", {}).get("properties", {})
        required_params = tool_schema.get("parameters", {}).get("required", [])

        for req_param in required_params:
            if req_param not in tool_arguments:
                validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{req_param}",
                    "issue_description": f"工具 '{tool_name}' 的必需参数 '{req_param}' 缺失。"
                })

        for arg_name, arg_value in tool_arguments.items():
            if arg_name not in param_schema_props:
                validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                    "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 是未在 Schema 中定义的未知参数。"
                })
                continue

            expected_type_str = param_schema_props[arg_name].get("type")
            is_optional_and_null_like = (arg_name not in required_params) and (arg_value is None)

            if expected_type_str == "string" and not isinstance(arg_value, str):
                if not is_optional_and_null_like:
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是字符串,但得到的是 {type(arg_value).__name__}。"
                    })
            elif expected_type_str == "integer" and not isinstance(arg_value, int):
                 if not (is_optional_and_null_like and expected_type_str == "integer"): 
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是整数,但得到的是 {type(arg_value).__name__}。"
                    })
            elif expected_type_str == "number" and not isinstance(arg_value, (int, float)):
                 if not (is_optional_and_null_like and expected_type_str == "number"):
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是数字,但得到的是 {type(arg_value).__name__}。"
                    })
            elif expected_type_str == "boolean" and not isinstance(arg_value, bool):
                 validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                    "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是布尔值,但得到的是 {type(arg_value).__name__}。"
                })
            elif expected_type_str == "object" and not isinstance(arg_value, dict):
                 validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                    "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是对象(字典),但得到的是 {type(arg_value).__name__}。"
                })
            elif expected_type_str == "array" and not isinstance(arg_value, list):
                 validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                    "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是数组(列表),但得到的是 {type(arg_value).__name__}。"
                })
        return validation_errors


    def parse_llm_response_to_structured_json(self, llm_api_response_message: Any, execution_phase: str) -> Tuple[Optional[Dict[str, Any]], str, List[Dict[str,str]]]:
        parser_id = f"parse{str(uuid4())[:8]}"
        logger.debug(f"[{parser_id}-OutputParser] 开始解析 LLM 响应 (阶段: {execution_phase})...")
        parsed_json_dict: Optional[Dict[str, Any]] = None
        error_message: str = ""
        failed_validation_points_list: List[Dict[str, str]] = []
        extracted_thought_process: Optional[str] = None

        if llm_api_response_message is None:
            error_message = "LLM 响应对象 (Message) 为 None。"
            logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message}")
            return None, error_message, [{"jsonPath": "root", "issue_description": error_message}]

        raw_content = getattr(llm_api_response_message, 'content', None)
        if not raw_content or not raw_content.strip():
            error_message = "LLM 响应内容 (content 字段) 为空或仅包含空白字符。"
            logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message}")
            return None, error_message, [{"jsonPath": "content", "issue_description": error_message}]

        logger.debug(f"[{parser_id}-OutputParser] 接收到的原始 LLM content (完整):\n{raw_content}")

        content_to_parse_for_json = raw_content
        think_match = re.search(r"<think>(.*?)</think>", raw_content, re.DOTALL | re.IGNORECASE)

        if think_match:
            extracted_thought_process = think_match.group(1).strip()
            content_to_parse_for_json = raw_content[think_match.end():].strip()
            logger.info(f"[{parser_id}-OutputParser] 成功提取到 <think>...</think> 内容。")
            logger.debug(f"[{parser_id}-OutputParser] 提取的思考过程 (预览):\n{extracted_thought_process[:1000]}...")
            logger.debug(f"[{parser_id}-OutputParser] 剩余内容待解析为JSON (预览):\n{content_to_parse_for_json[:1000]}...")
            if not content_to_parse_for_json:
                 error_message = "LLM 响应包含 <think> 块但之后没有内容可解析为 JSON。"
                 logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message}")
                 return None, error_message, [{"jsonPath": "root_after_think_block", "issue_description": error_message}]
        else:
            logger.warning(f"[{parser_id}-OutputParser] 未在LLM响应中找到有效的 <think>...</think> 块,将尝试按旧方式解析整个内容。")

        json_string_to_parse = content_to_parse_for_json.strip()
        match_md_json = re.search(r"```json\s*(.*?)\s*```", json_string_to_parse, re.DOTALL | re.IGNORECASE)
        if match_md_json:
            json_string_to_parse = match_md_json.group(1).strip()
            logger.debug(f"[{parser_id}-OutputParser] 从 Markdown 代码块中提取到 JSON 字符串。")
        else:
            first_brace = json_string_to_parse.find('{')
            last_brace = json_string_to_parse.rfind('}')
            if first_brace > 0 and (last_brace == -1 or first_brace > last_brace) :
                prefix_content = json_string_to_parse[:first_brace].strip()
                logger.warning(f"[{parser_id}-OutputParser] 在预期的 JSON 开头 '{{' 之前检测到非空白内容: '{prefix_content[:1000]}...'。将尝试从 '{{' 开始解析。")
                json_string_to_parse = json_string_to_parse[first_brace:]
            elif first_brace == -1 :
                error_message = "无法在 LLM 响应内容 (post-<think>或完整) 中找到 JSON 对象的起始 '{'。"
                logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message} 原始响应预览 (post-<think>或完整): {json_string_to_parse[:1000]}...")
                return None, error_message, [{"jsonPath": "content_for_json_parsing", "issue_description": error_message}]

        logger.debug(f"[{parser_id}-OutputParser] 预处理后,准备解析的 JSON 字符串 (完整):\n{json_string_to_parse}")

        try:
            parsed_json_dict = json.loads(json_string_to_parse)
            logger.info(f"[{parser_id}-OutputParser] JSON 字符串成功解析为字典。")
        except json.JSONDecodeError as json_err:
            error_message = f"JSON 解析失败: {json_err}。"
            logger.error(f"[{parser_id}-OutputParser] {error_message} Raw JSON string (截断): '{json_string_to_parse[:1000]}...'")
            return None, error_message, [{"jsonPath": "root_json_parsing", "issue_description": f"JSONDecodeError: {json_err}"}]
        except Exception as e:
            error_message = f"解析 LLM 响应时发生未知错误: {e}"
            logger.error(f"[{parser_id}-OutputParser] 解析时未知错误: {error_message}", exc_info=True)
            return None, error_message, [{"jsonPath": "root_json_parsing", "issue_description": f"Unexpected parsing error: {e}"}]

        if not isinstance(parsed_json_dict, dict):
            error_message = "解析后的结果不是一个 JSON 对象 (字典)。"
            logger.error(f"[{parser_id}-OutputParser] 结构验证失败: {error_message}")
            return None, error_message, [{"jsonPath": "root_json_parsing", "issue_description": error_message}]

        if extracted_thought_process is not None:
            if "thoughtProcess" in parsed_json_dict and parsed_json_dict["thoughtProcess"] and parsed_json_dict["thoughtProcess"] != extracted_thought_process:
                logger.warning(f"[{parser_id}-OutputParser] LLM提供了<think>块和JSON内部的thoughtProcess。将优先使用<think>块内容。")
            parsed_json_dict["thoughtProcess"] = extracted_thought_process
            logger.info(f"[{parser_id}-OutputParser] 已将<think>块内容置于parsed_json_dict['thoughtProcess']。")
        elif "thoughtProcess" not in parsed_json_dict or not parsed_json_dict.get("thoughtProcess", "").strip():
             logger.warning(f"[{parser_id}-OutputParser] LLM未提供<think>块,且JSON内部的thoughtProcess为空或缺失。思考过程可能不完整。")

        required_top_level_fields = ["requestId", "llmInteractionId", "timestampUtc", "status", "executionPhase", "thoughtProcess", "decision"]
        for field in required_top_level_fields:
            if field not in parsed_json_dict:
                failed_validation_points_list.append({"jsonPath": field, "issue_description": f"缺少必需的顶级字段 '{field}'。"})

        status_val = parsed_json_dict.get("status")
        if status_val not in ["success", "failure"]:
            failed_validation_points_list.append({"jsonPath": "status", "issue_description": f"字段 'status' 的值 '{status_val}' 无效,必须是 'success' 或 'failure'。"})

        exec_phase_val = parsed_json_dict.get("executionPhase")
        if exec_phase_val not in ["planning", "response_generation"]:
            failed_validation_points_list.append({"jsonPath": "executionPhase", "issue_description": f"字段 'executionPhase' 的值 '{exec_phase_val}' 无效,必须是 'planning' 或 'response_generation'。"})
        elif exec_phase_val != execution_phase:
             failed_validation_points_list.append({"jsonPath": "executionPhase", "issue_description": f"LLM报告的 'executionPhase' ('{exec_phase_val}') 与 Agent 期望的阶段 ('{execution_phase}') 不匹配。"})

        if status_val == "failure":
            error_details_obj = parsed_json_dict.get("errorDetails")
            if not isinstance(error_details_obj, dict):
                failed_validation_points_list.append({"jsonPath": "errorDetails", "issue_description": "当 'status' 为 'failure' 时, 'errorDetails' 必须是一个对象。"})
            else:
                if not isinstance(error_details_obj.get("errorType"), str) or not error_details_obj.get("errorType","").strip():
                    failed_validation_points_list.append({"jsonPath": "errorDetails.errorType", "issue_description": "'errorDetails' 对象中缺少有效的 'errorType' 字符串。"})
                if not isinstance(error_details_obj.get("errorCode"), str) or not error_details_obj.get("errorCode","").strip():
                    failed_validation_points_list.append({"jsonPath": "errorDetails.errorCode", "issue_description": "'errorDetails' 对象中缺少有效的 'errorCode' 字符串。"})
                if not isinstance(error_details_obj.get("technicalMessage"), str) or not error_details_obj.get("technicalMessage","").strip():
                    failed_validation_points_list.append({"jsonPath": "errorDetails.technicalMessage", "issue_description": "'errorDetails' 对象中缺少有效的 'technicalMessage' 字符串。"})
                if "isDirectLlmFailure" not in error_details_obj or not isinstance(error_details_obj.get("isDirectLlmFailure"), bool):
                    logger.warning(f"[{parser_id}-OutputParser] 'errorDetails.isDirectLlmFailure' 字段缺失或类型不为布尔。Agent将假定为False。LLM输出应包含此字段。")
                    failed_validation_points_list.append({"jsonPath": "errorDetails.isDirectLlmFailure", "issue_description": "'errorDetails' 对象中缺少有效的布尔字段 'isDirectLlmFailure'。"})
        elif status_val == "success" and parsed_json_dict.get("errorDetails") is not None:
             failed_validation_points_list.append({"jsonPath": "errorDetails", "issue_description": "当 'status' 为 'success' 时, 'errorDetails' 字段必须为 null 或不存在。"})

        if not isinstance(parsed_json_dict.get("thoughtProcess"), str):
            if parsed_json_dict.get("thoughtProcess") is not None:
                logger.warning(f"[{parser_id}-OutputParser] 'thoughtProcess' 字段存在但类型不正确 (应为字符串)。")
                failed_validation_points_list.append({"jsonPath": "thoughtProcess", "issue_description": "'thoughtProcess' 字段如果存在,必须是字符串。"})
        elif not parsed_json_dict.get("thoughtProcess","").strip() and extracted_thought_process is None:
            logger.warning(f"[{parser_id}-OutputParser] LLM未提供<think>块,且JSON内部的thoughtProcess为空或缺失。思考过程可能不完整。")

        decision_obj = parsed_json_dict.get("decision")
        if not isinstance(decision_obj, dict):
            failed_validation_points_list.append({"jsonPath": "decision", "issue_description": "'decision' 字段必须是一个对象。"})
        else:
            raw_is_call_tools_val = decision_obj.get("isCallTools")
            is_call_tools_val = None
            if isinstance(raw_is_call_tools_val, bool):
                is_call_tools_val = raw_is_call_tools_val
            elif isinstance(raw_is_call_tools_val, str):
                if raw_is_call_tools_val.lower() == 'true':
                    is_call_tools_val = True
                elif raw_is_call_tools_val.lower() == 'false':
                    is_call_tools_val = False
            
            if is_call_tools_val is None:
                failed_validation_points_list.append({"jsonPath": "decision.isCallTools", "issue_description": f"'decision.isCallTools' 值 '{raw_is_call_tools_val}' 无效。必须是布尔类型或可解析为布尔的字符串('true'/'false')。"})
            else:
                decision_obj["isCallTools"] = is_call_tools_val
                logger.debug(f"[{parser_id}-OutputParser] 'isCallTools' (原始值: {raw_is_call_tools_val}) 被解析为布尔值: {is_call_tools_val}。")

            tool_call_requests = decision_obj.get("toolCallRequests")
            if is_call_tools_val is True:
                if not isinstance(tool_call_requests, list):
                    failed_validation_points_list.append({"jsonPath": "decision.toolCallRequests", "issue_description": "当 'isCallTools' 为 True 时, 'toolCallRequests' 必须是一个列表。"})
                elif not tool_call_requests:
                    logger.warning(f"[{parser_id}-OutputParser] 'isCallTools' 为 True 但 'toolCallRequests' 列表为空。这可能是一个规划逻辑问题。")
                elif tool_call_requests:
                    for i, tool_req_item in enumerate(tool_call_requests):
                        item_path_prefix = f"decision.toolCallRequests[{i}]"
                        if not isinstance(tool_req_item, dict):
                            failed_validation_points_list.append({"jsonPath": item_path_prefix, "issue_description": "列表中的每个工具调用请求必须是对象。"}); continue

                        tool_call_id = tool_req_item.get("toolCallId")
                        if not isinstance(tool_call_id, str) or not tool_call_id.strip():
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.toolCallId", "issue_description": "缺少有效的 'toolCallId' 字符串。"})

                        tool_name = tool_req_item.get("toolName")
                        if not isinstance(tool_name, str) or not tool_name.strip():
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.toolName", "issue_description": "缺少有效的 'toolName' 字符串。"})

                        tool_arguments = tool_req_item.get("toolArguments")
                        if not isinstance(tool_arguments, dict):
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.toolArguments", "issue_description": "'toolArguments' 必须是一个对象。"})
                        elif tool_name and isinstance(tool_name, str) and tool_name.strip():
                            arg_validation_errors = self._validate_tool_arguments(tool_name, tool_arguments, tool_call_id if (tool_call_id and isinstance(tool_call_id, str) and tool_call_id.strip()) else f"index_{i}")
                            failed_validation_points_list.extend(arg_validation_errors)

                        ui_hints = tool_req_item.get("uiHints")
                        if ui_hints is not None and not isinstance(ui_hints, dict):
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.uiHints", "issue_description": "'uiHints' 如果存在,必须是一个对象。"})

            elif is_call_tools_val is False:
                if tool_call_requests is not None and (not isinstance(tool_call_requests, list) or tool_call_requests):
                    failed_validation_points_list.append({"jsonPath": "decision.toolCallRequests", "issue_description": "当 'isCallTools' 为 False 时, 'toolCallRequests' 必须是 null 或空列表 []。"})

            response_user_obj = decision_obj.get("responseToUser")
            if not isinstance(response_user_obj, dict):
                failed_validation_points_list.append({"jsonPath": "decision.responseToUser", "issue_description": "'responseToUser' 必须是一个对象。"})
            else:
                if not isinstance(response_user_obj.get("contentType"), str) or not response_user_obj.get("contentType","").strip():
                     failed_validation_points_list.append({"jsonPath": "decision.responseToUser.contentType", "issue_description": "'responseToUser' 对象缺少有效的 'contentType' 字符串。"})

                resp_content = response_user_obj.get("content")
                if not isinstance(resp_content, str):
                     failed_validation_points_list.append({"jsonPath": "decision.responseToUser.content", "issue_description": "'responseToUser.content' 必须是字符串。"})

                if is_call_tools_val is False and (not resp_content or resp_content.strip() == ""):
                     if execution_phase == "response_generation":
                         failed_validation_points_list.append({"jsonPath": "decision.responseToUser.content", "issue_description": "在响应生成阶段,当不调用工具时, 'responseToUser.content' 必须是有效的非空字符串。"})
                     else:
                        failed_validation_points_list.append({"jsonPath": "decision.responseToUser.content", "issue_description": "当 'isCallTools' 为 False (直接回复) 时, 'responseToUser.content' 必须是有效的非空字符串。"})

                suggestions = response_user_obj.get("suggestionsForNextSteps")
                if suggestions is not None:
                    if not isinstance(suggestions, list):
                        failed_validation_points_list.append({"jsonPath": "decision.responseToUser.suggestionsForNextSteps", "issue_description": "'suggestionsForNextSteps' 如果存在,必须是一个列表。"})
                    else:
                        for j, sugg_item in enumerate(suggestions):
                            sugg_path_prefix = f"decision.responseToUser.suggestionsForNextSteps[{j}]"
                            if not isinstance(sugg_item, dict):
                                failed_validation_points_list.append({"jsonPath": sugg_path_prefix, "issue_description": "列表中的每个建议必须是对象。"}); continue
                            if not isinstance(sugg_item.get("textForUser"), str) or not sugg_item.get("textForUser","").strip():
                                failed_validation_points_list.append({"jsonPath": f"{sugg_path_prefix}.textForUser", "issue_description": "建议对象缺少有效的 'textForUser' 字符串。"})

                clarification_flag = response_user_obj.get("requiresUserClarificationForCurrentRequest")
                if clarification_flag is not None and not isinstance(clarification_flag, bool):
                     failed_validation_points_list.append({"jsonPath": "decision.responseToUser.requiresUserClarificationForCurrentRequest", "issue_description": "'requiresUserClarificationForCurrentRequest' 如果存在,必须是布尔类型。"})

        diagnostics_obj = parsed_json_dict.get("diagnostics")
        if diagnostics_obj is not None and not isinstance(diagnostics_obj, dict):
            failed_validation_points_list.append({"jsonPath": "diagnostics", "issue_description": "'diagnostics' 如果存在,必须是一个对象。"})

        if failed_validation_points_list:
            error_message_parts = [f"JSON 结构或内容验证失败 (共 {len(failed_validation_points_list)} 点):"]
            for err_point in failed_validation_points_list:
                error_message_parts.append(f"  -路径 '{err_point['jsonPath']}': {err_point['issue_description']}")
            error_message = "\n".join(error_message_parts)

            json_content_for_log = json.dumps(parsed_json_dict, indent=2, ensure_ascii=False) if parsed_json_dict else json_string_to_parse[:1000]
            logger.error(f"[{parser_id}-OutputParser]\n{error_message}\n解析的 JSON 内容 (可能不完整或无效):\n{json_content_for_log}")
            return None, error_message, failed_validation_points_list

        logger.info(f"[{parser_id}-OutputParser] LLM 响应 (阶段: {execution_phase}, LLM_ID: {parsed_json_dict.get('llmInteractionId', 'N/A')}) 已成功解析并验证为 ManusLLMResponse-V1.0.0兼容结构 (思考过程来源: {'<think> block' if extracted_thought_process else 'JSON field'})！")
        return parsed_json_dict, "", []


# --- 模块化组件: ToolExecutor (工具执行器) ---
class ToolExecutor:
    def __init__(self, agent_instance: 'CircuitAgent', max_tool_retries: int = 1, tool_retry_delay_seconds: float = 1.0):
        logger.info("[ToolExecutor] 初始化工具执行器 (支持异步, 重试, 失败中止, UI回调增强 V1.0.0)。") # Version update
        if not isinstance(agent_instance, CircuitAgent):
            raise TypeError("ToolExecutor 需要一个 CircuitAgent 实例。")
        self.agent_instance = agent_instance
        if not hasattr(agent_instance, 'memory_manager') or not isinstance(agent_instance.memory_manager, MemoryManager):
            raise TypeError("Agent 实例缺少有效的 MemoryManager。")

        self.verbose_mode = getattr(agent_instance, 'verbose_mode', True)
        self.max_tool_retries = max(0, max_tool_retries)
        self.tool_retry_delay_seconds = max(0.1, tool_retry_delay_seconds)

        logger.info(f"[ToolExecutor] 工具执行配置: 每个工具最多重试 {self.max_tool_retries} 次,重试间隔 {self.tool_retry_delay_seconds} 秒。详细模式: {self.verbose_mode}。")

    async def _send_tool_status_update(
        self,
        status_callback: Optional[Callable[[Dict], Awaitable[None]]],
        tool_call_id: str,
        tool_name: str,
        tool_status: str,
        message: str,
        tool_arguments: Optional[Dict] = None,
        details: Optional[Dict] = None
    ):
        if status_callback:
            request_id_to_send = self.agent_instance.current_request_id if hasattr(self.agent_instance, 'current_request_id') else None
            arguments_summary_str = "N/A"
            if tool_arguments:
                try:
                    args_parts = []
                    for k, v in tool_arguments.items():
                        v_str = str(v) if v is not None else "None"
                        v_preview = v_str[:30] + '...' if len(v_str) > 30 else v_str
                        args_parts.append(f"{k}: {v_preview}")
                    arguments_summary_str = "; ".join(args_parts)
                    if not arguments_summary_str: arguments_summary_str = "(无参数)"
                except Exception as e_sum:
                    logger.warning(f"生成工具参数摘要时出错: {e_sum}")
                    arguments_summary_str = "(参数摘要生成错误)"
            await status_callback({
                "type": "tool_status_update",
                "request_id": request_id_to_send,
                "tool_call_id": tool_call_id,
                "tool_name": tool_name,
                "tool_arguments_summary_str": arguments_summary_str,
                "status": tool_status,
                "message": message,
                "details": details if details else {}
            })

    async def execute_tool_calls(self, tool_call_requests_from_plan: List[Dict[str, Any]], status_callback: Optional[Callable[[Dict], Awaitable[None]]] = None) -> List[Dict[str, Any]]:
        executor_id = f"exec_v1_1_3_{str(uuid4())[:8]}" 
        logger.info(f"[{executor_id}-ToolExecutor] 准备异步执行 {len(tool_call_requests_from_plan)} 个工具调用请求 (V1.0.0)...")
        execution_results_for_llm_history: List[Dict[str, Any]] = []

        if not tool_call_requests_from_plan:
            logger.info(f"[{executor_id}-ToolExecutor] 没有工具需要执行。")
            return []

        total_tools_in_plan = len(tool_call_requests_from_plan)

        for i, tool_request in enumerate(tool_call_requests_from_plan):
            llm_generated_tool_call_id = tool_request.get('toolCallId', f'fallback_tool_id_{str(uuid4())[:8]}')
            python_function_name = tool_request.get('toolName', 'unknown_function')
            parsed_arguments = tool_request.get('toolArguments', {})
            ui_hints_from_plan = tool_request.get('uiHints', {})
            tool_display_name = ui_hints_from_plan.get('displayNameForTool') or python_function_name.replace('_tool', '').replace('_', ' ').title()

            action_result_final_for_tool: Optional[Dict[str, Any]] = None
            
            logger.info(f"[{executor_id}-ToolExecutor] 处理工具调用 {i + 1}/{total_tools_in_plan}: Name='{python_function_name}', LLM_ToolCallID='{llm_generated_tool_call_id}'。")
            logger.debug(f"[{executor_id}-ToolExecutor] 待执行工具 '{python_function_name}' 的参数: {parsed_arguments}。")

            await self._send_tool_status_update(
                status_callback, llm_generated_tool_call_id, python_function_name,
                "running", f"开始执行操作: {tool_display_name}...",
                tool_arguments=parsed_arguments,
                details={"ui_hints": ui_hints_from_plan}
            )

            tool_action_method = getattr(self.agent_instance, python_function_name, None)
            
            # 检查工具方法是否存在且可调用
            if not callable(tool_action_method) or not getattr(tool_action_method, '_is_tool', False):
                err_msg_not_found = f"Agent 未实现名为 '{python_function_name}' 的已注册工具方法 (ID: {llm_generated_tool_call_id})。"
                logger.error(f"[{executor_id}-ToolExecutor] 工具未实现或未注册: {err_msg_not_found}")
                action_result_final_for_tool = {"status": "failure", "message": err_msg_not_found, "error": {"error_type": "TOOL_IMPLEMENTATION_ERROR", "error_code": "TOOL_NOT_FOUND_OR_NOT_REGISTERED", "technical_message": f"Action method '{python_function_name}' not found or not a registered tool in Agent."}}
            else: # 工具方法存在且已注册
                for retry_attempt in range(self.max_tool_retries + 1): # +1 to include the initial attempt
                    current_attempt_num = retry_attempt + 1
                    if retry_attempt > 0: # If this is a retry
                        logger.warning(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 执行失败,正在进行第 {retry_attempt}/{self.max_tool_retries} 次重试...")
                        await self._send_tool_status_update(
                            status_callback, llm_generated_tool_call_id, python_function_name,
                            "retrying", f"操作 '{tool_display_name}' 失败,等待 {self.tool_retry_delay_seconds} 秒后重试 (尝试 {current_attempt_num})...",
                            tool_arguments=parsed_arguments, details={"retry_count": retry_attempt, "max_retries": self.max_tool_retries, "ui_hints": ui_hints_from_plan}
                        )
                        await asyncio.sleep(self.tool_retry_delay_seconds)

                    action_result_this_attempt: Optional[Dict[str, Any]] = None
                    try:
                        is_coro = inspect.iscoroutinefunction(tool_action_method)
                        logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) 调用工具 '{python_function_name}'. 是否为协程: {is_coro}.")
                        
                        if is_coro:
                            # 直接 await 异步工具方法
                            logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) 直接 awaiting coroutine: {python_function_name}")
                            action_result_this_attempt = await tool_action_method(arguments=parsed_arguments)
                        else:
                            # 在线程中运行同步工具方法
                            logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) running sync tool in thread: {python_function_name}")
                            action_result_this_attempt = await asyncio.to_thread(tool_action_method, arguments=parsed_arguments)
                        
                        logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) 工具 '{python_function_name}' 返回结果类型: {type(action_result_this_attempt)}, 内容预览: {str(action_result_this_attempt)[:500]}...")

                        if not isinstance(action_result_this_attempt, dict) or \
                           'status' not in action_result_this_attempt or \
                           'message' not in action_result_this_attempt:
                            err_msg_struct = f"工具 '{python_function_name}' 返回的内部结果结构无效。期望字典包含 'status' 和 'message'。"
                            logger.error(f"[{executor_id}-ToolExecutor] 工具返回结构错误 (尝试 {current_attempt_num}): {err_msg_struct}. 实际返回类型: {type(action_result_this_attempt)}, 内容(部分): {str(action_result_this_attempt)[:200]}")
                            action_result_this_attempt = { # 强制转换为标准失败结构
                                "status": "failure", 
                                "message": f"错误: 工具 '{python_function_name}' 内部返回结果结构无效。", 
                                "error": {"error_type": "TOOL_IMPLEMENTATION_ERROR", "error_code": "INVALID_TOOL_ACTION_RESULT_STRUCTURE", "technical_message": err_msg_struct, "actual_return_type": str(type(action_result_this_attempt)), "actual_return_preview": str(action_result_this_attempt)[:200]}
                            }
                        else:
                            logger.info(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' 执行完毕 (尝试 {current_attempt_num})。状态: {action_result_this_attempt.get('status', 'N/A')}。")

                        if action_result_this_attempt.get("status") == "success":
                            action_result_final_for_tool = action_result_this_attempt
                            break # 成功，退出重试循环
                        else: # status 不是 "success"
                            logger.warning(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 执行失败 (尝试 {current_attempt_num})。报告状态: {action_result_this_attempt.get('status')}, 消息: {action_result_this_attempt.get('message')}")
                            action_result_final_for_tool = action_result_this_attempt # 保存本次失败的结果

                    except TypeError as te:
                        err_msg_type = f"调用工具 '{python_function_name}' 时参数不匹配或内部类型错误: {te}。"
                        logger.error(f"[{executor_id}-ToolExecutor] 工具调用参数/类型错误 (尝试 {current_attempt_num}): {err_msg_type}", exc_info=True)
                        action_result_final_for_tool = {"status": "failure", "message": f"错误: 调用工具 '{python_function_name}' 时参数或内部类型错误。", "error": {"error_type": "TOOL_EXECUTION_ERROR", "error_code": "ARGUMENT_TYPE_MISMATCH_OR_INTERNAL_TYPE_ERROR", "technical_message": err_msg_type, "exception_details": traceback.format_exc(limit=3)}}
                        break # 严重错误，无需重试
                    except Exception as exec_err:
                        err_msg_exec = f"工具 '{python_function_name}' 执行期间发生意外内部错误 (尝试 {current_attempt_num}): {exec_err}"
                        logger.error(f"[{executor_id}-ToolExecutor] 工具执行内部错误: {err_msg_exec}", exc_info=True)
                        action_result_final_for_tool = {"status": "failure", "message": f"错误: 执行工具 '{python_function_name}' 时发生内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "UNEXPECTED_TOOL_EXECUTION_FAILURE", "technical_message": err_msg_exec, "exception_details": traceback.format_exc(limit=3)}}
                    
                    # 如果是最后一次尝试，无论结果如何，都将是最终结果
                    if retry_attempt == self.max_tool_retries:
                        # action_result_final_for_tool 已经被设为最后一次尝试的结果
                        break # 退出重试循环

            # 确保 action_result_final_for_tool 有值
            if action_result_final_for_tool is None:
                 logger.error(f"[{executor_id}-ToolExecutor] 内部逻辑错误: 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 在所有重试后 action_result_final_for_tool 仍为 None。")
                 action_result_final_for_tool = {"status": "failure", "message": f"错误: 工具 '{python_function_name}' 未能确定最终结果。", "error": {"error_type": "TOOL_EXECUTION_ERROR", "error_code": "MISSING_TOOL_RESULT_LOGIC_ERROR", "technical_message": "Tool action_result_final_for_tool was None after retry loop."}}

            tool_succeeded_this_cycle = (action_result_final_for_tool.get("status") == "success")

            final_tool_status_str_for_cb = "succeeded" if tool_succeeded_this_cycle else "failed"
            status_message_for_cb = action_result_final_for_tool.get('message', '操作处理完成,但无特定消息。')
            details_for_cb: Dict[str, Any] = {"ui_hints": ui_hints_from_plan}
            if not tool_succeeded_this_cycle:
                details_for_cb["error"] = action_result_final_for_tool.get("error", {"error_type": "UNKNOWN_FAILURE", "technical_message": "工具最终失败,无详细错误信息。"})
            elif action_result_final_for_tool.get("data") is not None:
                 try: details_for_cb["result_data_preview"] = json.dumps(action_result_final_for_tool["data"], ensure_ascii=False, default=str, indent=None)[:1000]
                 except: details_for_cb["result_data_preview"] = "(数据无法序列化预览)"

            await self._send_tool_status_update(
                status_callback, llm_generated_tool_call_id, python_function_name,
                final_tool_status_str_for_cb, status_message_for_cb,
                details=details_for_cb
            )

            tool_result_message_for_llm = {
                "role": "tool",
                "tool_call_id": llm_generated_tool_call_id,
                "name": python_function_name,
                "content": json.dumps(action_result_final_for_tool, ensure_ascii=False, default=str)
            }
            execution_results_for_llm_history.append(tool_result_message_for_llm)
            logger.debug(f"[{executor_id}-ToolExecutor] 已记录工具 '{llm_generated_tool_call_id}' 的最终执行结果 (状态: {final_tool_status_str_for_cb}) 到LLM历史。")

            if not tool_succeeded_this_cycle:
                logger.warning(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 在所有重试后仍然失败。中止后续工具执行。")
                if i + 1 < total_tools_in_plan:
                    for k_aborted in range(i + 1, total_tools_in_plan):
                        aborted_tool_req = tool_call_requests_from_plan[k_aborted]
                        aborted_tool_id = aborted_tool_req.get('toolCallId', f'fallback_aborted_id_{str(uuid4())[:8]}')
                        aborted_tool_name = aborted_tool_req.get('toolName', 'unknown_aborted_tool')
                        aborted_ui_hints = aborted_tool_req.get('uiHints', {})
                        aborted_tool_display_name = aborted_ui_hints.get('displayNameForTool') or aborted_tool_name.replace('_tool','').replace('_',' ').title()

                        await self._send_tool_status_update(
                            status_callback, aborted_tool_id, aborted_tool_name,
                            "aborted_due_to_previous_failure",
                            f"操作 '{aborted_tool_display_name}' 已中止,因为先前的工具 '{tool_display_name}' 执行失败。",
                            details={"reason": f"Aborted due to failure of tool '{python_function_name}' (ID: {llm_generated_tool_call_id})", "ui_hints": aborted_ui_hints}
                        )
                        aborted_tool_result_for_llm_content = {
                                "status": "failure",
                                "message": f"工具 '{aborted_tool_name}' 未执行,因为前序工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 失败。",
                                "error": {"error_type": "TOOL_CHAIN_ABORTED", "error_code": "PRECEDING_TOOL_FAILURE", "technical_message": f"Execution of '{aborted_tool_name}' was skipped due to the failure of tool '{python_function_name}' (ID: {llm_generated_tool_call_id})."}
                            }
                        execution_results_for_llm_history.append({
                            "role": "tool", "tool_call_id": aborted_tool_id, "name": aborted_tool_name,
                            "content": json.dumps(aborted_tool_result_for_llm_content, ensure_ascii=False)
                        })
                        logger.info(f"[{executor_id}-ToolExecutor] 为中止的工具 '{aborted_tool_name}' (ID: {aborted_tool_id}) 添加了模拟失败记录到LLM历史。")
                break 

        total_processed_tools = len(execution_results_for_llm_history)
        logger.info(f"[{executor_id}-ToolExecutor] 工具执行流程完成。共处理/记录了 {total_processed_tools}/{total_tools_in_plan} 个计划中的工具调用 (可能因失败提前中止)。")
        return execution_results_for_llm_history

# --- Agent 核心类 (V1.0.0 - 11 Tools) ---
class CircuitAgent:
    def __init__(self, api_key: str, model_name: str = "glm-z1-flash",
                 max_short_term_items: int = 30, max_long_term_items: int = 75,
                 planning_llm_retries: int = 5, max_tool_retries: int = 3,
                 tool_retry_delay_seconds: float = 1.0, max_replanning_attempts: int = 3,
                 verbose: bool = True):
        logger.info(f"\n{'='*30} CircuitAgent 初始化开始 (V1.0.0 - 11 Tools) {'='*30}") # Version update
        self.api_key = api_key
        self.verbose_mode = verbose
        self.current_request_id: Optional[str] = None

        global console_handler
        console_log_level = logging.DEBUG if self.verbose_mode else logging.INFO
        if console_handler:
            console_handler.setLevel(console_log_level)
            logger.info(f"[AgentV1_1_3 Init] 控制台日志级别已设置为: {logging.getLevelName(console_log_level)} (详细模式: {self.verbose_mode})。")
        else:
            logger.warning("[AgentV1_1_3 Init] 未找到控制台日志处理器,无法动态设置日志级别。")

        self.tools_registry: Dict[str, Dict[str, Any]] = {}
        logger.info("[AgentV1_1_3 Init] 正在动态发现并注册工具...")
        for name, method in inspect.getmembers(self, predicate=inspect.ismethod):
            # 重要: 确保 inspect.ismethod 能正确处理被 @register_tool (特别是被 functools.wraps) 装饰的方法
            if hasattr(method, '_is_tool') and method._is_tool:
                schema = getattr(method, '_tool_schema', None)
                if schema and isinstance(schema, dict) and 'description' in schema and 'parameters' in schema:
                    self.tools_registry[name] = schema
                    # 记录工具是否为异步
                    is_async_tool = inspect.iscoroutinefunction(method)
                    logger.info(f"[AgentV1_1_3 Init] ✓ 已注册工具: '{name}' (异步: {is_async_tool})。")
                else:
                    logger.warning(f"[AgentV1_1_3 Init] 发现工具 '{name}' 但其 Schema 结构不完整或无效,已跳过注册。")
        if not self.tools_registry:
            logger.warning("[AgentV1_1_3 Init] 未发现任何通过 @register_tool 注册的工具！Agent 将主要依赖直接问答。")
        else:
            logger.info(f"[AgentV1_1_3 Init] 共发现并注册了 {len(self.tools_registry)} 个工具。")
            if logger.isEnabledFor(logging.DEBUG):
                try: logger.debug(f"[AgentV1_1_3 Init] 工具注册表详情:\n{json.dumps(self.tools_registry, indent=2, ensure_ascii=False)}")
                except Exception as e_dump: logger.debug(f"无法序列化工具注册表进行日志记录: {e_dump}")

        try:
            self.memory_manager = MemoryManager(max_short_term_items, max_long_term_items)
            self.llm_interface = LLMInterface(agent_instance=self, model_name=model_name)
            self.output_parser = OutputParser(agent_tools_registry=self.tools_registry)
            self.tool_executor = ToolExecutor(
                agent_instance=self,
                max_tool_retries=max_tool_retries,
                tool_retry_delay_seconds=tool_retry_delay_seconds
            )
        except (ValueError, ConnectionError, TypeError) as e:
            logger.critical(f"[AgentV1_1_3 Init] 核心模块初始化失败: {e}", exc_info=True)
            raise

        self.planning_llm_retries = max(0, planning_llm_retries)
        self.max_replanning_attempts = max(0, max_replanning_attempts)
        logger.info(f"[AgentV1_1_3 Init] 规划LLM重试次数: {self.planning_llm_retries}, 工具执行重试次数: {max_tool_retries}, 最大重规划尝试次数: {self.max_replanning_attempts}。")
        logger.info(f"\n{'='*30} CircuitAgent 初始化成功 (V1.0.0 - 11 Tools) {'='*30}\n")

    # --- Action Implementations (Tool methods) ---
    @register_tool(
        description="添加一个新的电路元件 (例如: 电阻, 电容, 电池, LED, 开关, 芯片, 地线, 端子/连接点等)。如果用户未指定 ID,系统会自动为其生成一个。",
        parameters={"type": "object", "properties": {"component_type": {"type": "string", "description": "元件的类型 (例如: '电阻', 'LED', 'Terminal', 'INPUT', 'GND')。"}, "component_id": {"type": "string", "description": "可选的用户为元件指定的ID。如果提供,则使用此ID; 如果不提供或提供格式无效,则由系统自动生成。"}, "value": {"type": "string", "description": "可选的元件值 (例如: '1k', '10uF', '3V')。"}}, "required": ["component_type"]}
    )
    def add_component_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-AddComponentTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行添加元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        
        component_type = arguments.get("component_type")
        component_id_req = arguments.get("component_id")
        value_req = arguments.get("value")

        if not component_type or not isinstance(component_type, str) or not component_type.strip():
            err_msg = "元件类型是必需的,并且必须是有效的非空字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_TYPE", "technical_message": err_msg}}

        target_id_final: Optional[str] = None
        id_was_generated_by_system = False
        user_provided_id_was_validated: Optional[str] = None

        if component_id_req and isinstance(component_id_req, str) and component_id_req.strip():
            user_provided_id_cleaned = component_id_req.strip().upper()
            if re.match(r'^[a-zA-Z0-9_][a-zA-Z0-9_-]*$', user_provided_id_cleaned) or user_provided_id_cleaned in ["INPUT", "OUTPUT", "GND"]:
                if user_provided_id_cleaned in self.memory_manager.circuit.components:
                    err_msg = f"您提供的元件 ID '{user_provided_id_cleaned}' 已被占用。"
                    logger.error(f"{tool_call_logger_prefix} ID 冲突: {err_msg}")
                    return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "CIRCUIT_STATE_ERROR", "error_code": "COMPONENT_ID_CONFLICT", "technical_message": err_msg, "conflicting_id": user_provided_id_cleaned}}
                else:
                    target_id_final = user_provided_id_cleaned
                    user_provided_id_was_validated = target_id_final
                    logger.debug(f"{tool_call_logger_prefix} 将使用用户提供的有效 ID: '{target_id_final}'。")
            else:
                logger.warning(f"{tool_call_logger_prefix} 用户提供的 ID '{component_id_req}' 格式无效。将自动生成 ID。")

        if target_id_final is None:
            try:
                target_id_final = self.memory_manager.circuit.generate_component_id(component_type)
                id_was_generated_by_system = True
                logger.debug(f"{tool_call_logger_prefix} 已自动为类型 '{component_type}' 生成 ID: '{target_id_final}'。")
            except RuntimeError as e_gen_id:
                err_msg = f"无法自动为类型 '{component_type}' 生成唯一 ID: {e_gen_id}"
                logger.error(f"{tool_call_logger_prefix} ID 生成失败: {err_msg}", exc_info=True)
                return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "INTERNAL_AGENT_ERROR", "error_code": "COMPONENT_ID_GENERATION_FAILED", "technical_message": str(e_gen_id)}}

        processed_value = str(value_req).strip() if value_req is not None and str(value_req).strip() else None
        if value_req is None and "value" in arguments:
            processed_value = None

        try:
            if target_id_final is None:
                raise ValueError("内部错误: 在尝试创建元件之前,未能最终确定有效的元件 ID。")

            new_component = CircuitComponent(target_id_final, component_type, processed_value)
            self.memory_manager.circuit.add_component(new_component)

            logger.info(f"{tool_call_logger_prefix} 成功添加元件 '{new_component.id}' ({new_component.type}) 到电路。")
            success_message_parts = [f"操作成功: 已添加元件 {str(new_component)}。"]
            if id_was_generated_by_system:
                success_message_parts.append(f"(系统自动分配 ID '{new_component.id}')")
            elif user_provided_id_was_validated:
                 success_message_parts.append(f"(使用了您指定的 ID '{user_provided_id_was_validated}')")
            final_success_message = " ".join(success_message_parts)
            self.memory_manager.add_to_long_term(f"添加了元件: {str(new_component)} (请求ID: {self.current_request_id or 'N/A'})")
            return {"status": "success", "message": final_success_message, "data": new_component.to_dict()}

        except ValueError as ve_comp:
            err_msg = f"创建或添加元件对象时发生内部验证错误: {ve_comp}"
            logger.error(f"{tool_call_logger_prefix} 元件创建/添加错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_CREATION_OR_ADDITION_VALIDATION_FAILED", "technical_message": str(ve_comp)}}
        except Exception as e_add_comp:
            err_msg = f"添加元件时发生未知的内部错误: {e_add_comp}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 添加元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "ADD_COMPONENT_UNEXPECTED_FAILURE", "technical_message": str(e_add_comp), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="使用两个已存在元件的 ID 将它们连接起来。",
        parameters={"type": "object", "properties": {"comp1_id": {"type": "string", "description": "第一个元件的 ID。"}, "comp2_id": {"type": "string", "description": "第二个元件的 ID。"}}, "required": ["comp1_id", "comp2_id"]}
    )
    def connect_components_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-ConnectComponentsTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行连接元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")

        comp1_id_req = arguments.get("comp1_id")
        comp2_id_req = arguments.get("comp2_id")

        if not comp1_id_req or not isinstance(comp1_id_req, str) or not comp1_id_req.strip() or \
           not comp2_id_req or not isinstance(comp2_id_req, str) or not comp2_id_req.strip():
            err_msg = "必须提供两个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_IDS_FOR_CONNECTION", "technical_message": err_msg}}

        id1_cleaned = comp1_id_req.strip().upper()
        id2_cleaned = comp2_id_req.strip().upper()

        try:
            connection_was_new = self.memory_manager.circuit.connect_components(id1_cleaned, id2_cleaned)
            if connection_was_new:
                logger.info(f"{tool_call_logger_prefix} 成功添加新连接: {id1_cleaned} <--> {id2_cleaned}。")
                self.memory_manager.add_to_long_term(f"连接了元件: {id1_cleaned} <--> {id2_cleaned} (请求ID: {self.current_request_id or 'N/A'})")
                return {"status": "success", "message": f"操作成功: 已将元件 '{id1_cleaned}' 与 '{id2_cleaned}' 连接起来。", "data": {"connection": sorted((id1_cleaned, id2_cleaned))}}
            else:
                msg_exists = f"元件 '{id1_cleaned}' 和 '{id2_cleaned}' 之间已经存在连接。无需重复操作。"
                logger.info(f"{tool_call_logger_prefix} 连接已存在: {msg_exists}")
                return {"status": "success", "message": f"注意: {msg_exists}", "data": {"connection": sorted((id1_cleaned, id2_cleaned)), "already_existed": True}}
        except ValueError as ve_connect:
            err_msg_val = str(ve_connect)
            logger.error(f"{tool_call_logger_prefix} 连接验证错误: {err_msg_val}")
            error_code_detail = "GENERIC_CIRCUIT_VALIDATION_ERROR"
            if "不存在" in err_msg_val: error_code_detail = "COMPONENT_NOT_FOUND_FOR_CONNECTION"
            elif "连接到它自己" in err_msg_val: error_code_detail = "SELF_CONNECTION_ATTEMPTED"
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": error_code_detail, "technical_message": err_msg_val}}
        except Exception as e_connect:
            err_msg = f"连接元件时发生未知的内部错误: {e_connect}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 连接元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "CONNECT_COMPONENTS_UNEXPECTED_FAILURE", "technical_message": str(e_connect), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(description="获取当前电路的详细描述,包括所有元件及其连接情况。", parameters={"type": "object", "properties": {}})
    def describe_circuit_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-DescribeCircuitTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行描述电路操作。")
        try:
            description = self.memory_manager.circuit.get_state_description()
            logger.info(f"{tool_call_logger_prefix} 成功生成电路描述。")
            return {"status": "success", "message": "已成功获取当前电路的描述。", "data": {"description": description}}
        except Exception as e_describe:
            err_msg = f"生成电路描述时发生意外的内部错误: {e_describe}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 获取电路描述时发生未知错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "DESCRIBE_CIRCUIT_UNEXPECTED_FAILURE", "technical_message": str(e_describe), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(description="彻底清空当前的电路设计,移除所有已添加的元件和它们之间的所有连接。此操作不可逆。", parameters={"type": "object", "properties": {}})
    def clear_circuit_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-ClearCircuitTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行清空电路操作。")
        try:
            self.memory_manager.circuit.clear()
            logger.info(f"{tool_call_logger_prefix} 电路状态已成功清空。")
            self.memory_manager.add_to_long_term(f"执行了清空电路操作 (请求ID: {self.current_request_id or 'N/A'})。")
            return {"status": "success", "message": "操作成功: 当前电路已彻底清空。"}
        except Exception as e_clear:
            err_msg = f"清空电路时发生意外的内部错误: {e_clear}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 清空电路时发生未知错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "CLEAR_CIRCUIT_UNEXPECTED_FAILURE", "technical_message": str(e_clear), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="从电路中移除一个指定的元件及其所有相关的连接。",
        parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要移除的元件的 ID。"}}, "required": ["component_id"]}
    )
    def remove_component_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-RemoveComponentTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行移除元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_id_req = arguments.get("component_id")

        if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
            err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_REMOVAL", "technical_message": err_msg}}

        id_cleaned = component_id_req.strip().upper()
        try:
            removed_comp_details, removed_conn_count = self.memory_manager.circuit.remove_component(id_cleaned)
            logger.info(f"{tool_call_logger_prefix} 成功移除元件 '{id_cleaned}' 及其 {removed_conn_count} 个连接。")
            self.memory_manager.add_to_long_term(f"移除了元件: ID '{id_cleaned}', 类型 '{removed_comp_details.get('type', 'N/A')}' (请求ID: {self.current_request_id or 'N/A'})")
            return {"status": "success", "message": f"操作成功: 已移除元件 '{id_cleaned}' 及其所有 {removed_conn_count} 个连接。", "data": {"removed_component": removed_comp_details, "connections_removed_count": removed_conn_count}}
        except ValueError as ve_remove:
            err_msg_val = str(ve_remove)
            logger.error(f"{tool_call_logger_prefix} 移除验证错误: {err_msg_val}")
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_REMOVAL", "technical_message": err_msg_val}}
        except Exception as e_remove:
            err_msg = f"移除元件时发生未知的内部错误: {e_remove}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 移除元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "REMOVE_COMPONENT_UNEXPECTED_FAILURE", "technical_message": str(e_remove), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="断开两个指定元件之间的连接。如果它们之间原本就没有连接,则不执行任何操作。",
        parameters={"type": "object", "properties": {"comp1_id": {"type": "string", "description": "第一个元件的 ID。"}, "comp2_id": {"type": "string", "description": "第二个元件的 ID。"}}, "required": ["comp1_id", "comp2_id"]}
    )
    def disconnect_components_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-DisconnectComponentsTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行断开元件连接操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        comp1_id_req = arguments.get("comp1_id")
        comp2_id_req = arguments.get("comp2_id")

        if not comp1_id_req or not isinstance(comp1_id_req, str) or not comp1_id_req.strip() or \
           not comp2_id_req or not isinstance(comp2_id_req, str) or not comp2_id_req.strip():
            err_msg = "必须提供两个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_IDS_FOR_DISCONNECTION", "technical_message": err_msg}}

        id1_cleaned = comp1_id_req.strip().upper()
        id2_cleaned = comp2_id_req.strip().upper()

        if id1_cleaned == id2_cleaned:
            err_msg = "不能断开一个元件与它自身的连接（它们本来就不可能连接）。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "SELF_DISCONNECTION_ATTEMPTED", "technical_message": err_msg}}
        
        try:
            if id1_cleaned not in self.memory_manager.circuit.components:
                raise ValueError(f"元件 '{id1_cleaned}' 在电路中不存在。")
            if id2_cleaned not in self.memory_manager.circuit.components:
                raise ValueError(f"元件 '{id2_cleaned}' 在电路中不存在。")

            disconnected_successfully = self.memory_manager.circuit.disconnect_components(id1_cleaned, id2_cleaned)
            if disconnected_successfully:
                logger.info(f"{tool_call_logger_prefix} 成功断开连接: {id1_cleaned} <--> {id2_cleaned}。")
                self.memory_manager.add_to_long_term(f"断开了元件连接: {id1_cleaned} <--> {id2_cleaned} (请求ID: {self.current_request_id or 'N/A'})")
                return {"status": "success", "message": f"操作成功: 已断开元件 '{id1_cleaned}' 与 '{id2_cleaned}' 之间的连接。", "data": {"disconnected_pair": sorted((id1_cleaned, id2_cleaned))}}
            else:
                msg_not_exist = f"元件 '{id1_cleaned}' 和 '{id2_cleaned}' 之间原本就没有连接,无需断开。"
                logger.info(f"{tool_call_logger_prefix} 连接不存在: {msg_not_exist}")
                return {"status": "success", "message": f"注意: {msg_not_exist}", "data": {"disconnected_pair": sorted((id1_cleaned, id2_cleaned)), "already_disconnected_or_not_connected": True}}
        except ValueError as ve_disconnect:
            err_msg_val = str(ve_disconnect)
            logger.error(f"{tool_call_logger_prefix} 断开连接验证错误: {err_msg_val}")
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_DISCONNECTION", "technical_message": err_msg_val}}
        except Exception as e_disconnect:
            err_msg = f"断开元件连接时发生未知的内部错误: {e_disconnect}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 断开元件连接时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "DISCONNECT_COMPONENTS_UNEXPECTED_FAILURE", "technical_message": str(e_disconnect), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="更新电路中一个已存在元件的值 (例如电阻的欧姆值, 电容的法拉值, 电池的电压等)。",
        parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要更新值的元件的 ID。"}, "new_value": {"type": "string", "description": "元件的新值。如果想要清除该元件的值,可以传入 null 或一个空字符串。"}}, "required": ["component_id", "new_value"]}
    )
    def update_component_value_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-UpdateComponentValueTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行更新元件值操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_id_req = arguments.get("component_id")
        new_value_req = arguments.get("new_value")

        if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
            err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_UPDATE", "technical_message": err_msg}}
        
        if not isinstance(new_value_req, (str, type(None))):
            err_msg = "元件的新值 'new_value' 必须是字符串或 null (用于清除值)。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "INVALID_NEW_VALUE_TYPE", "technical_message": err_msg}}

        id_cleaned = component_id_req.strip().upper()
        final_new_value = str(new_value_req).strip() if new_value_req is not None and str(new_value_req).strip() else None

        try:
            if id_cleaned not in self.memory_manager.circuit.components:
                raise ValueError(f"元件 '{id_cleaned}' 在电路中不存在。")
            
            component_to_update = self.memory_manager.circuit.components[id_cleaned]
            old_value = component_to_update.value
            component_to_update.value = final_new_value
            
            logger.info(f"{tool_call_logger_prefix} 成功更新元件 '{id_cleaned}' 的值从 '{old_value}' 到 '{final_new_value}'。")
            self.memory_manager.add_to_long_term(f"更新了元件 '{id_cleaned}' 的值: 旧值 '{old_value}', 新值 '{final_new_value}' (请求ID: {self.current_request_id or 'N/A'})")
            return {"status": "success", "message": f"操作成功: 元件 '{id_cleaned}' 的值已从 '{old_value if old_value else '(无值)'}' 更新为 '{final_new_value if final_new_value else '(无值)'}'。", "data": component_to_update.to_dict()}
        except ValueError as ve_update:
            err_msg_val = str(ve_update)
            logger.error(f"{tool_call_logger_prefix} 更新值验证错误: {err_msg_val}")
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_VALUE_UPDATE", "technical_message": err_msg_val}}
        except Exception as e_update:
            err_msg = f"更新元件值时发生未知的内部错误: {e_update}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 更新元件值时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "UPDATE_COMPONENT_VALUE_UNEXPECTED_FAILURE", "technical_message": str(e_update), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="根据提供的 ID 查找电路中的一个特定元件,并返回其详细信息 (类型、ID、值)。",
        parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要查找的元件的 ID。"}}, "required": ["component_id"]}
    )
    def find_component_by_id_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-FindComponentByIdTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行查找元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_id_req = arguments.get("component_id")

        if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
            err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_FIND", "technical_message": err_msg}}

        id_cleaned = component_id_req.strip().upper()
        try:
            if id_cleaned in self.memory_manager.circuit.components:
                component_found = self.memory_manager.circuit.components[id_cleaned]
                logger.info(f"{tool_call_logger_prefix} 成功找到元件 '{id_cleaned}'。")
                return {"status": "success", "message": f"操作成功: 已找到元件 '{id_cleaned}'。", "data": component_found.to_dict()}
            else:
                logger.info(f"{tool_call_logger_prefix} 未找到元件 '{id_cleaned}'。")
                return {"status": "failure", "message": f"错误: 电路中不存在 ID 为 '{id_cleaned}' 的元件。", "error": {"error_type": "CIRCUIT_QUERY_ERROR", "error_code": "COMPONENT_NOT_FOUND_BY_ID", "technical_message": f"Component with ID '{id_cleaned}' not found in circuit."}}
        except Exception as e_find:
            err_msg = f"查找元件时发生未知的内部错误: {e_find}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 查找元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "FIND_COMPONENT_UNEXPECTED_FAILURE", "technical_message": str(e_find), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="列出电路中所有属于指定类型的元件及其详细信息。",
        parameters={"type": "object", "properties": {"component_type": {"type": "string", "description": "要筛选的元件类型 (例如: '电阻', 'LED', '电池')。此匹配不区分大小写。"}}, "required": ["component_type"]}
    )
    def list_components_by_type_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-ListComponentsByTypeTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行按类型列出元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_type_req = arguments.get("component_type")

        if not component_type_req or not isinstance(component_type_req, str) or not component_type_req.strip():
            err_msg = "必须提供一个有效的、非空的元件类型字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_TYPE_FOR_LIST", "technical_message": err_msg}}
        
        type_cleaned = component_type_req.strip().lower()
        
        try:
            found_components = []
            for comp in self.memory_manager.circuit.components.values():
                if comp.type.lower() == type_cleaned:
                    found_components.append(comp.to_dict())
            
            if found_components:
                logger.info(f"{tool_call_logger_prefix} 成功找到 {len(found_components)} 个类型为 '{component_type_req}' 的元件。")
                return {"status": "success", "message": f"操作成功: 找到 {len(found_components)} 个类型为 '{component_type_req}' 的元件。", "data": {"components": found_components, "count": len(found_components)}}
            else:
                logger.info(f"{tool_call_logger_prefix} 未找到类型为 '{component_type_req}' 的元件。")
                return {"status": "success", "message": f"提示: 电路中没有找到类型为 '{component_type_req}' 的元件。", "data": {"components": [], "count": 0}}
        except Exception as e_list:
            err_msg = f"按类型列出元件时发生未知的内部错误: {e_list}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 按类型列出元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "LIST_COMPONENTS_UNEXPECTED_FAILURE", "technical_message": str(e_list), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="获取指定元件当前连接到其他元件的数量。",
        parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要查询连接数量的元件的 ID。"}}, "required": ["component_id"]}
    )
    def get_component_connection_count_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-GetComponentConnectionCountTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行获取元件连接数操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_id_req = arguments.get("component_id")

        if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
            err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_CONNECTION_COUNT", "technical_message": err_msg}}

        id_cleaned = component_id_req.strip().upper()
        try:
            if id_cleaned not in self.memory_manager.circuit.components:
                raise ValueError(f"元件 '{id_cleaned}' 在电路中不存在,无法查询其连接数。")
            
            connection_count = 0
            for conn_pair in self.memory_manager.circuit.connections:
                if id_cleaned in conn_pair:
                    connection_count += 1
            
            logger.info(f"{tool_call_logger_prefix} 元件 '{id_cleaned}' 有 {connection_count} 个连接。")
            return {"status": "success", "message": f"操作成功: 元件 '{id_cleaned}' 当前有 {connection_count} 个连接。", "data": {"component_id": id_cleaned, "connection_count": connection_count}}
        except ValueError as ve_count:
            err_msg_val = str(ve_count)
            logger.error(f"{tool_call_logger_prefix} 获取连接数验证错误: {err_msg_val}")
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_QUERY_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_CONNECTION_COUNT", "technical_message": err_msg_val}}
        except Exception as e_count:
            err_msg = f"获取元件连接数时发生未知的内部错误: {e_count}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 获取元件连接数时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "GET_CONNECTION_COUNT_UNEXPECTED_FAILURE", "technical_message": str(e_count), "exception_details": traceback.format_exc(limit=3)}}

    # --- DuckDuckGo 搜索工具 (确保返回期望的字典结构) ---
    @register_tool(
        description="使用 DuckDuckGo 搜索引擎在互联网上搜索与给定查询词相关的信息。用于获取通用知识、技术细节或背景资料。",
        parameters={
            "type": "object",
            "properties": {
                "query": {"type": "string", "description": "要搜索的关键词或问题。"},
                "num_results": {"type": "integer", "description": "期望返回的搜索结果数量 (例如: 1 到 5)。如果未提供或无效,默认为3。"}
            },
            "required": ["query"]
        }
    )
    async def duckduckgo_search_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]: # 标记为 async def
        tool_call_logger_prefix = f"[Action-DuckDuckGoSearchTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行 DuckDuckGo 搜索操作。")
        query = arguments.get("query")
        num_results_req = arguments.get("num_results")
        logger.debug(f"{tool_call_logger_prefix} 收到搜索查询: '{query}', 期望结果数 (原始请求): {num_results_req}。")

        # 预定义返回结构，确保status和message存在
        tool_result = {
            "status": "failure",
            "message": "DuckDuckGo 搜索工具初始化失败或发生未知错误。",
            "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "DUCKDUCKGO_UNKNOWN_FAILURE", "technical_message": "Tool did not complete successfully."}
        }

        if not query or not isinstance(query, str) or not query.strip():
            err_msg = "必须提供一个有效的、非空的搜索查询词。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            tool_result["message"] = f"错误: {err_msg}"
            tool_result["error"] = {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_SEARCH_QUERY", "technical_message": err_msg}
            return tool_result

        num_results = 3 
        if num_results_req is not None:
            if isinstance(num_results_req, int) and 1 <= num_results_req <= 10:
                num_results = num_results_req
            else:
                logger.warning(f"{tool_call_logger_prefix} num_results 参数 '{num_results_req}' 无效或超出范围(1-10), 将使用默认值 {num_results}。")
        else:
            logger.debug(f"{tool_call_logger_prefix} 未提供 num_results 参数, 将使用默认值 {num_results}。")
            
        search_results_raw_list = []
        try:
            # 将实际的同步DDGS操作封装在一个内部函数中
            def sync_ddgs_operation():
                _internal_results = []
                logger.debug(f"{tool_call_logger_prefix} [sync_op_internal] 开始执行DDGS搜索 for '{query}', max_results={num_results}")
                with DDGS(timeout=20) as ddgs: # 确保每次调用都创建新的DDGS实例
                    # ddgs.text返回一个迭代器，我们需要将其物化为列表来获取所有结果
                    fetched_results = list(ddgs.text(keywords=query, max_results=num_results))
                    logger.debug(f"{tool_call_logger_prefix} [sync_op_internal] DDGS.text 返回了 {len(fetched_results)} 个原始条目。")
                    # 手动限制结果数量，因为max_results在DDGS中可能不是硬限制
                    for r_item in fetched_results[:num_results]:
                        _internal_results.append({
                            "title": r_item.get('title', 'N/A'),
                            "snippet": r_item.get('body', 'N/A'), # DDGS 使用 'body' 作为摘要
                            "link": r_item.get('href', '#')
                        })
                logger.debug(f"{tool_call_logger_prefix} [sync_op_internal] 处理后得到 {len(_internal_results)} 个结果。")
                return _internal_results

            logger.debug(f"{tool_call_logger_prefix} 准备将同步DDGS操作提交到线程池...")
            search_results_raw_list = await asyncio.to_thread(sync_ddgs_operation)
            logger.debug(f"{tool_call_logger_prefix} 同步DDGS操作完成，从线程返回了 {len(search_results_raw_list)} 个结果。")


            search_results_json_str = json.dumps(search_results_raw_list, ensure_ascii=False)
            success_message = f"已成功完成对“{query}”的 DuckDuckGo 搜索,找到 {len(search_results_raw_list)} 条相关信息。"
            logger.info(f"{tool_call_logger_prefix} {success_message}")
            
            self.memory_manager.add_to_long_term(f"执行了 DuckDuckGo 搜索,查询词: '{query}', 返回了 {len(search_results_raw_list)} 条结果 (请求ID: {self.current_request_id or 'N/A'})。")
            
            # 更新为成功的返回字典
            tool_result = {
                "status": "success",
                "message": success_message,
                "data": {
                    "query": query,
                    "num_results_requested": num_results,
                    "num_results_returned": len(search_results_raw_list),
                    "results_json_string": search_results_json_str 
                }
            }
            return tool_result

        except Exception as e_search:
            err_msg = f"使用 DuckDuckGo 搜索时发生错误: {e_search}"
            logger.error(f"{tool_call_logger_prefix} {err_msg}", exc_info=True)
            tool_result["message"] = f"错误: {err_msg}"
            tool_result["error"] = {"error_type": "EXTERNAL_SERVICE_ERROR", "error_code": "DUCKDUCKGO_SEARCH_FAILED", "technical_message": str(e_search), "exception_details": traceback.format_exc(limit=3)}
            return tool_result

    # --- Orchestration Layer Method (V1.0.0 - 核心调度逻辑) ---
    async def process_user_request(self, user_request: str, status_callback: Callable[[Dict[str, Any]], Awaitable[None]]) -> None:
        request_start_time = time.monotonic()
        self.current_request_id = f"req_{str(uuid4())[:12]}"

        final_llm_camelcase_json_for_reply: Optional[Dict[str, Any]] = None
        final_reply_for_user: str = "抱歉,处理您的请求时发生未知错误。"
        final_llm_interaction_id_for_user: Optional[str] = None
        active_llm_interaction_id: Optional[str] = None

        logger.info(f"\n{'='*25} CircuitAgent 开始处理用户请求 (ReqID: {self.current_request_id}) {'='*25}")
        logger.info(f"[OrchestratorV1_1_3] 收到用户指令: \"{user_request}\"")

        try:
            if not user_request or user_request.isspace():
                logger.info(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 用户指令为空。")
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "input_validation", "status": "ignored", "message": "用户输入为空,已忽略。"})
                empty_input_err_json = {
                    "requestId": self.current_request_id,
                    "llmInteractionId": f"agent_input_err_{str(uuid4())[:6]}",
                    "timestampUtc": datetime.now(timezone.utc).isoformat(),
                    "status": "failure",
                    "errorDetails": {
                        "errorType": "USER_INPUT_ERROR",
                        "errorCode": "EMPTY_USER_REQUEST",
                        "messageToUser": "您的指令似乎是空的,请重新输入！",
                        "technicalMessage": "User request was empty or whitespace.",
                        "isDirectLlmFailure": False
                    },
                    "executionPhase": "planning",
                    "thoughtProcess": "Agent检测到用户输入为空或仅包含空白字符,无需进一步处理。",
                    "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content": "您的指令似乎是空的,请重新输入！"}}
                }
                await status_callback({"type": "final_response", "request_id": self.current_request_id, "llm_interaction_id": empty_input_err_json["llmInteractionId"], "content": empty_input_err_json["decision"]["responseToUser"]["content"], "finaljson_if_success": None})
                return

            await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "input_validation", "status": "received", "message": "收到用户指令,开始处理...", "details": {"user_request_preview": user_request[:1000]}})
            try:
                self.memory_manager.add_to_short_term({"role": "user", "content": user_request})
            except Exception as e_mem_user:
                logger.error(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 添加用户消息到短期记忆时出错: {e_mem_user}", exc_info=True)
                err_msg_mem = f"记录用户指令时发生内部记忆错误: {e_mem_user}"
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "input_validation", "status": "error", "message": err_msg_mem})
                mem_err_json = {
                    "requestId": self.current_request_id, "llmInteractionId": f"agent_mem_err_{str(uuid4())[:6]}",
                    "timestampUtc": datetime.now(timezone.utc).isoformat(), "status": "failure",
                    "errorDetails": {"errorType": "INTERNAL_AGENT_ERROR", "errorCode": "MEMORY_ADD_USER_MSG_FAILED", "messageToUser": f"抱歉,我在记录您的指令时遇到了内部问题 ({e_mem_user})！请稍后重试。", "technicalMessage": err_msg_mem, "isDirectLlmFailure": False },
                    "executionPhase": "planning", "thoughtProcess": "Agent在将用户消息添加到短期记忆时遇到错误。",
                    "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content": f"抱歉,我在记录您的指令时遇到了内部问题 ({e_mem_user})！请稍后重试。" }}
                }
                await status_callback({"type": "final_response", "request_id": self.current_request_id, "llm_interaction_id": mem_err_json["llmInteractionId"], "content": mem_err_json["decision"]["responseToUser"]["content"], "finaljson_if_success": None})
                return

            replanning_loop_count = 0
            current_llm_plan_camelcase_json_obj: Optional[Dict[str, Any]] = None
            tool_execution_results_for_llm_history: List[Dict[str, Any]] = []
            agent_accepted_latest_plan_for_action = False

            while replanning_loop_count <= self.max_replanning_attempts:
                current_planning_attempt_num = replanning_loop_count + 1
                log_prefix = f"[OrchestratorV1_1_3 - PlanAttempt {current_planning_attempt_num} - ReqID: {self.current_request_id}]"
                logger.info(f"\n--- {log_prefix} 开始 ---")

                is_currently_replanning = (replanning_loop_count > 0)
                status_msg_planning_start = "正在分析指令并制定计划..." if not is_currently_replanning else f"正在尝试第 {replanning_loop_count}/{self.max_replanning_attempts} 次重规划..."
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "started", "message": status_msg_planning_start, "details": {"attempt_number": current_planning_attempt_num, "max_replanning_attempts": self.max_replanning_attempts}})

                memory_context = self.memory_manager.get_memory_context_for_prompt()
                tool_schemas = self._get_tool_schemas_for_prompt()
                system_prompt_planning = self._get_planning_prompt(tool_schemas, memory_context, is_currently_replanning, self.current_request_id)
                messages_for_planning = [{"role": "system", "content": system_prompt_planning}] + self.memory_manager.short_term

                llm_call_attempt_inner = 0
                parsed_plan_camelcase_json_this_llm_call: Optional[Dict[str, Any]] = None
                parser_error_msg_this_llm_call: str = ""
                parsed_failed_validation_points_this_llm_call: List[Dict[str,str]] = []
                agent_accepted_latest_plan_for_action = False

                while llm_call_attempt_inner <= self.planning_llm_retries:
                    logger.info(f"{log_prefix} 调用规划 LLM (LLM Call Attempt {llm_call_attempt_inner + 1} of {self.planning_llm_retries + 1})...")
                    try:
                        llm_response_planning_raw = await self.llm_interface.call_llm(messages_for_planning, "planning", status_callback)
                        if not llm_response_planning_raw or not llm_response_planning_raw.choices:
                            raise ConnectionError("LLM规划响应无效或缺少choices。这是LLMInterface层面的问题。")

                        llm_msg_obj_planning = llm_response_planning_raw.choices[0].message
                        parsed_plan_camelcase_json_this_llm_call, parser_error_msg_this_llm_call, parsed_failed_validation_points_this_llm_call = \
                            self.output_parser.parse_llm_response_to_structured_json(llm_msg_obj_planning, "planning")

                        if parsed_plan_camelcase_json_this_llm_call:
                            active_llm_interaction_id = parsed_plan_camelcase_json_this_llm_call.get("llmInteractionId")
                            current_thought_process = parsed_plan_camelcase_json_this_llm_call.get("thoughtProcess")
                            if current_thought_process:
                                await status_callback({"type": "thinking_log", "request_id": self.current_request_id, "llm_interaction_id": active_llm_interaction_id, "stage": "planning", "content": current_thought_process})

                        if parsed_plan_camelcase_json_this_llm_call and not parser_error_msg_this_llm_call and not parsed_failed_validation_points_this_llm_call:
                            if parsed_plan_camelcase_json_this_llm_call.get("status") == "success":
                                logger.info(f"{log_prefix} 成功解析并验证V1.0-CamelCaseJSON计划。LLM报告状态为 'success' (LLM_ID: {active_llm_interaction_id})。Agent采纳此计划。")
                                agent_accepted_latest_plan_for_action = True
                            elif is_currently_replanning and \
                                 parsed_plan_camelcase_json_this_llm_call.get("decision", {}).get("isCallTools") is True and \
                                 isinstance(parsed_plan_camelcase_json_this_llm_call.get("decision", {}).get("toolCallRequests"), list) and \
                                 parsed_plan_camelcase_json_this_llm_call.get("decision", {}).get("toolCallRequests"):
                                logger.warning(f"{log_prefix} LLM在重规划时提供了新的工具调用计划,但可能将其顶层status标记为 'failure' (LLM_ID: {active_llm_interaction_id})。Agent将审慎采纳此新计划以尝试修正。LLM报告的错误(如有): {parsed_plan_camelcase_json_this_llm_call.get('errorDetails')}")
                                agent_accepted_latest_plan_for_action = True
                            else:
                                error_detail_from_llm = parsed_plan_camelcase_json_this_llm_call.get("errorDetails", {}).get("technicalMessage", "LLM规划指示内部错误,但JSON结构有效。")
                                logger.warning(f"{log_prefix} LLM报告的V1.0-CamelCaseJSON计划状态为 'failure': {error_detail_from_llm} (LLM_ID: {active_llm_interaction_id})。Agent将不采纳此计划,并尝试让LLM修正(如果还有LLM调用重试次数)。")
                                parser_error_msg_this_llm_call = f"LLM主动报告规划失败: {error_detail_from_llm}"

                            if agent_accepted_latest_plan_for_action:
                                current_llm_plan_camelcase_json_obj = parsed_plan_camelcase_json_this_llm_call
                                try:
                                    self.memory_manager.add_to_short_term(llm_msg_obj_planning.model_dump(exclude_unset=True))
                                except Exception as e_mem_add: logger.error(f"{log_prefix} 添加LLM规划响应到记忆失败: {e_mem_add}")
                                break

                        if not agent_accepted_latest_plan_for_action and llm_call_attempt_inner < self.planning_llm_retries:
                            error_to_report_cb = parser_error_msg_this_llm_call or "V1.0.0结构或内容校验失败。"
                            if parsed_failed_validation_points_this_llm_call:
                                error_to_report_cb += " 失败点: " + json.dumps(parsed_failed_validation_points_this_llm_call[:2], ensure_ascii=False)
                            await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "llm_retry_needed", "message": f"大脑计划处理遇到问题,尝试重新沟通 ({error_to_report_cb[:1000]})", "details": {"llm_call_attempt": llm_call_attempt_inner + 1, "parser_error": parser_error_msg_this_llm_call, "validation_failures": parsed_failed_validation_points_this_llm_call}})
                            if parsed_plan_camelcase_json_this_llm_call and parsed_plan_camelcase_json_this_llm_call.get("status") == "failure":
                                try: self.memory_manager.add_to_short_term(llm_msg_obj_planning.model_dump(exclude_unset=True))
                                except Exception as e_mem_add_fail: logger.error(f"{log_prefix} 添加LLM失败规划到记忆失败: {e_mem_add_fail}")
                            elif parser_error_msg_this_llm_call or parsed_failed_validation_points_this_llm_call:
                                 sim_err_plan_content = {
                                    "requestId": self.current_request_id, "llmInteractionId": f"agent_parser_err_{active_llm_interaction_id or str(uuid4())[:6]}",
                                    "timestampUtc": datetime.now(timezone.utc).isoformat(), "status": "failure",
                                    "errorDetails": {"errorType": "LLM_OUTPUT_VALIDATION_ERROR", "errorCode": "V1_CAMELCASE_JSON_VALIDATION_FAILED", "technicalMessage": parser_error_msg_this_llm_call, "isDirectLlmFailure": False, "failedValidationPoints": parsed_failed_validation_points_this_llm_call },
                                    "executionPhase": "planning", "thoughtProcess": "Agent在解析或验证LLM上一次规划输出时发现以下问题,将请求LLM修正。",
                                    "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content":""}}
                                 }
                                 try: self.memory_manager.add_to_short_term({"role": "assistant", "content": json.dumps(sim_err_plan_content, ensure_ascii=False)})
                                 except Exception as e_mem_add_parse_err: logger.error(f"{log_prefix} 添加Agent解析错误到记忆失败: {e_mem_add_parse_err}")

                    except Exception as e_llm_call_level:
                        logger.error(f"{log_prefix} LLM调用或规划解析时发生严重错误 (LLM Call Attempt {llm_call_attempt_inner + 1}): {e_llm_call_level}", exc_info=True)
                        parser_error_msg_this_llm_call = f"LLM调用/解析严重错误: {str(e_llm_call_level)[:1000]}"
                        parsed_failed_validation_points_this_llm_call = [{"jsonPath":"root", "issue_description": parser_error_msg_this_llm_call}]
                        if llm_call_attempt_inner < self.planning_llm_retries:
                             await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "llm_error_retrying", "message": f"与大脑沟通时发生严重错误,尝试重新连接 ({parser_error_msg_this_llm_call})", "details": {"llm_call_attempt": llm_call_attempt_inner + 1}})

                    llm_call_attempt_inner += 1
                    if agent_accepted_latest_plan_for_action: break

                if not agent_accepted_latest_plan_for_action:
                    error_summary_final_planning_llm_attempt = parser_error_msg_this_llm_call or "在多次LLM调用尝试后,未能从LLM获取可接受的V1.0-CamelCaseJSON规划。"
                    if parsed_failed_validation_points_this_llm_call:
                         error_summary_final_planning_llm_attempt += " 最后一次校验失败点: " + json.dumps(parsed_failed_validation_points_this_llm_call[:2], ensure_ascii=False)

                    await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "failed_after_llm_retries", "message": f"规划失败 (在第 {current_planning_attempt_num} 次规划尝试中,LLM调用重试均失败): {error_summary_final_planning_llm_attempt}", "details": {"final_parser_error": parser_error_msg_this_llm_call, "final_validation_failures": parsed_failed_validation_points_this_llm_call, "thinking_log_from_last_attempt": parsed_plan_camelcase_json_this_llm_call.get("thoughtProcess") if parsed_plan_camelcase_json_this_llm_call else "无有效思考过程"}})

                    if replanning_loop_count >= self.max_replanning_attempts:
                        logger.critical(f"{log_prefix} 已达最大重规划尝试次数 ({self.max_replanning_attempts}),且本次规划尝试在LLM调用/解析层面最终失败。中止处理。")
                        final_reply_for_user = f"抱歉,即使经过多次尝试与智能大脑沟通,也未能为您的请求 '{user_request[:50]}...' 制定出有效的执行计划。错误详情: {error_summary_final_planning_llm_attempt}"
                        final_llm_interaction_id_for_user = active_llm_interaction_id or f"error_plan_max_replan_llm_fail_{str(uuid4())[:6]}"
                        final_llm_camelcase_json_for_reply = None
                        break
                    else:
                        sim_fail_plan_content_for_replan = {
                            "requestId": self.current_request_id, "llmInteractionId": f"agent_replan_trigger_{active_llm_interaction_id or str(uuid4())[:6]}",
                            "timestampUtc": datetime.now(timezone.utc).isoformat(), "status": "failure",
                            "errorDetails": {"errorType": "LLM_OUTPUT_VALIDATION_ERROR", "errorCode": "V1_CAMELCASE_JSON_VALIDATION_FAILED_IN_PLAN_ATTEMPT", "technicalMessage": error_summary_final_planning_llm_attempt, "isDirectLlmFailure": False, "failedValidationPoints": parsed_failed_validation_points_this_llm_call },
                            "executionPhase": "planning", "thoughtProcess": f"Agent在第 {current_planning_attempt_num} 次规划尝试的LLM调用/解析阶段遇到问题,将进行重规划。错误: {error_summary_final_planning_llm_attempt}",
                            "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content":""}}
                        }
                        try: self.memory_manager.add_to_short_term({"role": "assistant", "content": json.dumps(sim_fail_plan_content_for_replan, ensure_ascii=False)})
                        except Exception as e_mem_add_replan_trigger: logger.error(f"{log_prefix} 添加重规划触发信息到记忆出错: {e_mem_add_replan_trigger}")
                        replanning_loop_count += 1
                        continue

                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "completed_and_validated", "message": "规划完成并通过验证,准备执行或直接回复。", "details": {"plan_llm_id": current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else None}})

                tool_requests_from_plan = current_llm_plan_camelcase_json_obj.get("decision", {}).get("toolCallRequests", []) if current_llm_plan_camelcase_json_obj else []
                if isinstance(tool_requests_from_plan, list) and current_llm_plan_camelcase_json_obj:
                    plan_details_for_ui = []
                    for req_idx, tool_req in enumerate(tool_requests_from_plan):
                        plan_details_for_ui.append({
                            "tool_call_id": tool_req.get("toolCallId"),
                            "tool_name": tool_req.get("toolName"),
                            "tool_arguments": tool_req.get("toolArguments", {}),
                            "ui_hints": tool_req.get("uiHints", {}),
                            "status": "pending",
                            "order": req_idx + 1
                        })
                    await status_callback({
                        "type": "plan_details",
                        "request_id": self.current_request_id,
                        "llm_interaction_id": current_llm_plan_camelcase_json_obj.get("llmInteractionId"),
                        "plan": plan_details_for_ui
                    })

                decision_from_plan = current_llm_plan_camelcase_json_obj.get("decision", {}) if current_llm_plan_camelcase_json_obj else {}
                should_call_tools = decision_from_plan.get("isCallTools", False)
                response_user_obj_from_plan = decision_from_plan.get("responseToUser")

                if should_call_tools:
                    tool_count_in_plan = len(tool_requests_from_plan) if isinstance(tool_requests_from_plan, list) else 0
                    logger.info(f"{log_prefix} 决策: 执行 {tool_count_in_plan} 个工具。")
                    await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "action_execution", "status": "started", "message": f"开始执行 {tool_count_in_plan} 个计划操作...", "details": {"tool_count": tool_count_in_plan}})

                    if isinstance(response_user_obj_from_plan, dict) and response_user_obj_from_plan.get("content","").strip():
                        transitional_reply_content = response_user_obj_from_plan["content"]
                        await status_callback({"type": "interim_response", "request_id": self.current_request_id, "llm_interaction_id": current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else None, "content": transitional_reply_content})

                    if not isinstance(tool_requests_from_plan, list) or not tool_requests_from_plan:
                        err_msg_list_tools_critical = "内部规划错误: isCallTools为True但toolCallRequests列表无效或为空。OutputParser应已校验。"
                        logger.error(f"{log_prefix} {err_msg_list_tools_critical}")
                        tool_execution_results_for_llm_history = [{"role":"tool", "tool_call_id":f"plan_integrity_err_{str(uuid4())[:6]}", "name":"plan_integrity_checker", "content":json.dumps({"status":"failure", "message":err_msg_list_tools_critical, "error": {"error_type":"INTERNAL_AGENT_ERROR", "error_code":"INVALID_TOOL_REQUEST_LIST_POST_VALIDATION", "technical_message": err_msg_list_tools_critical}})}]
                        try: self.memory_manager.add_to_short_term(tool_execution_results_for_llm_history[0])
                        except Exception as e_mem_add_integrity_err: logger.error(f"{log_prefix} 添加规划完整性错误到记忆失败: {e_mem_add_integrity_err}")

                        if replanning_loop_count >= self.max_replanning_attempts:
                            final_reply_for_user = f"抱歉,系统在准备执行操作时遇到内部规划结构问题。请稍后重试或联系技术支持。错误: {err_msg_list_tools_critical}"
                            final_llm_interaction_id_for_user = current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else active_llm_interaction_id
                            final_llm_camelcase_json_for_reply = None
                            break
                        else:
                            replanning_loop_count += 1; agent_accepted_latest_plan_for_action = False; continue

                    current_tool_exec_results_for_llm_hist = await self.tool_executor.execute_tool_calls(tool_requests_from_plan, status_callback)
                    tool_execution_results_for_llm_history = current_tool_exec_results_for_llm_hist

                    if tool_execution_results_for_llm_history:
                        for res_msg_tool in tool_execution_results_for_llm_history:
                            try: self.memory_manager.add_to_short_term(res_msg_tool)
                            except Exception as e_mem_add_tool_res: logger.error(f"{log_prefix} 添加工具结果 {res_msg_tool.get('tool_call_id')} 到记忆失败: {e_mem_add_tool_res}")

                    any_tool_failed_persistently = False
                    last_failed_tool_message_for_user = "一个或多个操作未能成功完成。"
                    if tool_execution_results_for_llm_history:
                        for tool_res_for_hist in tool_execution_results_for_llm_history:
                            try:
                                tool_res_content_dict = json.loads(tool_res_for_hist.get("content","{}"))
                                if tool_res_content_dict.get("status") != "success":
                                    any_tool_failed_persistently = True
                                    last_failed_tool_message_for_user = tool_res_content_dict.get("message", last_failed_tool_message_for_user)
                            except json.JSONDecodeError:
                                logger.error(f"{log_prefix} 无法解析工具结果的content JSON: {tool_res_for_hist.get('content')}")
                                any_tool_failed_persistently = True
                                last_failed_tool_message_for_user = "一个操作的结果格式不正确。"

                    if any_tool_failed_persistently:
                        logger.warning(f"{log_prefix} 工具执行过程中发生了一个或多个持久性失败。")
                        await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "action_execution", "status": "tool_failure_detected", "message": "部分操作失败,准备评估是否重规划。", "details": {"last_error_message": last_failed_tool_message_for_user}})
                        if replanning_loop_count < self.max_replanning_attempts:
                            replanning_loop_count += 1; agent_accepted_latest_plan_for_action = False; continue
                        else:
                            logger.critical(f"{log_prefix} 已达最大重规划尝试次数 ({self.max_replanning_attempts}),但工具执行仍有失败。中止处理。")
                            final_reply_for_user = f"抱歉,在执行您的请求时,即使经过多次尝试,仍遇到问题: {last_failed_tool_message_for_user} 请检查您的指令或稍后再试。"
                            final_llm_interaction_id_for_user = current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else active_llm_interaction_id
                            final_llm_camelcase_json_for_reply = None
                            break
                    else:
                        logger.info(f"{log_prefix} 所有计划中的工具均成功执行。准备生成最终回复。")
                        final_llm_camelcase_json_for_reply = current_llm_plan_camelcase_json_obj
                        break

                else:
                    logger.info(f"{log_prefix} 决策: 直接回复 (V1.0.0)。无需工具调用。")
                    if isinstance(response_user_obj_from_plan, dict) and response_user_obj_from_plan.get("content","").strip():
                        tool_execution_results_for_llm_history = []
                        final_llm_camelcase_json_for_reply = current_llm_plan_camelcase_json_obj
                        logger.info(f"{log_prefix} 规划阶段决定直接回复,内容有效。将使用此V1.0-CamelCaseJSON作为最终输出。LLM_ID: {final_llm_camelcase_json_for_reply.get('llmInteractionId')}")
                        break
                    else:
                        err_msg_direct_content_critical = "内部规划错误: isCallTools为False但responseToUser.content无效或为空。OutputParser应已校验。"
                        logger.error(f"{log_prefix} {err_msg_direct_content_critical}")
                        tool_execution_results_for_llm_history = [{"role":"tool", "tool_call_id":f"direct_reply_integrity_err_{str(uuid4())[:6]}", "name":"direct_reply_integrity_checker", "content":json.dumps({"status":"failure", "message":err_msg_direct_content_critical, "error": {"error_type":"INTERNAL_AGENT_ERROR", "error_code":"INVALID_DIRECT_RESPONSE_CONTENT_POST_VALIDATION", "technical_message": err_msg_direct_content_critical}})}]
                        try: self.memory_manager.add_to_short_term(tool_execution_results_for_llm_history[0])
                        except Exception as e_mem_add_direct_reply_err: logger.error(f"{log_prefix} 添加直接回复完整性错误到记忆失败: {e_mem_add_direct_reply_err}")

                        if replanning_loop_count >= self.max_replanning_attempts:
                            final_reply_for_user = f"抱歉,系统在准备直接回复时遇到内部规划结构问题。请稍后重试或联系技术支持。错误: {err_msg_direct_content_critical}"
                            final_llm_interaction_id_for_user = current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else active_llm_interaction_id
                            final_llm_camelcase_json_for_reply = None
                            break
                        else:
                            replanning_loop_count += 1; agent_accepted_latest_plan_for_action = False; continue
            
            logger.debug(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 重规划循环结束。采纳的计划: {agent_accepted_latest_plan_for_action}, 重规划次数: {replanning_loop_count}, 用于回复的最终LLM JSON是否已设置: {final_llm_camelcase_json_for_reply is not None}")
            
            if not agent_accepted_latest_plan_for_action and replanning_loop_count > self.max_replanning_attempts:
                logger.error(f"[OrchestratorV1_1_3 - FinalPrep - ReqID:{self.current_request_id}] 已达最大重规划次数,且最终规划尝试仍失败。将使用上次记录的错误信息。")
            
            logger.debug(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 响应生成检查前。最终JSON状态: {final_llm_camelcase_json_for_reply.get('status') if final_llm_camelcase_json_for_reply else 'N/A'}, isCallTools: {final_llm_camelcase_json_for_reply.get('decision', {}).get('isCallTools') if final_llm_camelcase_json_for_reply else 'N/A'}")

            if final_llm_camelcase_json_for_reply and \
               final_llm_camelcase_json_for_reply.get("status") == "success" and \
               final_llm_camelcase_json_for_reply.get("decision",{}).get("isCallTools") is True:
                logger.info(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 工具执行成功,开始生成最终响应...")
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "response_generation", "status": "started", "message": "正在总结操作结果并生成最终回复...", "details": {"reason": "Tool execution completed successfully. Generating final summary."}})

                system_prompt_resp_gen = self._get_response_generation_prompt(
                    self.memory_manager.get_memory_context_for_prompt(),
                    self._get_tool_schemas_for_prompt(),
                    self.current_request_id
                )
                messages_for_resp_gen = [{"role": "system", "content": system_prompt_resp_gen}] + self.memory_manager.short_term

                try:
                    llm_response_final_gen_raw = await self.llm_interface.call_llm(messages_for_resp_gen, "response_generation", status_callback)
                    if not llm_response_final_gen_raw or not llm_response_final_gen_raw.choices: raise ConnectionError("LLM最终响应生成阶段的响应无效或缺少choices。")

                    llm_msg_obj_final_gen = llm_response_final_gen_raw.choices[0].message
                    parsed_final_camelcase_resp_json, final_parser_err_resp, final_validation_failures_resp = \
                        self.output_parser.parse_llm_response_to_structured_json(llm_msg_obj_final_gen, "response_generation")

                    if parsed_final_camelcase_resp_json:
                        active_llm_interaction_id = parsed_final_camelcase_resp_json.get("llmInteractionId")
                        final_resp_thought_process = parsed_final_camelcase_resp_json.get("thoughtProcess")
                        if final_resp_thought_process:
                             await status_callback({"type": "thinking_log", "request_id": self.current_request_id, "llm_interaction_id": active_llm_interaction_id, "stage": "response_generation", "content": final_resp_thought_process})

                    if parsed_final_camelcase_resp_json and not final_parser_err_resp and not final_validation_failures_resp and parsed_final_camelcase_resp_json.get("status") == "success":
                        final_llm_camelcase_json_for_reply = parsed_final_camelcase_resp_json
                        final_llm_interaction_id_for_user = active_llm_interaction_id
                        logger.info(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 成功解析并验证最终响应V1.0-CamelCaseJSON (LLM_ID: {final_llm_interaction_id_for_user})。")
                        try:
                            self.memory_manager.add_to_short_term(llm_msg_obj_final_gen.model_dump(exclude_unset=True))
                        except Exception as e_mem_add_final_resp: logger.error(f"添加最终LLM响应到记忆失败: {e_mem_add_final_resp}")
                    else:
                        err_msg_final_resp_gen = final_parser_err_resp or "V1.0.0最终响应JSON校验失败。"
                        if final_validation_failures_resp: err_msg_final_resp_gen += " 失败点: " + json.dumps(final_validation_failures_resp[:2], ensure_ascii=False)
                        elif parsed_final_camelcase_resp_json and parsed_final_camelcase_resp_json.get("status") == "failure":
                             err_msg_final_resp_gen = parsed_final_camelcase_resp_json.get("errorDetails",{}).get("technicalMessage", err_msg_final_resp_gen)

                        logger.error(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] LLM未能生成有效V1.0-CamelCaseJSON最终回复: {err_msg_final_resp_gen}")
                        final_reply_for_user = f"抱歉,在总结操作结果时发生了一些问题。错误: {err_msg_final_resp_gen[:1000]}... "
                        final_llm_interaction_id_for_user = active_llm_interaction_id or (final_llm_camelcase_json_for_reply.get("llmInteractionId") if final_llm_camelcase_json_for_reply else f"error_resp_gen_{str(uuid4())[:6]}")
                        final_llm_camelcase_json_for_reply = None
                except Exception as e_llm_final_gen_call:
                    logger.critical(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] LLM最终响应调用或处理失败: {e_llm_final_gen_call}", exc_info=True)
                    final_reply_for_user = f"抱歉,系统在为您准备最终报告时遇到了严重的内部错误: {str(e_llm_final_gen_call)[:1000]}... "
                    final_llm_interaction_id_for_user = (final_llm_camelcase_json_for_reply.get("llmInteractionId") if final_llm_camelcase_json_for_reply else active_llm_interaction_id or f"critical_err_resp_gen_{str(uuid4())[:6]}")
                    final_llm_camelcase_json_for_reply = None
            
            elif final_llm_camelcase_json_for_reply and \
                 final_llm_camelcase_json_for_reply.get("status") == "success" and \
                 final_llm_camelcase_json_for_reply.get("decision",{}).get("isCallTools") is False:
                logger.info(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 使用规划阶段的直接回复V1.0-CamelCaseJSON作为最终输出。")
                final_llm_interaction_id_for_user = final_llm_camelcase_json_for_reply.get("llmInteractionId")

            elif not final_llm_camelcase_json_for_reply :
                 logger.error(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 流程结束时,final_llm_camelcase_json_for_reply 为空,表明处理失败。将使用之前记录的错误信息 (final_reply_for_user)。")

            user_facing_thought_process_final_summary = "综合思考过程已在之前的日志中发送。"
            if final_llm_camelcase_json_for_reply and final_llm_camelcase_json_for_reply.get("status") == "success":
                user_facing_thought_process_final_summary = final_llm_camelcase_json_for_reply.get("thoughtProcess", user_facing_thought_process_final_summary)
                resp_user_obj_final = final_llm_camelcase_json_for_reply.get("decision", {}).get("responseToUser", {})
                final_reply_for_user = resp_user_obj_final.get("content", final_reply_for_user)
            
            await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "finalization", "status": "completed" if (final_llm_camelcase_json_for_reply and final_llm_camelcase_json_for_reply.get("status") == "success") else "failed", "message": "请求处理流程已结束。"})
            await status_callback({
                "type": "final_response",
                "request_id": self.current_request_id,
                "llm_interaction_id": final_llm_interaction_id_for_user,
                "content": final_reply_for_user.strip() if final_reply_for_user else "抱歉,未能生成有效的回复。",
                "finaljson_if_success": final_llm_camelcase_json_for_reply
            })

            if not (final_llm_camelcase_json_for_reply and final_llm_camelcase_json_for_reply.get("status") == "success"):
                final_assistant_synthetic_error_message_camelcase_json = {
                    "requestId": self.current_request_id,
                    "llmInteractionId": final_llm_interaction_id_for_user or f"agent_synth_final_err_{str(uuid4())[:6]}",
                    "timestampUtc": datetime.now(timezone.utc).isoformat(),
                    "status": "failure",
                    "errorDetails": {"errorType": "AGENT_PROCESSING_FAILURE", "errorCode": "OVERALL_REQUEST_HANDLING_FAILED", "messageToUser": final_reply_for_user, "technicalMessage": "Agent failed to successfully complete the user request after all attempts.", "isDirectLlmFailure": False },
                    "executionPhase": "final_error_synthesis",
                    "thoughtProcess": user_facing_thought_process_final_summary or "Agent 最终处理失败,未能生成详细思考过程。",
                    "decision": {"isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content": final_reply_for_user}}
                }
                try: self.memory_manager.add_to_short_term({"role": "assistant", "content": json.dumps(final_assistant_synthetic_error_message_camelcase_json, ensure_ascii=False)})
                except Exception as e_mem_add_synth_err: logger.error(f"添加Agent合成的最终错误助手消息到记忆失败: {e_mem_add_synth_err}")

        except Exception as e_process_top_level:
            request_id_for_fatal = self.current_request_id or f"fatal_err_no_req_id_{str(uuid4())[:6]}"
            logger.critical(f"[OrchestratorV1_1_3 - ReqID:{request_id_for_fatal}] 处理用户请求 '{user_request[:1000]}' 时发生顶层未捕获异常: {e_process_top_level}", exc_info=True)
            error_msg_for_user_fatal = f"抱歉,处理您的请求 ('{user_request[:30]}...') 时发生严重的、未预期的内部系统错误。请稍后再试或联系技术支持。"
            tb_str_for_thinking_log_fatal = traceback.format_exc().replace('\n', ' | ')
            thinking_log_content_fatal = f"请求处理流程中发生顶层致命错误: {e_process_top_level}。Traceback (部分): {tb_str_for_thinking_log_fatal[:1000]}..."
            fatal_llm_interaction_id = f"fatal_agent_err_{str(uuid4())[:6]}"
            await status_callback({"type": "thinking_log", "request_id": request_id_for_fatal, "llm_interaction_id": fatal_llm_interaction_id, "stage": "fatal_error_capture", "content": thinking_log_content_fatal})
            await status_callback({"type": "general_status", "request_id": request_id_for_fatal, "stage": "fatal_error_handler", "status": "error", "message": f"请求处理失败,发生致命内部错误: {str(e_process_top_level)[:1000]}", "details": {"error_type": type(e_process_top_level).__name__, "full_error_message": str(e_process_top_level)}})
            await status_callback({"type": "final_response", "request_id": request_id_for_fatal, "llm_interaction_id": fatal_llm_interaction_id, "content": error_msg_for_user_fatal, "finaljson_if_success": None})
        finally:
            request_end_time = time.monotonic()
            duration_total = request_end_time - request_start_time
            logger.info(f"\n{'='*25} CircuitAgent 请求处理完毕 (ReqID: {self.current_request_id or 'N/A'}, 总耗时: {duration_total:.3f} 秒) {'='*25}\n")
            self.current_request_id = None


    # --- Helper Methods for Prompts (V1.0.0 - 辅助方法,用于生成系统提示) ---
    def _get_tool_schemas_for_prompt(self) -> str:
        if not self.tools_registry: return "  (当前无可用工具)"
        tool_schemas_parts = []
        sorted_tool_names = sorted(self.tools_registry.keys())

        for tool_name in sorted_tool_names:
            schema = self.tools_registry[tool_name]
            desc = schema.get('description', '无描述。')
            params_schema = schema.get('parameters', {})
            props_schema = params_schema.get('properties', {})
            req_params = params_schema.get('required', [])

            param_desc_segments = []
            if props_schema:
                sorted_param_names = sorted(props_schema.keys())
                for param_name in sorted_param_names: 
                    param_details_dict = props_schema[param_name]
                    param_type = param_details_dict.get('type','any')
                    is_required_str = "必须 (required)" if param_name in req_params else "可选 (optional)"
                    param_description = param_details_dict.get('description','无参数描述')
                    enum_values = param_details_dict.get('enum')
                    enum_desc = f" 可选值: {enum_values}。" if enum_values and isinstance(enum_values, list) else ""
                    param_desc_segments.append(f"    - 参数名 `{param_name}`:\n      - 类型: `{param_type}`\n      - 是否必需: {is_required_str}\n      - 描述: {param_description}{enum_desc}")
            elif params_schema.get("type") == "object" and not props_schema :
                 param_desc_segments = ["    - 此工具不接受任何参数(参数对象 `toolArguments` 应为空对象 `{}`)。"]
            else:
                 param_desc_segments = ["    - (此工具的参数定义似乎不完整或无参数)"]

            tool_schemas_parts.append(f"  - 工具名称: `{tool_name}`\n    工具描述: {desc}\n  工具参数详情 (这些参数应放在 `toolArguments` 对象内部):\n{chr(10).join(param_desc_segments)}")
        return "\n\n".join(tool_schemas_parts)

    def _get_planning_prompt(self, tool_schemas_desc: str, memory_context: str,
                                is_replanning: bool = False, request_id: Optional[str] = None) -> str:
        current_timestamp_utc = datetime.now(timezone.utc).isoformat()
        llm_interaction_id_example_plan_prefix = f"plan_ex_llm_id_{str(uuid4())[:6]}"
        example_prev_tool_call_id = f"tc_ex_prev_fail_{str(uuid4())[:6]}"

        reasoning_model_instructions = (
            "\n【重要: Reasoning Model 输出规范 (V1.0.0)】\n"
            "1.  **思考过程**: 您的详细思考过程、分析、逐步推理和决策逻辑【必须】包含在 `<think>...</think>` 标签内,并放在您回复的最开始部分。\n"
            "2.  **JSON 输出**: 在 `</think>` 标签之后,您【必须】输出一个严格符合下面描述的V1.0-CamelCaseJSON格式的单个JSON对象。此JSON对象应被三个反引号和'json'标记包围 (即 ```json ... ```)。JSON中所有key【必须】使用camelCase (例如: `isCallTools`, `toolCallRequests`, `requestId`).\n"
            "3.  **`thoughtProcess` 字段 (in JSON)**: JSON对象内部的 `thoughtProcess` 字段现在是次要的。它可以是一个简短的总结或留空 ( `\"\"` ),因为您的主要思考过程已在 `<think>...</think>` 块中。Agent将优先使用 `<think>` 块中的内容作为思考日志。\n"
        )

        replanning_guidance = ""
        if is_replanning:
            replanning_guidance = (
                "\n【重要: 重规划指示 (V1.0.0 - Reasoning Model)】\n"
                "您当前正在进行重规划。这意味着您之前的规划或工具执行遇到了问题。请在您的 `<think>...</think>` 块中：\n"
                "1.  **仔细分析失败原因**: 详细检查对话历史中的 `role: tool` 消息 (`content` JSON内的 `status: \"failure\"`, `message`, `errorDetails`) 和 `role: assistant` 消息中可能的Agent解析/校验错误 (`errorDetails.failedValidationPoints`)。\n"
                "2.  **参考当前电路状态**: 【务必】仔细查阅 `memory_context` 中的【当前电路状态】。您的新计划【必须】基于当前实际存在的元件和连接。不要不必要地重新添加已存在的元件。\n"
                "3.  **处理抽象节点**: 若涉及连接到 'INPUT', 'OUTPUT', 'GND' 等未作为元件存在的抽象节点失败,优先规划使用 `add_component_tool` (如 `component_type: 'Terminal'`) 创建它们,然后再连接。\n"
                "4.  **制定修正计划**: 基于以上分析,制定一个【全新的、修正了先前问题的计划】。这应在您的 `<think>...</think>` 块中清晰阐述。\n"
                "然后,在 `</think>` 之后输出符合V1.0-CamelCaseJSON规范的JSON。如果这个【新JSON本身的顶层 `status` 字段必须设置为 `'success'`】(因为您成功地为【当前这次思考和规划】输出了一个结构完整且逻辑合理的V1.0-CamelCaseJSON JSON)。\n"
                "5.  **无法解决的情况**: 如果分析后认为无法完成用户核心请求,则在 `<think>...</think>` 中解释,并在 `</think>` 后的JSON中制定一个【直接回复用户并解释情况的计划】 (`status: 'success'`, `isCallTools: False`).\n"
                "6.  **真正意义上的规划失败**: 只有当您在【当前这次重规划尝试中】,由于自身的理解困难、无法形成任何有效的 `<think>...</think>` 块或后续的V1.0-CamelCaseJSON JSON结构时,才应将后续JSON的顶层 `status` 字段设为 `'failure'`。\n"
                "**核心原则**: 不要因为*过去*的工具执行失败,就将您*当前新制定*的计划的JSON标记为 `status: 'failure'`. `status` 反映的是您【当前这次生成JSON这个行为本身】的成功与否。\n"
            )

        json_schema_description_for_prompt = """
```json
{
  "requestId": "string_or_null_当前用户请求周期的ID_如果系统提示中提供了此值请原样返回_否则为null",
  "llmInteractionId": "string_必须是本次LLM响应的唯一ID_例如_plan_llm_id_后跟8位随机字符_如_plan_llm_id_a1b2c3d4",
  "timestampUtc": "string_当前UTC时间戳_ISO_8601格式_例如_2024-07-16T12:00:00.000Z",
  "status": "string_必须是 'success' 或 'failure'._表示本次JSON输出是否由LLM为当前阶段成功生成。",
  "errorDetails": { // 如果 status 是 'success',则此字段为 null
    "errorType": "string_enum_高级错误类别_例如_PLANNING_ERROR_LLM_OUTPUT_VALIDATION_ERROR_INTERNAL_LOGIC_ERROR",
    "errorCode": "string_特定错误代码_例如_JSON_MALFORMED_MISSING_REQUIRED_FIELD_TOOL_PARAMS_INVALID",
    "messageToUser": "string_用户友好的解释_如果此错误与用户操作直接相关或适合用户查看。否则为通用Agent错误消息。",
    "technicalMessage": "string_详细的技术错误消息_用于日志记录和调试_这是LLM认为其自身输出生成过程中出现的问题。",
    "isDirectLlmFailure": "boolean_如果LLM明确表示无法完成请求或为本次尝试生成有效JSON则为True。如果错误是由于Agent端对LLM输出的JSON进行校验失败(即使JSON本身语法有效)_或LLM在格式良好的JSON中报告逻辑失败_则为False。",
    "failedValidationPoints": [ // 可选_如果LLM根据Agent反馈修正其先前的输出_则列出Agent发现的校验问题
      {
        "jsonPath": "string_例如_decision.toolCallRequests[0].toolArguments.component_id",
        "issue_description": "string_例如_必需字段缺失_或_值必须是字符串但得到的是整数"
      }
    ]
  },
  "executionPhase": "string_对于此任务_必须是 'planning'",
  "thoughtProcess": "string_此字段现在是次要的_您的主要详细推理必须在初始的 `<think>...</think>` 块中_此JSON字段可以是简短总结或为空_Agent将优先使用 `<think>` 块内容。",
  "decision": {
    "isCallTools": "boolean_如果需要调用工具则为True_否则为False_也接受不区分大小写的字符串 'true'/'false'",
    "toolCallRequests": [ // 如果 isCallTools 为 False, 则为 null 或空列表
      {
        "toolCallId": "string_由您为本次特定工具调用生成的唯一ID_例如_tc_add_resistor_xyz123",
        "toolName": "string_要调用的工具名称_从可用工具列表中选择 (例如 add_component_tool)",
        "toolArguments": { 
            // 此对象的内容是工具特定的_此处的键 (例如 component_type, value)
            // 应与 '可用工具列表与参数规范' 部分提供的 snake_case 名称匹配。
            // 电路工具示例: "component_type": "电阻", "value": "1k"
            // 搜索工具示例: "query": "欧姆定律", "num_results": 2 
        },
        "uiHints": { // 可选
            "displayNameForTool": "string_optional_更用户友好的工具调用名称_例如_添加电阻R1",
            "estimatedDurationCategory": "string_enum_optional_short_medium_long_very_long",
            "showProgressGranularly": "boolean_optional_如果为True_UI可能会显示更细粒度的进度(如果工具支持)_默认为False"
        },
        "estimatedComplexityOrNotes": "string_optional_LLM对此调用的内部注释_依赖关系或置信度。"
      }
    ],
    "responseToUser": {
      "contentType": "string_例如_text/plain_或_application/markdown",
      "content": "string_如果isCallTools为False_这是您对用户的直接且完整的回复_它必须非空。如果isCallTools为True_这应该是一条有意义的过渡消息_反映计划的操作_例如_好的_我将添加元件X然后连接到Y_如果确实不需要过渡消息则可以为空字符串_但为了用户体验首选提供一条好的消息。",
      "suggestionsForNextSteps": [ // 可选
        {
          "suggestionId": "string_optional_此建议的唯一ID_例如_sugg_ask_about_led_color",
          "textForUser": "string_向用户显示的建议文本_例如_您想指定LED颜色吗",
          "actionType": "string_enum_optional_USER_INPUT_EXPECTED_or_PREDEFINED_AGENT_ACTION_or_UI_NAVIGATION",
          "actionPayload": "object_or_string_optional_如果类型是PREDEFINED_AGENT_ACTION_这可能是简化的请求对象或命令字符串_供Agent在用户选择后处理"
        }
      ],
      "requiresUserClarificationForCurrentRequest": "boolean_optional_如果当前请求需要用户进一步输入才能继续_并且content正在请求该澄清_则设置为True_默认为False"
    }
  },
  "diagnostics": { // 可选
      "llmConfidenceScoreForThisOutput": "float_optional_0.0_到_1.0_LLM对此JSON输出的正确性和完整性的自评估置信度",
      "alternativePlansConsideredCount": "integer_optional_如果LLM在确定此计划前考虑了多个计划",
      "parsingFeedbackFromPreviousAttemptId": "string_or_null_如果这是对先前格式错误的JSON的修正_则为该失败尝试的llmInteractionId"
  },
  "usageMetadata": null
}
```
"""
        direct_qa_example = (
            "\n【通用示例1: 直接回答用户问题 (无需工具) - V1.0.0 Reasoning Model Output】\n"
            "如果用户问: “你好,什么是电容？”\n"
            "您的输出应类似 (ID和时间戳会变化): \n"
            "<think>\n"
            "用户询问电容的定义。这是一个概念性问题,不需要调用任何电路设计工具,我可以根据我的知识库直接回答。我将提供一个关于电容基本作用、单位和常见类型的解释,并给出下一步建议。我的回答将是清晰和直接的。\n"
            "</think>\n"
            "```json\n"
            "{\n"
            "  \"requestId\": \"" + (request_id or "userReqExampleId123") + "\",\n"
            "  \"llmInteractionId\": \"" + llm_interaction_id_example_plan_prefix + "_directQaCap\",\n"
            "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
            "  \"status\": \"success\",\n"
            "  \"errorDetails\": null,\n"
            "  \"executionPhase\": \"planning\",\n"
            "  \"thoughtProcess\": \"用户询问电容定义,直接回答。(主要思考过程在 <think> 块中)\",\n"
            "  \"decision\": {\n"
            "    \"isCallTools\": false,\n"
            "    \"toolCallRequests\": [],\n"
            "    \"responseToUser\": {\n"
            "      \"contentType\": \"text/plain\",\n"
            "      \"content\": \"电容是一种能够储存电荷的电子元件,由两块导体板中间夹一层绝缘介质构成。它的主要特性是电容量,单位是法拉(F),常用单位有微法(μF)、纳法(nF)和皮法(pF). 电容在电路中常用于滤波、耦合、隔直流、储能等.\",\n"
            "      \"suggestionsForNextSteps\": [\n"
            "        {\"textForUser\": \"您想了解电容在具体电路中的应用吗？\", \"actionType\": \"USER_INPUT_EXPECTED\"},\n"
            "        {\"textForUser\": \"需要我帮您在当前电路中添加一个电容吗？\", \"actionType\": \"USER_INPUT_EXPECTED\", \"actionPayload\": \"请帮我添加一个10uF的电解电容\"}\n"
            "      ],\n"
            "      \"requiresUserClarificationForCurrentRequest\": false\n"
            "    }\n"
            "  },\n"
            "  \"diagnostics\": {\"llmConfidenceScoreForThisOutput\": 0.95},\n"
            "  \"usageMetadata\": null\n"
            "}\n"
            "```\n"
        )
        tool_call_example = (
            "\n【通用示例2: 需要调用工具时的输出V1.0-CamelCaseJSON Reasoning Model Output】\n"
            "如果用户说: “帮我加一个1k欧姆的电阻R1,再用DuckDuckGo搜索'什么是LED'并返回2条结果,然后把R1连到GND。”\n"
            "您的输出应类似 (ID和时间戳会变化,每个toolCallId必须唯一,由您生成): \n"
            "<think>\n"
            "用户需要执行三个操作: 1. 添加电阻R1 (1kΩ)。 2. 使用DuckDuckGo搜索'什么是LED'并明确要求返回2条结果。3. 添加GND (如果不存在)并连接R1和GND。我将按顺序规划这三个/四个工具调用。确保为每个工具调用生成唯一的toolCallId。并为用户提供一个过渡性的回复,表明我理解了请求并正在处理。电路状态目前为空,元件GND可能需要先添加。\n"
            "</think>\n"
            "```json\n"
            "{\n"
            "  \"requestId\": \"" + (request_id or "userReqExampleId456") + "\",\n"
            "  \"llmInteractionId\": \"" + llm_interaction_id_example_plan_prefix + "_multiToolSearchFix2\",\n"
            "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
            "  \"status\": \"success\",\n"
            "  \"errorDetails\": null,\n"
            "  \"executionPhase\": \"planning\",\n"
            "  \"thoughtProcess\": \"规划添加R1,搜索,连接GND。(主要思考过程在 <think> 块中)\",\n"
            "  \"decision\": {\n"
            "    \"isCallTools\": true,\n"
            "    \"toolCallRequests\": [\n"
            "      {\n"
            "        \"toolCallId\": \"tc_add_r1_" + str(uuid4())[:8] + "\",\n"
            "        \"toolName\": \"add_component_tool\",\n"
            "        \"toolArguments\": {\"component_type\": \"电阻\", \"component_id\": \"R1\", \"value\": \"1kΩ\"},\n"
            "        \"uiHints\": {\"displayNameForTool\": \"添加电阻 R1 (1kΩ)\"}\n"
            "      },\n"
            "      {\n"
            "        \"toolCallId\": \"tc_search_led_" + str(uuid4())[:8] + "\",\n"
            "        \"toolName\": \"duckduckgo_search_tool\",\n"
            "        \"toolArguments\": {\"query\": \"什么是LED\", \"num_results\": 2},\n"
            "        \"uiHints\": {\"displayNameForTool\": \"搜索LED定义(2条结果)\"}\n"
            "      },\n"
            "      {\n"
            "        \"toolCallId\": \"tc_add_gnd_" + str(uuid4())[:8] + "\",\n"
            "        \"toolName\": \"add_component_tool\",\n"
            "        \"toolArguments\": {\"component_type\": \"地\", \"component_id\": \"GND\"},\n"
            "        \"uiHints\": {\"displayNameForTool\": \"添加地线 GND (如果需要)\"}\n"
            "      },\n"
            "      {\n"
            "        \"toolCallId\": \"tc_conn_r1gnd_" + str(uuid4())[:8] + "\",\n"
            "        \"toolName\": \"connect_components_tool\",\n"
            "        \"toolArguments\": {\"comp1_id\": \"R1\", \"comp2_id\": \"GND\"},\n"
            "        \"uiHints\": {\"displayNameForTool\": \"连接 R1 与 GND\"}\n"
            "      }\n"
            "    ],\n"
            "    \"responseToUser\": {\n"
            "      \"contentType\": \"text/plain\",\n"
            "      \"content\": \"好的,我正在为您添加电阻R1 (1kΩ),搜索LED的定义(2条结果),并准备连接R1到GND。请稍候...\",\n"
            "      \"suggestionsForNextSteps\": []\n"
            "    }\n"
            "  },\n"
            "  \"diagnostics\": null,\n"
            "  \"usageMetadata\": null\n"
            "}\n"
            "```\n"
        )
        
        replan_example = ""
        if is_replanning:
            replan_example = (
                "\n【重规划示例 (V1.0.0 Reasoning Model Output): 工具失败后,成功重规划并调用新/修正的工具】\n"
                "假设历史记录中有如下用户请求和失败的工具调用: \n"
                "  User: \"连接 R10 和 C5\"\n"
                "  Assistant (Previous Plan JSON): ... (Planned connect_components_tool for R10, C5, llmInteractionId: " + example_prev_tool_call_id + "_plan) ...\n"
                "  Tool (connect_components_tool, toolCallId: " + example_prev_tool_call_id + "_tool, name: connect_components_tool) result (in history): { \"role\": \"tool\", ..., \"content\": \"{\\\"status\\\": \\\"failure\\\", \\\"message\\\": \\\"错误: 元件 'R10' 在电路中不存在. \\\", \\\"error\\\": { \\\"error_type\\\": \\\"CIRCUIT_OPERATION_ERROR\\\", \\\"error_code\\\": \\\"COMPONENT_NOT_FOUND_FOR_CONNECTION\\\", ... }}\" }\n"
                "  Current Circuit State (in memory_context): (R10 does not exist, C5 exists)\n"
                "您在【当前重规划】时,您的新V1.0-CamelCaseJSON 输出应类似: \n"
                "<think>\n"
                "重规划开始。分析历史: 用户想连接R10和C5。上一个计划 (llmInteractionId: " + example_prev_tool_call_id + "_plan) 中调用connect_components_tool (toolCallId: " + example_prev_tool_call_id + "_tool) 失败了,工具报告原因是元件 'R10' 在电路中不存在。当前电路状态也确认R10不在电路中，但C5存在。因此,我的新计划是首先添加R10 (用户未指定类型或值,我将默认为电阻,并提供一个常用值如1kΩ). 然后再调用connect_components_tool连接新创建的R10和已存在的C5。本次规划逻辑清晰，后续的JSON应标记为status: 'success'.\n"
                "</think>\n"
                "```json\n"
                "{\n"
                "  \"requestId\": \"" + (request_id or "userReqExampleId789Replan") + "\",\n"
                "  \"llmInteractionId\": \"" + llm_interaction_id_example_plan_prefix + "_replanAddConnectFix2\",\n"
                "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
                "  \"status\": \"success\",\n"
                "  \"errorDetails\": null,\n"
                "  \"executionPhase\": \"planning\",\n"
                "  \"thoughtProcess\": \"R10不存在,先添加再连接。(主要思考过程在 <think> 块中)\",\n"
                "  \"decision\": {\n"
                "    \"isCallTools\": true,\n"
                "    \"toolCallRequests\": [\n"
                "      {\n"
                "        \"toolCallId\": \"tc_replan_add_r10_" + str(uuid4())[:8] + "\",\n"
                "        \"toolName\": \"add_component_tool\",\n"
                "        \"toolArguments\": {\"component_type\": \"电阻\", \"component_id\": \"R10\", \"value\": \"1k\"},\n"
                "        \"uiHints\": {\"displayNameForTool\": \"(修正) 添加电阻 R10 (1kΩ)\"}\n"
                "      },\n"
                "      {\n"
                "        \"toolCallId\": \"tc_replan_connect_r10c5_" + str(uuid4())[:8] + "\",\n"
                "        \"toolName\": \"connect_components_tool\",\n"
                "        \"toolArguments\": {\"comp1_id\": \"R10\", \"comp2_id\": \"C5\"},\n"
                "        \"uiHints\": {\"displayNameForTool\": \"(修正) 连接 R10 与 C5\"}\n"
                "      }\n"
                "    ],\n"
                "    \"responseToUser\": {\n"
                "      \"contentType\": \"text/plain\",\n"
                "      \"content\": \"检测到元件R10之前不存在。我将先为您添加一个1kΩ的电阻R10,然后再将它与C5连接。\",\n"
                "      \"suggestionsForNextSteps\": [\n"
                "        {\"textForUser\": \"操作完成后显示电路状态.\"}\n"
                "      ],\n"
                "      \"requiresUserClarificationForCurrentRequest\": false\n"
                "    }\n"
                "  },\n"
                "  \"diagnostics\": {\"parsingFeedbackFromPreviousAttemptId\": \"" + example_prev_tool_call_id + "_plan\"},\n"
                "  \"usageMetadata\": null\n"
                "}\n"
                "```\n"
            )
        prompt_parts = [
            "您是一位初版电路设计编程助理 (Agent Version V1.0.0, 11 Tools)。您的任务是理解用户指令,并据此规划行动或直接回复。\n", # Version update
            reasoning_model_instructions,
            "\n【核心任务: 规划阶段 (V1.0.0)】\n"
            "请首先在 `<think>...</think>` 标签内深入分析用户的最新指令、完整的对话历史、当前的电路状态和记忆。然后,在 `</think>` 标签之后,生成一个符合V1.0-CamelCaseJSON规范的JSON对象作为您的行动计划或直接回复。JSON中所有key【必须】使用camelCase (例如: `isCallTools`, `toolCallRequests`, `requestId`).\n",
            replanning_guidance if is_replanning else "",
            "【V1.0.0 输出格式规范 (在</think>之后输出, 必须严格遵守)】:\n",
            json_schema_description_for_prompt,
            "\n【重要指令与检查清单 (V1.0.0 - Planning)】:\n"
            "1.  **`<think>` Block First**: 您的详细逐步推理**必须**在 `<think>...</think>` 标签内,并置于回复最开始。\n"
            "2.  **JSON After `</think>`**: V1.0.0 对象 (用 ```json ... ``` 包裹) **必须**紧跟 `</think>` 标签。此JSON中的所有键名必须是 camelCase (例如, `requestId`, `isCallTools`, `toolCallRequests`)。`toolArguments` 内部的键名 (例如, `component_type`) 应遵循下面工具 Schema 中提供的 snake_case 命名。\n"
            "3.  **JSON `thoughtProcess` Field**: 此JSON字段现在是次要的。它可以是简短总结或空字符串 `\"\"`。`<think>...</think>` 块中的内容是主要的思考过程。\n"
            "4.  **`decision.isCallTools`**: JSON中的此字段**必须**是布尔值 (`true` 或 `false`)。大小写不敏感的字符串 \"True\" 或 \"true\" 也可接受,Agent会将其解析为布尔值。\n"
            "5.  **其他 JSON 字段**: 严格遵循V1.0-CamelCaseJSON Schema 的JSON部分。\n"
            "6.  **电路状态感知**: 在规划涉及现有元件的工具调用前,请在 `memory_context` (当前电路状态) 中确认它们的存在。如果需要连接像 'INPUT' 这样的抽象节点而它们并非作为元件存在,请首先规划添加它们 (例如,作为 'Terminal')。\n\n",
            direct_qa_example,
            tool_call_example,
        ]
        if is_replanning:
            prompt_parts.append(replan_example)

        prompt_parts.extend([
            "\n【可用工具列表与参数规范 (V1.0.0 - 11 Tools)】:\n", # Version update
            tool_schemas_desc,
            "\n\n【当前上下文信息 (V1.0.0)】:\n"
            f"Current Request ID (如果可用,请在JSON的requestId字段中原样返回): {request_id or 'N/A_NOT_PROVIDED_IN_PROMPT_SET_TO_NULL'}\n"
            f"Current UTC Time (供您生成timestampUtc参考): {current_timestamp_utc}\n"
            f"当前电路与记忆摘要:\n{memory_context}\n\n"
            "【最后再次强调】: 您的输出【必须】以 `<think>...</think>` 块开始,后跟一个被 ```json ... ``` 包围的、严格符合上述V1.0-CamelCaseJSON规范 (所有key使用camelCase) 的单个JSON对象。JSON对象之外不应有任何其他文本。请务必仔细检查 `<think>` 块的使用以及JSON的语法和所有字段的类型及条件要求！"
        ])
        return "".join(prompt_parts)

    def _get_response_generation_prompt(self, memory_context: str, tool_schemas_desc: str, request_id: Optional[str] = None) -> str:
        current_timestamp_utc = datetime.now(timezone.utc).isoformat()
        llm_interaction_id_example_resp_prefix = f"resp_ex_llm_id_{str(uuid4())[:6]}"

        reasoning_model_instructions_resp_phase = (
            "\n【重要: Reasoning Model 输出规范 (V1.0.0 - Response Generation)】\n"
            "1.  **思考过程**: 您的详细思考过程 (如何分析工具结果或决定直接回复, 以及如何构思最终回复) 【必须】包含在 `<think>...</think>` 标签内,并放在您回复的最开始部分。\n"
            "2.  **JSON 输出**: 在 `</think>` 标签之后,您【必须】输出一个严格符合下面描述的V1.0-CamelCaseJSON格式的单个JSON对象。此JSON对象应被三个反引号和'json'标记包围 (即 ```json ... ```)。JSON中所有key【必须】使用camelCase.\n"
            "3.  **`thoughtProcess` 字段 (in JSON)**: JSON对象内部的 `thoughtProcess` 字段现在是次要的。它可以是一个简短的总结或留空 ( `\"\"` ),因为您的主要思考过程已在 `<think>...</think>` 块中。Agent将优先使用 `<think>` 块中的内容作为思考日志。\n"
        )
        
        json_schema_description_for_resp_phase = """
```json
{
  "requestId": "string_or_null_当前用户请求周期的ID_如果系统提示中提供了此值请原样返回_否则为null",
  "llmInteractionId": "string_必须是本次LLM响应的唯一ID_例如_resp_llm_id_后跟8位随机字符_如_resp_llm_id_e5f6g7h8",
  "timestampUtc": "string_当前UTC时间戳_ISO_8601格式_例如_2024-07-16T12:05:00.000Z",
  "status": "string_必须是 'success' 或 'failure'_表示您是否为本次尝试成功生成了此最终响应JSON_如果您现在无法构思出合适的摘要或回复_则设为failure",
  "errorDetails": {
    "errorType": "string_enum_例如_RESPONSE_GENERATION_ERROR_LLM_OUTPUT_VALIDATION_ERROR",
    "errorCode": "string_例如_JSON_MALFORMED_SUMMARY_LOGIC_ERROR",
    "messageToUser": "string_optional_用户友好的消息_如果适用",
    "technicalMessage": "string_本次响应生成尝试的详细技术错误消息。",
    "isDirectLlmFailure": "boolean_如果LLM明确表示无法完成请求或为本次尝试生成有效JSON则为True。如果错误是由于Agent端对LLM输出的JSON进行校验失败(即使JSON本身语法有效)_或LLM在格式良好的JSON中报告逻辑失败_则为False。",
    "failedValidationPoints": [ { "jsonPath": "...", "issue_description": "..." } ]
  },
  "executionPhase": "string_对于此任务_必须是 'response_generation'",
  "thoughtProcess": "string_此字段现在是次要的_您的主要详细推理必须在初始的 `<think>...</think>` 块中_此JSON字段可以是简短总结或为空_Agent将优先使用 `<think>` 块内容。",
  "decision": {
    "isCallTools": "boolean_在此响应生成阶段必须为false_也接受不区分大小写的字符串 'true'/'false'",
    "toolCallRequests": [],
    "responseToUser": {
      "contentType": "string_例如_text/plain_或_application/markdown",
      "content": "string_这是您对用户的最终且完整的回复_它必须非空。它应总结已采取的操作_报告结果_并根据工具输出(如果最初未调用工具_则根据您的直接知识)回应用户的原始请求。此内容是用户将看到的。",
      "suggestionsForNextSteps": [
        {
          "suggestionId": "string_optional_此建议的唯一ID_例如_sugg_ask_about_led_color",
          "textForUser": "string_向用户显示的建议文本_例如_您想指定LED颜色吗",
          "actionType": "string_enum_optional_USER_INPUT_EXPECTED_or_PREDEFINED_AGENT_ACTION_or_UI_NAVIGATION",
          "actionPayload": "object_or_string_optional_如果类型是PREDEFINED_AGENT_ACTION_这可能是简化的请求对象或命令字符串_供Agent在用户选择后处理"
        }
      ],
      "requiresUserClarificationForCurrentRequest": "boolean_optional_如果当前请求需要用户进一步输入才能继续_并且content正在请求该澄清_则设置为True_默认为False"
    }
  },
  "diagnostics": {
      "llmConfidenceScoreForThisOutput": "float_optional_0.0_到_1.0",
      "alternativePlansConsideredCount": "integer_optional",
      "parsingFeedbackFromPreviousAttemptId": "string_or_null"
  },
  "usageMetadata": null
}
```
"""
        response_gen_example = (
            "\n【示例 (V1.0.0 Reasoning Model Output): 总结工具结果并生成最终回复】\n"
            "假设对话历史中包含以下工具执行结果 (工具1成功, 工具2是搜索工具也成功):\n"
            "  Tool Message 1 (for toolCallId: tc_xyz_add_r1): { \"role\": \"tool\", ..., \"content\": \"{\\\"status\\\": \\\"success\\\", \\\"message\\\": \\\"已添加电阻R1\\\", ...}\" }\n"
            "  Tool Message 2 (for toolCallId: tc_abc_search_led): { \"role\": \"tool\", ..., \"content\": \"{\\\"status\\\": \\\"success\\\", \\\"message\\\": \\\"已完成对'LED'的DuckDuckGo搜索,找到2条相关信息。\\\", \\\"data\\\": {\\\"query\\\": \\\"LED\\\", \\\"num_results_returned\\\": 2, \\\"results_json_string\\\": \\\"[{\\\\\\\"title\\\\\\\":\\\\\\\"LED - Wikipedia\\\\\\\", ...}]\\\"}}\" }\n"
            "您的输出V1.0-CamelCaseJSON JSON应类似 (ID和时间戳会变化): \n"
            "<think>\n"
            "回顾工具执行结果: add_component_tool (toolCallId: tc_xyz_add_r1) 成功添加了电阻R1。duckduckgo_search_tool (toolCallId: tc_abc_search_led) 成功搜索了'LED'并返回了结果。我需要向用户清晰地报告这两个操作的成功,并简要提及搜索到的信息。最终的回复将整合这些信息,保持友好和乐于助人的语气。\n"
            "</think>\n"
            "```json\n"
            "{\n"
            "  \"requestId\": \"" + (request_id or "userReqExampleIdResp123") + "\",\n"
            "  \"llmInteractionId\": \"" + llm_interaction_id_example_resp_prefix + "_finalSummaryRSearchFix2\",\n" 
            "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
            "  \"status\": \"success\",\n"
            "  \"errorDetails\": null,\n"
            "  \"executionPhase\": \"response_generation\",\n"
            "  \"thoughtProcess\": \"总结R1添加成功,LED搜索成功。(主要思考过程在 <think> 块中)\",\n"
            "  \"decision\": {\n"
            "    \"isCallTools\": false, \n"
            "    \"toolCallRequests\": [], \n"
            "    \"responseToUser\": {\n"
            "      \"contentType\": \"text/plain\",\n"
            "      \"content\": \"您好,我已经成功为您添加了电阻R1。关于LED的DuckDuckGo搜索也已完成,我找到了2条相关信息,例如 'LED - Wikipedia'。您想了解更多搜索到的细节吗？\",\n"
            "      \"suggestionsForNextSteps\": [\n"
            "        {\"suggestionId\": \"sugg_show_search_details\", \"textForUser\": \"显示LED搜索结果的详细信息\", \"actionType\": \"USER_INPUT_EXPECTED\"},\n"
            "        {\"suggestionId\": \"sugg_view_circuit\", \"textForUser\": \"查看当前电路中已有的元件列表。\", \"actionType\": \"USER_INPUT_EXPECTED\", \"actionPayload\": \"当前电路什么样\"}\n"
            "      ],\n"
            "      \"requiresUserClarificationForCurrentRequest\": false \n"
            "    }\n"
            "  },\n"
            "  \"diagnostics\": {\"llmConfidenceScoreForThisOutput\": 0.98},\n"
            "  \"usageMetadata\": null\n"
            "}\n"
            "```\n"
        )
        return (
            "您是一位初版电路设计编程助理 (Agent Version V1.0.0, 11 Tools), 经验丰富,技术精湛,并且极其擅长清晰、准确、诚实地汇报工作结果。\n" # Version update
            f"{reasoning_model_instructions_resp_phase}\n"
            "【核心任务: 响应生成阶段 (V1.0.0)】\n"
            "您当前的任务是: 基于到目前为止的【完整对话历史】(包括用户最初的指令、您在规划阶段生成的V1.0-CamelCaseJSON计划、以及所有【已执行工具的结果详情】,这些工具结果是以 'role: tool', 'toolCallId: ...', 'name: ...', 'content: JSON_string_of_tool_output' 的格式存在于历史记录中的), 首先在 `<think>...</think>` 标签内进行思考和总结, 然后在 `</think>` 之后生成【最终的、面向用户的V1.0-CamelCaseJSON回复】。JSON中所有key【必须】使用camelCase.\n\n"
            "【V1.0.0 输出格式规范 (在</think>之后输出, 与规划阶段结构相同,但有特定值要求 - 再次强调)】:\n"
            f"{json_schema_description_for_resp_phase}\n"
            "【重要指令与检查清单 (V1.0.0 - 响应生成阶段特定要求)】:\n"
            "1.  **`<think>` Block First**: 您的详细工具结果分析和回复构思**必须**在 `<think>...</think>` 标签内。\n"
            "2.  **JSON After `</think>`**: V1.0.0 对象 (用 ```json ... ``` 包裹) **必须**紧跟 `</think>` 标签。此JSON中的所有键名必须是 camelCase。\n"
            "3.  **`executionPhase`**: 在此阶段,此值【必须】是 `\"response_generation\"`。\n"
            "4.  **`decision.isCallTools`**: 在此响应生成阶段,此值【必须】为 `false` (或可解析为`false`的字符串)。\n"
            "5.  **`decision.toolCallRequests`**: 在此响应生成阶段,此列表【必须】为 `[]` (空数组) 或 `null`。\n"
            "6.  **`decision.responseToUser.content`**: 这是您基于所有先前步骤生成的【最终、完整、友好】的文本回复。它【不能】为空字符串或仅包含空白。\n"
            "7.  **回顾工具结果**: 仔细检查对话历史中 `role: tool` 的消息。您的最终回复必须准确反映这些结果。\n\n"
            f"{response_gen_example}\n"
            "【上下文参考信息 (仅供你回顾 - V1.0.0)】:\n"
            f"Current Request ID (如果可用,请在JSON的requestId字段中原样返回): {request_id or 'N/A_NOT_PROVIDED_IN_PROMPT_SET_TO_NULL'}\n"
            f"Current UTC Time (供您生成timestampUtc参考): {current_timestamp_utc}\n"
            f"当前电路与记忆摘要:\n{memory_context}\n"
            f"我的可用工具列表 (共11个, 仅供你参考,此阶段不应再调用它们):\n{tool_schemas_desc}\n\n" # Version update
            "【最后再次强调】: 您的输出【必须】以 `<think>...</think>` 块开始,后跟一个被 ```json ... ``` 包围的、严格符合上述V1.0-CamelCaseJSON规范 (所有key使用camelCase) 的单个JSON对象。在这个阶段,您【绝对不能】再请求调用任何新工具。您的任务是总结并回复。"
        )

# --- Main entry point for testing (Optional) ---
async def main_test_flow(agent: CircuitAgent, user_query: str):
    logger.info(f"\n\n>>>>>>>>> 测试开始 (V1.0.0): 用户查询: '{user_query}' <<<<<<<<<<") # Version update

    async def mock_status_callback(status_update: Dict[str, Any]):
        if "finaljson_if_success" in status_update and status_update["finaljson_if_success"]:
            printable_update = status_update.copy()
            try:
                printable_update["finaljson_if_success"] = json.loads(json.dumps(status_update["finaljson_if_success"], indent=2, ensure_ascii=False))
            except:
                pass
            logger.info(f"[StatusCallback] {json.dumps(printable_update, indent=2, ensure_ascii=False, default=str)}")
        elif "plan" in status_update and isinstance(status_update["plan"], list):
            printable_update = status_update.copy()
            try:
                printable_update["plan"] = json.loads(json.dumps(status_update["plan"], indent=2, ensure_ascii=False))
            except:
                pass
            logger.info(f"[StatusCallback] {json.dumps(printable_update, indent=2, ensure_ascii=False, default=str)}")
        else:
            logger.info(f"[StatusCallback] {json.dumps(status_update, ensure_ascii=False, default=str)}")

    await agent.process_user_request(user_query, mock_status_callback)
    logger.info(f">>>>>>>>>> 测试结束 (V1.0.0): 用户查询: '{user_query}' <<<<<<<<<<\n") # Version update

if __name__ == "__main__":
    logger.info("========== CircuitAgent V1.0.0 (11 Tools) - 命令行测试模式 ==========") 
    
    zhipu_api_key = os.environ.get("ZHIPUAI_API_KEY")
    if not zhipu_api_key:
        logger.critical("严重错误: ZHIPUAI_API_KEY 环境变量未设置,且代码中也未提供。Agent 无法运行。")
        sys.exit("错误: ZHIPUAI_API_KEY 未设置。请在运行前设置此环境变量。")

    test_agent = None # 初始化为 None
    try:
        test_agent = CircuitAgent(
            api_key=zhipu_api_key,
            model_name="glm-z1-flash",
            verbose=True,
            max_short_term_items=20,
            planning_llm_retries=1, 
            max_tool_retries=0, 
            max_replanning_attempts=1 
        )
        logger.info("CircuitAgent V1.0.0 (11 Tools) 初始化成功,准备接收测试指令。")
    except Exception as e_init:
        logger.critical(f"Agent 初始化失败: {e_init}", exc_info=True)
        sys.exit(f"Agent 初始化失败: {e_init}")

    test_queries = [
        "你好,你是谁？",
        "当前电路是什么样的?",
        "帮我添加一个10k欧姆的电阻,命名为R100。",
        "使用 DuckDuckGo 搜索一下什么是基尔霍夫电流定律。",
        "用 DuckDuckGo 搜索 'Python async library' 并返回2条结果",
        "搜索知乎", 
        "请帮我把R100的电阻值更新为4.7k, 然后查一下R100的连接数量, 接着用DuckDuckGo搜索“运算放大器原理”, 最后再移除R100。",
        "清空整个电路。",
    ]

    async def run_all_tests_main(agent_instance: CircuitAgent): # 修改函数名以示区别
        for i, query in enumerate(test_queries):
            logger.info(f"\n--- 测试用例 {i+1}/{len(test_queries)} (V1.0.0) ---")
            await main_test_flow(agent_instance, query) # 传递 agent_instance
            logger.info(f"--- 测试用例 {i+1} (V1.0.0) 完成 ---\n")
            if i < len(test_queries) - 1:
                 await asyncio.sleep(2)

    # ------------------- 关键修复部分开始 -------------------
    async def cleanup_remaining_tasks(current_loop):
        """Helper coroutine to clean up remaining tasks."""
        active_tasks = [task for task in asyncio.all_tasks(current_loop) if not task.done()]
        if active_tasks:
            logger.info(f"等待 {len(active_tasks)} 个剩余异步任务完成...")
            try:
                # 等待所有当前活动的任务完成，设置一个超时以防万一
                await asyncio.wait_for(asyncio.gather(*active_tasks, return_exceptions=True), timeout=5.0)
                logger.info("所有剩余异步任务已处理。")
            except asyncio.TimeoutError:
                logger.warning("等待剩余异步任务超时。")
                # 对于超时的任务，尝试取消它们
                for task in active_tasks:
                    if not task.done():
                        task.cancel()
                        try:
                            await task # 等待取消完成
                        except asyncio.CancelledError:
                            logger.info(f"任务 {task.get_name()} 已取消。")
                        except Exception as e_cancel:
                            logger.error(f"取消任务 {task.get_name()} 时发生错误: {e_cancel}")
            except Exception as e_gather:
                logger.error(f"处理剩余异步任务时发生错误: {e_gather}", exc_info=True)
    # ------------------- 关键修复部分结束 -------------------

    main_loop_is_running_at_start = loop.is_running()
    try:
        if test_agent: # 确保 agent 实例已创建
            # 如果主循环没有运行 (例如，直接从脚本顶部获取的 loop)，则使用 run_until_complete
            if not main_loop_is_running_at_start:
                loop.run_until_complete(run_all_tests_main(test_agent))
            else:
                # 如果已经在运行的循环中 (不太可能直接运行脚本时发生，但为了健壮性)
                # 我们可以创建一个新任务并等待它，但这会复杂化。
                # 简单起见，假设直接运行脚本时，loop 是由我们控制的。
                # 为了安全，我们还是用 run_until_complete, 它能处理好新旧循环。
                asyncio.run(run_all_tests_main(test_agent)) # 或者 loop.run_until_complete
        else:
            logger.error("Agent 实例未能创建，无法运行测试。")

    except KeyboardInterrupt:
        logger.info("测试被用户中断。")
    except Exception as e_main_run:
        logger.critical(f"运行测试时发生未处理的异常: {e_main_run}", exc_info=True)
    finally:
        # 确保在 finally 块中我们使用的是仍然有效的 loop 引用
        # 并且只在它真的还在运行时尝试关闭它。
        # asyncio.run() 会自己管理循环的关闭。
        # 如果是手动管理的 loop，则需要这里的逻辑。
        
        current_loop_ref = None
        try:
            current_loop_ref = asyncio.get_running_loop()
        except RuntimeError: # No running loop
            current_loop_ref = loop # Fallback to the loop we initially got/created

        if current_loop_ref and not current_loop_ref.is_closed():
            # 使用 run_until_complete 来运行清理协程
            logger.info("开始执行异步清理任务...")
            current_loop_ref.run_until_complete(cleanup_remaining_tasks(current_loop_ref))
            logger.info("异步清理任务完成。")
            
            # 只有当这个循环不是由 asyncio.run() 管理时才手动关闭
            # 如果是手动通过 set_event_loop 和 run_until_complete (针对单个协程) 管理的
            if not main_loop_is_running_at_start and current_loop_ref is loop: # 确保是我们手动启动和停止的循环
                 if not current_loop_ref.is_closed(): # 再次检查，因为cleanup可能已经关闭了某些东西
                    current_loop_ref.close()
                    logger.info("事件循环已关闭。")
            elif current_loop_ref.is_running() and not current_loop_ref.is_closed(): # 如果是其他情况且仍在运行
                logger.warning("事件循环仍在运行但未明确关闭，这可能发生在嵌套的asyncio使用中。")


        logger.info("========== CircuitAgent V1.0.0 (11 Tools) - 命令行测试结束 ==========")
--- END: CircuitManusCore.py ---

--- START: completeCode.txt ---
--- START: CircuitManusCore.py ---

# @FileName: circuitmanus.py
# @Version: V1.0.0 - 核心电路交互逻辑与DuckDuckGo搜索工具集 (深化修复ToolExecutor异步调用新)
# @Author: 您的专属程序员 (致力于构建稳定、清晰、可扩展的智能助手核心)
# @Date: [当前日期] - 深化修复ToolExecutor对异步工具的调用，确保协程被正确await。
# @License: MIT License
# @Description:
# ==============================================================================================
#  Manus 系统 V1.0.0 技术实现说明 (附带11个工具)
# ==============================================================================================
# (V1.0.0 变更日志:
#  - 针对ToolExecutor中异步工具返回协程对象而非执行结果的问题，进行了更直接的await调用修复。
#  - 强化日志，在ToolExecutor调用工具前后打印更多关于工具方法类型和返回类型的信息。
#  - 确保duckduckgo_search_tool的返回结构在所有路径下都符合预期。)
# ==============================================================================================

# --- 基础库导入 ---
import re
import os
import json
import time
import logging
import sys
import asyncio
import traceback
import inspect
import functools
from datetime import datetime, timezone
from typing import List, Dict, Any, Optional, Tuple, Set, Union, Callable, Awaitable
from uuid import uuid4
from zhipuai import ZhipuAI
import httpx
from duckduckgo_search import DDGS

# --- 全局异步事件循环 ---
try:
    loop = asyncio.get_running_loop()
except RuntimeError:
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

# --- 日志系统配置 ---
LOG_DIR = "WebUIAgentLogs"
try:
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)
except OSError as e:
    sys.stderr.write(f"严重错误: 无法创建日志目录 '{LOG_DIR}'. 错误信息: {e}\n")
    sys.stderr.write("文件日志功能可能不可用。程序将仅使用控制台日志继续运行。\n")

current_time_for_log = datetime.now()
# 更新日志文件名以反映版本
log_file_name = os.path.join(
    LOG_DIR,
    f"agent_log_v1_1_3_async_call_fix_{current_time_for_log.strftime('%Y%m%d_%H%M%S')}_{current_time_for_log.microsecond // 1000:03d}_P{os.getpid()}.log"
)

log_format = '%(asctime)s - %(name)s - %(levelname)s [%(module)s.%(funcName)s:%(lineno)d] - %(message)s'

console_handler = logging.StreamHandler(sys.stderr)
console_handler.setLevel(logging.DEBUG)
console_handler.setFormatter(logging.Formatter(log_format))

root_logger = logging.getLogger()
root_logger.setLevel(logging.DEBUG)
root_logger.addHandler(console_handler)

logger = logging.getLogger(__name__)

try:
    file_handler = logging.FileHandler(log_file_name, mode='a', encoding='utf-8')
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(logging.Formatter(log_format))
    root_logger.addHandler(file_handler)
    logger.info(f"文件日志配置成功。日志消息也将保存至: {os.path.abspath(log_file_name)}")
except Exception as e:
    logger.error(f"严重错误: 配置日志文件到 '{log_file_name}' 失败。错误信息: {e}", exc_info=True)
    logger.error("Agent 将仅使用控制台日志继续运行。")

logging.getLogger("zhipuai").setLevel(logging.WARNING)
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("duckduckgo_search").setLevel(logging.WARNING)


# --- 电路元件数据类 ---
class CircuitComponent:
    __slots__ = ['id', 'type', 'value']
    def __init__(self, component_id: str, component_type: str, value: Optional[str] = None):
        if not isinstance(component_id, str) or not component_id.strip():
            raise ValueError("元件 ID 必须是有效的非空字符串。")
        if not isinstance(component_type, str) or not component_type.strip():
            raise ValueError("元件类型必须是有效的非空字符串。")
        
        self.id: str = component_id.strip().upper()
        self.type: str = component_type.strip()
        self.value: Optional[str] = str(value).strip() if value is not None and str(value).strip() else None

    def __str__(self) -> str:
        value_str = f" (值: {self.value})" if self.value else ""
        return f"元件: {self.type} (ID: {self.id}){value_str}"

    def __repr__(self) -> str:
        return f"CircuitComponent(id='{self.id}', type='{self.type}', value={repr(self.value)})"

    def to_dict(self) -> Dict[str, Any]:
        return {"id": self.id, "type": self.type, "value": self.value}

# --- 电路实体类 ---
class Circuit:
    def __init__(self):
        logger.info("[Circuit] 初始化电路实体...")
        self.components: Dict[str, CircuitComponent] = {}
        self.connections: Set[Tuple[str, str]] = set()
        self._component_counters: Dict[str, int] = {
            'R': 0, 'L': 0, 'B': 0, 'S': 0, 'C': 0, 'V': 0, 'G': 0, 'U': 0, 'O': 0,
            'I': 0, 'A': 0, 'D': 0, 'P': 0, 'F': 0, 'H': 0,
            'T': 0, 'N': 0, 'IN': 0, 'OUT': 0,
            'SRCH': 0 
        }
        logger.info("[Circuit] 电路实体初始化完成。")

    def add_component(self, component: CircuitComponent):
        if component.id in self.components:
            raise ValueError(f"元件 ID '{component.id}' 已被占用。")
        self.components[component.id] = component
        logger.debug(f"[Circuit] 元件 '{component.id}' ({component.type}) 已添加到电路。")

    def remove_component(self, component_id: str) -> Tuple[Dict[str, Any], int]:
        comp_id_upper = component_id.strip().upper()
        if comp_id_upper not in self.components:
            raise ValueError(f"元件 '{comp_id_upper}' 在电路中不存在。")
        
        removed_component_details = self.components[comp_id_upper].to_dict()
        del self.components[comp_id_upper]
        
        connections_to_remove = {conn for conn in self.connections if comp_id_upper in conn}
        removed_connections_count = len(connections_to_remove)
        for conn in connections_to_remove:
            self.connections.remove(conn)
            logger.debug(f"[Circuit] 移除了涉及元件 '{comp_id_upper}' 的连接 {conn}。")
        
        logger.debug(f"[Circuit] 元件 '{comp_id_upper}' 及其相关 {removed_connections_count} 个连接已从电路中移除。")
        return removed_component_details, removed_connections_count


    def connect_components(self, id1: str, id2: str) -> bool:
        id1_upper = id1.strip().upper()
        id2_upper = id2.strip().upper()
        if id1_upper == id2_upper: raise ValueError(f"不能将元件 '{id1_upper}' 连接到它自己。")
        if id1_upper not in self.components: raise ValueError(f"元件 '{id1_upper}' 在电路中不存在。")
        if id2_upper not in self.components: raise ValueError(f"元件 '{id2_upper}' 在电路中不存在。")
        
        connection = tuple(sorted((id1_upper, id2_upper)))
        if connection in self.connections:
             logger.warning(f"[Circuit] 连接 '{id1_upper}' <--> '{id2_upper}' 已存在。")
             return False
        self.connections.add(connection)
        logger.debug(f"[Circuit] 添加了连接: {id1_upper} <--> {id2_upper}。")
        return True

    def disconnect_components(self, id1: str, id2: str) -> bool:
        id1_upper = id1.strip().upper()
        id2_upper = id2.strip().upper()
        connection = tuple(sorted((id1_upper, id2_upper)))
        if connection not in self.connections:
             logger.warning(f"[Circuit] 连接 '{id1_upper}' <--> '{id2_upper}' 不存在,无需断开。")
             return False
        self.connections.remove(connection)
        logger.debug(f"[Circuit] 断开了连接: {id1_upper} <--> {id2_upper}。")
        return True

    def get_state_description(self) -> str:
        logger.debug("[Circuit] 正在生成电路状态描述...")
        num_components = len(self.components)
        num_connections = len(self.connections)

        if num_components == 0 and num_connections == 0:
            return "【当前电路状态】: 电路为空。"

        desc_lines = ["【当前电路状态】:"]
        desc_lines.append(f"  - 元件 ({num_components}):")
        if self.components:
            sorted_ids = sorted(self.components.keys())
            for cid in sorted_ids:
                desc_lines.append(f"    - {str(self.components[cid])}")
        else:
            desc_lines.append("    (无)")

        desc_lines.append(f"  - 连接 ({num_connections}):")
        if self.connections:
            sorted_connections = sorted(list(self.connections))
            for c1, c2 in sorted_connections:
                desc_lines.append(f"    - {c1} <--> {c2}")
        else:
            desc_lines.append("    (无)")

        description = "\n".join(desc_lines)
        logger.debug("[Circuit] 电路状态描述生成完毕。")
        return description

    def generate_component_id(self, component_type: str) -> str:
        logger.debug(f"[Circuit] 正在为类型 '{component_type}' 生成唯一 ID...")
        type_map = {
            "resistor": "R", "电阻": "R", "capacitor": "C", "电容": "C",
            "battery": "B", "电池": "B", "voltage source": "V", "voltage": "V",
            "电压源": "V", "电压": "V", "led": "L", "发光二极管": "L", "switch": "S",
            "开关": "S", "ground": "G", "地": "G", "ic": "U", "chip": "U", "芯片": "U",
            "集成电路": "U", "inductor": "I", "电感": "I", "current source": "A",
            "电流源": "A", "diode": "D", "二极管": "D", "potentiometer": "P", "电位器": "P",
            "fuse": "F", "保险丝": "F", "header": "H", "排针": "H",
            "terminal": "T", "端子": "T", "connection point": "P", "连接点": "P",
            "node": "N", "节点": "N",
            "input": "IN", "输入": "IN", "output": "OUT", "输出": "OUT",
            "search_record": "SRCH", "搜索记录": "SRCH", 
            "component": "O", "元件": "O",
        }

        for code in type_map.values():
            if code not in self._component_counters:
                 self._component_counters[code] = 0

        cleaned_type = component_type.strip().lower()
        type_code = "O"
        best_match_len = 0

        if cleaned_type == "input": type_code = "IN"
        elif cleaned_type == "output": type_code = "OUT"
        elif cleaned_type == "ground" or cleaned_type == "地": type_code = "G"
        else:
            for keyword, code in type_map.items():
                if keyword in cleaned_type and len(keyword) > best_match_len:
                    type_code = code
                    best_match_len = len(keyword)

        if type_code == "O" and cleaned_type not in ["component", "元件"]:
             logger.warning(f"[Circuit] 未找到类型 '{component_type}' 的特定前缀,将使用通用前缀 'O'。")

        MAX_ID_ATTEMPTS = 10000
        for attempt in range(MAX_ID_ATTEMPTS):
            self._component_counters[type_code] += 1
            gen_id = f"{type_code}{self._component_counters[type_code]}"
            if gen_id not in self.components:
                logger.debug(f"[Circuit] 生成唯一 ID: '{gen_id}' (尝试 {attempt + 1})。")
                return gen_id
            logger.debug(f"[Circuit] ID '{gen_id}' 已存在,尝试下一个。(尝试 {attempt + 1})。")

        raise RuntimeError(f"未能为类型 '{component_type}' (代码 '{type_code}') 生成唯一 ID ({MAX_ID_ATTEMPTS} 次尝试后)。")

    def clear(self):
        logger.info("[Circuit] 正在清空电路状态...")
        comp_count = len(self.components)
        conn_count = len(self.connections)

        self.components = {}
        self.connections = set()
        self._component_counters = {k: 0 for k in self._component_counters}

        logger.info(f"[Circuit] 电路状态已清空 (移除了 {comp_count} 个元件, {conn_count} 个连接,并重置了所有 ID 计数器)。")

# --- 工具注册装饰器 ---
def register_tool(description: str, parameters: Dict[str, Any]):
    def decorator(func):
        func._tool_schema = {"description": description, "parameters": parameters}
        func._is_tool = True
        # functools.wraps is important to preserve metadata, especially for inspect.iscoroutinefunction
        @functools.wraps(func)
        async def async_wrapper(*args, **kwargs): # if original func is async
            return await func(*args, **kwargs)
        
        @functools.wraps(func)
        def sync_wrapper(*args, **kwargs): # if original func is sync
            return func(*args, **kwargs)

        if inspect.iscoroutinefunction(func):
            return async_wrapper
        else:
            return sync_wrapper
    return decorator

# --- 模块化组件: MemoryManager (记忆管理器) ---
class MemoryManager:
    def __init__(self, max_short_term_items: int = 30, max_long_term_items: int = 200):
        logger.info("[MemoryManager] 初始化记忆模块...")
        if max_short_term_items <= 1:
            raise ValueError("参数 'max_short_term_items' 必须大于 1。")

        self.max_short_term_items = max_short_term_items
        self.max_long_term_items = max_long_term_items
        self.short_term: List[Dict[str, Any]] = []
        self.long_term: List[str] = []
        self.circuit: Circuit = Circuit()

        logger.info(f"[MemoryManager] 记忆模块初始化完成。短期记忆上限: {max_short_term_items} 条, 长期记忆上限: {max_long_term_items} 条。")

    def add_to_short_term(self, message: Dict[str, Any]):
        logger.debug(f"[MemoryManager] 添加消息到短期记忆 (Role: {message.get('role', 'N/A')})。当前数量: {len(self.short_term)}。")
        self.short_term.append(message)
        current_size = len(self.short_term)
        if current_size > self.max_short_term_items:
            logger.debug(f"[MemoryManager] 短期记忆超限 ({current_size}/{self.max_short_term_items}),执行修剪...")
            items_to_remove_count = current_size - self.max_short_term_items
            non_system_indices = [i for i, msg in enumerate(self.short_term) if msg.get("role") != "system"]
            num_to_actually_remove = min(items_to_remove_count, len(non_system_indices))

            if num_to_actually_remove > 0:
                indices_to_remove_set = set(non_system_indices[:num_to_actually_remove])
                removed_roles = [self.short_term[i].get('role', 'N/A') for i in sorted(list(indices_to_remove_set))]
                new_short_term = [msg for i, msg in enumerate(self.short_term) if i not in indices_to_remove_set]
                self.short_term = new_short_term
                logger.info(f"[MemoryManager] 短期记忆修剪完成,移除了 {num_to_actually_remove} 条最旧的非系统消息 (角色: {removed_roles})。")
            elif items_to_remove_count > 0:
                 logger.warning(f"[MemoryManager] 短期记忆超限 ({current_size}/{self.max_short_term_items}) 但未能找到足够的非系统消息进行移除。")
        logger.debug(f"[MemoryManager] 添加后短期记忆数量: {len(self.short_term)}。")

    def add_to_long_term(self, knowledge_snippet: str):
        MAX_SNIPPET_LENGTH = 10000
        if len(knowledge_snippet) > MAX_SNIPPET_LENGTH:
            logger.warning(f"[MemoryManager] 尝试添加的长期记忆片段过长 ({len(knowledge_snippet)} 字符),已截断为 {MAX_SNIPPET_LENGTH} 字符。")
            knowledge_snippet = knowledge_snippet[:MAX_SNIPPET_LENGTH] + "... (已截断)"

        logger.debug(f"[MemoryManager] 添加知识到长期记忆: '{knowledge_snippet[:1000]}{'...' if len(knowledge_snippet) > 100 else ''}'。当前数量: {len(self.long_term)}。")
        self.long_term.append(knowledge_snippet)
        if len(self.long_term) > self.max_long_term_items:
            removed_snippet = self.long_term.pop(0)
            logger.info(f"[MemoryManager] 长期记忆超限 ({self.max_long_term_items}), 移除最旧知识: '{removed_snippet[:50]}...'。")
        logger.debug(f"[MemoryManager] 添加后长期记忆数量: {len(self.long_term)}。")

    def get_circuit_state_description(self) -> str:
        return self.circuit.get_state_description()

    def get_memory_context_for_prompt(self, recent_long_term_count: int = 7) -> str:
        logger.debug("[MemoryManager] 正在格式化记忆上下文用于 Prompt...")
        circuit_desc = self.get_circuit_state_description()
        long_term_str = ""
        if self.long_term:
            actual_count = min(recent_long_term_count, len(self.long_term))
            if actual_count > 0:
                recent_items = self.long_term[-actual_count:]
                long_term_str = "\n\n【近期经验总结 (仅显示最近 N 条,按时间倒序排列,最新在前)】\n" + "\n".join(f"- {item}" for item in reversed(recent_items))
                logger.debug(f"[MemoryManager] 已提取最近 {len(recent_items)} 条长期记忆 (倒序)。")
        long_term_str += "\n(注: 当前仅使用最近期记忆,未来版本将实现基于相关性的检索。)"
        context = f"{circuit_desc}{long_term_str}".strip()
        logger.debug(f"[MemoryManager] 记忆上下文 (电路+长期) 格式化完成。")
        return context

# --- 模块化组件: LLMInterface (LLM 交互接口) ---
class LLMInterface:
    def __init__(self, agent_instance: 'CircuitAgent', model_name: str = "glm-z1-flash", default_temperature: float = 0.01, default_max_tokens: int = 8190):
        logger.info(f"[LLMInterface V1.0.0] 初始化 LLM 接口,目标模型: {model_name}。")
        if not agent_instance or not hasattr(agent_instance, 'api_key'):
             raise ValueError("LLMInterface 需要一个包含 'api_key' 属性的 Agent 实例。")
        self.agent_instance = agent_instance
        api_key = self.agent_instance.api_key
        if not api_key: raise ValueError("智谱 AI API Key 不能为空。")
        try:
            self.client = ZhipuAI(api_key=api_key)
            logger.info("[LLMInterface V1.0.0] 智谱 AI 客户端初始化成功。")
        except Exception as e:
            logger.critical(f"[LLMInterface V1.0.0] 初始化智谱 AI 客户端失败: {e}", exc_info=True)
            raise ConnectionError(f"初始化智谱 AI 客户端失败: {e}") from e

        self.model_name = model_name
        self.default_temperature = default_temperature
        self.default_max_tokens = default_max_tokens
        logger.info(f"[LLMInterface V1.0.0] LLM 接口初始化完成 (模型: {model_name}, 温度: {default_temperature}, 最大Token数: {default_max_tokens}, 流式输出: False)。")

    async def call_llm(self, messages: List[Dict[str, Any]], execution_phase: str, status_callback: Optional[Callable[[Dict], Awaitable[None]]] = None) -> Any:
        call_args = {
            "model": self.model_name,
            "messages": messages,
            "temperature": self.default_temperature,
            "max_tokens": self.default_max_tokens,
            "stream": False,
        }

        logger.info(f"[LLMInterface V1.0.0] 准备异步调用 LLM ({self.model_name}, 阶段: {execution_phase}, 期望输出格式: <think> 标签后跟 JSON)...")
        logger.debug(f"[LLMInterface V1.0.0] 发送的消息条数: {len(messages)}。")
        if logger.isEnabledFor(logging.DEBUG) and len(messages) > 0:
             try:
                 messages_content_for_log = []
                 for m_idx, m in enumerate(messages):
                     role = m.get("role")
                     content = str(m.get("content",""))
                     if role == "system":
                         content_preview = content[:10000] + ("..." if len(content) > 10000 else "")
                     else:
                         content_preview = content[:1000] + ("..." if len(content) > 200 else "")
                     messages_content_for_log.append({"index": m_idx, "role": role, "content_preview_length": len(content), "content_preview": content_preview})
                 messages_summary = json.dumps(messages_content_for_log, ensure_ascii=False, indent=2)
                 logger.debug(f"[LLMInterface V1.0.0] 发送给 LLM 的消息列表 (预览):\n{messages_summary}")
             except Exception as e_json:
                 logger.debug(f"[LLMInterface V1.0.0] 无法序列化消息列表进行调试日志: {e_json}")

        request_id_to_send = self.agent_instance.current_request_id if hasattr(self.agent_instance, 'current_request_id') else None
        if status_callback:
            await status_callback({
                "type": "llm_communication_status",
                "request_id": request_id_to_send,
                "llm_phase": execution_phase,
                "status": "started",
                "message": f"正在与智能大脑 ({self.model_name}) 沟通 ({execution_phase})..."
            })

        response = None
        try:
            start_time = time.monotonic()
            response = await asyncio.to_thread(self.client.chat.completions.create, **call_args)
            duration = time.monotonic() - start_time
            logger.info(f"[LLMInterface V1.0.0] LLM 异步调用成功。耗时: {duration:.3f} 秒。")
            if status_callback:
                await status_callback({
                    "type": "llm_communication_status",
                    "request_id": request_id_to_send,
                    "llm_phase": execution_phase,
                    "status": "completed",
                    "message": f"与智能大脑 ({self.model_name}) 沟通完成 ({execution_phase})。",
                    "details": {"duration_seconds": duration}
                })

            if response:
                if response.usage: logger.info(f"[LLMInterface V1.0.0] Token 统计: Prompt={response.usage.prompt_tokens}, Completion={response.usage.completion_tokens}, Total={response.usage.total_tokens}")
                if response.choices:
                    finish_reason = response.choices[0].finish_reason
                    logger.info(f"[LLMInterface V1.0.0] 完成原因: {finish_reason}")
                    if finish_reason == 'length': logger.warning("[LLMInterface V1.0.0] LLM 响应因达到最大 token 限制而被截断！这可能导致输出不完整！")
                    raw_llm_content = response.choices[0].message.content
                    logger.debug(f"[LLMInterface V1.0.0] LLM 原始响应内容 (完整):\n{raw_llm_content}")
                else:
                    logger.warning("[LLMInterface V1.0.0] LLM 响应中缺少 'choices' 字段。")
            else:
                 logger.error("[LLMInterface V1.0.0] LLM API 调用返回了 None！")
                 raise ConnectionError("LLM API call returned None.")
            return response
        except Exception as e:
            logger.error(f"[LLMInterface V1.0.0] LLM API 异步调用失败: {e}", exc_info=True)
            if status_callback:
                 await status_callback({
                    "type": "llm_communication_status",
                    "request_id": request_id_to_send,
                    "llm_phase": execution_phase,
                    "status": "error",
                    "message": f"与智能大脑 ({self.model_name}) 沟通失败 ({execution_phase})。",
                    "details": {"error": str(e), "error_type": type(e).__name__}
                 })
            raise

# --- 模块化组件: OutputParser (输出解析器) ---
class OutputParser:
    def __init__(self, agent_tools_registry: Optional[Dict[str, Dict[str, Any]]] = None):
        logger.info("[OutputParser] 初始化输出解析器 (适配 ManusLLMResponse-V1.0.0 CamelCase JSON结构,提取 <think> 标签,增强布尔解析)。")
        self.agent_tools_registry = agent_tools_registry if agent_tools_registry else {}

    def _validate_tool_arguments(self, tool_name: str, tool_arguments: Dict[str, Any], tool_call_id: str) -> List[Dict[str, str]]:
        validation_errors: List[Dict[str, str]] = []
        if not self.agent_tools_registry or tool_name not in self.agent_tools_registry:
            validation_errors.append({
                "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolName",
                "issue_description": f"工具 '{tool_name}' 未在 Agent 的注册表中找到。"
            })
            return validation_errors

        tool_schema = self.agent_tools_registry[tool_name]
        param_schema_props = tool_schema.get("parameters", {}).get("properties", {})
        required_params = tool_schema.get("parameters", {}).get("required", [])

        for req_param in required_params:
            if req_param not in tool_arguments:
                validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{req_param}",
                    "issue_description": f"工具 '{tool_name}' 的必需参数 '{req_param}' 缺失。"
                })

        for arg_name, arg_value in tool_arguments.items():
            if arg_name not in param_schema_props:
                validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                    "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 是未在 Schema 中定义的未知参数。"
                })
                continue

            expected_type_str = param_schema_props[arg_name].get("type")
            is_optional_and_null_like = (arg_name not in required_params) and (arg_value is None)

            if expected_type_str == "string" and not isinstance(arg_value, str):
                if not is_optional_and_null_like:
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是字符串,但得到的是 {type(arg_value).__name__}。"
                    })
            elif expected_type_str == "integer" and not isinstance(arg_value, int):
                 if not (is_optional_and_null_like and expected_type_str == "integer"): 
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是整数,但得到的是 {type(arg_value).__name__}。"
                    })
            elif expected_type_str == "number" and not isinstance(arg_value, (int, float)):
                 if not (is_optional_and_null_like and expected_type_str == "number"):
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是数字,但得到的是 {type(arg_value).__name__}。"
                    })
            elif expected_type_str == "boolean" and not isinstance(arg_value, bool):
                 validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                    "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是布尔值,但得到的是 {type(arg_value).__name__}。"
                })
            elif expected_type_str == "object" and not isinstance(arg_value, dict):
                 validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                    "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是对象(字典),但得到的是 {type(arg_value).__name__}。"
                })
            elif expected_type_str == "array" and not isinstance(arg_value, list):
                 validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                    "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是数组(列表),但得到的是 {type(arg_value).__name__}。"
                })
        return validation_errors


    def parse_llm_response_to_structured_json(self, llm_api_response_message: Any, execution_phase: str) -> Tuple[Optional[Dict[str, Any]], str, List[Dict[str,str]]]:
        parser_id = f"parse{str(uuid4())[:8]}"
        logger.debug(f"[{parser_id}-OutputParser] 开始解析 LLM 响应 (阶段: {execution_phase})...")
        parsed_json_dict: Optional[Dict[str, Any]] = None
        error_message: str = ""
        failed_validation_points_list: List[Dict[str, str]] = []
        extracted_thought_process: Optional[str] = None

        if llm_api_response_message is None:
            error_message = "LLM 响应对象 (Message) 为 None。"
            logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message}")
            return None, error_message, [{"jsonPath": "root", "issue_description": error_message}]

        raw_content = getattr(llm_api_response_message, 'content', None)
        if not raw_content or not raw_content.strip():
            error_message = "LLM 响应内容 (content 字段) 为空或仅包含空白字符。"
            logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message}")
            return None, error_message, [{"jsonPath": "content", "issue_description": error_message}]

        logger.debug(f"[{parser_id}-OutputParser] 接收到的原始 LLM content (完整):\n{raw_content}")

        content_to_parse_for_json = raw_content
        think_match = re.search(r"<think>(.*?)</think>", raw_content, re.DOTALL | re.IGNORECASE)

        if think_match:
            extracted_thought_process = think_match.group(1).strip()
            content_to_parse_for_json = raw_content[think_match.end():].strip()
            logger.info(f"[{parser_id}-OutputParser] 成功提取到 <think>...</think> 内容。")
            logger.debug(f"[{parser_id}-OutputParser] 提取的思考过程 (预览):\n{extracted_thought_process[:1000]}...")
            logger.debug(f"[{parser_id}-OutputParser] 剩余内容待解析为JSON (预览):\n{content_to_parse_for_json[:1000]}...")
            if not content_to_parse_for_json:
                 error_message = "LLM 响应包含 <think> 块但之后没有内容可解析为 JSON。"
                 logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message}")
                 return None, error_message, [{"jsonPath": "root_after_think_block", "issue_description": error_message}]
        else:
            logger.warning(f"[{parser_id}-OutputParser] 未在LLM响应中找到有效的 <think>...</think> 块,将尝试按旧方式解析整个内容。")

        json_string_to_parse = content_to_parse_for_json.strip()
        match_md_json = re.search(r"```json\s*(.*?)\s*```", json_string_to_parse, re.DOTALL | re.IGNORECASE)
        if match_md_json:
            json_string_to_parse = match_md_json.group(1).strip()
            logger.debug(f"[{parser_id}-OutputParser] 从 Markdown 代码块中提取到 JSON 字符串。")
        else:
            first_brace = json_string_to_parse.find('{')
            last_brace = json_string_to_parse.rfind('}')
            if first_brace > 0 and (last_brace == -1 or first_brace > last_brace) :
                prefix_content = json_string_to_parse[:first_brace].strip()
                logger.warning(f"[{parser_id}-OutputParser] 在预期的 JSON 开头 '{{' 之前检测到非空白内容: '{prefix_content[:1000]}...'。将尝试从 '{{' 开始解析。")
                json_string_to_parse = json_string_to_parse[first_brace:]
            elif first_brace == -1 :
                error_message = "无法在 LLM 响应内容 (post-<think>或完整) 中找到 JSON 对象的起始 '{'。"
                logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message} 原始响应预览 (post-<think>或完整): {json_string_to_parse[:1000]}...")
                return None, error_message, [{"jsonPath": "content_for_json_parsing", "issue_description": error_message}]

        logger.debug(f"[{parser_id}-OutputParser] 预处理后,准备解析的 JSON 字符串 (完整):\n{json_string_to_parse}")

        try:
            parsed_json_dict = json.loads(json_string_to_parse)
            logger.info(f"[{parser_id}-OutputParser] JSON 字符串成功解析为字典。")
        except json.JSONDecodeError as json_err:
            error_message = f"JSON 解析失败: {json_err}。"
            logger.error(f"[{parser_id}-OutputParser] {error_message} Raw JSON string (截断): '{json_string_to_parse[:1000]}...'")
            return None, error_message, [{"jsonPath": "root_json_parsing", "issue_description": f"JSONDecodeError: {json_err}"}]
        except Exception as e:
            error_message = f"解析 LLM 响应时发生未知错误: {e}"
            logger.error(f"[{parser_id}-OutputParser] 解析时未知错误: {error_message}", exc_info=True)
            return None, error_message, [{"jsonPath": "root_json_parsing", "issue_description": f"Unexpected parsing error: {e}"}]

        if not isinstance(parsed_json_dict, dict):
            error_message = "解析后的结果不是一个 JSON 对象 (字典)。"
            logger.error(f"[{parser_id}-OutputParser] 结构验证失败: {error_message}")
            return None, error_message, [{"jsonPath": "root_json_parsing", "issue_description": error_message}]

        if extracted_thought_process is not None:
            if "thoughtProcess" in parsed_json_dict and parsed_json_dict["thoughtProcess"] and parsed_json_dict["thoughtProcess"] != extracted_thought_process:
                logger.warning(f"[{parser_id}-OutputParser] LLM提供了<think>块和JSON内部的thoughtProcess。将优先使用<think>块内容。")
            parsed_json_dict["thoughtProcess"] = extracted_thought_process
            logger.info(f"[{parser_id}-OutputParser] 已将<think>块内容置于parsed_json_dict['thoughtProcess']。")
        elif "thoughtProcess" not in parsed_json_dict or not parsed_json_dict.get("thoughtProcess", "").strip():
             logger.warning(f"[{parser_id}-OutputParser] LLM未提供<think>块,且JSON内部的thoughtProcess为空或缺失。思考过程可能不完整。")

        required_top_level_fields = ["requestId", "llmInteractionId", "timestampUtc", "status", "executionPhase", "thoughtProcess", "decision"]
        for field in required_top_level_fields:
            if field not in parsed_json_dict:
                failed_validation_points_list.append({"jsonPath": field, "issue_description": f"缺少必需的顶级字段 '{field}'。"})

        status_val = parsed_json_dict.get("status")
        if status_val not in ["success", "failure"]:
            failed_validation_points_list.append({"jsonPath": "status", "issue_description": f"字段 'status' 的值 '{status_val}' 无效,必须是 'success' 或 'failure'。"})

        exec_phase_val = parsed_json_dict.get("executionPhase")
        if exec_phase_val not in ["planning", "response_generation"]:
            failed_validation_points_list.append({"jsonPath": "executionPhase", "issue_description": f"字段 'executionPhase' 的值 '{exec_phase_val}' 无效,必须是 'planning' 或 'response_generation'。"})
        elif exec_phase_val != execution_phase:
             failed_validation_points_list.append({"jsonPath": "executionPhase", "issue_description": f"LLM报告的 'executionPhase' ('{exec_phase_val}') 与 Agent 期望的阶段 ('{execution_phase}') 不匹配。"})

        if status_val == "failure":
            error_details_obj = parsed_json_dict.get("errorDetails")
            if not isinstance(error_details_obj, dict):
                failed_validation_points_list.append({"jsonPath": "errorDetails", "issue_description": "当 'status' 为 'failure' 时, 'errorDetails' 必须是一个对象。"})
            else:
                if not isinstance(error_details_obj.get("errorType"), str) or not error_details_obj.get("errorType","").strip():
                    failed_validation_points_list.append({"jsonPath": "errorDetails.errorType", "issue_description": "'errorDetails' 对象中缺少有效的 'errorType' 字符串。"})
                if not isinstance(error_details_obj.get("errorCode"), str) or not error_details_obj.get("errorCode","").strip():
                    failed_validation_points_list.append({"jsonPath": "errorDetails.errorCode", "issue_description": "'errorDetails' 对象中缺少有效的 'errorCode' 字符串。"})
                if not isinstance(error_details_obj.get("technicalMessage"), str) or not error_details_obj.get("technicalMessage","").strip():
                    failed_validation_points_list.append({"jsonPath": "errorDetails.technicalMessage", "issue_description": "'errorDetails' 对象中缺少有效的 'technicalMessage' 字符串。"})
                if "isDirectLlmFailure" not in error_details_obj or not isinstance(error_details_obj.get("isDirectLlmFailure"), bool):
                    logger.warning(f"[{parser_id}-OutputParser] 'errorDetails.isDirectLlmFailure' 字段缺失或类型不为布尔。Agent将假定为False。LLM输出应包含此字段。")
                    failed_validation_points_list.append({"jsonPath": "errorDetails.isDirectLlmFailure", "issue_description": "'errorDetails' 对象中缺少有效的布尔字段 'isDirectLlmFailure'。"})
        elif status_val == "success" and parsed_json_dict.get("errorDetails") is not None:
             failed_validation_points_list.append({"jsonPath": "errorDetails", "issue_description": "当 'status' 为 'success' 时, 'errorDetails' 字段必须为 null 或不存在。"})

        if not isinstance(parsed_json_dict.get("thoughtProcess"), str):
            if parsed_json_dict.get("thoughtProcess") is not None:
                logger.warning(f"[{parser_id}-OutputParser] 'thoughtProcess' 字段存在但类型不正确 (应为字符串)。")
                failed_validation_points_list.append({"jsonPath": "thoughtProcess", "issue_description": "'thoughtProcess' 字段如果存在,必须是字符串。"})
        elif not parsed_json_dict.get("thoughtProcess","").strip() and extracted_thought_process is None:
            logger.warning(f"[{parser_id}-OutputParser] LLM未提供<think>块,且JSON内部的thoughtProcess为空或缺失。思考过程可能不完整。")

        decision_obj = parsed_json_dict.get("decision")
        if not isinstance(decision_obj, dict):
            failed_validation_points_list.append({"jsonPath": "decision", "issue_description": "'decision' 字段必须是一个对象。"})
        else:
            raw_is_call_tools_val = decision_obj.get("isCallTools")
            is_call_tools_val = None
            if isinstance(raw_is_call_tools_val, bool):
                is_call_tools_val = raw_is_call_tools_val
            elif isinstance(raw_is_call_tools_val, str):
                if raw_is_call_tools_val.lower() == 'true':
                    is_call_tools_val = True
                elif raw_is_call_tools_val.lower() == 'false':
                    is_call_tools_val = False
            
            if is_call_tools_val is None:
                failed_validation_points_list.append({"jsonPath": "decision.isCallTools", "issue_description": f"'decision.isCallTools' 值 '{raw_is_call_tools_val}' 无效。必须是布尔类型或可解析为布尔的字符串('true'/'false')。"})
            else:
                decision_obj["isCallTools"] = is_call_tools_val
                logger.debug(f"[{parser_id}-OutputParser] 'isCallTools' (原始值: {raw_is_call_tools_val}) 被解析为布尔值: {is_call_tools_val}。")

            tool_call_requests = decision_obj.get("toolCallRequests")
            if is_call_tools_val is True:
                if not isinstance(tool_call_requests, list):
                    failed_validation_points_list.append({"jsonPath": "decision.toolCallRequests", "issue_description": "当 'isCallTools' 为 True 时, 'toolCallRequests' 必须是一个列表。"})
                elif not tool_call_requests:
                    logger.warning(f"[{parser_id}-OutputParser] 'isCallTools' 为 True 但 'toolCallRequests' 列表为空。这可能是一个规划逻辑问题。")
                elif tool_call_requests:
                    for i, tool_req_item in enumerate(tool_call_requests):
                        item_path_prefix = f"decision.toolCallRequests[{i}]"
                        if not isinstance(tool_req_item, dict):
                            failed_validation_points_list.append({"jsonPath": item_path_prefix, "issue_description": "列表中的每个工具调用请求必须是对象。"}); continue

                        tool_call_id = tool_req_item.get("toolCallId")
                        if not isinstance(tool_call_id, str) or not tool_call_id.strip():
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.toolCallId", "issue_description": "缺少有效的 'toolCallId' 字符串。"})

                        tool_name = tool_req_item.get("toolName")
                        if not isinstance(tool_name, str) or not tool_name.strip():
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.toolName", "issue_description": "缺少有效的 'toolName' 字符串。"})

                        tool_arguments = tool_req_item.get("toolArguments")
                        if not isinstance(tool_arguments, dict):
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.toolArguments", "issue_description": "'toolArguments' 必须是一个对象。"})
                        elif tool_name and isinstance(tool_name, str) and tool_name.strip():
                            arg_validation_errors = self._validate_tool_arguments(tool_name, tool_arguments, tool_call_id if (tool_call_id and isinstance(tool_call_id, str) and tool_call_id.strip()) else f"index_{i}")
                            failed_validation_points_list.extend(arg_validation_errors)

                        ui_hints = tool_req_item.get("uiHints")
                        if ui_hints is not None and not isinstance(ui_hints, dict):
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.uiHints", "issue_description": "'uiHints' 如果存在,必须是一个对象。"})

            elif is_call_tools_val is False:
                if tool_call_requests is not None and (not isinstance(tool_call_requests, list) or tool_call_requests):
                    failed_validation_points_list.append({"jsonPath": "decision.toolCallRequests", "issue_description": "当 'isCallTools' 为 False 时, 'toolCallRequests' 必须是 null 或空列表 []。"})

            response_user_obj = decision_obj.get("responseToUser")
            if not isinstance(response_user_obj, dict):
                failed_validation_points_list.append({"jsonPath": "decision.responseToUser", "issue_description": "'responseToUser' 必须是一个对象。"})
            else:
                if not isinstance(response_user_obj.get("contentType"), str) or not response_user_obj.get("contentType","").strip():
                     failed_validation_points_list.append({"jsonPath": "decision.responseToUser.contentType", "issue_description": "'responseToUser' 对象缺少有效的 'contentType' 字符串。"})

                resp_content = response_user_obj.get("content")
                if not isinstance(resp_content, str):
                     failed_validation_points_list.append({"jsonPath": "decision.responseToUser.content", "issue_description": "'responseToUser.content' 必须是字符串。"})

                if is_call_tools_val is False and (not resp_content or resp_content.strip() == ""):
                     if execution_phase == "response_generation":
                         failed_validation_points_list.append({"jsonPath": "decision.responseToUser.content", "issue_description": "在响应生成阶段,当不调用工具时, 'responseToUser.content' 必须是有效的非空字符串。"})
                     else:
                        failed_validation_points_list.append({"jsonPath": "decision.responseToUser.content", "issue_description": "当 'isCallTools' 为 False (直接回复) 时, 'responseToUser.content' 必须是有效的非空字符串。"})

                suggestions = response_user_obj.get("suggestionsForNextSteps")
                if suggestions is not None:
                    if not isinstance(suggestions, list):
                        failed_validation_points_list.append({"jsonPath": "decision.responseToUser.suggestionsForNextSteps", "issue_description": "'suggestionsForNextSteps' 如果存在,必须是一个列表。"})
                    else:
                        for j, sugg_item in enumerate(suggestions):
                            sugg_path_prefix = f"decision.responseToUser.suggestionsForNextSteps[{j}]"
                            if not isinstance(sugg_item, dict):
                                failed_validation_points_list.append({"jsonPath": sugg_path_prefix, "issue_description": "列表中的每个建议必须是对象。"}); continue
                            if not isinstance(sugg_item.get("textForUser"), str) or not sugg_item.get("textForUser","").strip():
                                failed_validation_points_list.append({"jsonPath": f"{sugg_path_prefix}.textForUser", "issue_description": "建议对象缺少有效的 'textForUser' 字符串。"})

                clarification_flag = response_user_obj.get("requiresUserClarificationForCurrentRequest")
                if clarification_flag is not None and not isinstance(clarification_flag, bool):
                     failed_validation_points_list.append({"jsonPath": "decision.responseToUser.requiresUserClarificationForCurrentRequest", "issue_description": "'requiresUserClarificationForCurrentRequest' 如果存在,必须是布尔类型。"})

        diagnostics_obj = parsed_json_dict.get("diagnostics")
        if diagnostics_obj is not None and not isinstance(diagnostics_obj, dict):
            failed_validation_points_list.append({"jsonPath": "diagnostics", "issue_description": "'diagnostics' 如果存在,必须是一个对象。"})

        if failed_validation_points_list:
            error_message_parts = [f"JSON 结构或内容验证失败 (共 {len(failed_validation_points_list)} 点):"]
            for err_point in failed_validation_points_list:
                error_message_parts.append(f"  -路径 '{err_point['jsonPath']}': {err_point['issue_description']}")
            error_message = "\n".join(error_message_parts)

            json_content_for_log = json.dumps(parsed_json_dict, indent=2, ensure_ascii=False) if parsed_json_dict else json_string_to_parse[:1000]
            logger.error(f"[{parser_id}-OutputParser]\n{error_message}\n解析的 JSON 内容 (可能不完整或无效):\n{json_content_for_log}")
            return None, error_message, failed_validation_points_list

        logger.info(f"[{parser_id}-OutputParser] LLM 响应 (阶段: {execution_phase}, LLM_ID: {parsed_json_dict.get('llmInteractionId', 'N/A')}) 已成功解析并验证为 ManusLLMResponse-V1.0.0兼容结构 (思考过程来源: {'<think> block' if extracted_thought_process else 'JSON field'})！")
        return parsed_json_dict, "", []


# --- 模块化组件: ToolExecutor (工具执行器) ---
class ToolExecutor:
    def __init__(self, agent_instance: 'CircuitAgent', max_tool_retries: int = 1, tool_retry_delay_seconds: float = 1.0):
        logger.info("[ToolExecutor] 初始化工具执行器 (支持异步, 重试, 失败中止, UI回调增强 V1.0.0)。") # Version update
        if not isinstance(agent_instance, CircuitAgent):
            raise TypeError("ToolExecutor 需要一个 CircuitAgent 实例。")
        self.agent_instance = agent_instance
        if not hasattr(agent_instance, 'memory_manager') or not isinstance(agent_instance.memory_manager, MemoryManager):
            raise TypeError("Agent 实例缺少有效的 MemoryManager。")

        self.verbose_mode = getattr(agent_instance, 'verbose_mode', True)
        self.max_tool_retries = max(0, max_tool_retries)
        self.tool_retry_delay_seconds = max(0.1, tool_retry_delay_seconds)

        logger.info(f"[ToolExecutor] 工具执行配置: 每个工具最多重试 {self.max_tool_retries} 次,重试间隔 {self.tool_retry_delay_seconds} 秒。详细模式: {self.verbose_mode}。")

    async def _send_tool_status_update(
        self,
        status_callback: Optional[Callable[[Dict], Awaitable[None]]],
        tool_call_id: str,
        tool_name: str,
        tool_status: str,
        message: str,
        tool_arguments: Optional[Dict] = None,
        details: Optional[Dict] = None
    ):
        if status_callback:
            request_id_to_send = self.agent_instance.current_request_id if hasattr(self.agent_instance, 'current_request_id') else None
            arguments_summary_str = "N/A"
            if tool_arguments:
                try:
                    args_parts = []
                    for k, v in tool_arguments.items():
                        v_str = str(v) if v is not None else "None"
                        v_preview = v_str[:30] + '...' if len(v_str) > 30 else v_str
                        args_parts.append(f"{k}: {v_preview}")
                    arguments_summary_str = "; ".join(args_parts)
                    if not arguments_summary_str: arguments_summary_str = "(无参数)"
                except Exception as e_sum:
                    logger.warning(f"生成工具参数摘要时出错: {e_sum}")
                    arguments_summary_str = "(参数摘要生成错误)"
            await status_callback({
                "type": "tool_status_update",
                "request_id": request_id_to_send,
                "tool_call_id": tool_call_id,
                "tool_name": tool_name,
                "tool_arguments_summary_str": arguments_summary_str,
                "status": tool_status,
                "message": message,
                "details": details if details else {}
            })

    async def execute_tool_calls(self, tool_call_requests_from_plan: List[Dict[str, Any]], status_callback: Optional[Callable[[Dict], Awaitable[None]]] = None) -> List[Dict[str, Any]]:
        executor_id = f"exec_v1_1_3_{str(uuid4())[:8]}" 
        logger.info(f"[{executor_id}-ToolExecutor] 准备异步执行 {len(tool_call_requests_from_plan)} 个工具调用请求 (V1.0.0)...")
        execution_results_for_llm_history: List[Dict[str, Any]] = []

        if not tool_call_requests_from_plan:
            logger.info(f"[{executor_id}-ToolExecutor] 没有工具需要执行。")
            return []

        total_tools_in_plan = len(tool_call_requests_from_plan)

        for i, tool_request in enumerate(tool_call_requests_from_plan):
            llm_generated_tool_call_id = tool_request.get('toolCallId', f'fallback_tool_id_{str(uuid4())[:8]}')
            python_function_name = tool_request.get('toolName', 'unknown_function')
            parsed_arguments = tool_request.get('toolArguments', {})
            ui_hints_from_plan = tool_request.get('uiHints', {})
            tool_display_name = ui_hints_from_plan.get('displayNameForTool') or python_function_name.replace('_tool', '').replace('_', ' ').title()

            action_result_final_for_tool: Optional[Dict[str, Any]] = None
            
            logger.info(f"[{executor_id}-ToolExecutor] 处理工具调用 {i + 1}/{total_tools_in_plan}: Name='{python_function_name}', LLM_ToolCallID='{llm_generated_tool_call_id}'。")
            logger.debug(f"[{executor_id}-ToolExecutor] 待执行工具 '{python_function_name}' 的参数: {parsed_arguments}。")

            await self._send_tool_status_update(
                status_callback, llm_generated_tool_call_id, python_function_name,
                "running", f"开始执行操作: {tool_display_name}...",
                tool_arguments=parsed_arguments,
                details={"ui_hints": ui_hints_from_plan}
            )

            tool_action_method = getattr(self.agent_instance, python_function_name, None)
            
            # 检查工具方法是否存在且可调用
            if not callable(tool_action_method) or not getattr(tool_action_method, '_is_tool', False):
                err_msg_not_found = f"Agent 未实现名为 '{python_function_name}' 的已注册工具方法 (ID: {llm_generated_tool_call_id})。"
                logger.error(f"[{executor_id}-ToolExecutor] 工具未实现或未注册: {err_msg_not_found}")
                action_result_final_for_tool = {"status": "failure", "message": err_msg_not_found, "error": {"error_type": "TOOL_IMPLEMENTATION_ERROR", "error_code": "TOOL_NOT_FOUND_OR_NOT_REGISTERED", "technical_message": f"Action method '{python_function_name}' not found or not a registered tool in Agent."}}
            else: # 工具方法存在且已注册
                for retry_attempt in range(self.max_tool_retries + 1): # +1 to include the initial attempt
                    current_attempt_num = retry_attempt + 1
                    if retry_attempt > 0: # If this is a retry
                        logger.warning(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 执行失败,正在进行第 {retry_attempt}/{self.max_tool_retries} 次重试...")
                        await self._send_tool_status_update(
                            status_callback, llm_generated_tool_call_id, python_function_name,
                            "retrying", f"操作 '{tool_display_name}' 失败,等待 {self.tool_retry_delay_seconds} 秒后重试 (尝试 {current_attempt_num})...",
                            tool_arguments=parsed_arguments, details={"retry_count": retry_attempt, "max_retries": self.max_tool_retries, "ui_hints": ui_hints_from_plan}
                        )
                        await asyncio.sleep(self.tool_retry_delay_seconds)

                    action_result_this_attempt: Optional[Dict[str, Any]] = None
                    try:
                        is_coro = inspect.iscoroutinefunction(tool_action_method)
                        logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) 调用工具 '{python_function_name}'. 是否为协程: {is_coro}.")
                        
                        if is_coro:
                            # 直接 await 异步工具方法
                            logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) 直接 awaiting coroutine: {python_function_name}")
                            action_result_this_attempt = await tool_action_method(arguments=parsed_arguments)
                        else:
                            # 在线程中运行同步工具方法
                            logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) running sync tool in thread: {python_function_name}")
                            action_result_this_attempt = await asyncio.to_thread(tool_action_method, arguments=parsed_arguments)
                        
                        logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) 工具 '{python_function_name}' 返回结果类型: {type(action_result_this_attempt)}, 内容预览: {str(action_result_this_attempt)[:500]}...")

                        if not isinstance(action_result_this_attempt, dict) or \
                           'status' not in action_result_this_attempt or \
                           'message' not in action_result_this_attempt:
                            err_msg_struct = f"工具 '{python_function_name}' 返回的内部结果结构无效。期望字典包含 'status' 和 'message'。"
                            logger.error(f"[{executor_id}-ToolExecutor] 工具返回结构错误 (尝试 {current_attempt_num}): {err_msg_struct}. 实际返回类型: {type(action_result_this_attempt)}, 内容(部分): {str(action_result_this_attempt)[:200]}")
                            action_result_this_attempt = { # 强制转换为标准失败结构
                                "status": "failure", 
                                "message": f"错误: 工具 '{python_function_name}' 内部返回结果结构无效。", 
                                "error": {"error_type": "TOOL_IMPLEMENTATION_ERROR", "error_code": "INVALID_TOOL_ACTION_RESULT_STRUCTURE", "technical_message": err_msg_struct, "actual_return_type": str(type(action_result_this_attempt)), "actual_return_preview": str(action_result_this_attempt)[:200]}
                            }
                        else:
                            logger.info(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' 执行完毕 (尝试 {current_attempt_num})。状态: {action_result_this_attempt.get('status', 'N/A')}。")

                        if action_result_this_attempt.get("status") == "success":
                            action_result_final_for_tool = action_result_this_attempt
                            break # 成功，退出重试循环
                        else: # status 不是 "success"
                            logger.warning(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 执行失败 (尝试 {current_attempt_num})。报告状态: {action_result_this_attempt.get('status')}, 消息: {action_result_this_attempt.get('message')}")
                            action_result_final_for_tool = action_result_this_attempt # 保存本次失败的结果

                    except TypeError as te:
                        err_msg_type = f"调用工具 '{python_function_name}' 时参数不匹配或内部类型错误: {te}。"
                        logger.error(f"[{executor_id}-ToolExecutor] 工具调用参数/类型错误 (尝试 {current_attempt_num}): {err_msg_type}", exc_info=True)
                        action_result_final_for_tool = {"status": "failure", "message": f"错误: 调用工具 '{python_function_name}' 时参数或内部类型错误。", "error": {"error_type": "TOOL_EXECUTION_ERROR", "error_code": "ARGUMENT_TYPE_MISMATCH_OR_INTERNAL_TYPE_ERROR", "technical_message": err_msg_type, "exception_details": traceback.format_exc(limit=3)}}
                        break # 严重错误，无需重试
                    except Exception as exec_err:
                        err_msg_exec = f"工具 '{python_function_name}' 执行期间发生意外内部错误 (尝试 {current_attempt_num}): {exec_err}"
                        logger.error(f"[{executor_id}-ToolExecutor] 工具执行内部错误: {err_msg_exec}", exc_info=True)
                        action_result_final_for_tool = {"status": "failure", "message": f"错误: 执行工具 '{python_function_name}' 时发生内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "UNEXPECTED_TOOL_EXECUTION_FAILURE", "technical_message": err_msg_exec, "exception_details": traceback.format_exc(limit=3)}}
                    
                    # 如果是最后一次尝试，无论结果如何，都将是最终结果
                    if retry_attempt == self.max_tool_retries:
                        # action_result_final_for_tool 已经被设为最后一次尝试的结果
                        break # 退出重试循环

            # 确保 action_result_final_for_tool 有值
            if action_result_final_for_tool is None:
                 logger.error(f"[{executor_id}-ToolExecutor] 内部逻辑错误: 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 在所有重试后 action_result_final_for_tool 仍为 None。")
                 action_result_final_for_tool = {"status": "failure", "message": f"错误: 工具 '{python_function_name}' 未能确定最终结果。", "error": {"error_type": "TOOL_EXECUTION_ERROR", "error_code": "MISSING_TOOL_RESULT_LOGIC_ERROR", "technical_message": "Tool action_result_final_for_tool was None after retry loop."}}

            tool_succeeded_this_cycle = (action_result_final_for_tool.get("status") == "success")

            final_tool_status_str_for_cb = "succeeded" if tool_succeeded_this_cycle else "failed"
            status_message_for_cb = action_result_final_for_tool.get('message', '操作处理完成,但无特定消息。')
            details_for_cb: Dict[str, Any] = {"ui_hints": ui_hints_from_plan}
            if not tool_succeeded_this_cycle:
                details_for_cb["error"] = action_result_final_for_tool.get("error", {"error_type": "UNKNOWN_FAILURE", "technical_message": "工具最终失败,无详细错误信息。"})
            elif action_result_final_for_tool.get("data") is not None:
                 try: details_for_cb["result_data_preview"] = json.dumps(action_result_final_for_tool["data"], ensure_ascii=False, default=str, indent=None)[:1000]
                 except: details_for_cb["result_data_preview"] = "(数据无法序列化预览)"

            await self._send_tool_status_update(
                status_callback, llm_generated_tool_call_id, python_function_name,
                final_tool_status_str_for_cb, status_message_for_cb,
                details=details_for_cb
            )

            tool_result_message_for_llm = {
                "role": "tool",
                "tool_call_id": llm_generated_tool_call_id,
                "name": python_function_name,
                "content": json.dumps(action_result_final_for_tool, ensure_ascii=False, default=str)
            }
            execution_results_for_llm_history.append(tool_result_message_for_llm)
            logger.debug(f"[{executor_id}-ToolExecutor] 已记录工具 '{llm_generated_tool_call_id}' 的最终执行结果 (状态: {final_tool_status_str_for_cb}) 到LLM历史。")

            if not tool_succeeded_this_cycle:
                logger.warning(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 在所有重试后仍然失败。中止后续工具执行。")
                if i + 1 < total_tools_in_plan:
                    for k_aborted in range(i + 1, total_tools_in_plan):
                        aborted_tool_req = tool_call_requests_from_plan[k_aborted]
                        aborted_tool_id = aborted_tool_req.get('toolCallId', f'fallback_aborted_id_{str(uuid4())[:8]}')
                        aborted_tool_name = aborted_tool_req.get('toolName', 'unknown_aborted_tool')
                        aborted_ui_hints = aborted_tool_req.get('uiHints', {})
                        aborted_tool_display_name = aborted_ui_hints.get('displayNameForTool') or aborted_tool_name.replace('_tool','').replace('_',' ').title()

                        await self._send_tool_status_update(
                            status_callback, aborted_tool_id, aborted_tool_name,
                            "aborted_due_to_previous_failure",
                            f"操作 '{aborted_tool_display_name}' 已中止,因为先前的工具 '{tool_display_name}' 执行失败。",
                            details={"reason": f"Aborted due to failure of tool '{python_function_name}' (ID: {llm_generated_tool_call_id})", "ui_hints": aborted_ui_hints}
                        )
                        aborted_tool_result_for_llm_content = {
                                "status": "failure",
                                "message": f"工具 '{aborted_tool_name}' 未执行,因为前序工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 失败。",
                                "error": {"error_type": "TOOL_CHAIN_ABORTED", "error_code": "PRECEDING_TOOL_FAILURE", "technical_message": f"Execution of '{aborted_tool_name}' was skipped due to the failure of tool '{python_function_name}' (ID: {llm_generated_tool_call_id})."}
                            }
                        execution_results_for_llm_history.append({
                            "role": "tool", "tool_call_id": aborted_tool_id, "name": aborted_tool_name,
                            "content": json.dumps(aborted_tool_result_for_llm_content, ensure_ascii=False)
                        })
                        logger.info(f"[{executor_id}-ToolExecutor] 为中止的工具 '{aborted_tool_name}' (ID: {aborted_tool_id}) 添加了模拟失败记录到LLM历史。")
                break 

        total_processed_tools = len(execution_results_for_llm_history)
        logger.info(f"[{executor_id}-ToolExecutor] 工具执行流程完成。共处理/记录了 {total_processed_tools}/{total_tools_in_plan} 个计划中的工具调用 (可能因失败提前中止)。")
        return execution_results_for_llm_history

# --- Agent 核心类 (V1.0.0 - 11 Tools) ---
class CircuitAgent:
    def __init__(self, api_key: str, model_name: str = "glm-z1-flash",
                 max_short_term_items: int = 30, max_long_term_items: int = 75,
                 planning_llm_retries: int = 5, max_tool_retries: int = 3,
                 tool_retry_delay_seconds: float = 1.0, max_replanning_attempts: int = 3,
                 verbose: bool = True):
        logger.info(f"\n{'='*30} CircuitAgent 初始化开始 (V1.0.0 - 11 Tools) {'='*30}") # Version update
        self.api_key = api_key
        self.verbose_mode = verbose
        self.current_request_id: Optional[str] = None

        global console_handler
        console_log_level = logging.DEBUG if self.verbose_mode else logging.INFO
        if console_handler:
            console_handler.setLevel(console_log_level)
            logger.info(f"[AgentV1_1_3 Init] 控制台日志级别已设置为: {logging.getLevelName(console_log_level)} (详细模式: {self.verbose_mode})。")
        else:
            logger.warning("[AgentV1_1_3 Init] 未找到控制台日志处理器,无法动态设置日志级别。")

        self.tools_registry: Dict[str, Dict[str, Any]] = {}
        logger.info("[AgentV1_1_3 Init] 正在动态发现并注册工具...")
        for name, method in inspect.getmembers(self, predicate=inspect.ismethod):
            # 重要: 确保 inspect.ismethod 能正确处理被 @register_tool (特别是被 functools.wraps) 装饰的方法
            if hasattr(method, '_is_tool') and method._is_tool:
                schema = getattr(method, '_tool_schema', None)
                if schema and isinstance(schema, dict) and 'description' in schema and 'parameters' in schema:
                    self.tools_registry[name] = schema
                    # 记录工具是否为异步
                    is_async_tool = inspect.iscoroutinefunction(method)
                    logger.info(f"[AgentV1_1_3 Init] ✓ 已注册工具: '{name}' (异步: {is_async_tool})。")
                else:
                    logger.warning(f"[AgentV1_1_3 Init] 发现工具 '{name}' 但其 Schema 结构不完整或无效,已跳过注册。")
        if not self.tools_registry:
            logger.warning("[AgentV1_1_3 Init] 未发现任何通过 @register_tool 注册的工具！Agent 将主要依赖直接问答。")
        else:
            logger.info(f"[AgentV1_1_3 Init] 共发现并注册了 {len(self.tools_registry)} 个工具。")
            if logger.isEnabledFor(logging.DEBUG):
                try: logger.debug(f"[AgentV1_1_3 Init] 工具注册表详情:\n{json.dumps(self.tools_registry, indent=2, ensure_ascii=False)}")
                except Exception as e_dump: logger.debug(f"无法序列化工具注册表进行日志记录: {e_dump}")

        try:
            self.memory_manager = MemoryManager(max_short_term_items, max_long_term_items)
            self.llm_interface = LLMInterface(agent_instance=self, model_name=model_name)
            self.output_parser = OutputParser(agent_tools_registry=self.tools_registry)
            self.tool_executor = ToolExecutor(
                agent_instance=self,
                max_tool_retries=max_tool_retries,
                tool_retry_delay_seconds=tool_retry_delay_seconds
            )
        except (ValueError, ConnectionError, TypeError) as e:
            logger.critical(f"[AgentV1_1_3 Init] 核心模块初始化失败: {e}", exc_info=True)
            raise

        self.planning_llm_retries = max(0, planning_llm_retries)
        self.max_replanning_attempts = max(0, max_replanning_attempts)
        logger.info(f"[AgentV1_1_3 Init] 规划LLM重试次数: {self.planning_llm_retries}, 工具执行重试次数: {max_tool_retries}, 最大重规划尝试次数: {self.max_replanning_attempts}。")
        logger.info(f"\n{'='*30} CircuitAgent 初始化成功 (V1.0.0 - 11 Tools) {'='*30}\n")

    # --- Action Implementations (Tool methods) ---
    @register_tool(
        description="添加一个新的电路元件 (例如: 电阻, 电容, 电池, LED, 开关, 芯片, 地线, 端子/连接点等)。如果用户未指定 ID,系统会自动为其生成一个。",
        parameters={"type": "object", "properties": {"component_type": {"type": "string", "description": "元件的类型 (例如: '电阻', 'LED', 'Terminal', 'INPUT', 'GND')。"}, "component_id": {"type": "string", "description": "可选的用户为元件指定的ID。如果提供,则使用此ID; 如果不提供或提供格式无效,则由系统自动生成。"}, "value": {"type": "string", "description": "可选的元件值 (例如: '1k', '10uF', '3V')。"}}, "required": ["component_type"]}
    )
    def add_component_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-AddComponentTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行添加元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        
        component_type = arguments.get("component_type")
        component_id_req = arguments.get("component_id")
        value_req = arguments.get("value")

        if not component_type or not isinstance(component_type, str) or not component_type.strip():
            err_msg = "元件类型是必需的,并且必须是有效的非空字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_TYPE", "technical_message": err_msg}}

        target_id_final: Optional[str] = None
        id_was_generated_by_system = False
        user_provided_id_was_validated: Optional[str] = None

        if component_id_req and isinstance(component_id_req, str) and component_id_req.strip():
            user_provided_id_cleaned = component_id_req.strip().upper()
            if re.match(r'^[a-zA-Z0-9_][a-zA-Z0-9_-]*$', user_provided_id_cleaned) or user_provided_id_cleaned in ["INPUT", "OUTPUT", "GND"]:
                if user_provided_id_cleaned in self.memory_manager.circuit.components:
                    err_msg = f"您提供的元件 ID '{user_provided_id_cleaned}' 已被占用。"
                    logger.error(f"{tool_call_logger_prefix} ID 冲突: {err_msg}")
                    return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "CIRCUIT_STATE_ERROR", "error_code": "COMPONENT_ID_CONFLICT", "technical_message": err_msg, "conflicting_id": user_provided_id_cleaned}}
                else:
                    target_id_final = user_provided_id_cleaned
                    user_provided_id_was_validated = target_id_final
                    logger.debug(f"{tool_call_logger_prefix} 将使用用户提供的有效 ID: '{target_id_final}'。")
            else:
                logger.warning(f"{tool_call_logger_prefix} 用户提供的 ID '{component_id_req}' 格式无效。将自动生成 ID。")

        if target_id_final is None:
            try:
                target_id_final = self.memory_manager.circuit.generate_component_id(component_type)
                id_was_generated_by_system = True
                logger.debug(f"{tool_call_logger_prefix} 已自动为类型 '{component_type}' 生成 ID: '{target_id_final}'。")
            except RuntimeError as e_gen_id:
                err_msg = f"无法自动为类型 '{component_type}' 生成唯一 ID: {e_gen_id}"
                logger.error(f"{tool_call_logger_prefix} ID 生成失败: {err_msg}", exc_info=True)
                return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "INTERNAL_AGENT_ERROR", "error_code": "COMPONENT_ID_GENERATION_FAILED", "technical_message": str(e_gen_id)}}

        processed_value = str(value_req).strip() if value_req is not None and str(value_req).strip() else None
        if value_req is None and "value" in arguments:
            processed_value = None

        try:
            if target_id_final is None:
                raise ValueError("内部错误: 在尝试创建元件之前,未能最终确定有效的元件 ID。")

            new_component = CircuitComponent(target_id_final, component_type, processed_value)
            self.memory_manager.circuit.add_component(new_component)

            logger.info(f"{tool_call_logger_prefix} 成功添加元件 '{new_component.id}' ({new_component.type}) 到电路。")
            success_message_parts = [f"操作成功: 已添加元件 {str(new_component)}。"]
            if id_was_generated_by_system:
                success_message_parts.append(f"(系统自动分配 ID '{new_component.id}')")
            elif user_provided_id_was_validated:
                 success_message_parts.append(f"(使用了您指定的 ID '{user_provided_id_was_validated}')")
            final_success_message = " ".join(success_message_parts)
            self.memory_manager.add_to_long_term(f"添加了元件: {str(new_component)} (请求ID: {self.current_request_id or 'N/A'})")
            return {"status": "success", "message": final_success_message, "data": new_component.to_dict()}

        except ValueError as ve_comp:
            err_msg = f"创建或添加元件对象时发生内部验证错误: {ve_comp}"
            logger.error(f"{tool_call_logger_prefix} 元件创建/添加错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_CREATION_OR_ADDITION_VALIDATION_FAILED", "technical_message": str(ve_comp)}}
        except Exception as e_add_comp:
            err_msg = f"添加元件时发生未知的内部错误: {e_add_comp}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 添加元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "ADD_COMPONENT_UNEXPECTED_FAILURE", "technical_message": str(e_add_comp), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="使用两个已存在元件的 ID 将它们连接起来。",
        parameters={"type": "object", "properties": {"comp1_id": {"type": "string", "description": "第一个元件的 ID。"}, "comp2_id": {"type": "string", "description": "第二个元件的 ID。"}}, "required": ["comp1_id", "comp2_id"]}
    )
    def connect_components_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-ConnectComponentsTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行连接元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")

        comp1_id_req = arguments.get("comp1_id")
        comp2_id_req = arguments.get("comp2_id")

        if not comp1_id_req or not isinstance(comp1_id_req, str) or not comp1_id_req.strip() or \
           not comp2_id_req or not isinstance(comp2_id_req, str) or not comp2_id_req.strip():
            err_msg = "必须提供两个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_IDS_FOR_CONNECTION", "technical_message": err_msg}}

        id1_cleaned = comp1_id_req.strip().upper()
        id2_cleaned = comp2_id_req.strip().upper()

        try:
            connection_was_new = self.memory_manager.circuit.connect_components(id1_cleaned, id2_cleaned)
            if connection_was_new:
                logger.info(f"{tool_call_logger_prefix} 成功添加新连接: {id1_cleaned} <--> {id2_cleaned}。")
                self.memory_manager.add_to_long_term(f"连接了元件: {id1_cleaned} <--> {id2_cleaned} (请求ID: {self.current_request_id or 'N/A'})")
                return {"status": "success", "message": f"操作成功: 已将元件 '{id1_cleaned}' 与 '{id2_cleaned}' 连接起来。", "data": {"connection": sorted((id1_cleaned, id2_cleaned))}}
            else:
                msg_exists = f"元件 '{id1_cleaned}' 和 '{id2_cleaned}' 之间已经存在连接。无需重复操作。"
                logger.info(f"{tool_call_logger_prefix} 连接已存在: {msg_exists}")
                return {"status": "success", "message": f"注意: {msg_exists}", "data": {"connection": sorted((id1_cleaned, id2_cleaned)), "already_existed": True}}
        except ValueError as ve_connect:
            err_msg_val = str(ve_connect)
            logger.error(f"{tool_call_logger_prefix} 连接验证错误: {err_msg_val}")
            error_code_detail = "GENERIC_CIRCUIT_VALIDATION_ERROR"
            if "不存在" in err_msg_val: error_code_detail = "COMPONENT_NOT_FOUND_FOR_CONNECTION"
            elif "连接到它自己" in err_msg_val: error_code_detail = "SELF_CONNECTION_ATTEMPTED"
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": error_code_detail, "technical_message": err_msg_val}}
        except Exception as e_connect:
            err_msg = f"连接元件时发生未知的内部错误: {e_connect}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 连接元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "CONNECT_COMPONENTS_UNEXPECTED_FAILURE", "technical_message": str(e_connect), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(description="获取当前电路的详细描述,包括所有元件及其连接情况。", parameters={"type": "object", "properties": {}})
    def describe_circuit_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-DescribeCircuitTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行描述电路操作。")
        try:
            description = self.memory_manager.circuit.get_state_description()
            logger.info(f"{tool_call_logger_prefix} 成功生成电路描述。")
            return {"status": "success", "message": "已成功获取当前电路的描述。", "data": {"description": description}}
        except Exception as e_describe:
            err_msg = f"生成电路描述时发生意外的内部错误: {e_describe}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 获取电路描述时发生未知错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "DESCRIBE_CIRCUIT_UNEXPECTED_FAILURE", "technical_message": str(e_describe), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(description="彻底清空当前的电路设计,移除所有已添加的元件和它们之间的所有连接。此操作不可逆。", parameters={"type": "object", "properties": {}})
    def clear_circuit_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-ClearCircuitTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行清空电路操作。")
        try:
            self.memory_manager.circuit.clear()
            logger.info(f"{tool_call_logger_prefix} 电路状态已成功清空。")
            self.memory_manager.add_to_long_term(f"执行了清空电路操作 (请求ID: {self.current_request_id or 'N/A'})。")
            return {"status": "success", "message": "操作成功: 当前电路已彻底清空。"}
        except Exception as e_clear:
            err_msg = f"清空电路时发生意外的内部错误: {e_clear}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 清空电路时发生未知错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "CLEAR_CIRCUIT_UNEXPECTED_FAILURE", "technical_message": str(e_clear), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="从电路中移除一个指定的元件及其所有相关的连接。",
        parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要移除的元件的 ID。"}}, "required": ["component_id"]}
    )
    def remove_component_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-RemoveComponentTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行移除元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_id_req = arguments.get("component_id")

        if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
            err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_REMOVAL", "technical_message": err_msg}}

        id_cleaned = component_id_req.strip().upper()
        try:
            removed_comp_details, removed_conn_count = self.memory_manager.circuit.remove_component(id_cleaned)
            logger.info(f"{tool_call_logger_prefix} 成功移除元件 '{id_cleaned}' 及其 {removed_conn_count} 个连接。")
            self.memory_manager.add_to_long_term(f"移除了元件: ID '{id_cleaned}', 类型 '{removed_comp_details.get('type', 'N/A')}' (请求ID: {self.current_request_id or 'N/A'})")
            return {"status": "success", "message": f"操作成功: 已移除元件 '{id_cleaned}' 及其所有 {removed_conn_count} 个连接。", "data": {"removed_component": removed_comp_details, "connections_removed_count": removed_conn_count}}
        except ValueError as ve_remove:
            err_msg_val = str(ve_remove)
            logger.error(f"{tool_call_logger_prefix} 移除验证错误: {err_msg_val}")
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_REMOVAL", "technical_message": err_msg_val}}
        except Exception as e_remove:
            err_msg = f"移除元件时发生未知的内部错误: {e_remove}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 移除元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "REMOVE_COMPONENT_UNEXPECTED_FAILURE", "technical_message": str(e_remove), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="断开两个指定元件之间的连接。如果它们之间原本就没有连接,则不执行任何操作。",
        parameters={"type": "object", "properties": {"comp1_id": {"type": "string", "description": "第一个元件的 ID。"}, "comp2_id": {"type": "string", "description": "第二个元件的 ID。"}}, "required": ["comp1_id", "comp2_id"]}
    )
    def disconnect_components_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-DisconnectComponentsTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行断开元件连接操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        comp1_id_req = arguments.get("comp1_id")
        comp2_id_req = arguments.get("comp2_id")

        if not comp1_id_req or not isinstance(comp1_id_req, str) or not comp1_id_req.strip() or \
           not comp2_id_req or not isinstance(comp2_id_req, str) or not comp2_id_req.strip():
            err_msg = "必须提供两个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_IDS_FOR_DISCONNECTION", "technical_message": err_msg}}

        id1_cleaned = comp1_id_req.strip().upper()
        id2_cleaned = comp2_id_req.strip().upper()

        if id1_cleaned == id2_cleaned:
            err_msg = "不能断开一个元件与它自身的连接（它们本来就不可能连接）。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "SELF_DISCONNECTION_ATTEMPTED", "technical_message": err_msg}}
        
        try:
            if id1_cleaned not in self.memory_manager.circuit.components:
                raise ValueError(f"元件 '{id1_cleaned}' 在电路中不存在。")
            if id2_cleaned not in self.memory_manager.circuit.components:
                raise ValueError(f"元件 '{id2_cleaned}' 在电路中不存在。")

            disconnected_successfully = self.memory_manager.circuit.disconnect_components(id1_cleaned, id2_cleaned)
            if disconnected_successfully:
                logger.info(f"{tool_call_logger_prefix} 成功断开连接: {id1_cleaned} <--> {id2_cleaned}。")
                self.memory_manager.add_to_long_term(f"断开了元件连接: {id1_cleaned} <--> {id2_cleaned} (请求ID: {self.current_request_id or 'N/A'})")
                return {"status": "success", "message": f"操作成功: 已断开元件 '{id1_cleaned}' 与 '{id2_cleaned}' 之间的连接。", "data": {"disconnected_pair": sorted((id1_cleaned, id2_cleaned))}}
            else:
                msg_not_exist = f"元件 '{id1_cleaned}' 和 '{id2_cleaned}' 之间原本就没有连接,无需断开。"
                logger.info(f"{tool_call_logger_prefix} 连接不存在: {msg_not_exist}")
                return {"status": "success", "message": f"注意: {msg_not_exist}", "data": {"disconnected_pair": sorted((id1_cleaned, id2_cleaned)), "already_disconnected_or_not_connected": True}}
        except ValueError as ve_disconnect:
            err_msg_val = str(ve_disconnect)
            logger.error(f"{tool_call_logger_prefix} 断开连接验证错误: {err_msg_val}")
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_DISCONNECTION", "technical_message": err_msg_val}}
        except Exception as e_disconnect:
            err_msg = f"断开元件连接时发生未知的内部错误: {e_disconnect}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 断开元件连接时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "DISCONNECT_COMPONENTS_UNEXPECTED_FAILURE", "technical_message": str(e_disconnect), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="更新电路中一个已存在元件的值 (例如电阻的欧姆值, 电容的法拉值, 电池的电压等)。",
        parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要更新值的元件的 ID。"}, "new_value": {"type": "string", "description": "元件的新值。如果想要清除该元件的值,可以传入 null 或一个空字符串。"}}, "required": ["component_id", "new_value"]}
    )
    def update_component_value_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-UpdateComponentValueTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行更新元件值操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_id_req = arguments.get("component_id")
        new_value_req = arguments.get("new_value")

        if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
            err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_UPDATE", "technical_message": err_msg}}
        
        if not isinstance(new_value_req, (str, type(None))):
            err_msg = "元件的新值 'new_value' 必须是字符串或 null (用于清除值)。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "INVALID_NEW_VALUE_TYPE", "technical_message": err_msg}}

        id_cleaned = component_id_req.strip().upper()
        final_new_value = str(new_value_req).strip() if new_value_req is not None and str(new_value_req).strip() else None

        try:
            if id_cleaned not in self.memory_manager.circuit.components:
                raise ValueError(f"元件 '{id_cleaned}' 在电路中不存在。")
            
            component_to_update = self.memory_manager.circuit.components[id_cleaned]
            old_value = component_to_update.value
            component_to_update.value = final_new_value
            
            logger.info(f"{tool_call_logger_prefix} 成功更新元件 '{id_cleaned}' 的值从 '{old_value}' 到 '{final_new_value}'。")
            self.memory_manager.add_to_long_term(f"更新了元件 '{id_cleaned}' 的值: 旧值 '{old_value}', 新值 '{final_new_value}' (请求ID: {self.current_request_id or 'N/A'})")
            return {"status": "success", "message": f"操作成功: 元件 '{id_cleaned}' 的值已从 '{old_value if old_value else '(无值)'}' 更新为 '{final_new_value if final_new_value else '(无值)'}'。", "data": component_to_update.to_dict()}
        except ValueError as ve_update:
            err_msg_val = str(ve_update)
            logger.error(f"{tool_call_logger_prefix} 更新值验证错误: {err_msg_val}")
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_VALUE_UPDATE", "technical_message": err_msg_val}}
        except Exception as e_update:
            err_msg = f"更新元件值时发生未知的内部错误: {e_update}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 更新元件值时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "UPDATE_COMPONENT_VALUE_UNEXPECTED_FAILURE", "technical_message": str(e_update), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="根据提供的 ID 查找电路中的一个特定元件,并返回其详细信息 (类型、ID、值)。",
        parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要查找的元件的 ID。"}}, "required": ["component_id"]}
    )
    def find_component_by_id_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-FindComponentByIdTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行查找元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_id_req = arguments.get("component_id")

        if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
            err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_FIND", "technical_message": err_msg}}

        id_cleaned = component_id_req.strip().upper()
        try:
            if id_cleaned in self.memory_manager.circuit.components:
                component_found = self.memory_manager.circuit.components[id_cleaned]
                logger.info(f"{tool_call_logger_prefix} 成功找到元件 '{id_cleaned}'。")
                return {"status": "success", "message": f"操作成功: 已找到元件 '{id_cleaned}'。", "data": component_found.to_dict()}
            else:
                logger.info(f"{tool_call_logger_prefix} 未找到元件 '{id_cleaned}'。")
                return {"status": "failure", "message": f"错误: 电路中不存在 ID 为 '{id_cleaned}' 的元件。", "error": {"error_type": "CIRCUIT_QUERY_ERROR", "error_code": "COMPONENT_NOT_FOUND_BY_ID", "technical_message": f"Component with ID '{id_cleaned}' not found in circuit."}}
        except Exception as e_find:
            err_msg = f"查找元件时发生未知的内部错误: {e_find}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 查找元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "FIND_COMPONENT_UNEXPECTED_FAILURE", "technical_message": str(e_find), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="列出电路中所有属于指定类型的元件及其详细信息。",
        parameters={"type": "object", "properties": {"component_type": {"type": "string", "description": "要筛选的元件类型 (例如: '电阻', 'LED', '电池')。此匹配不区分大小写。"}}, "required": ["component_type"]}
    )
    def list_components_by_type_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-ListComponentsByTypeTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行按类型列出元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_type_req = arguments.get("component_type")

        if not component_type_req or not isinstance(component_type_req, str) or not component_type_req.strip():
            err_msg = "必须提供一个有效的、非空的元件类型字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_TYPE_FOR_LIST", "technical_message": err_msg}}
        
        type_cleaned = component_type_req.strip().lower()
        
        try:
            found_components = []
            for comp in self.memory_manager.circuit.components.values():
                if comp.type.lower() == type_cleaned:
                    found_components.append(comp.to_dict())
            
            if found_components:
                logger.info(f"{tool_call_logger_prefix} 成功找到 {len(found_components)} 个类型为 '{component_type_req}' 的元件。")
                return {"status": "success", "message": f"操作成功: 找到 {len(found_components)} 个类型为 '{component_type_req}' 的元件。", "data": {"components": found_components, "count": len(found_components)}}
            else:
                logger.info(f"{tool_call_logger_prefix} 未找到类型为 '{component_type_req}' 的元件。")
                return {"status": "success", "message": f"提示: 电路中没有找到类型为 '{component_type_req}' 的元件。", "data": {"components": [], "count": 0}}
        except Exception as e_list:
            err_msg = f"按类型列出元件时发生未知的内部错误: {e_list}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 按类型列出元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "LIST_COMPONENTS_UNEXPECTED_FAILURE", "technical_message": str(e_list), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="获取指定元件当前连接到其他元件的数量。",
        parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要查询连接数量的元件的 ID。"}}, "required": ["component_id"]}
    )
    def get_component_connection_count_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-GetComponentConnectionCountTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行获取元件连接数操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_id_req = arguments.get("component_id")

        if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
            err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_CONNECTION_COUNT", "technical_message": err_msg}}

        id_cleaned = component_id_req.strip().upper()
        try:
            if id_cleaned not in self.memory_manager.circuit.components:
                raise ValueError(f"元件 '{id_cleaned}' 在电路中不存在,无法查询其连接数。")
            
            connection_count = 0
            for conn_pair in self.memory_manager.circuit.connections:
                if id_cleaned in conn_pair:
                    connection_count += 1
            
            logger.info(f"{tool_call_logger_prefix} 元件 '{id_cleaned}' 有 {connection_count} 个连接。")
            return {"status": "success", "message": f"操作成功: 元件 '{id_cleaned}' 当前有 {connection_count} 个连接。", "data": {"component_id": id_cleaned, "connection_count": connection_count}}
        except ValueError as ve_count:
            err_msg_val = str(ve_count)
            logger.error(f"{tool_call_logger_prefix} 获取连接数验证错误: {err_msg_val}")
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_QUERY_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_CONNECTION_COUNT", "technical_message": err_msg_val}}
        except Exception as e_count:
            err_msg = f"获取元件连接数时发生未知的内部错误: {e_count}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 获取元件连接数时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "GET_CONNECTION_COUNT_UNEXPECTED_FAILURE", "technical_message": str(e_count), "exception_details": traceback.format_exc(limit=3)}}

    # --- DuckDuckGo 搜索工具 (确保返回期望的字典结构) ---
    @register_tool(
        description="使用 DuckDuckGo 搜索引擎在互联网上搜索与给定查询词相关的信息。用于获取通用知识、技术细节或背景资料。",
        parameters={
            "type": "object",
            "properties": {
                "query": {"type": "string", "description": "要搜索的关键词或问题。"},
                "num_results": {"type": "integer", "description": "期望返回的搜索结果数量 (例如: 1 到 5)。如果未提供或无效,默认为3。"}
            },
            "required": ["query"]
        }
    )
    async def duckduckgo_search_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]: # 标记为 async def
        tool_call_logger_prefix = f"[Action-DuckDuckGoSearchTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行 DuckDuckGo 搜索操作。")
        query = arguments.get("query")
        num_results_req = arguments.get("num_results")
        logger.debug(f"{tool_call_logger_prefix} 收到搜索查询: '{query}', 期望结果数 (原始请求): {num_results_req}。")

        # 预定义返回结构，确保status和message存在
        tool_result = {
            "status": "failure",
            "message": "DuckDuckGo 搜索工具初始化失败或发生未知错误。",
            "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "DUCKDUCKGO_UNKNOWN_FAILURE", "technical_message": "Tool did not complete successfully."}
        }

        if not query or not isinstance(query, str) or not query.strip():
            err_msg = "必须提供一个有效的、非空的搜索查询词。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            tool_result["message"] = f"错误: {err_msg}"
            tool_result["error"] = {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_SEARCH_QUERY", "technical_message": err_msg}
            return tool_result

        num_results = 3 
        if num_results_req is not None:
            if isinstance(num_results_req, int) and 1 <= num_results_req <= 10:
                num_results = num_results_req
            else:
                logger.warning(f"{tool_call_logger_prefix} num_results 参数 '{num_results_req}' 无效或超出范围(1-10), 将使用默认值 {num_results}。")
        else:
            logger.debug(f"{tool_call_logger_prefix} 未提供 num_results 参数, 将使用默认值 {num_results}。")
            
        search_results_raw_list = []
        try:
            # 将实际的同步DDGS操作封装在一个内部函数中
            def sync_ddgs_operation():
                _internal_results = []
                logger.debug(f"{tool_call_logger_prefix} [sync_op_internal] 开始执行DDGS搜索 for '{query}', max_results={num_results}")
                with DDGS(timeout=20) as ddgs: # 确保每次调用都创建新的DDGS实例
                    # ddgs.text返回一个迭代器，我们需要将其物化为列表来获取所有结果
                    fetched_results = list(ddgs.text(keywords=query, max_results=num_results))
                    logger.debug(f"{tool_call_logger_prefix} [sync_op_internal] DDGS.text 返回了 {len(fetched_results)} 个原始条目。")
                    # 手动限制结果数量，因为max_results在DDGS中可能不是硬限制
                    for r_item in fetched_results[:num_results]:
                        _internal_results.append({
                            "title": r_item.get('title', 'N/A'),
                            "snippet": r_item.get('body', 'N/A'), # DDGS 使用 'body' 作为摘要
                            "link": r_item.get('href', '#')
                        })
                logger.debug(f"{tool_call_logger_prefix} [sync_op_internal] 处理后得到 {len(_internal_results)} 个结果。")
                return _internal_results

            logger.debug(f"{tool_call_logger_prefix} 准备将同步DDGS操作提交到线程池...")
            search_results_raw_list = await asyncio.to_thread(sync_ddgs_operation)
            logger.debug(f"{tool_call_logger_prefix} 同步DDGS操作完成，从线程返回了 {len(search_results_raw_list)} 个结果。")


            search_results_json_str = json.dumps(search_results_raw_list, ensure_ascii=False)
            success_message = f"已成功完成对“{query}”的 DuckDuckGo 搜索,找到 {len(search_results_raw_list)} 条相关信息。"
            logger.info(f"{tool_call_logger_prefix} {success_message}")
            
            self.memory_manager.add_to_long_term(f"执行了 DuckDuckGo 搜索,查询词: '{query}', 返回了 {len(search_results_raw_list)} 条结果 (请求ID: {self.current_request_id or 'N/A'})。")
            
            # 更新为成功的返回字典
            tool_result = {
                "status": "success",
                "message": success_message,
                "data": {
                    "query": query,
                    "num_results_requested": num_results,
                    "num_results_returned": len(search_results_raw_list),
                    "results_json_string": search_results_json_str 
                }
            }
            return tool_result

        except Exception as e_search:
            err_msg = f"使用 DuckDuckGo 搜索时发生错误: {e_search}"
            logger.error(f"{tool_call_logger_prefix} {err_msg}", exc_info=True)
            tool_result["message"] = f"错误: {err_msg}"
            tool_result["error"] = {"error_type": "EXTERNAL_SERVICE_ERROR", "error_code": "DUCKDUCKGO_SEARCH_FAILED", "technical_message": str(e_search), "exception_details": traceback.format_exc(limit=3)}
            return tool_result

    # --- Orchestration Layer Method (V1.0.0 - 核心调度逻辑) ---
    async def process_user_request(self, user_request: str, status_callback: Callable[[Dict[str, Any]], Awaitable[None]]) -> None:
        request_start_time = time.monotonic()
        self.current_request_id = f"req_{str(uuid4())[:12]}"

        final_llm_camelcase_json_for_reply: Optional[Dict[str, Any]] = None
        final_reply_for_user: str = "抱歉,处理您的请求时发生未知错误。"
        final_llm_interaction_id_for_user: Optional[str] = None
        active_llm_interaction_id: Optional[str] = None

        logger.info(f"\n{'='*25} CircuitAgent 开始处理用户请求 (ReqID: {self.current_request_id}) {'='*25}")
        logger.info(f"[OrchestratorV1_1_3] 收到用户指令: \"{user_request}\"")

        try:
            if not user_request or user_request.isspace():
                logger.info(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 用户指令为空。")
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "input_validation", "status": "ignored", "message": "用户输入为空,已忽略。"})
                empty_input_err_json = {
                    "requestId": self.current_request_id,
                    "llmInteractionId": f"agent_input_err_{str(uuid4())[:6]}",
                    "timestampUtc": datetime.now(timezone.utc).isoformat(),
                    "status": "failure",
                    "errorDetails": {
                        "errorType": "USER_INPUT_ERROR",
                        "errorCode": "EMPTY_USER_REQUEST",
                        "messageToUser": "您的指令似乎是空的,请重新输入！",
                        "technicalMessage": "User request was empty or whitespace.",
                        "isDirectLlmFailure": False
                    },
                    "executionPhase": "planning",
                    "thoughtProcess": "Agent检测到用户输入为空或仅包含空白字符,无需进一步处理。",
                    "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content": "您的指令似乎是空的,请重新输入！"}}
                }
                await status_callback({"type": "final_response", "request_id": self.current_request_id, "llm_interaction_id": empty_input_err_json["llmInteractionId"], "content": empty_input_err_json["decision"]["responseToUser"]["content"], "finaljson_if_success": None})
                return

            await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "input_validation", "status": "received", "message": "收到用户指令,开始处理...", "details": {"user_request_preview": user_request[:1000]}})
            try:
                self.memory_manager.add_to_short_term({"role": "user", "content": user_request})
            except Exception as e_mem_user:
                logger.error(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 添加用户消息到短期记忆时出错: {e_mem_user}", exc_info=True)
                err_msg_mem = f"记录用户指令时发生内部记忆错误: {e_mem_user}"
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "input_validation", "status": "error", "message": err_msg_mem})
                mem_err_json = {
                    "requestId": self.current_request_id, "llmInteractionId": f"agent_mem_err_{str(uuid4())[:6]}",
                    "timestampUtc": datetime.now(timezone.utc).isoformat(), "status": "failure",
                    "errorDetails": {"errorType": "INTERNAL_AGENT_ERROR", "errorCode": "MEMORY_ADD_USER_MSG_FAILED", "messageToUser": f"抱歉,我在记录您的指令时遇到了内部问题 ({e_mem_user})！请稍后重试。", "technicalMessage": err_msg_mem, "isDirectLlmFailure": False },
                    "executionPhase": "planning", "thoughtProcess": "Agent在将用户消息添加到短期记忆时遇到错误。",
                    "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content": f"抱歉,我在记录您的指令时遇到了内部问题 ({e_mem_user})！请稍后重试。" }}
                }
                await status_callback({"type": "final_response", "request_id": self.current_request_id, "llm_interaction_id": mem_err_json["llmInteractionId"], "content": mem_err_json["decision"]["responseToUser"]["content"], "finaljson_if_success": None})
                return

            replanning_loop_count = 0
            current_llm_plan_camelcase_json_obj: Optional[Dict[str, Any]] = None
            tool_execution_results_for_llm_history: List[Dict[str, Any]] = []
            agent_accepted_latest_plan_for_action = False

            while replanning_loop_count <= self.max_replanning_attempts:
                current_planning_attempt_num = replanning_loop_count + 1
                log_prefix = f"[OrchestratorV1_1_3 - PlanAttempt {current_planning_attempt_num} - ReqID: {self.current_request_id}]"
                logger.info(f"\n--- {log_prefix} 开始 ---")

                is_currently_replanning = (replanning_loop_count > 0)
                status_msg_planning_start = "正在分析指令并制定计划..." if not is_currently_replanning else f"正在尝试第 {replanning_loop_count}/{self.max_replanning_attempts} 次重规划..."
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "started", "message": status_msg_planning_start, "details": {"attempt_number": current_planning_attempt_num, "max_replanning_attempts": self.max_replanning_attempts}})

                memory_context = self.memory_manager.get_memory_context_for_prompt()
                tool_schemas = self._get_tool_schemas_for_prompt()
                system_prompt_planning = self._get_planning_prompt(tool_schemas, memory_context, is_currently_replanning, self.current_request_id)
                messages_for_planning = [{"role": "system", "content": system_prompt_planning}] + self.memory_manager.short_term

                llm_call_attempt_inner = 0
                parsed_plan_camelcase_json_this_llm_call: Optional[Dict[str, Any]] = None
                parser_error_msg_this_llm_call: str = ""
                parsed_failed_validation_points_this_llm_call: List[Dict[str,str]] = []
                agent_accepted_latest_plan_for_action = False

                while llm_call_attempt_inner <= self.planning_llm_retries:
                    logger.info(f"{log_prefix} 调用规划 LLM (LLM Call Attempt {llm_call_attempt_inner + 1} of {self.planning_llm_retries + 1})...")
                    try:
                        llm_response_planning_raw = await self.llm_interface.call_llm(messages_for_planning, "planning", status_callback)
                        if not llm_response_planning_raw or not llm_response_planning_raw.choices:
                            raise ConnectionError("LLM规划响应无效或缺少choices。这是LLMInterface层面的问题。")

                        llm_msg_obj_planning = llm_response_planning_raw.choices[0].message
                        parsed_plan_camelcase_json_this_llm_call, parser_error_msg_this_llm_call, parsed_failed_validation_points_this_llm_call = \
                            self.output_parser.parse_llm_response_to_structured_json(llm_msg_obj_planning, "planning")

                        if parsed_plan_camelcase_json_this_llm_call:
                            active_llm_interaction_id = parsed_plan_camelcase_json_this_llm_call.get("llmInteractionId")
                            current_thought_process = parsed_plan_camelcase_json_this_llm_call.get("thoughtProcess")
                            if current_thought_process:
                                await status_callback({"type": "thinking_log", "request_id": self.current_request_id, "llm_interaction_id": active_llm_interaction_id, "stage": "planning", "content": current_thought_process})

                        if parsed_plan_camelcase_json_this_llm_call and not parser_error_msg_this_llm_call and not parsed_failed_validation_points_this_llm_call:
                            if parsed_plan_camelcase_json_this_llm_call.get("status") == "success":
                                logger.info(f"{log_prefix} 成功解析并验证V1.0-CamelCaseJSON计划。LLM报告状态为 'success' (LLM_ID: {active_llm_interaction_id})。Agent采纳此计划。")
                                agent_accepted_latest_plan_for_action = True
                            elif is_currently_replanning and \
                                 parsed_plan_camelcase_json_this_llm_call.get("decision", {}).get("isCallTools") is True and \
                                 isinstance(parsed_plan_camelcase_json_this_llm_call.get("decision", {}).get("toolCallRequests"), list) and \
                                 parsed_plan_camelcase_json_this_llm_call.get("decision", {}).get("toolCallRequests"):
                                logger.warning(f"{log_prefix} LLM在重规划时提供了新的工具调用计划,但可能将其顶层status标记为 'failure' (LLM_ID: {active_llm_interaction_id})。Agent将审慎采纳此新计划以尝试修正。LLM报告的错误(如有): {parsed_plan_camelcase_json_this_llm_call.get('errorDetails')}")
                                agent_accepted_latest_plan_for_action = True
                            else:
                                error_detail_from_llm = parsed_plan_camelcase_json_this_llm_call.get("errorDetails", {}).get("technicalMessage", "LLM规划指示内部错误,但JSON结构有效。")
                                logger.warning(f"{log_prefix} LLM报告的V1.0-CamelCaseJSON计划状态为 'failure': {error_detail_from_llm} (LLM_ID: {active_llm_interaction_id})。Agent将不采纳此计划,并尝试让LLM修正(如果还有LLM调用重试次数)。")
                                parser_error_msg_this_llm_call = f"LLM主动报告规划失败: {error_detail_from_llm}"

                            if agent_accepted_latest_plan_for_action:
                                current_llm_plan_camelcase_json_obj = parsed_plan_camelcase_json_this_llm_call
                                try:
                                    self.memory_manager.add_to_short_term(llm_msg_obj_planning.model_dump(exclude_unset=True))
                                except Exception as e_mem_add: logger.error(f"{log_prefix} 添加LLM规划响应到记忆失败: {e_mem_add}")
                                break

                        if not agent_accepted_latest_plan_for_action and llm_call_attempt_inner < self.planning_llm_retries:
                            error_to_report_cb = parser_error_msg_this_llm_call or "V1.0.0结构或内容校验失败。"
                            if parsed_failed_validation_points_this_llm_call:
                                error_to_report_cb += " 失败点: " + json.dumps(parsed_failed_validation_points_this_llm_call[:2], ensure_ascii=False)
                            await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "llm_retry_needed", "message": f"大脑计划处理遇到问题,尝试重新沟通 ({error_to_report_cb[:1000]})", "details": {"llm_call_attempt": llm_call_attempt_inner + 1, "parser_error": parser_error_msg_this_llm_call, "validation_failures": parsed_failed_validation_points_this_llm_call}})
                            if parsed_plan_camelcase_json_this_llm_call and parsed_plan_camelcase_json_this_llm_call.get("status") == "failure":
                                try: self.memory_manager.add_to_short_term(llm_msg_obj_planning.model_dump(exclude_unset=True))
                                except Exception as e_mem_add_fail: logger.error(f"{log_prefix} 添加LLM失败规划到记忆失败: {e_mem_add_fail}")
                            elif parser_error_msg_this_llm_call or parsed_failed_validation_points_this_llm_call:
                                 sim_err_plan_content = {
                                    "requestId": self.current_request_id, "llmInteractionId": f"agent_parser_err_{active_llm_interaction_id or str(uuid4())[:6]}",
                                    "timestampUtc": datetime.now(timezone.utc).isoformat(), "status": "failure",
                                    "errorDetails": {"errorType": "LLM_OUTPUT_VALIDATION_ERROR", "errorCode": "V1_CAMELCASE_JSON_VALIDATION_FAILED", "technicalMessage": parser_error_msg_this_llm_call, "isDirectLlmFailure": False, "failedValidationPoints": parsed_failed_validation_points_this_llm_call },
                                    "executionPhase": "planning", "thoughtProcess": "Agent在解析或验证LLM上一次规划输出时发现以下问题,将请求LLM修正。",
                                    "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content":""}}
                                 }
                                 try: self.memory_manager.add_to_short_term({"role": "assistant", "content": json.dumps(sim_err_plan_content, ensure_ascii=False)})
                                 except Exception as e_mem_add_parse_err: logger.error(f"{log_prefix} 添加Agent解析错误到记忆失败: {e_mem_add_parse_err}")

                    except Exception as e_llm_call_level:
                        logger.error(f"{log_prefix} LLM调用或规划解析时发生严重错误 (LLM Call Attempt {llm_call_attempt_inner + 1}): {e_llm_call_level}", exc_info=True)
                        parser_error_msg_this_llm_call = f"LLM调用/解析严重错误: {str(e_llm_call_level)[:1000]}"
                        parsed_failed_validation_points_this_llm_call = [{"jsonPath":"root", "issue_description": parser_error_msg_this_llm_call}]
                        if llm_call_attempt_inner < self.planning_llm_retries:
                             await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "llm_error_retrying", "message": f"与大脑沟通时发生严重错误,尝试重新连接 ({parser_error_msg_this_llm_call})", "details": {"llm_call_attempt": llm_call_attempt_inner + 1}})

                    llm_call_attempt_inner += 1
                    if agent_accepted_latest_plan_for_action: break

                if not agent_accepted_latest_plan_for_action:
                    error_summary_final_planning_llm_attempt = parser_error_msg_this_llm_call or "在多次LLM调用尝试后,未能从LLM获取可接受的V1.0-CamelCaseJSON规划。"
                    if parsed_failed_validation_points_this_llm_call:
                         error_summary_final_planning_llm_attempt += " 最后一次校验失败点: " + json.dumps(parsed_failed_validation_points_this_llm_call[:2], ensure_ascii=False)

                    await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "failed_after_llm_retries", "message": f"规划失败 (在第 {current_planning_attempt_num} 次规划尝试中,LLM调用重试均失败): {error_summary_final_planning_llm_attempt}", "details": {"final_parser_error": parser_error_msg_this_llm_call, "final_validation_failures": parsed_failed_validation_points_this_llm_call, "thinking_log_from_last_attempt": parsed_plan_camelcase_json_this_llm_call.get("thoughtProcess") if parsed_plan_camelcase_json_this_llm_call else "无有效思考过程"}})

                    if replanning_loop_count >= self.max_replanning_attempts:
                        logger.critical(f"{log_prefix} 已达最大重规划尝试次数 ({self.max_replanning_attempts}),且本次规划尝试在LLM调用/解析层面最终失败。中止处理。")
                        final_reply_for_user = f"抱歉,即使经过多次尝试与智能大脑沟通,也未能为您的请求 '{user_request[:50]}...' 制定出有效的执行计划。错误详情: {error_summary_final_planning_llm_attempt}"
                        final_llm_interaction_id_for_user = active_llm_interaction_id or f"error_plan_max_replan_llm_fail_{str(uuid4())[:6]}"
                        final_llm_camelcase_json_for_reply = None
                        break
                    else:
                        sim_fail_plan_content_for_replan = {
                            "requestId": self.current_request_id, "llmInteractionId": f"agent_replan_trigger_{active_llm_interaction_id or str(uuid4())[:6]}",
                            "timestampUtc": datetime.now(timezone.utc).isoformat(), "status": "failure",
                            "errorDetails": {"errorType": "LLM_OUTPUT_VALIDATION_ERROR", "errorCode": "V1_CAMELCASE_JSON_VALIDATION_FAILED_IN_PLAN_ATTEMPT", "technicalMessage": error_summary_final_planning_llm_attempt, "isDirectLlmFailure": False, "failedValidationPoints": parsed_failed_validation_points_this_llm_call },
                            "executionPhase": "planning", "thoughtProcess": f"Agent在第 {current_planning_attempt_num} 次规划尝试的LLM调用/解析阶段遇到问题,将进行重规划。错误: {error_summary_final_planning_llm_attempt}",
                            "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content":""}}
                        }
                        try: self.memory_manager.add_to_short_term({"role": "assistant", "content": json.dumps(sim_fail_plan_content_for_replan, ensure_ascii=False)})
                        except Exception as e_mem_add_replan_trigger: logger.error(f"{log_prefix} 添加重规划触发信息到记忆出错: {e_mem_add_replan_trigger}")
                        replanning_loop_count += 1
                        continue

                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "completed_and_validated", "message": "规划完成并通过验证,准备执行或直接回复。", "details": {"plan_llm_id": current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else None}})

                tool_requests_from_plan = current_llm_plan_camelcase_json_obj.get("decision", {}).get("toolCallRequests", []) if current_llm_plan_camelcase_json_obj else []
                if isinstance(tool_requests_from_plan, list) and current_llm_plan_camelcase_json_obj:
                    plan_details_for_ui = []
                    for req_idx, tool_req in enumerate(tool_requests_from_plan):
                        plan_details_for_ui.append({
                            "tool_call_id": tool_req.get("toolCallId"),
                            "tool_name": tool_req.get("toolName"),
                            "tool_arguments": tool_req.get("toolArguments", {}),
                            "ui_hints": tool_req.get("uiHints", {}),
                            "status": "pending",
                            "order": req_idx + 1
                        })
                    await status_callback({
                        "type": "plan_details",
                        "request_id": self.current_request_id,
                        "llm_interaction_id": current_llm_plan_camelcase_json_obj.get("llmInteractionId"),
                        "plan": plan_details_for_ui
                    })

                decision_from_plan = current_llm_plan_camelcase_json_obj.get("decision", {}) if current_llm_plan_camelcase_json_obj else {}
                should_call_tools = decision_from_plan.get("isCallTools", False)
                response_user_obj_from_plan = decision_from_plan.get("responseToUser")

                if should_call_tools:
                    tool_count_in_plan = len(tool_requests_from_plan) if isinstance(tool_requests_from_plan, list) else 0
                    logger.info(f"{log_prefix} 决策: 执行 {tool_count_in_plan} 个工具。")
                    await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "action_execution", "status": "started", "message": f"开始执行 {tool_count_in_plan} 个计划操作...", "details": {"tool_count": tool_count_in_plan}})

                    if isinstance(response_user_obj_from_plan, dict) and response_user_obj_from_plan.get("content","").strip():
                        transitional_reply_content = response_user_obj_from_plan["content"]
                        await status_callback({"type": "interim_response", "request_id": self.current_request_id, "llm_interaction_id": current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else None, "content": transitional_reply_content})

                    if not isinstance(tool_requests_from_plan, list) or not tool_requests_from_plan:
                        err_msg_list_tools_critical = "内部规划错误: isCallTools为True但toolCallRequests列表无效或为空。OutputParser应已校验。"
                        logger.error(f"{log_prefix} {err_msg_list_tools_critical}")
                        tool_execution_results_for_llm_history = [{"role":"tool", "tool_call_id":f"plan_integrity_err_{str(uuid4())[:6]}", "name":"plan_integrity_checker", "content":json.dumps({"status":"failure", "message":err_msg_list_tools_critical, "error": {"error_type":"INTERNAL_AGENT_ERROR", "error_code":"INVALID_TOOL_REQUEST_LIST_POST_VALIDATION", "technical_message": err_msg_list_tools_critical}})}]
                        try: self.memory_manager.add_to_short_term(tool_execution_results_for_llm_history[0])
                        except Exception as e_mem_add_integrity_err: logger.error(f"{log_prefix} 添加规划完整性错误到记忆失败: {e_mem_add_integrity_err}")

                        if replanning_loop_count >= self.max_replanning_attempts:
                            final_reply_for_user = f"抱歉,系统在准备执行操作时遇到内部规划结构问题。请稍后重试或联系技术支持。错误: {err_msg_list_tools_critical}"
                            final_llm_interaction_id_for_user = current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else active_llm_interaction_id
                            final_llm_camelcase_json_for_reply = None
                            break
                        else:
                            replanning_loop_count += 1; agent_accepted_latest_plan_for_action = False; continue

                    current_tool_exec_results_for_llm_hist = await self.tool_executor.execute_tool_calls(tool_requests_from_plan, status_callback)
                    tool_execution_results_for_llm_history = current_tool_exec_results_for_llm_hist

                    if tool_execution_results_for_llm_history:
                        for res_msg_tool in tool_execution_results_for_llm_history:
                            try: self.memory_manager.add_to_short_term(res_msg_tool)
                            except Exception as e_mem_add_tool_res: logger.error(f"{log_prefix} 添加工具结果 {res_msg_tool.get('tool_call_id')} 到记忆失败: {e_mem_add_tool_res}")

                    any_tool_failed_persistently = False
                    last_failed_tool_message_for_user = "一个或多个操作未能成功完成。"
                    if tool_execution_results_for_llm_history:
                        for tool_res_for_hist in tool_execution_results_for_llm_history:
                            try:
                                tool_res_content_dict = json.loads(tool_res_for_hist.get("content","{}"))
                                if tool_res_content_dict.get("status") != "success":
                                    any_tool_failed_persistently = True
                                    last_failed_tool_message_for_user = tool_res_content_dict.get("message", last_failed_tool_message_for_user)
                            except json.JSONDecodeError:
                                logger.error(f"{log_prefix} 无法解析工具结果的content JSON: {tool_res_for_hist.get('content')}")
                                any_tool_failed_persistently = True
                                last_failed_tool_message_for_user = "一个操作的结果格式不正确。"

                    if any_tool_failed_persistently:
                        logger.warning(f"{log_prefix} 工具执行过程中发生了一个或多个持久性失败。")
                        await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "action_execution", "status": "tool_failure_detected", "message": "部分操作失败,准备评估是否重规划。", "details": {"last_error_message": last_failed_tool_message_for_user}})
                        if replanning_loop_count < self.max_replanning_attempts:
                            replanning_loop_count += 1; agent_accepted_latest_plan_for_action = False; continue
                        else:
                            logger.critical(f"{log_prefix} 已达最大重规划尝试次数 ({self.max_replanning_attempts}),但工具执行仍有失败。中止处理。")
                            final_reply_for_user = f"抱歉,在执行您的请求时,即使经过多次尝试,仍遇到问题: {last_failed_tool_message_for_user} 请检查您的指令或稍后再试。"
                            final_llm_interaction_id_for_user = current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else active_llm_interaction_id
                            final_llm_camelcase_json_for_reply = None
                            break
                    else:
                        logger.info(f"{log_prefix} 所有计划中的工具均成功执行。准备生成最终回复。")
                        final_llm_camelcase_json_for_reply = current_llm_plan_camelcase_json_obj
                        break

                else:
                    logger.info(f"{log_prefix} 决策: 直接回复 (V1.0.0)。无需工具调用。")
                    if isinstance(response_user_obj_from_plan, dict) and response_user_obj_from_plan.get("content","").strip():
                        tool_execution_results_for_llm_history = []
                        final_llm_camelcase_json_for_reply = current_llm_plan_camelcase_json_obj
                        logger.info(f"{log_prefix} 规划阶段决定直接回复,内容有效。将使用此V1.0-CamelCaseJSON作为最终输出。LLM_ID: {final_llm_camelcase_json_for_reply.get('llmInteractionId')}")
                        break
                    else:
                        err_msg_direct_content_critical = "内部规划错误: isCallTools为False但responseToUser.content无效或为空。OutputParser应已校验。"
                        logger.error(f"{log_prefix} {err_msg_direct_content_critical}")
                        tool_execution_results_for_llm_history = [{"role":"tool", "tool_call_id":f"direct_reply_integrity_err_{str(uuid4())[:6]}", "name":"direct_reply_integrity_checker", "content":json.dumps({"status":"failure", "message":err_msg_direct_content_critical, "error": {"error_type":"INTERNAL_AGENT_ERROR", "error_code":"INVALID_DIRECT_RESPONSE_CONTENT_POST_VALIDATION", "technical_message": err_msg_direct_content_critical}})}]
                        try: self.memory_manager.add_to_short_term(tool_execution_results_for_llm_history[0])
                        except Exception as e_mem_add_direct_reply_err: logger.error(f"{log_prefix} 添加直接回复完整性错误到记忆失败: {e_mem_add_direct_reply_err}")

                        if replanning_loop_count >= self.max_replanning_attempts:
                            final_reply_for_user = f"抱歉,系统在准备直接回复时遇到内部规划结构问题。请稍后重试或联系技术支持。错误: {err_msg_direct_content_critical}"
                            final_llm_interaction_id_for_user = current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else active_llm_interaction_id
                            final_llm_camelcase_json_for_reply = None
                            break
                        else:
                            replanning_loop_count += 1; agent_accepted_latest_plan_for_action = False; continue
            
            logger.debug(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 重规划循环结束。采纳的计划: {agent_accepted_latest_plan_for_action}, 重规划次数: {replanning_loop_count}, 用于回复的最终LLM JSON是否已设置: {final_llm_camelcase_json_for_reply is not None}")
            
            if not agent_accepted_latest_plan_for_action and replanning_loop_count > self.max_replanning_attempts:
                logger.error(f"[OrchestratorV1_1_3 - FinalPrep - ReqID:{self.current_request_id}] 已达最大重规划次数,且最终规划尝试仍失败。将使用上次记录的错误信息。")
            
            logger.debug(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 响应生成检查前。最终JSON状态: {final_llm_camelcase_json_for_reply.get('status') if final_llm_camelcase_json_for_reply else 'N/A'}, isCallTools: {final_llm_camelcase_json_for_reply.get('decision', {}).get('isCallTools') if final_llm_camelcase_json_for_reply else 'N/A'}")

            if final_llm_camelcase_json_for_reply and \
               final_llm_camelcase_json_for_reply.get("status") == "success" and \
               final_llm_camelcase_json_for_reply.get("decision",{}).get("isCallTools") is True:
                logger.info(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 工具执行成功,开始生成最终响应...")
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "response_generation", "status": "started", "message": "正在总结操作结果并生成最终回复...", "details": {"reason": "Tool execution completed successfully. Generating final summary."}})

                system_prompt_resp_gen = self._get_response_generation_prompt(
                    self.memory_manager.get_memory_context_for_prompt(),
                    self._get_tool_schemas_for_prompt(),
                    self.current_request_id
                )
                messages_for_resp_gen = [{"role": "system", "content": system_prompt_resp_gen}] + self.memory_manager.short_term

                try:
                    llm_response_final_gen_raw = await self.llm_interface.call_llm(messages_for_resp_gen, "response_generation", status_callback)
                    if not llm_response_final_gen_raw or not llm_response_final_gen_raw.choices: raise ConnectionError("LLM最终响应生成阶段的响应无效或缺少choices。")

                    llm_msg_obj_final_gen = llm_response_final_gen_raw.choices[0].message
                    parsed_final_camelcase_resp_json, final_parser_err_resp, final_validation_failures_resp = \
                        self.output_parser.parse_llm_response_to_structured_json(llm_msg_obj_final_gen, "response_generation")

                    if parsed_final_camelcase_resp_json:
                        active_llm_interaction_id = parsed_final_camelcase_resp_json.get("llmInteractionId")
                        final_resp_thought_process = parsed_final_camelcase_resp_json.get("thoughtProcess")
                        if final_resp_thought_process:
                             await status_callback({"type": "thinking_log", "request_id": self.current_request_id, "llm_interaction_id": active_llm_interaction_id, "stage": "response_generation", "content": final_resp_thought_process})

                    if parsed_final_camelcase_resp_json and not final_parser_err_resp and not final_validation_failures_resp and parsed_final_camelcase_resp_json.get("status") == "success":
                        final_llm_camelcase_json_for_reply = parsed_final_camelcase_resp_json
                        final_llm_interaction_id_for_user = active_llm_interaction_id
                        logger.info(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 成功解析并验证最终响应V1.0-CamelCaseJSON (LLM_ID: {final_llm_interaction_id_for_user})。")
                        try:
                            self.memory_manager.add_to_short_term(llm_msg_obj_final_gen.model_dump(exclude_unset=True))
                        except Exception as e_mem_add_final_resp: logger.error(f"添加最终LLM响应到记忆失败: {e_mem_add_final_resp}")
                    else:
                        err_msg_final_resp_gen = final_parser_err_resp or "V1.0.0最终响应JSON校验失败。"
                        if final_validation_failures_resp: err_msg_final_resp_gen += " 失败点: " + json.dumps(final_validation_failures_resp[:2], ensure_ascii=False)
                        elif parsed_final_camelcase_resp_json and parsed_final_camelcase_resp_json.get("status") == "failure":
                             err_msg_final_resp_gen = parsed_final_camelcase_resp_json.get("errorDetails",{}).get("technicalMessage", err_msg_final_resp_gen)

                        logger.error(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] LLM未能生成有效V1.0-CamelCaseJSON最终回复: {err_msg_final_resp_gen}")
                        final_reply_for_user = f"抱歉,在总结操作结果时发生了一些问题。错误: {err_msg_final_resp_gen[:1000]}... "
                        final_llm_interaction_id_for_user = active_llm_interaction_id or (final_llm_camelcase_json_for_reply.get("llmInteractionId") if final_llm_camelcase_json_for_reply else f"error_resp_gen_{str(uuid4())[:6]}")
                        final_llm_camelcase_json_for_reply = None
                except Exception as e_llm_final_gen_call:
                    logger.critical(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] LLM最终响应调用或处理失败: {e_llm_final_gen_call}", exc_info=True)
                    final_reply_for_user = f"抱歉,系统在为您准备最终报告时遇到了严重的内部错误: {str(e_llm_final_gen_call)[:1000]}... "
                    final_llm_interaction_id_for_user = (final_llm_camelcase_json_for_reply.get("llmInteractionId") if final_llm_camelcase_json_for_reply else active_llm_interaction_id or f"critical_err_resp_gen_{str(uuid4())[:6]}")
                    final_llm_camelcase_json_for_reply = None
            
            elif final_llm_camelcase_json_for_reply and \
                 final_llm_camelcase_json_for_reply.get("status") == "success" and \
                 final_llm_camelcase_json_for_reply.get("decision",{}).get("isCallTools") is False:
                logger.info(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 使用规划阶段的直接回复V1.0-CamelCaseJSON作为最终输出。")
                final_llm_interaction_id_for_user = final_llm_camelcase_json_for_reply.get("llmInteractionId")

            elif not final_llm_camelcase_json_for_reply :
                 logger.error(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 流程结束时,final_llm_camelcase_json_for_reply 为空,表明处理失败。将使用之前记录的错误信息 (final_reply_for_user)。")

            user_facing_thought_process_final_summary = "综合思考过程已在之前的日志中发送。"
            if final_llm_camelcase_json_for_reply and final_llm_camelcase_json_for_reply.get("status") == "success":
                user_facing_thought_process_final_summary = final_llm_camelcase_json_for_reply.get("thoughtProcess", user_facing_thought_process_final_summary)
                resp_user_obj_final = final_llm_camelcase_json_for_reply.get("decision", {}).get("responseToUser", {})
                final_reply_for_user = resp_user_obj_final.get("content", final_reply_for_user)
            
            await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "finalization", "status": "completed" if (final_llm_camelcase_json_for_reply and final_llm_camelcase_json_for_reply.get("status") == "success") else "failed", "message": "请求处理流程已结束。"})
            await status_callback({
                "type": "final_response",
                "request_id": self.current_request_id,
                "llm_interaction_id": final_llm_interaction_id_for_user,
                "content": final_reply_for_user.strip() if final_reply_for_user else "抱歉,未能生成有效的回复。",
                "finaljson_if_success": final_llm_camelcase_json_for_reply
            })

            if not (final_llm_camelcase_json_for_reply and final_llm_camelcase_json_for_reply.get("status") == "success"):
                final_assistant_synthetic_error_message_camelcase_json = {
                    "requestId": self.current_request_id,
                    "llmInteractionId": final_llm_interaction_id_for_user or f"agent_synth_final_err_{str(uuid4())[:6]}",
                    "timestampUtc": datetime.now(timezone.utc).isoformat(),
                    "status": "failure",
                    "errorDetails": {"errorType": "AGENT_PROCESSING_FAILURE", "errorCode": "OVERALL_REQUEST_HANDLING_FAILED", "messageToUser": final_reply_for_user, "technicalMessage": "Agent failed to successfully complete the user request after all attempts.", "isDirectLlmFailure": False },
                    "executionPhase": "final_error_synthesis",
                    "thoughtProcess": user_facing_thought_process_final_summary or "Agent 最终处理失败,未能生成详细思考过程。",
                    "decision": {"isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content": final_reply_for_user}}
                }
                try: self.memory_manager.add_to_short_term({"role": "assistant", "content": json.dumps(final_assistant_synthetic_error_message_camelcase_json, ensure_ascii=False)})
                except Exception as e_mem_add_synth_err: logger.error(f"添加Agent合成的最终错误助手消息到记忆失败: {e_mem_add_synth_err}")

        except Exception as e_process_top_level:
            request_id_for_fatal = self.current_request_id or f"fatal_err_no_req_id_{str(uuid4())[:6]}"
            logger.critical(f"[OrchestratorV1_1_3 - ReqID:{request_id_for_fatal}] 处理用户请求 '{user_request[:1000]}' 时发生顶层未捕获异常: {e_process_top_level}", exc_info=True)
            error_msg_for_user_fatal = f"抱歉,处理您的请求 ('{user_request[:30]}...') 时发生严重的、未预期的内部系统错误。请稍后再试或联系技术支持。"
            tb_str_for_thinking_log_fatal = traceback.format_exc().replace('\n', ' | ')
            thinking_log_content_fatal = f"请求处理流程中发生顶层致命错误: {e_process_top_level}。Traceback (部分): {tb_str_for_thinking_log_fatal[:1000]}..."
            fatal_llm_interaction_id = f"fatal_agent_err_{str(uuid4())[:6]}"
            await status_callback({"type": "thinking_log", "request_id": request_id_for_fatal, "llm_interaction_id": fatal_llm_interaction_id, "stage": "fatal_error_capture", "content": thinking_log_content_fatal})
            await status_callback({"type": "general_status", "request_id": request_id_for_fatal, "stage": "fatal_error_handler", "status": "error", "message": f"请求处理失败,发生致命内部错误: {str(e_process_top_level)[:1000]}", "details": {"error_type": type(e_process_top_level).__name__, "full_error_message": str(e_process_top_level)}})
            await status_callback({"type": "final_response", "request_id": request_id_for_fatal, "llm_interaction_id": fatal_llm_interaction_id, "content": error_msg_for_user_fatal, "finaljson_if_success": None})
        finally:
            request_end_time = time.monotonic()
            duration_total = request_end_time - request_start_time
            logger.info(f"\n{'='*25} CircuitAgent 请求处理完毕 (ReqID: {self.current_request_id or 'N/A'}, 总耗时: {duration_total:.3f} 秒) {'='*25}\n")
            self.current_request_id = None


    # --- Helper Methods for Prompts (V1.0.0 - 辅助方法,用于生成系统提示) ---
    def _get_tool_schemas_for_prompt(self) -> str:
        if not self.tools_registry: return "  (当前无可用工具)"
        tool_schemas_parts = []
        sorted_tool_names = sorted(self.tools_registry.keys())

        for tool_name in sorted_tool_names:
            schema = self.tools_registry[tool_name]
            desc = schema.get('description', '无描述。')
            params_schema = schema.get('parameters', {})
            props_schema = params_schema.get('properties', {})
            req_params = params_schema.get('required', [])

            param_desc_segments = []
            if props_schema:
                sorted_param_names = sorted(props_schema.keys())
                for param_name in sorted_param_names: 
                    param_details_dict = props_schema[param_name]
                    param_type = param_details_dict.get('type','any')
                    is_required_str = "必须 (required)" if param_name in req_params else "可选 (optional)"
                    param_description = param_details_dict.get('description','无参数描述')
                    enum_values = param_details_dict.get('enum')
                    enum_desc = f" 可选值: {enum_values}。" if enum_values and isinstance(enum_values, list) else ""
                    param_desc_segments.append(f"    - 参数名 `{param_name}`:\n      - 类型: `{param_type}`\n      - 是否必需: {is_required_str}\n      - 描述: {param_description}{enum_desc}")
            elif params_schema.get("type") == "object" and not props_schema :
                 param_desc_segments = ["    - 此工具不接受任何参数(参数对象 `toolArguments` 应为空对象 `{}`)。"]
            else:
                 param_desc_segments = ["    - (此工具的参数定义似乎不完整或无参数)"]

            tool_schemas_parts.append(f"  - 工具名称: `{tool_name}`\n    工具描述: {desc}\n  工具参数详情 (这些参数应放在 `toolArguments` 对象内部):\n{chr(10).join(param_desc_segments)}")
        return "\n\n".join(tool_schemas_parts)

    def _get_planning_prompt(self, tool_schemas_desc: str, memory_context: str,
                                is_replanning: bool = False, request_id: Optional[str] = None) -> str:
        current_timestamp_utc = datetime.now(timezone.utc).isoformat()
        llm_interaction_id_example_plan_prefix = f"plan_ex_llm_id_{str(uuid4())[:6]}"
        example_prev_tool_call_id = f"tc_ex_prev_fail_{str(uuid4())[:6]}"

        reasoning_model_instructions = (
            "\n【重要: Reasoning Model 输出规范 (V1.0.0)】\n"
            "1.  **思考过程**: 您的详细思考过程、分析、逐步推理和决策逻辑【必须】包含在 `<think>...</think>` 标签内,并放在您回复的最开始部分。\n"
            "2.  **JSON 输出**: 在 `</think>` 标签之后,您【必须】输出一个严格符合下面描述的V1.0-CamelCaseJSON格式的单个JSON对象。此JSON对象应被三个反引号和'json'标记包围 (即 ```json ... ```)。JSON中所有key【必须】使用camelCase (例如: `isCallTools`, `toolCallRequests`, `requestId`).\n"
            "3.  **`thoughtProcess` 字段 (in JSON)**: JSON对象内部的 `thoughtProcess` 字段现在是次要的。它可以是一个简短的总结或留空 ( `\"\"` ),因为您的主要思考过程已在 `<think>...</think>` 块中。Agent将优先使用 `<think>` 块中的内容作为思考日志。\n"
        )

        replanning_guidance = ""
        if is_replanning:
            replanning_guidance = (
                "\n【重要: 重规划指示 (V1.0.0 - Reasoning Model)】\n"
                "您当前正在进行重规划。这意味着您之前的规划或工具执行遇到了问题。请在您的 `<think>...</think>` 块中：\n"
                "1.  **仔细分析失败原因**: 详细检查对话历史中的 `role: tool` 消息 (`content` JSON内的 `status: \"failure\"`, `message`, `errorDetails`) 和 `role: assistant` 消息中可能的Agent解析/校验错误 (`errorDetails.failedValidationPoints`)。\n"
                "2.  **参考当前电路状态**: 【务必】仔细查阅 `memory_context` 中的【当前电路状态】。您的新计划【必须】基于当前实际存在的元件和连接。不要不必要地重新添加已存在的元件。\n"
                "3.  **处理抽象节点**: 若涉及连接到 'INPUT', 'OUTPUT', 'GND' 等未作为元件存在的抽象节点失败,优先规划使用 `add_component_tool` (如 `component_type: 'Terminal'`) 创建它们,然后再连接。\n"
                "4.  **制定修正计划**: 基于以上分析,制定一个【全新的、修正了先前问题的计划】。这应在您的 `<think>...</think>` 块中清晰阐述。\n"
                "然后,在 `</think>` 之后输出符合V1.0-CamelCaseJSON规范的JSON。如果这个【新JSON本身的顶层 `status` 字段必须设置为 `'success'`】(因为您成功地为【当前这次思考和规划】输出了一个结构完整且逻辑合理的V1.0-CamelCaseJSON JSON)。\n"
                "5.  **无法解决的情况**: 如果分析后认为无法完成用户核心请求,则在 `<think>...</think>` 中解释,并在 `</think>` 后的JSON中制定一个【直接回复用户并解释情况的计划】 (`status: 'success'`, `isCallTools: False`).\n"
                "6.  **真正意义上的规划失败**: 只有当您在【当前这次重规划尝试中】,由于自身的理解困难、无法形成任何有效的 `<think>...</think>` 块或后续的V1.0-CamelCaseJSON JSON结构时,才应将后续JSON的顶层 `status` 字段设为 `'failure'`。\n"
                "**核心原则**: 不要因为*过去*的工具执行失败,就将您*当前新制定*的计划的JSON标记为 `status: 'failure'`. `status` 反映的是您【当前这次生成JSON这个行为本身】的成功与否。\n"
            )

        json_schema_description_for_prompt = """
```json
{
  "requestId": "string_or_null_当前用户请求周期的ID_如果系统提示中提供了此值请原样返回_否则为null",
  "llmInteractionId": "string_必须是本次LLM响应的唯一ID_例如_plan_llm_id_后跟8位随机字符_如_plan_llm_id_a1b2c3d4",
  "timestampUtc": "string_当前UTC时间戳_ISO_8601格式_例如_2024-07-16T12:00:00.000Z",
  "status": "string_必须是 'success' 或 'failure'._表示本次JSON输出是否由LLM为当前阶段成功生成。",
  "errorDetails": { // 如果 status 是 'success',则此字段为 null
    "errorType": "string_enum_高级错误类别_例如_PLANNING_ERROR_LLM_OUTPUT_VALIDATION_ERROR_INTERNAL_LOGIC_ERROR",
    "errorCode": "string_特定错误代码_例如_JSON_MALFORMED_MISSING_REQUIRED_FIELD_TOOL_PARAMS_INVALID",
    "messageToUser": "string_用户友好的解释_如果此错误与用户操作直接相关或适合用户查看。否则为通用Agent错误消息。",
    "technicalMessage": "string_详细的技术错误消息_用于日志记录和调试_这是LLM认为其自身输出生成过程中出现的问题。",
    "isDirectLlmFailure": "boolean_如果LLM明确表示无法完成请求或为本次尝试生成有效JSON则为True。如果错误是由于Agent端对LLM输出的JSON进行校验失败(即使JSON本身语法有效)_或LLM在格式良好的JSON中报告逻辑失败_则为False。",
    "failedValidationPoints": [ // 可选_如果LLM根据Agent反馈修正其先前的输出_则列出Agent发现的校验问题
      {
        "jsonPath": "string_例如_decision.toolCallRequests[0].toolArguments.component_id",
        "issue_description": "string_例如_必需字段缺失_或_值必须是字符串但得到的是整数"
      }
    ]
  },
  "executionPhase": "string_对于此任务_必须是 'planning'",
  "thoughtProcess": "string_此字段现在是次要的_您的主要详细推理必须在初始的 `<think>...</think>` 块中_此JSON字段可以是简短总结或为空_Agent将优先使用 `<think>` 块内容。",
  "decision": {
    "isCallTools": "boolean_如果需要调用工具则为True_否则为False_也接受不区分大小写的字符串 'true'/'false'",
    "toolCallRequests": [ // 如果 isCallTools 为 False, 则为 null 或空列表
      {
        "toolCallId": "string_由您为本次特定工具调用生成的唯一ID_例如_tc_add_resistor_xyz123",
        "toolName": "string_要调用的工具名称_从可用工具列表中选择 (例如 add_component_tool)",
        "toolArguments": { 
            // 此对象的内容是工具特定的_此处的键 (例如 component_type, value)
            // 应与 '可用工具列表与参数规范' 部分提供的 snake_case 名称匹配。
            // 电路工具示例: "component_type": "电阻", "value": "1k"
            // 搜索工具示例: "query": "欧姆定律", "num_results": 2 
        },
        "uiHints": { // 可选
            "displayNameForTool": "string_optional_更用户友好的工具调用名称_例如_添加电阻R1",
            "estimatedDurationCategory": "string_enum_optional_short_medium_long_very_long",
            "showProgressGranularly": "boolean_optional_如果为True_UI可能会显示更细粒度的进度(如果工具支持)_默认为False"
        },
        "estimatedComplexityOrNotes": "string_optional_LLM对此调用的内部注释_依赖关系或置信度。"
      }
    ],
    "responseToUser": {
      "contentType": "string_例如_text/plain_或_application/markdown",
      "content": "string_如果isCallTools为False_这是您对用户的直接且完整的回复_它必须非空。如果isCallTools为True_这应该是一条有意义的过渡消息_反映计划的操作_例如_好的_我将添加元件X然后连接到Y_如果确实不需要过渡消息则可以为空字符串_但为了用户体验首选提供一条好的消息。",
      "suggestionsForNextSteps": [ // 可选
        {
          "suggestionId": "string_optional_此建议的唯一ID_例如_sugg_ask_about_led_color",
          "textForUser": "string_向用户显示的建议文本_例如_您想指定LED颜色吗",
          "actionType": "string_enum_optional_USER_INPUT_EXPECTED_or_PREDEFINED_AGENT_ACTION_or_UI_NAVIGATION",
          "actionPayload": "object_or_string_optional_如果类型是PREDEFINED_AGENT_ACTION_这可能是简化的请求对象或命令字符串_供Agent在用户选择后处理"
        }
      ],
      "requiresUserClarificationForCurrentRequest": "boolean_optional_如果当前请求需要用户进一步输入才能继续_并且content正在请求该澄清_则设置为True_默认为False"
    }
  },
  "diagnostics": { // 可选
      "llmConfidenceScoreForThisOutput": "float_optional_0.0_到_1.0_LLM对此JSON输出的正确性和完整性的自评估置信度",
      "alternativePlansConsideredCount": "integer_optional_如果LLM在确定此计划前考虑了多个计划",
      "parsingFeedbackFromPreviousAttemptId": "string_or_null_如果这是对先前格式错误的JSON的修正_则为该失败尝试的llmInteractionId"
  },
  "usageMetadata": null
}
```
"""
        direct_qa_example = (
            "\n【通用示例1: 直接回答用户问题 (无需工具) - V1.0.0 Reasoning Model Output】\n"
            "如果用户问: “你好,什么是电容？”\n"
            "您的输出应类似 (ID和时间戳会变化): \n"
            "<think>\n"
            "用户询问电容的定义。这是一个概念性问题,不需要调用任何电路设计工具,我可以根据我的知识库直接回答。我将提供一个关于电容基本作用、单位和常见类型的解释,并给出下一步建议。我的回答将是清晰和直接的。\n"
            "</think>\n"
            "```json\n"
            "{\n"
            "  \"requestId\": \"" + (request_id or "userReqExampleId123") + "\",\n"
            "  \"llmInteractionId\": \"" + llm_interaction_id_example_plan_prefix + "_directQaCap\",\n"
            "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
            "  \"status\": \"success\",\n"
            "  \"errorDetails\": null,\n"
            "  \"executionPhase\": \"planning\",\n"
            "  \"thoughtProcess\": \"用户询问电容定义,直接回答。(主要思考过程在 <think> 块中)\",\n"
            "  \"decision\": {\n"
            "    \"isCallTools\": false,\n"
            "    \"toolCallRequests\": [],\n"
            "    \"responseToUser\": {\n"
            "      \"contentType\": \"text/plain\",\n"
            "      \"content\": \"电容是一种能够储存电荷的电子元件,由两块导体板中间夹一层绝缘介质构成。它的主要特性是电容量,单位是法拉(F),常用单位有微法(μF)、纳法(nF)和皮法(pF). 电容在电路中常用于滤波、耦合、隔直流、储能等.\",\n"
            "      \"suggestionsForNextSteps\": [\n"
            "        {\"textForUser\": \"您想了解电容在具体电路中的应用吗？\", \"actionType\": \"USER_INPUT_EXPECTED\"},\n"
            "        {\"textForUser\": \"需要我帮您在当前电路中添加一个电容吗？\", \"actionType\": \"USER_INPUT_EXPECTED\", \"actionPayload\": \"请帮我添加一个10uF的电解电容\"}\n"
            "      ],\n"
            "      \"requiresUserClarificationForCurrentRequest\": false\n"
            "    }\n"
            "  },\n"
            "  \"diagnostics\": {\"llmConfidenceScoreForThisOutput\": 0.95},\n"
            "  \"usageMetadata\": null\n"
            "}\n"
            "```\n"
        )
        tool_call_example = (
            "\n【通用示例2: 需要调用工具时的输出V1.0-CamelCaseJSON Reasoning Model Output】\n"
            "如果用户说: “帮我加一个1k欧姆的电阻R1,再用DuckDuckGo搜索'什么是LED'并返回2条结果,然后把R1连到GND。”\n"
            "您的输出应类似 (ID和时间戳会变化,每个toolCallId必须唯一,由您生成): \n"
            "<think>\n"
            "用户需要执行三个操作: 1. 添加电阻R1 (1kΩ)。 2. 使用DuckDuckGo搜索'什么是LED'并明确要求返回2条结果。3. 添加GND (如果不存在)并连接R1和GND。我将按顺序规划这三个/四个工具调用。确保为每个工具调用生成唯一的toolCallId。并为用户提供一个过渡性的回复,表明我理解了请求并正在处理。电路状态目前为空,元件GND可能需要先添加。\n"
            "</think>\n"
            "```json\n"
            "{\n"
            "  \"requestId\": \"" + (request_id or "userReqExampleId456") + "\",\n"
            "  \"llmInteractionId\": \"" + llm_interaction_id_example_plan_prefix + "_multiToolSearchFix2\",\n"
            "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
            "  \"status\": \"success\",\n"
            "  \"errorDetails\": null,\n"
            "  \"executionPhase\": \"planning\",\n"
            "  \"thoughtProcess\": \"规划添加R1,搜索,连接GND。(主要思考过程在 <think> 块中)\",\n"
            "  \"decision\": {\n"
            "    \"isCallTools\": true,\n"
            "    \"toolCallRequests\": [\n"
            "      {\n"
            "        \"toolCallId\": \"tc_add_r1_" + str(uuid4())[:8] + "\",\n"
            "        \"toolName\": \"add_component_tool\",\n"
            "        \"toolArguments\": {\"component_type\": \"电阻\", \"component_id\": \"R1\", \"value\": \"1kΩ\"},\n"
            "        \"uiHints\": {\"displayNameForTool\": \"添加电阻 R1 (1kΩ)\"}\n"
            "      },\n"
            "      {\n"
            "        \"toolCallId\": \"tc_search_led_" + str(uuid4())[:8] + "\",\n"
            "        \"toolName\": \"duckduckgo_search_tool\",\n"
            "        \"toolArguments\": {\"query\": \"什么是LED\", \"num_results\": 2},\n"
            "        \"uiHints\": {\"displayNameForTool\": \"搜索LED定义(2条结果)\"}\n"
            "      },\n"
            "      {\n"
            "        \"toolCallId\": \"tc_add_gnd_" + str(uuid4())[:8] + "\",\n"
            "        \"toolName\": \"add_component_tool\",\n"
            "        \"toolArguments\": {\"component_type\": \"地\", \"component_id\": \"GND\"},\n"
            "        \"uiHints\": {\"displayNameForTool\": \"添加地线 GND (如果需要)\"}\n"
            "      },\n"
            "      {\n"
            "        \"toolCallId\": \"tc_conn_r1gnd_" + str(uuid4())[:8] + "\",\n"
            "        \"toolName\": \"connect_components_tool\",\n"
            "        \"toolArguments\": {\"comp1_id\": \"R1\", \"comp2_id\": \"GND\"},\n"
            "        \"uiHints\": {\"displayNameForTool\": \"连接 R1 与 GND\"}\n"
            "      }\n"
            "    ],\n"
            "    \"responseToUser\": {\n"
            "      \"contentType\": \"text/plain\",\n"
            "      \"content\": \"好的,我正在为您添加电阻R1 (1kΩ),搜索LED的定义(2条结果),并准备连接R1到GND。请稍候...\",\n"
            "      \"suggestionsForNextSteps\": []\n"
            "    }\n"
            "  },\n"
            "  \"diagnostics\": null,\n"
            "  \"usageMetadata\": null\n"
            "}\n"
            "```\n"
        )
        
        replan_example = ""
        if is_replanning:
            replan_example = (
                "\n【重规划示例 (V1.0.0 Reasoning Model Output): 工具失败后,成功重规划并调用新/修正的工具】\n"
                "假设历史记录中有如下用户请求和失败的工具调用: \n"
                "  User: \"连接 R10 和 C5\"\n"
                "  Assistant (Previous Plan JSON): ... (Planned connect_components_tool for R10, C5, llmInteractionId: " + example_prev_tool_call_id + "_plan) ...\n"
                "  Tool (connect_components_tool, toolCallId: " + example_prev_tool_call_id + "_tool, name: connect_components_tool) result (in history): { \"role\": \"tool\", ..., \"content\": \"{\\\"status\\\": \\\"failure\\\", \\\"message\\\": \\\"错误: 元件 'R10' 在电路中不存在. \\\", \\\"error\\\": { \\\"error_type\\\": \\\"CIRCUIT_OPERATION_ERROR\\\", \\\"error_code\\\": \\\"COMPONENT_NOT_FOUND_FOR_CONNECTION\\\", ... }}\" }\n"
                "  Current Circuit State (in memory_context): (R10 does not exist, C5 exists)\n"
                "您在【当前重规划】时,您的新V1.0-CamelCaseJSON 输出应类似: \n"
                "<think>\n"
                "重规划开始。分析历史: 用户想连接R10和C5。上一个计划 (llmInteractionId: " + example_prev_tool_call_id + "_plan) 中调用connect_components_tool (toolCallId: " + example_prev_tool_call_id + "_tool) 失败了,工具报告原因是元件 'R10' 在电路中不存在。当前电路状态也确认R10不在电路中，但C5存在。因此,我的新计划是首先添加R10 (用户未指定类型或值,我将默认为电阻,并提供一个常用值如1kΩ). 然后再调用connect_components_tool连接新创建的R10和已存在的C5。本次规划逻辑清晰，后续的JSON应标记为status: 'success'.\n"
                "</think>\n"
                "```json\n"
                "{\n"
                "  \"requestId\": \"" + (request_id or "userReqExampleId789Replan") + "\",\n"
                "  \"llmInteractionId\": \"" + llm_interaction_id_example_plan_prefix + "_replanAddConnectFix2\",\n"
                "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
                "  \"status\": \"success\",\n"
                "  \"errorDetails\": null,\n"
                "  \"executionPhase\": \"planning\",\n"
                "  \"thoughtProcess\": \"R10不存在,先添加再连接。(主要思考过程在 <think> 块中)\",\n"
                "  \"decision\": {\n"
                "    \"isCallTools\": true,\n"
                "    \"toolCallRequests\": [\n"
                "      {\n"
                "        \"toolCallId\": \"tc_replan_add_r10_" + str(uuid4())[:8] + "\",\n"
                "        \"toolName\": \"add_component_tool\",\n"
                "        \"toolArguments\": {\"component_type\": \"电阻\", \"component_id\": \"R10\", \"value\": \"1k\"},\n"
                "        \"uiHints\": {\"displayNameForTool\": \"(修正) 添加电阻 R10 (1kΩ)\"}\n"
                "      },\n"
                "      {\n"
                "        \"toolCallId\": \"tc_replan_connect_r10c5_" + str(uuid4())[:8] + "\",\n"
                "        \"toolName\": \"connect_components_tool\",\n"
                "        \"toolArguments\": {\"comp1_id\": \"R10\", \"comp2_id\": \"C5\"},\n"
                "        \"uiHints\": {\"displayNameForTool\": \"(修正) 连接 R10 与 C5\"}\n"
                "      }\n"
                "    ],\n"
                "    \"responseToUser\": {\n"
                "      \"contentType\": \"text/plain\",\n"
                "      \"content\": \"检测到元件R10之前不存在。我将先为您添加一个1kΩ的电阻R10,然后再将它与C5连接。\",\n"
                "      \"suggestionsForNextSteps\": [\n"
                "        {\"textForUser\": \"操作完成后显示电路状态.\"}\n"
                "      ],\n"
                "      \"requiresUserClarificationForCurrentRequest\": false\n"
                "    }\n"
                "  },\n"
                "  \"diagnostics\": {\"parsingFeedbackFromPreviousAttemptId\": \"" + example_prev_tool_call_id + "_plan\"},\n"
                "  \"usageMetadata\": null\n"
                "}\n"
                "```\n"
            )
        prompt_parts = [
            "您是一位初版电路设计编程助理 (Agent Version V1.0.0, 11 Tools)。您的任务是理解用户指令,并据此规划行动或直接回复。\n", # Version update
            reasoning_model_instructions,
            "\n【核心任务: 规划阶段 (V1.0.0)】\n"
            "请首先在 `<think>...</think>` 标签内深入分析用户的最新指令、完整的对话历史、当前的电路状态和记忆。然后,在 `</think>` 标签之后,生成一个符合V1.0-CamelCaseJSON规范的JSON对象作为您的行动计划或直接回复。JSON中所有key【必须】使用camelCase (例如: `isCallTools`, `toolCallRequests`, `requestId`).\n",
            replanning_guidance if is_replanning else "",
            "【V1.0.0 输出格式规范 (在</think>之后输出, 必须严格遵守)】:\n",
            json_schema_description_for_prompt,
            "\n【重要指令与检查清单 (V1.0.0 - Planning)】:\n"
            "1.  **`<think>` Block First**: 您的详细逐步推理**必须**在 `<think>...</think>` 标签内,并置于回复最开始。\n"
            "2.  **JSON After `</think>`**: V1.0.0 对象 (用 ```json ... ``` 包裹) **必须**紧跟 `</think>` 标签。此JSON中的所有键名必须是 camelCase (例如, `requestId`, `isCallTools`, `toolCallRequests`)。`toolArguments` 内部的键名 (例如, `component_type`) 应遵循下面工具 Schema 中提供的 snake_case 命名。\n"
            "3.  **JSON `thoughtProcess` Field**: 此JSON字段现在是次要的。它可以是简短总结或空字符串 `\"\"`。`<think>...</think>` 块中的内容是主要的思考过程。\n"
            "4.  **`decision.isCallTools`**: JSON中的此字段**必须**是布尔值 (`true` 或 `false`)。大小写不敏感的字符串 \"True\" 或 \"true\" 也可接受,Agent会将其解析为布尔值。\n"
            "5.  **其他 JSON 字段**: 严格遵循V1.0-CamelCaseJSON Schema 的JSON部分。\n"
            "6.  **电路状态感知**: 在规划涉及现有元件的工具调用前,请在 `memory_context` (当前电路状态) 中确认它们的存在。如果需要连接像 'INPUT' 这样的抽象节点而它们并非作为元件存在,请首先规划添加它们 (例如,作为 'Terminal')。\n\n",
            direct_qa_example,
            tool_call_example,
        ]
        if is_replanning:
            prompt_parts.append(replan_example)

        prompt_parts.extend([
            "\n【可用工具列表与参数规范 (V1.0.0 - 11 Tools)】:\n", # Version update
            tool_schemas_desc,
            "\n\n【当前上下文信息 (V1.0.0)】:\n"
            f"Current Request ID (如果可用,请在JSON的requestId字段中原样返回): {request_id or 'N/A_NOT_PROVIDED_IN_PROMPT_SET_TO_NULL'}\n"
            f"Current UTC Time (供您生成timestampUtc参考): {current_timestamp_utc}\n"
            f"当前电路与记忆摘要:\n{memory_context}\n\n"
            "【最后再次强调】: 您的输出【必须】以 `<think>...</think>` 块开始,后跟一个被 ```json ... ``` 包围的、严格符合上述V1.0-CamelCaseJSON规范 (所有key使用camelCase) 的单个JSON对象。JSON对象之外不应有任何其他文本。请务必仔细检查 `<think>` 块的使用以及JSON的语法和所有字段的类型及条件要求！"
        ])
        return "".join(prompt_parts)

    def _get_response_generation_prompt(self, memory_context: str, tool_schemas_desc: str, request_id: Optional[str] = None) -> str:
        current_timestamp_utc = datetime.now(timezone.utc).isoformat()
        llm_interaction_id_example_resp_prefix = f"resp_ex_llm_id_{str(uuid4())[:6]}"

        reasoning_model_instructions_resp_phase = (
            "\n【重要: Reasoning Model 输出规范 (V1.0.0 - Response Generation)】\n"
            "1.  **思考过程**: 您的详细思考过程 (如何分析工具结果或决定直接回复, 以及如何构思最终回复) 【必须】包含在 `<think>...</think>` 标签内,并放在您回复的最开始部分。\n"
            "2.  **JSON 输出**: 在 `</think>` 标签之后,您【必须】输出一个严格符合下面描述的V1.0-CamelCaseJSON格式的单个JSON对象。此JSON对象应被三个反引号和'json'标记包围 (即 ```json ... ```)。JSON中所有key【必须】使用camelCase.\n"
            "3.  **`thoughtProcess` 字段 (in JSON)**: JSON对象内部的 `thoughtProcess` 字段现在是次要的。它可以是一个简短的总结或留空 ( `\"\"` ),因为您的主要思考过程已在 `<think>...</think>` 块中。Agent将优先使用 `<think>` 块中的内容作为思考日志。\n"
        )
        
        json_schema_description_for_resp_phase = """
```json
{
  "requestId": "string_or_null_当前用户请求周期的ID_如果系统提示中提供了此值请原样返回_否则为null",
  "llmInteractionId": "string_必须是本次LLM响应的唯一ID_例如_resp_llm_id_后跟8位随机字符_如_resp_llm_id_e5f6g7h8",
  "timestampUtc": "string_当前UTC时间戳_ISO_8601格式_例如_2024-07-16T12:05:00.000Z",
  "status": "string_必须是 'success' 或 'failure'_表示您是否为本次尝试成功生成了此最终响应JSON_如果您现在无法构思出合适的摘要或回复_则设为failure",
  "errorDetails": {
    "errorType": "string_enum_例如_RESPONSE_GENERATION_ERROR_LLM_OUTPUT_VALIDATION_ERROR",
    "errorCode": "string_例如_JSON_MALFORMED_SUMMARY_LOGIC_ERROR",
    "messageToUser": "string_optional_用户友好的消息_如果适用",
    "technicalMessage": "string_本次响应生成尝试的详细技术错误消息。",
    "isDirectLlmFailure": "boolean_如果LLM明确表示无法完成请求或为本次尝试生成有效JSON则为True。如果错误是由于Agent端对LLM输出的JSON进行校验失败(即使JSON本身语法有效)_或LLM在格式良好的JSON中报告逻辑失败_则为False。",
    "failedValidationPoints": [ { "jsonPath": "...", "issue_description": "..." } ]
  },
  "executionPhase": "string_对于此任务_必须是 'response_generation'",
  "thoughtProcess": "string_此字段现在是次要的_您的主要详细推理必须在初始的 `<think>...</think>` 块中_此JSON字段可以是简短总结或为空_Agent将优先使用 `<think>` 块内容。",
  "decision": {
    "isCallTools": "boolean_在此响应生成阶段必须为false_也接受不区分大小写的字符串 'true'/'false'",
    "toolCallRequests": [],
    "responseToUser": {
      "contentType": "string_例如_text/plain_或_application/markdown",
      "content": "string_这是您对用户的最终且完整的回复_它必须非空。它应总结已采取的操作_报告结果_并根据工具输出(如果最初未调用工具_则根据您的直接知识)回应用户的原始请求。此内容是用户将看到的。",
      "suggestionsForNextSteps": [
        {
          "suggestionId": "string_optional_此建议的唯一ID_例如_sugg_ask_about_led_color",
          "textForUser": "string_向用户显示的建议文本_例如_您想指定LED颜色吗",
          "actionType": "string_enum_optional_USER_INPUT_EXPECTED_or_PREDEFINED_AGENT_ACTION_or_UI_NAVIGATION",
          "actionPayload": "object_or_string_optional_如果类型是PREDEFINED_AGENT_ACTION_这可能是简化的请求对象或命令字符串_供Agent在用户选择后处理"
        }
      ],
      "requiresUserClarificationForCurrentRequest": "boolean_optional_如果当前请求需要用户进一步输入才能继续_并且content正在请求该澄清_则设置为True_默认为False"
    }
  },
  "diagnostics": {
      "llmConfidenceScoreForThisOutput": "float_optional_0.0_到_1.0",
      "alternativePlansConsideredCount": "integer_optional",
      "parsingFeedbackFromPreviousAttemptId": "string_or_null"
  },
  "usageMetadata": null
}
```
"""
        response_gen_example = (
            "\n【示例 (V1.0.0 Reasoning Model Output): 总结工具结果并生成最终回复】\n"
            "假设对话历史中包含以下工具执行结果 (工具1成功, 工具2是搜索工具也成功):\n"
            "  Tool Message 1 (for toolCallId: tc_xyz_add_r1): { \"role\": \"tool\", ..., \"content\": \"{\\\"status\\\": \\\"success\\\", \\\"message\\\": \\\"已添加电阻R1\\\", ...}\" }\n"
            "  Tool Message 2 (for toolCallId: tc_abc_search_led): { \"role\": \"tool\", ..., \"content\": \"{\\\"status\\\": \\\"success\\\", \\\"message\\\": \\\"已完成对'LED'的DuckDuckGo搜索,找到2条相关信息。\\\", \\\"data\\\": {\\\"query\\\": \\\"LED\\\", \\\"num_results_returned\\\": 2, \\\"results_json_string\\\": \\\"[{\\\\\\\"title\\\\\\\":\\\\\\\"LED - Wikipedia\\\\\\\", ...}]\\\"}}\" }\n"
            "您的输出V1.0-CamelCaseJSON JSON应类似 (ID和时间戳会变化): \n"
            "<think>\n"
            "回顾工具执行结果: add_component_tool (toolCallId: tc_xyz_add_r1) 成功添加了电阻R1。duckduckgo_search_tool (toolCallId: tc_abc_search_led) 成功搜索了'LED'并返回了结果。我需要向用户清晰地报告这两个操作的成功,并简要提及搜索到的信息。最终的回复将整合这些信息,保持友好和乐于助人的语气。\n"
            "</think>\n"
            "```json\n"
            "{\n"
            "  \"requestId\": \"" + (request_id or "userReqExampleIdResp123") + "\",\n"
            "  \"llmInteractionId\": \"" + llm_interaction_id_example_resp_prefix + "_finalSummaryRSearchFix2\",\n" 
            "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
            "  \"status\": \"success\",\n"
            "  \"errorDetails\": null,\n"
            "  \"executionPhase\": \"response_generation\",\n"
            "  \"thoughtProcess\": \"总结R1添加成功,LED搜索成功。(主要思考过程在 <think> 块中)\",\n"
            "  \"decision\": {\n"
            "    \"isCallTools\": false, \n"
            "    \"toolCallRequests\": [], \n"
            "    \"responseToUser\": {\n"
            "      \"contentType\": \"text/plain\",\n"
            "      \"content\": \"您好,我已经成功为您添加了电阻R1。关于LED的DuckDuckGo搜索也已完成,我找到了2条相关信息,例如 'LED - Wikipedia'。您想了解更多搜索到的细节吗？\",\n"
            "      \"suggestionsForNextSteps\": [\n"
            "        {\"suggestionId\": \"sugg_show_search_details\", \"textForUser\": \"显示LED搜索结果的详细信息\", \"actionType\": \"USER_INPUT_EXPECTED\"},\n"
            "        {\"suggestionId\": \"sugg_view_circuit\", \"textForUser\": \"查看当前电路中已有的元件列表。\", \"actionType\": \"USER_INPUT_EXPECTED\", \"actionPayload\": \"当前电路什么样\"}\n"
            "      ],\n"
            "      \"requiresUserClarificationForCurrentRequest\": false \n"
            "    }\n"
            "  },\n"
            "  \"diagnostics\": {\"llmConfidenceScoreForThisOutput\": 0.98},\n"
            "  \"usageMetadata\": null\n"
            "}\n"
            "```\n"
        )
        return (
            "您是一位初版电路设计编程助理 (Agent Version V1.0.0, 11 Tools), 经验丰富,技术精湛,并且极其擅长清晰、准确、诚实地汇报工作结果。\n" # Version update
            f"{reasoning_model_instructions_resp_phase}\n"
            "【核心任务: 响应生成阶段 (V1.0.0)】\n"
            "您当前的任务是: 基于到目前为止的【完整对话历史】(包括用户最初的指令、您在规划阶段生成的V1.0-CamelCaseJSON计划、以及所有【已执行工具的结果详情】,这些工具结果是以 'role: tool', 'toolCallId: ...', 'name: ...', 'content: JSON_string_of_tool_output' 的格式存在于历史记录中的), 首先在 `<think>...</think>` 标签内进行思考和总结, 然后在 `</think>` 之后生成【最终的、面向用户的V1.0-CamelCaseJSON回复】。JSON中所有key【必须】使用camelCase.\n\n"
            "【V1.0.0 输出格式规范 (在</think>之后输出, 与规划阶段结构相同,但有特定值要求 - 再次强调)】:\n"
            f"{json_schema_description_for_resp_phase}\n"
            "【重要指令与检查清单 (V1.0.0 - 响应生成阶段特定要求)】:\n"
            "1.  **`<think>` Block First**: 您的详细工具结果分析和回复构思**必须**在 `<think>...</think>` 标签内。\n"
            "2.  **JSON After `</think>`**: V1.0.0 对象 (用 ```json ... ``` 包裹) **必须**紧跟 `</think>` 标签。此JSON中的所有键名必须是 camelCase。\n"
            "3.  **`executionPhase`**: 在此阶段,此值【必须】是 `\"response_generation\"`。\n"
            "4.  **`decision.isCallTools`**: 在此响应生成阶段,此值【必须】为 `false` (或可解析为`false`的字符串)。\n"
            "5.  **`decision.toolCallRequests`**: 在此响应生成阶段,此列表【必须】为 `[]` (空数组) 或 `null`。\n"
            "6.  **`decision.responseToUser.content`**: 这是您基于所有先前步骤生成的【最终、完整、友好】的文本回复。它【不能】为空字符串或仅包含空白。\n"
            "7.  **回顾工具结果**: 仔细检查对话历史中 `role: tool` 的消息。您的最终回复必须准确反映这些结果。\n\n"
            f"{response_gen_example}\n"
            "【上下文参考信息 (仅供你回顾 - V1.0.0)】:\n"
            f"Current Request ID (如果可用,请在JSON的requestId字段中原样返回): {request_id or 'N/A_NOT_PROVIDED_IN_PROMPT_SET_TO_NULL'}\n"
            f"Current UTC Time (供您生成timestampUtc参考): {current_timestamp_utc}\n"
            f"当前电路与记忆摘要:\n{memory_context}\n"
            f"我的可用工具列表 (共11个, 仅供你参考,此阶段不应再调用它们):\n{tool_schemas_desc}\n\n" # Version update
            "【最后再次强调】: 您的输出【必须】以 `<think>...</think>` 块开始,后跟一个被 ```json ... ``` 包围的、严格符合上述V1.0-CamelCaseJSON规范 (所有key使用camelCase) 的单个JSON对象。在这个阶段,您【绝对不能】再请求调用任何新工具。您的任务是总结并回复。"
        )

# --- Main entry point for testing (Optional) ---
async def main_test_flow(agent: CircuitAgent, user_query: str):
    logger.info(f"\n\n>>>>>>>>> 测试开始 (V1.0.0): 用户查询: '{user_query}' <<<<<<<<<<") # Version update

    async def mock_status_callback(status_update: Dict[str, Any]):
        if "finaljson_if_success" in status_update and status_update["finaljson_if_success"]:
            printable_update = status_update.copy()
            try:
                printable_update["finaljson_if_success"] = json.loads(json.dumps(status_update["finaljson_if_success"], indent=2, ensure_ascii=False))
            except:
                pass
            logger.info(f"[StatusCallback] {json.dumps(printable_update, indent=2, ensure_ascii=False, default=str)}")
        elif "plan" in status_update and isinstance(status_update["plan"], list):
            printable_update = status_update.copy()
            try:
                printable_update["plan"] = json.loads(json.dumps(status_update["plan"], indent=2, ensure_ascii=False))
            except:
                pass
            logger.info(f"[StatusCallback] {json.dumps(printable_update, indent=2, ensure_ascii=False, default=str)}")
        else:
            logger.info(f"[StatusCallback] {json.dumps(status_update, ensure_ascii=False, default=str)}")

    await agent.process_user_request(user_query, mock_status_callback)
    logger.info(f">>>>>>>>>> 测试结束 (V1.0.0): 用户查询: '{user_query}' <<<<<<<<<<\n") # Version update

if __name__ == "__main__":
    logger.info("========== CircuitAgent V1.0.0 (11 Tools) - 命令行测试模式 ==========") 
    
    zhipu_api_key = os.environ.get("ZHIPUAI_API_KEY")
    if not zhipu_api_key:
        logger.critical("严重错误: ZHIPUAI_API_KEY 环境变量未设置,且代码中也未提供。Agent 无法运行。")
        sys.exit("错误: ZHIPUAI_API_KEY 未设置。请在运行前设置此环境变量。")

    test_agent = None # 初始化为 None
    try:
        test_agent = CircuitAgent(
            api_key=zhipu_api_key,
            model_name="glm-z1-flash",
            verbose=True,
            max_short_term_items=20,
            planning_llm_retries=1, 
            max_tool_retries=0, 
            max_replanning_attempts=1 
        )
        logger.info("CircuitAgent V1.0.0 (11 Tools) 初始化成功,准备接收测试指令。")
    except Exception as e_init:
        logger.critical(f"Agent 初始化失败: {e_init}", exc_info=True)
        sys.exit(f"Agent 初始化失败: {e_init}")

    test_queries = [
        "你好,你是谁？",
        "当前电路是什么样的?",
        "帮我添加一个10k欧姆的电阻,命名为R100。",
        "使用 DuckDuckGo 搜索一下什么是基尔霍夫电流定律。",
        "用 DuckDuckGo 搜索 'Python async library' 并返回2条结果",
        "搜索知乎", 
        "请帮我把R100的电阻值更新为4.7k, 然后查一下R100的连接数量, 接着用DuckDuckGo搜索“运算放大器原理”, 最后再移除R100。",
        "清空整个电路。",
    ]

    async def run_all_tests_main(agent_instance: CircuitAgent): # 修改函数名以示区别
        for i, query in enumerate(test_queries):
            logger.info(f"\n--- 测试用例 {i+1}/{len(test_queries)} (V1.0.0) ---")
            await main_test_flow(agent_instance, query) # 传递 agent_instance
            logger.info(f"--- 测试用例 {i+1} (V1.0.0) 完成 ---\n")
            if i < len(test_queries) - 1:
                 await asyncio.sleep(2)

    # ------------------- 关键修复部分开始 -------------------
    async def cleanup_remaining_tasks(current_loop):
        """Helper coroutine to clean up remaining tasks."""
        active_tasks = [task for task in asyncio.all_tasks(current_loop) if not task.done()]
        if active_tasks:
            logger.info(f"等待 {len(active_tasks)} 个剩余异步任务完成...")
            try:
                # 等待所有当前活动的任务完成，设置一个超时以防万一
                await asyncio.wait_for(asyncio.gather(*active_tasks, return_exceptions=True), timeout=5.0)
                logger.info("所有剩余异步任务已处理。")
            except asyncio.TimeoutError:
                logger.warning("等待剩余异步任务超时。")
                # 对于超时的任务，尝试取消它们
                for task in active_tasks:
                    if not task.done():
                        task.cancel()
                        try:
                            await task # 等待取消完成
                        except asyncio.CancelledError:
                            logger.info(f"任务 {task.get_name()} 已取消。")
                        except Exception as e_cancel:
                            logger.error(f"取消任务 {task.get_name()} 时发生错误: {e_cancel}")
            except Exception as e_gather:
                logger.error(f"处理剩余异步任务时发生错误: {e_gather}", exc_info=True)
    # ------------------- 关键修复部分结束 -------------------

    main_loop_is_running_at_start = loop.is_running()
    try:
        if test_agent: # 确保 agent 实例已创建
            # 如果主循环没有运行 (例如，直接从脚本顶部获取的 loop)，则使用 run_until_complete
            if not main_loop_is_running_at_start:
                loop.run_until_complete(run_all_tests_main(test_agent))
            else:
                # 如果已经在运行的循环中 (不太可能直接运行脚本时发生，但为了健壮性)
                # 我们可以创建一个新任务并等待它，但这会复杂化。
                # 简单起见，假设直接运行脚本时，loop 是由我们控制的。
                # 为了安全，我们还是用 run_until_complete, 它能处理好新旧循环。
                asyncio.run(run_all_tests_main(test_agent)) # 或者 loop.run_until_complete
        else:
            logger.error("Agent 实例未能创建，无法运行测试。")

    except KeyboardInterrupt:
        logger.info("测试被用户中断。")
    except Exception as e_main_run:
        logger.critical(f"运行测试时发生未处理的异常: {e_main_run}", exc_info=True)
    finally:
        # 确保在 finally 块中我们使用的是仍然有效的 loop 引用
        # 并且只在它真的还在运行时尝试关闭它。
        # asyncio.run() 会自己管理循环的关闭。
        # 如果是手动管理的 loop，则需要这里的逻辑。
        
        current_loop_ref = None
        try:
            current_loop_ref = asyncio.get_running_loop()
        except RuntimeError: # No running loop
            current_loop_ref = loop # Fallback to the loop we initially got/created

        if current_loop_ref and not current_loop_ref.is_closed():
            # 使用 run_until_complete 来运行清理协程
            logger.info("开始执行异步清理任务...")
            current_loop_ref.run_until_complete(cleanup_remaining_tasks(current_loop_ref))
            logger.info("异步清理任务完成。")
            
            # 只有当这个循环不是由 asyncio.run() 管理时才手动关闭
            # 如果是手动通过 set_event_loop 和 run_until_complete (针对单个协程) 管理的
            if not main_loop_is_running_at_start and current_loop_ref is loop: # 确保是我们手动启动和停止的循环
                 if not current_loop_ref.is_closed(): # 再次检查，因为cleanup可能已经关闭了某些东西
                    current_loop_ref.close()
                    logger.info("事件循环已关闭。")
            elif current_loop_ref.is_running() and not current_loop_ref.is_closed(): # 如果是其他情况且仍在运行
                logger.warning("事件循环仍在运行但未明确关闭，这可能发生在嵌套的asyncio使用中。")


        logger.info("========== CircuitAgent V1.0.0 (11 Tools) - 命令行测试结束 ==========")
--- END: completeCode.txt ---

--- START: requirements.txt ---
zhipuai>=2.0.0
fastapi
uvicorn[standard]
zhipuai
jinja2
aiofiles
google-search-results
python-dotenv>=0.19.0
PyYAML>=5.4.1
--- END: requirements.txt ---

--- START: server.py ---
# IDT_AGENT_Pro/server.py
import os
import uuid
import asyncio
import logging
import json 
from fastapi import FastAPI, Request, WebSocket, WebSocketDisconnect, HTTPException
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from typing import Dict, Callable, Awaitable, Any, Optional, Union
import time
import traceback 

try:
    from circuitmanus.agent import CircuitAgent
    AGENT_AVAILABLE = True 
    logger = logging.getLogger("server") 
    logger.info("CircuitAgent 模块从 'circuitmanus.agent' 导入成功.")
except ImportError as e:
    logger = logging.getLogger("server_fallback") 
    logger.critical(f"严重错误: 无法导入 Agent 类 'CircuitAgent' 从 'circuitmanus.agent'. 错误信息: {e}", exc_info=True)
    AGENT_AVAILABLE = False
    class CircuitAgent: 
        def __init__(self, *args: Any, **kwargs: Any) -> None:
            logger.warning("Agent核心代码不可用,使用假的CircuitAgent实例 (server.py fallback).")
            self.verbose_mode = kwargs.get('verbose', False) 
            self.current_request_id: str | None = None 
            class FakeConfigLoader:
                def get_config(self, key, default): return default
                def get_env_var(self, key, default=None): return default if key != "ZHIPUAI_API_KEY" else "fake_key_for_init_pass"
            self.config_loader = FakeConfigLoader()
            self.default_llm_identifier = "zhipu-ai"
            self.default_enable_chinese_thinking = False
            # 【新增】为假的Agent也模拟 model_availability_details
            self.model_availability_details = [
                {"id": "zhipu-ai", "name": "智谱清言 (GLM) - Fallback", "available": False},
                {"id": "deepseek", "name": "DeepSeek 大模型 - Fallback", "available": False}
            ]


        async def process_user_request(self, 
                                     user_request: str, 
                                     status_callback: Callable[[Dict[str, Any]], Awaitable[None]],
                                     selected_llm_identifier_from_frontend: Optional[str] = None,
                                     enable_chinese_thinking_from_frontend: Optional[bool] = None
                                     ) -> None:
            error_msg_content = "错误: 后端Agent核心模块未能加载,无法处理您的请求. 请联系管理员检查服务器日志 (V1.1.1-Fallback)." # 版本更新
            logger.error("假的Agent (server.py fallback): 收到请求,返回错误信息.")
            if status_callback:
                 request_id_fallback = f"fallback_req_{str(uuid.uuid4())[:6]}"
                 llm_interaction_id_fallback = f"fallback_llm_interaction_id_{str(uuid.uuid4())[:6]}"
                 
                 await status_callback({
                     "type": "general_status", 
                     "request_id": request_id_fallback,
                     "stage": "fatal_error_handler", 
                     "status": "error", 
                     "message": "Agent核心模块未加载,无法提供服务.",
                     "details": {"error_type": "AGENT_UNAVAILABLE", "technicalMessage": "Agent core module CircuitManusCore or circuitmanus.agent failed to load."}
                    })
                 await status_callback({
                     "type": "thinking_log", 
                     "request_id": request_id_fallback,
                     "llm_interaction_id": llm_interaction_id_fallback,
                     "stage": "error_synthesis",
                     "content": "Agent核心代码未加载 (V1.1.1 Fallback). 无法处理请求。" # 版本更新
                    })
                 await status_callback({
                     "type": "final_response", 
                     "request_id": request_id_fallback,
                     "llm_interaction_id": llm_interaction_id_fallback,
                     "content": error_msg_content,
                     "final_camelcase_json_if_success": None 
                    })


app = FastAPI(title="CircuitManus Agent API - V1.1.1 (Dynamic Model Availability)", version="1.4.1_dyn_model") # 版本更新

STATIC_DIR = os.path.join(os.path.dirname(__file__), "static")
if not os.path.isdir(STATIC_DIR):
    logger.warning(f"默认静态文件目录 '{STATIC_DIR}' 未找到。尝试上一级目录的 'static'...")
    alt_static_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), "static")
    if os.path.isdir(alt_static_dir):
        STATIC_DIR = alt_static_dir
        logger.info(f"使用备用静态文件目录: {STATIC_DIR}")
    else:
        logger.error(f"静态文件目录 'static' 在 {STATIC_DIR} 或 {alt_static_dir} 均未找到。Web UI可能无法加载。")
try:
    app.mount("/static", StaticFiles(directory=STATIC_DIR), name="static")
    logger.info(f"静态文件目录 '{STATIC_DIR}' 已尝试挂载到 '/static'.")
except RuntimeError as e:
    logger.error(f"挂载静态文件目录 '{STATIC_DIR}' 失败: {e}. 请确保 'static' 目录存在于正确的位置.", exc_info=True)


agent_sessions: Dict[str, CircuitAgent] = {} 
agent_locks: Dict[str, asyncio.Lock] = {}   
active_websockets: Dict[str, WebSocket] = {} 


async def get_agent_instance(session_id: str) -> CircuitAgent:
    if session_id not in agent_sessions:
        logger.info(f"为 Session {session_id} 创建新的 Agent 实例 (V1.1.1 Multi-LLM & Configurable)...") # 版本更新
        if AGENT_AVAILABLE: 
            try:
                config_yaml_file_path = "config.yaml" 
                dotenv_file_path = ".env" 
                
                new_agent = CircuitAgent(
                    config_yaml_path=config_yaml_file_path,
                    dotenv_path=dotenv_file_path
                )
                
                agent_sessions[session_id] = new_agent
                agent_locks[session_id] = asyncio.Lock() 
                logger.info(f"Agent 实例为 Session {session_id} 创建成功 (V1.1.1).") # 版本更新
            except ValueError as ve: 
                logger.error(f"创建真实的 Agent 实例因配置问题失败 (Session {session_id}): {ve}", exc_info=True)
                raise RuntimeError(f"无法为会话 {session_id} 创建真实的 Agent 实例: {ve}") from ve
            except Exception as e: 
                logger.error(f"创建真实的 Agent 实例发生未知错误 (Session {session_id}): {e}", exc_info=True)
                raise RuntimeError(f"无法为会话 {session_id} 创建真实的 Agent 实例: {e}") from e
        else: 
             logger.warning(f"Agent 核心代码不可用,为 Session {session_id} 创建了一个假的 Agent 实例 (get_agent_instance).")
             agent_sessions[session_id] = CircuitAgent(config_yaml_path="dummy_config.yaml", dotenv_path=None) 
             agent_locks[session_id] = asyncio.Lock()
    return agent_sessions[session_id]

async def get_session_lock(session_id: str) -> asyncio.Lock:
    if session_id not in agent_locks:
        logger.debug(f"锁在 get_session_lock 中为 Session {session_id} 创建。")
        agent_locks[session_id] = asyncio.Lock()
    return agent_locks[session_id]

@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request) -> HTMLResponse:
    logger.info(f"收到对根路径 '/' 的请求 (来自: {request.client.host if request.client else '未知客户端'}). 尝试提供静态主页.")
    html_file_path = os.path.join(STATIC_DIR, "index.html")
    
    if not os.path.exists(html_file_path):
        logger.error(f"错误: 未在静态文件目录 '{STATIC_DIR}' 下找到 'index.html' 文件！")
        error_content = """
        <html><head><title>Error</title></head><body>
        <h1>500 - Internal Server Error</h1>
        <p>The User Interface file (index.html) could not be found on the server.</p>
        <p>Please check server logs for the configured static directory path.</p>
        </body></html>
        """
        return HTMLResponse(content=error_content, status_code=500)
    try:
        with open(html_file_path, "r", encoding="utf-8") as f:
            html_content = f.read()
        return HTMLResponse(content=html_content)
    except Exception as e:
        logger.error(f"读取 index.html 文件 ('{html_file_path}') 时出错: {e}", exc_info=True)
        return HTMLResponse(content="<h1>500 - Internal Server Error: Error loading UI.</h1>", status_code=500)


@app.websocket("/ws/chat")
async def websocket_endpoint(websocket: WebSocket) -> None:
    await websocket.accept()
    logger.info(f"WebSocket 连接已接受 (来自: {websocket.client.host if websocket.client else '未知客户端'}:{websocket.client.port if websocket.client else '未知端口'}).")
    
    session_id: Optional[str] = None 
    agent_instance: Optional[CircuitAgent] = None 

    try:
        async def send_status_update_to_client(status_data: Dict[str, Any]) -> None:
            nonlocal session_id 
            if websocket.client_state.name == "CONNECTED": 
                try:
                    log_preview = json.dumps(status_data, ensure_ascii=False, default=str) 
                    logger.debug(f"SERVER SENDING TO CLIENT (Session {session_id or 'N/A'}, WS: {websocket.scope.get('path', '')}): {log_preview[:500]}{'...' if len(log_preview) > 500 else ''}")
                    await websocket.send_json(status_data)
                except WebSocketDisconnect: 
                    logger.warning(f"尝试发送状态更新到 Session {session_id or 'N/A'} 时WebSocket已断开 (send_status_update).")
                    raise asyncio.CancelledError("WebSocket connection lost during status update.")
                except Exception as e_send_status:
                    logger.error(f"通过WebSocket发送状态更新失败 (Session {session_id or 'N/A'}): {e_send_status}", exc_info=True)
            else:
                logger.warning(f"尝试发送状态更新到 Session {session_id or 'N/A'} 但WebSocket状态为 {websocket.client_state.name}。")
        
        while True:
            data = await websocket.receive_text() 
            try:
                message = json.loads(data) 
                msg_type = message.get("type") 

                if msg_type == "init": 
                    temp_session_id = message.get("session_id")
                    if not temp_session_id or not isinstance(temp_session_id, str) or not temp_session_id.strip():
                        session_id = str(uuid.uuid4()) 
                        logger.info(f"收到WebSocket初始化消息,未提供有效session_id,生成新的: {session_id}")
                    else:
                        session_id = temp_session_id.strip()
                        logger.info(f"收到WebSocket初始化消息,使用提供的session_id: {session_id}")
                    
                    active_websockets[session_id] = websocket
                    
                    try:
                        agent_instance = await get_agent_instance(session_id)
                        
                        # 【修改】在 init_success 中发送更详细的模型可用性信息
                        agent_defaults_for_frontend = {
                            "default_llm_identifier": agent_instance.default_llm_identifier,
                            "default_enable_chinese_thinking": agent_instance.default_enable_chinese_thinking,
                            "globally_enable_chinese_thinking": agent_instance.config_loader.get_config("agent_settings.feature_flags.enable_chinese_deep_thinking_globally", True),
                            # 发送 agent_instance.model_availability_details 而不是简单的列表
                            "detailed_available_llms": agent_instance.model_availability_details 
                        }
                        
                        await websocket.send_json({
                            "type": "init_success",
                            "session_id": session_id,
                            "message": "WebSocket连接建立成功,Agent (V1.1.1 Dynamic Models)已准备就绪.", # 版本更新
                            "agent_available": AGENT_AVAILABLE,
                            "agent_default_settings": agent_defaults_for_frontend
                        })
                        logger.info(f"Session {session_id} WebSocket初始化成功并发送确认 (包含详细模型可用性)。")
                    except Exception as e_init_agent: 
                         logger.error(f"Session {session_id} Agent初始化失败: {e_init_agent}", exc_info=True)
                         await websocket.send_json({
                             "type": "init_error",
                             "session_id": session_id, 
                             "message": f"Agent初始化失败: {str(e_init_agent)}",
                             "agent_available": AGENT_AVAILABLE 
                         })
                         await websocket.close(code=1011) 
                         break 

                elif msg_type == "message" and session_id and agent_instance: 
                    user_message_content = message.get("content")
                    
                    selected_llm_from_fe = message.get("selected_llm") 
                    enable_chinese_thinking_from_fe = message.get("enable_chinese_thinking") 

                    if not isinstance(selected_llm_from_fe, str) or not selected_llm_from_fe:
                        logger.warning(f"Session {session_id}: 前端未提供有效的 selected_llm，将使用Agent默认值。")
                        selected_llm_from_fe = None 
                    if not isinstance(enable_chinese_thinking_from_fe, bool):
                        logger.warning(f"Session {session_id}: 前端未提供有效的 enable_chinese_thinking (布尔型)，将使用Agent默认值。")
                        enable_chinese_thinking_from_fe = None 
                    
                    logger.info(f"Session {session_id} 收到用户消息 (内容预览: '{user_message_content[:100]}...', 模型选择: {selected_llm_from_fe}, 中文思考: {enable_chinese_thinking_from_fe})")
                    
                    if not user_message_content or not isinstance(user_message_content, str) or not user_message_content.strip():
                         logger.warning(f"Session {session_id} 收到空消息内容或非字符串内容.")
                         await send_status_update_to_client({"type": "error", "message": "收到空消息或无效消息内容,已忽略.", "request_id": agent_instance.current_request_id or f"err_req_{str(uuid.uuid4())[:6]}"})
                         continue

                    lock = await get_session_lock(session_id) 
                    async with lock: 
                        logger.info(f"Session {session_id} 获取到锁,开始处理用户消息 (模型: {selected_llm_from_fe or 'Agent默认'}, 中文思考: {enable_chinese_thinking_from_fe if enable_chinese_thinking_from_fe is not None else 'Agent默认'})...")
                        start_time_process = time.monotonic()
                        try:
                            await agent_instance.process_user_request(
                                user_request=user_message_content, 
                                status_callback=send_status_update_to_client,
                                selected_llm_identifier_from_frontend=selected_llm_from_fe,
                                enable_chinese_thinking_from_frontend=enable_chinese_thinking_from_fe
                            )
                            duration_process = time.monotonic() - start_time_process
                            logger.info(f"Session {session_id} (ReqID: {agent_instance.current_request_id or 'N/A'}) 消息处理流程调用完成,耗时: {duration_process:.3f} 秒.")
                        except asyncio.CancelledError: 
                             logger.warning(f"Session {session_id} (ReqID: {agent_instance.current_request_id or 'N/A'}) Agent消息处理任务被取消 (可能由于WebSocket断开).")
                        except Exception as e_process: 
                            logger.error(f"Session {session_id} (ReqID: {agent_instance.current_request_id or 'N/A'}) Agent消息处理时发生内部顶层错误: {e_process}", exc_info=True)
                            error_details_str = str(e_process)
                            current_req_id_for_error = agent_instance.current_request_id if agent_instance and agent_instance.current_request_id else f"error_req_{str(uuid.uuid4())[:6]}"
                            try:
                                await send_status_update_to_client({
                                    "type": "general_status", 
                                    "request_id": current_req_id_for_error,
                                    "stage": "fatal_processing_error", 
                                    "status": "error", 
                                    "message": "处理您的消息时服务器内部发生了严重错误.", 
                                    "details": {"error_type": type(e_process).__name__, "error_message": error_details_str}
                                })
                                await send_status_update_to_client({
                                    "type": "final_response", 
                                    "request_id": current_req_id_for_error,
                                    "llm_interaction_id": f"fatal_err_llm_id_{str(uuid.uuid4())[:6]}",
                                    "content": f"抱歉,处理您的消息时服务器内部发生了严重错误: {error_details_str[:100]}...",
                                    "final_camelcase_json_if_success": None
                                })
                            except asyncio.CancelledError: 
                                logger.warning(f"Session {session_id} 发送顶层处理错误回调时WebSocket已断开。")
                            except Exception as e_send_fatal:
                                logger.error(f"Session {session_id} 发送顶层处理错误回调本身失败: {e_send_fatal}")
                        finally:
                             logger.info(f"Session {session_id} (ReqID: {agent_instance.current_request_id if agent_instance else 'N/A'}) 处理完毕,释放锁.")
                
                elif not session_id or not agent_instance: 
                    logger.warning(f"收到消息 (type: {msg_type}) 但 session_id ('{session_id}') 或 agent_instance ({'存在' if agent_instance else '不存在'}) 未完全初始化。忽略。")
                    if websocket.client_state.name == "CONNECTED":
                        await websocket.send_json({"type": "error", "message": "会话未初始化或Agent实例创建失败,请先发送有效的 'init' 消息."})

                elif msg_type: 
                    logger.warning(f"Session {session_id or '未知'} 收到未知消息类型: '{msg_type}'. 消息内容(部分): {data[:100]}")
                    if websocket.client_state.name == "CONNECTED":
                        await websocket.send_json({"type": "error", "message": f"服务器收到未知消息类型: '{msg_type}'"})
                
            except json.JSONDecodeError: 
                logger.warning(f"Session {session_id or '未知'} 收到非JSON格式或无效JSON消息: {data[:100]}...")
                if websocket.client_state.name == "CONNECTED":
                    try: 
                        await websocket.send_json({"type": "error", "message": "服务器收到无效消息格式,请发送JSON.", "details": f"原始消息(部分): {data[:100]}"})
                    except WebSocketDisconnect: pass 
            except WebSocketDisconnect: 
                 logger.info(f"Session {session_id or '未知'} WebSocket连接已断开 (在主接收循环中).")
                 break 
            except asyncio.CancelledError: 
                 logger.info(f"Session {session_id or '未知'} WebSocket消息处理任务被取消。")
                 break
            except Exception as e_loop: 
                logger.error(f"Session {session_id or '未知'} 在消息接收/处理循环中发生未预期错误: {e_loop}", exc_info=True)
                if websocket.client_state.name == "CONNECTED":
                    try:
                        await websocket.send_json({"type": "error", "message": f"服务器内部错误: {str(e_loop)[:100]}...", "details": "详细错误已记录在服务器日志中。"})
                        await websocket.close(code=1011) 
                    except Exception: pass 
                break 

    except WebSocketDisconnect as e_ws_disconnect: 
        logger.info(f"Session {session_id or '未知'} WebSocket连接已断开 (在主 try 块捕获): code={e_ws_disconnect.code}, reason='{e_ws_disconnect.reason}'")
    except Exception as e_websocket_main: 
        logger.critical(f"Session {session_id or '未知'} WebSocket连接处理发生顶层未预期异常: {e_websocket_main}", exc_info=True)
        if websocket.client_state.name == "CONNECTED": 
            try: 
                await websocket.send_json({"type":"error", "message":"WebSocket服务器遇到严重内部错误，连接将关闭。"})
                await websocket.close(code=1011)
            except Exception: pass 
    finally:
        if session_id:
            if session_id in active_websockets:
                del active_websockets[session_id]
                logger.info(f"Session {session_id} 的WebSocket连接已从活动列表中移除.")
        
        client_addr = f"{websocket.client.host if websocket.client else '未知'}:{websocket.client.port if websocket.client else '未知'}"
        logger.info(f"Session {session_id or '未知'} WebSocket连接处理结束 (客户端: {client_addr}).")


if __name__ == "__main__":
    import uvicorn
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s [%(module)s.%(funcName)s:%(lineno)d] - %(message)s')
    logging.getLogger("uvicorn.error").setLevel(logging.INFO)
    logging.getLogger("uvicorn.access").setLevel(logging.WARNING) 
    logging.getLogger("fastapi").setLevel(logging.INFO)

    server_logger = logging.getLogger("server_main") 
    server_logger.info("直接运行 server.py, 启动 Uvicorn 开发服务器 (V1.1.1 Dynamic Model Availability)...") # 版本更新

    if not os.path.exists(".env") and not (os.environ.get("ZHIPUAI_API_KEY") or os.environ.get("DEEPSEEK_API_KEY")):
        server_logger.warning("！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！")
        server_logger.warning("警告: 未找到 .env 文件，且 ZHIPUAI_API_KEY 和 DEEPSEEK_API_KEY 环境变量均未设置。")
        server_logger.warning("Agent 可能无法连接到任何 LLM 服务。")
        server_logger.warning("！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！")
    elif not AGENT_AVAILABLE:
        server_logger.warning("警告: Agent核心模块 (circuitmanus.agent) 未能加载。服务器将使用备用的假Agent。")


    uvicorn.run(
        "server:app", 
        host="127.0.0.1",
        port=8000,
        reload=True, 
        log_level="debug" 
    )

--- END: server.py ---

--- START: circuitmanus/agent.py ---
# IDT_AGENT_NATIVE/circuitmanus/agent.py
import os
import sys 
import json
import time
import inspect 
import logging
import asyncio
import traceback
import functools 
from uuid import uuid4
from datetime import datetime, timezone
from typing import List, Dict, Any, Optional, Callable, Awaitable

from .utils.config_loader import ConfigLoader 
from .utils.logging_config import setup_logging 
from .memory.manager import MemoryManager 
from .llm.interface import LLMInterface   
from .llm.parser import OutputParser      
from .tools.base import register_tool     
from .tools.executor import ToolExecutor  
from .tools import circuit_ops            
from .tools import web_search             
from .prompts.templates import (          
    get_tool_schemas_for_prompt,
    get_planning_prompt,
    get_response_generation_prompt
)

class CircuitAgent:
    def __init__(self, 
                 config_yaml_path: str = "config.yaml", 
                 dotenv_path: Optional[str] = None
                 ):
        self.config_loader = ConfigLoader(yaml_config_path=config_yaml_path, dotenv_path=dotenv_path)
        self.api_key: str = self.config_loader.get_env_var("ZHIPUAI_API_KEY", "") 
        # ZhipuAI API Key 的检查逻辑保持，因为它是核心功能之一
        # DeepSeek Key 的检查将在下面模型可用性判断中进行

        self.current_request_id: Optional[str] = None 

        log_level_console_str: str = self.config_loader.get_config("agent_settings.logging.log_level_console", "INFO")
        log_level_file_str: str = self.config_loader.get_config("agent_settings.logging.log_level_file", "DEBUG")
        log_dir_cfg: Optional[str] = self.config_loader.get_config("agent_settings.logging.log_dir", None) 
        self.verbose_mode: bool = (log_level_console_str.upper() == "DEBUG")
        console_level_int = getattr(logging, log_level_console_str.upper(), logging.INFO)
        file_level_int = getattr(logging, log_level_file_str.upper(), logging.DEBUG)
        self.logger = setup_logging(
            console_log_level=console_level_int,
            file_log_level=file_level_int,
            log_dir_override=log_dir_cfg
        )
        
        self.default_llm_identifier: str = self.config_loader.get_config("agent_settings.llm.default_model_identifier", "zhipu-ai")
        self.default_enable_chinese_thinking: bool = self.config_loader.get_config("agent_settings.prompts.enable_deep_thinking_chinese_default", False)
        self.current_llm_identifier: str = self.default_llm_identifier
        self.current_enable_chinese_thinking: bool = self.default_enable_chinese_thinking

        # 【新增】判断并存储各模型可用性
        self.model_availability_details: List[Dict[str, Any]] = []
        configured_llm_identifiers = self.config_loader.get_config("agent_settings.llm.available_models", [])
        
        for model_id in configured_llm_identifiers:
            is_available = False
            display_name = model_id # 默认显示名称
            if model_id == "zhipu-ai":
                is_available = bool(self.api_key) # ZHIPUAI_API_KEY 存储在 self.api_key
                display_name = "智谱清言 (GLM)"
                if not is_available:
                    self.logger.warning("智谱AI API Key未配置，智谱模型将不可用。")
            elif model_id == "deepseek":
                deepseek_key = self.config_loader.get_env_var("DEEPSEEK_API_KEY")
                is_available = bool(deepseek_key)
                display_name = "DeepSeek 大模型"
                if not is_available:
                    self.logger.warning("DeepSeek API Key未配置，DeepSeek模型将不可用。")
            # 可以为未来其他模型添加类似的检查逻辑
            # else:
            #     self.logger.warning(f"配置文件中存在未知模型标识符 '{model_id}'，其可用性检查未实现。")

            self.model_availability_details.append({
                "id": model_id,
                "name": display_name, # 前端将使用这个名字作为选项文本
                "available": is_available
            })

        self.logger.info(f"\n{'='*30} CircuitAgent 初始化开始 (V1.1.1 - 动态模型可用性) {'='*30}")
        self.logger.info(f"Agent配置已从 '{os.path.abspath(config_yaml_path)}' 和 .env (如果存在) 加载。")
        self.logger.info(f"Agent verbose_mode (推导自 console_log_level='{log_level_console_str}'): {self.verbose_mode}")
        self.logger.info(f"默认LLM标识符: '{self.default_llm_identifier}', 默认中文深度思考: {self.default_enable_chinese_thinking}")
        self.logger.info(f"模型可用性详情: {json.dumps(self.model_availability_details, ensure_ascii=False)}")


        self.tools_registry: Dict[str, Dict[str, Any]] = {}
        self.logger.info("[Agent Init] 正在动态发现并注册工具...")
        tool_modules = [circuit_ops, web_search] 
        for module in tool_modules:
            for name, func in inspect.getmembers(module, inspect.isfunction):
                if hasattr(func, '_is_tool') and func._is_tool:
                    schema = getattr(func, '_tool_schema', None) 
                    if schema and isinstance(schema, dict) and 'description' in schema and 'parameters' in schema:
                        if inspect.iscoroutinefunction(func): 
                            async def async_bound_method_wrapper(arguments: Dict[str, Any], agent_self=self, original_func=func):
                                return await original_func(agent_self, arguments)
                            functools.update_wrapper(async_bound_method_wrapper, func) 
                            setattr(self, name, async_bound_method_wrapper) 
                        else: 
                            bound_method = functools.partial(func, self) 
                            functools.update_wrapper(bound_method, func) 
                            setattr(self, name, bound_method) 
                        self.tools_registry[name] = schema 
                        is_async_tool = inspect.iscoroutinefunction(func) 
                        self.logger.info(f"[Agent Init] ✓ 已动态绑定并注册工具: '{name}' (来自模块: {module.__name__}, 原始是否异步: {is_async_tool})。")
                    else:
                        self.logger.warning(f"[Agent Init] 在模块 {module.__name__} 中发现函数 '{name}' 被标记为工具,但其 Schema 结构不完整或无效,已跳过注册。")
        
        if not self.tools_registry:
            self.logger.warning("[Agent Init] 未发现任何通过 @register_tool 注册的工具！Agent 功能将受限。")
        else:
            self.logger.info(f"[Agent Init] 共动态绑定并注册了 {len(self.tools_registry)} 个工具。")
            if self.logger.isEnabledFor(logging.DEBUG):
                try:
                    self.logger.debug(f"[Agent Init] 工具注册表详情:\n{json.dumps(self.tools_registry, indent=2, ensure_ascii=False)}")
                except Exception as e_dump:
                    self.logger.debug(f"无法序列化工具注册表进行日志记录: {e_dump}")


        try:
            max_short_term = self.config_loader.get_config("agent_settings.memory.max_short_term_items", 30)
            max_long_term = self.config_loader.get_config("agent_settings.memory.max_long_term_items", 75)
            self.memory_manager = MemoryManager(max_short_term_items=max_short_term, max_long_term_items=max_long_term)

            self.llm_interface = LLMInterface(agent_instance=self)

            self.output_parser = OutputParser(agent_tools_registry=self.tools_registry)

            tool_retries_cfg = self.config_loader.get_config("agent_settings.tools.max_tool_retries", 1)
            tool_delay_cfg = self.config_loader.get_config("agent_settings.tools.tool_retry_delay_seconds", 1.0)
            self.tool_executor = ToolExecutor(
                agent_instance=self, 
                max_tool_retries=tool_retries_cfg,
                tool_retry_delay_seconds=tool_delay_cfg
            )
        except (ValueError, ConnectionError, TypeError) as e: 
            self.logger.critical(f"[Agent Init] 核心模块实例化失败: {e}", exc_info=True)
            raise 

        self.planning_llm_retries: int = self.config_loader.get_config("agent_settings.llm.planning_llm_retries", 3)
        self.response_generation_llm_retries: int = self.config_loader.get_config("agent_settings.llm.response_generation_llm_retries", 1)
        self.max_replanning_attempts: int = self.config_loader.get_config("agent_settings.orchestration.max_replanning_attempts", 2)
        
        self.logger.info(f"[Agent Init] LLM规划重试: {self.planning_llm_retries}, LLM响应生成重试: {self.response_generation_llm_retries}, 工具执行重试: {tool_retries_cfg}, 最大重规划尝试: {self.max_replanning_attempts}。")
        self.logger.info(f"\n{'='*30} CircuitAgent 初始化成功 (V1.1.1 - 动态模型可用性) {'='*30}\n") # 版本号微调

    async def process_user_request(self, 
                                 user_request: str, 
                                 status_callback: Callable[[Dict[str, Any]], Awaitable[None]],
                                 selected_llm_identifier_from_frontend: Optional[str] = None,
                                 enable_chinese_thinking_from_frontend: Optional[bool] = None
                                 ) -> None:
        request_start_time = time.monotonic()
        self.current_request_id = f"req_{str(uuid4())[:12]}" 

        final_llm_camelcase_json_for_reply: Optional[Dict[str, Any]] = None
        final_reply_for_user: str = self.config_loader.get_config(
            "agent_settings.general.default_user_facing_error_message", 
            "抱歉,处理您的请求时发生未知错误。" 
        )
        final_llm_interaction_id_for_user: Optional[str] = None
        active_llm_interaction_id: Optional[str] = None 

        # --- 更新当前请求使用的模型和中文思考设置 ---
        # 1. 模型选择
        if selected_llm_identifier_from_frontend:
            # 检查前端传来的模型是否在Agent的可用模型列表(基于API Key配置)中实际可用
            is_selected_model_actually_available = False
            for model_detail in self.model_availability_details:
                if model_detail["id"] == selected_llm_identifier_from_frontend and model_detail["available"]:
                    is_selected_model_actually_available = True
                    break
            if is_selected_model_actually_available:
                self.current_llm_identifier = selected_llm_identifier_from_frontend
            else:
                self.logger.warning(f"前端请求使用模型 '{selected_llm_identifier_from_frontend}'，但该模型当前不可用 (API Key可能未配置)。将回退到默认模型 '{self.default_llm_identifier}'。")
                self.current_llm_identifier = self.default_llm_identifier
                # 可以通过 status_callback 通知前端模型选择被覆盖
                await status_callback({
                    "type": "general_status", "request_id": self.current_request_id,
                    "stage": "llm_selection_override", "status": "warning",
                    "message": f"您选择的模型 '{selected_llm_identifier_from_frontend}' 当前不可用，已自动切换到默认模型 '{self.current_llm_identifier}'。",
                    "details": {"requested_model": selected_llm_identifier_from_frontend, "used_model": self.current_llm_identifier}
                })
        else:
            self.current_llm_identifier = self.default_llm_identifier
        
        # 2. 中文深度思考设置
        globally_enabled_chinese_thinking = self.config_loader.get_config("agent_settings.feature_flags.enable_chinese_deep_thinking_globally", True)
        if not globally_enabled_chinese_thinking:
            self.current_enable_chinese_thinking = False 
            self.logger.info(f"[Orchestrator - ReqID:{self.current_request_id}] 深度中文思考功能全局禁用。")
        elif enable_chinese_thinking_from_frontend is not None:
            self.current_enable_chinese_thinking = enable_chinese_thinking_from_frontend
        else:
            self.current_enable_chinese_thinking = self.default_enable_chinese_thinking
        # --- 模型和中文思考设置更新完毕 ---


        self.logger.info(f"\n{'='*25} CircuitAgent 开始处理用户请求 (ReqID: {self.current_request_id}) {'='*25}")
        self.logger.info(f"[Orchestrator - ReqID:{self.current_request_id}] 使用模型: '{self.current_llm_identifier}', 启用中文深度思考: {self.current_enable_chinese_thinking}")
        self.logger.info(f"[Orchestrator - ReqID:{self.current_request_id}] 收到用户指令 (预览): \"{user_request[:200]}{'...' if len(user_request)>200 else ''}\"")

        # ... (后续的 process_user_request 逻辑与上一版本 Agent.py 中基本一致，此处不再重复，
        #    关键在于 get_planning_prompt, get_response_generation_prompt, 和 llm_interface.call_llm
        #    现在会使用 self.current_llm_identifier 和 self.current_enable_chinese_thinking) ...
        # --- START OF ORCHESTRATION LOGIC (Copied and checked for new param usage) ---
        try:
            max_input_len = self.config_loader.get_config("agent_settings.security.max_input_length_user_request", 10000)
            if len(user_request) > max_input_len:
                original_length = len(user_request)
                user_request_truncated = user_request[:max_input_len]
                self.logger.warning(f"[Orchestrator - ReqID:{self.current_request_id}] 用户指令过长 (原始长度: {original_length}, 上限: {max_input_len})。已截断为: \"{user_request_truncated[:50]}...\"")
                user_request = user_request_truncated 
                await status_callback({ "type": "general_status", "request_id": self.current_request_id, "stage": "input_validation", "status": "warning", "message": f"您的输入内容过长(原始长度{original_length}), 已被自动截断为{max_input_len}字符进行处理。", "details": {"original_length": original_length, "truncated_length": max_input_len} })

            if not user_request or user_request.strip() == "": 
                self.logger.info(f"[Orchestrator - ReqID:{self.current_request_id}] 用户指令为空或无效。")
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "input_validation", "status": "ignored", "message": "用户输入为空或无效,已忽略。"})
                empty_input_err_json = { "requestId": self.current_request_id, "llmInteractionId": f"agent_input_err_{str(uuid4())[:6]}", "timestampUtc": datetime.now(timezone.utc).isoformat(), "status": "failure", "errorDetails": { "errorType": "USER_INPUT_ERROR", "errorCode": "EMPTY_OR_INVALID_USER_REQUEST", "messageToUser": "您的指令似乎是空的或无效的,请重新输入！", "technicalMessage": "User request was empty or whitespace.", "isDirectLlmFailure": False }, "executionPhase": "planning", "thoughtProcess": "Agent检测到用户输入为空或无效,无需进一步处理。", "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content": "您的指令似乎是空的或无效的,请重新输入！"}}}
                await status_callback({ "type": "final_response", "request_id": self.current_request_id, "llm_interaction_id": empty_input_err_json["llmInteractionId"], "content": empty_input_err_json["decision"]["responseToUser"]["content"], "final_camelcase_json_if_success": None })
                return

            await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "input_validation", "status": "received", "message": "收到用户指令,开始处理...", "details": {"user_request_preview": user_request[:1000]}})
            
            try: 
                self.memory_manager.add_to_short_term({"role": "user", "content": user_request})
            except Exception as e_mem_user:
                self.logger.error(f"[Orchestrator - ReqID:{self.current_request_id}] 添加用户消息到短期记忆时出错: {e_mem_user}", exc_info=True)
                err_msg_mem = f"记录用户指令时发生内部记忆错误: {e_mem_user}"
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "input_validation", "status": "error", "message": err_msg_mem})
                mem_err_json = { "requestId": self.current_request_id, "llmInteractionId": f"agent_mem_err_{str(uuid4())[:6]}", "timestampUtc": datetime.now(timezone.utc).isoformat(), "status": "failure", "errorDetails": {"errorType": "INTERNAL_AGENT_ERROR", "errorCode": "MEMORY_ADD_USER_MSG_FAILED", "messageToUser": f"抱歉,我在记录您的指令时遇到了内部问题 ({e_mem_user})！请稍后重试。", "technicalMessage": err_msg_mem, "isDirectLlmFailure": False }, "executionPhase": "planning", "thoughtProcess": "Agent在将用户消息添加到短期记忆时遇到错误。", "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content": f"抱歉,我在记录您的指令时遇到了内部问题 ({e_mem_user})！请稍后重试。" }}}
                await status_callback({"type": "final_response", "request_id": self.current_request_id, "llm_interaction_id": mem_err_json["llmInteractionId"], "content": mem_err_json["decision"]["responseToUser"]["content"], "final_camelcase_json_if_success": None})
                return

            replanning_loop_count = 0
            current_llm_plan_camelcase_json_obj: Optional[Dict[str, Any]] = None
            agent_accepted_latest_plan_for_action = False 
            tool_execution_results_for_llm_history: List[Dict[str, Any]] = [] # 确保在循环外定义

            while replanning_loop_count <= self.max_replanning_attempts:
                current_planning_attempt_num = replanning_loop_count + 1
                log_prefix = f"[Orchestrator - PlanAttempt {current_planning_attempt_num} - ReqID: {self.current_request_id}]"
                self.logger.info(f"\n--- {log_prefix} 开始 ---")

                is_currently_replanning = (replanning_loop_count > 0)
                status_msg_planning_start = "正在分析指令并制定计划..." if not is_currently_replanning else f"正在尝试第 {replanning_loop_count +1 }/{self.max_replanning_attempts +1} 次重规划..." 
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "started", "message": status_msg_planning_start, "details": {"attempt_number": current_planning_attempt_num, "max_replanning_attempts": self.max_replanning_attempts}})

                recent_long_term_for_prompt = self.config_loader.get_config("agent_settings.memory.recent_long_term_count_for_prompt", 7)
                memory_context = self.memory_manager.get_memory_context_for_prompt(recent_long_term_count=recent_long_term_for_prompt)
                tool_schemas_for_llm = get_tool_schemas_for_prompt(self.tools_registry)
                
                system_prompt_planning = get_planning_prompt(
                    tool_schemas_desc=tool_schemas_for_llm, 
                    memory_context=memory_context, 
                    is_replanning=is_currently_replanning, 
                    request_id=self.current_request_id,
                    enable_deep_thinking_chinese=self.current_enable_chinese_thinking 
                )
                messages_for_planning = [{"role": "system", "content": system_prompt_planning}] + self.memory_manager.short_term

                llm_call_attempt_inner = 0 
                parsed_plan_camelcase_json_this_llm_call: Optional[Dict[str, Any]] = None
                parser_error_msg_this_llm_call: str = ""
                parsed_failed_validation_points_this_llm_call: List[Dict[str,str]] = []
                agent_accepted_latest_plan_for_action = False 

                while llm_call_attempt_inner <= self.planning_llm_retries: 
                    self.logger.info(f"{log_prefix} 调用规划 LLM (模型: {self.current_llm_identifier}, LLM Call Attempt {llm_call_attempt_inner + 1} of {self.planning_llm_retries + 1})...")
                    try:
                        llm_response_planning_raw = await self.llm_interface.call_llm( 
                            messages=messages_for_planning, 
                            execution_phase="planning", 
                            status_callback=status_callback,
                            selected_model_identifier=self.current_llm_identifier 
                        )
                        if not llm_response_planning_raw or not hasattr(llm_response_planning_raw, 'choices') or not llm_response_planning_raw.choices: 
                            raise ConnectionError("LLM规划响应无效或缺少choices。")
                        
                        llm_msg_obj_planning = llm_response_planning_raw.choices[0].message
                        
                        parsed_plan_camelcase_json_this_llm_call, parser_error_msg_this_llm_call, parsed_failed_validation_points_this_llm_call = \
                            self.output_parser.parse_llm_response_to_structured_json(llm_msg_obj_planning, "planning")

                        if parsed_plan_camelcase_json_this_llm_call:
                            active_llm_interaction_id = parsed_plan_camelcase_json_this_llm_call.get("llmInteractionId")
                            current_thought_process = parsed_plan_camelcase_json_this_llm_call.get("thoughtProcess")
                            if current_thought_process: await status_callback({"type": "thinking_log", "request_id": self.current_request_id, "llm_interaction_id": active_llm_interaction_id, "stage": "planning", "content": current_thought_process})

                        if parsed_plan_camelcase_json_this_llm_call and not parser_error_msg_this_llm_call and not parsed_failed_validation_points_this_llm_call:
                            if parsed_plan_camelcase_json_this_llm_call.get("status") == "success":
                                self.logger.info(f"{log_prefix} 规划LLM调用成功且响应有效 (LLM_ID: {active_llm_interaction_id})。Agent采纳此计划。")
                                agent_accepted_latest_plan_for_action = True
                            elif is_currently_replanning and parsed_plan_camelcase_json_this_llm_call.get("decision", {}).get("isCallTools") is True and \
                                 isinstance(parsed_plan_camelcase_json_this_llm_call.get("decision", {}).get("toolCallRequests"), list) and \
                                 parsed_plan_camelcase_json_this_llm_call.get("decision", {}).get("toolCallRequests"): 
                                self.logger.warning(f"{log_prefix} LLM在重规划时提供了新工具计划但顶层status为failure (LLM_ID: {active_llm_interaction_id})。Agent审慎采纳。错误: {parsed_plan_camelcase_json_this_llm_call.get('errorDetails')}")
                                agent_accepted_latest_plan_for_action = True 
                            else: 
                                error_detail_from_llm = parsed_plan_camelcase_json_this_llm_call.get("errorDetails", {}).get("technicalMessage", "LLM规划指示内部错误。")
                                self.logger.warning(f"{log_prefix} LLM报告规划状态为 'failure': {error_detail_from_llm} (LLM_ID: {active_llm_interaction_id})。不采纳，尝试让LLM修正。")
                                parser_error_msg_this_llm_call = f"LLM主动报告规划失败: {error_detail_from_llm}" 

                            if agent_accepted_latest_plan_for_action:
                                current_llm_plan_camelcase_json_obj = parsed_plan_camelcase_json_this_llm_call
                                try: 
                                    if hasattr(llm_msg_obj_planning, 'model_dump'):
                                        self.memory_manager.add_to_short_term(llm_msg_obj_planning.model_dump(exclude_unset=True))
                                    elif isinstance(llm_msg_obj_planning, dict):
                                         self.memory_manager.add_to_short_term(llm_msg_obj_planning)
                                    else: 
                                        self.memory_manager.add_to_short_term(llm_msg_obj_planning.dict(exclude_unset=True)) # type: ignore
                                except AttributeError as e_attr:
                                    self.logger.error(f"{log_prefix} 添加LLM规划响应到记忆时，message对象缺少model_dump或dict方法: {e_attr}。对象类型: {type(llm_msg_obj_planning)}")
                                except Exception as e_mem_add: 
                                    self.logger.error(f"{log_prefix} 添加LLM规划响应到记忆失败: {e_mem_add}")
                                break 
                        if not agent_accepted_latest_plan_for_action and llm_call_attempt_inner < self.planning_llm_retries:
                            error_to_report_cb = parser_error_msg_this_llm_call or "V1.0.0结构或内容校验失败。"
                            if parsed_failed_validation_points_this_llm_call: error_to_report_cb += " 失败点(部分): " + json.dumps(parsed_failed_validation_points_this_llm_call[:2], ensure_ascii=False) 
                            await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "llm_retry_needed", "message": f"大脑计划处理遇问题,尝试重沟通 ({error_to_report_cb[:1000]})", "details": {"llm_call_attempt": llm_call_attempt_inner + 1}})
                            if parsed_plan_camelcase_json_this_llm_call and parsed_plan_camelcase_json_this_llm_call.get("status") == "failure":
                                try: 
                                    if hasattr(llm_msg_obj_planning, 'model_dump'):
                                        self.memory_manager.add_to_short_term(llm_msg_obj_planning.model_dump(exclude_unset=True))
                                    elif isinstance(llm_msg_obj_planning, dict):
                                        self.memory_manager.add_to_short_term(llm_msg_obj_planning)
                                    else:
                                        self.memory_manager.add_to_short_term(llm_msg_obj_planning.dict(exclude_unset=True)) # type: ignore
                                except AttributeError as e_attr:
                                     self.logger.error(f"{log_prefix} 添加LLM失败规划到记忆时，message对象缺少model_dump或dict方法: {e_attr}。")
                                except Exception as e_mem_add_fail: self.logger.error(f"{log_prefix} 添加LLM失败规划到记忆失败: {e_mem_add_fail}")
                            elif parser_error_msg_this_llm_call or parsed_failed_validation_points_this_llm_call:
                                 sim_err_plan_content = { "requestId": self.current_request_id, "llmInteractionId": f"agent_parser_err_{active_llm_interaction_id or str(uuid4())[:6]}", "timestampUtc": datetime.now(timezone.utc).isoformat(), "status": "failure", "errorDetails": { "errorType": "LLM_OUTPUT_VALIDATION_ERROR", "errorCode": "V1_CAMELCASE_JSON_VALIDATION_FAILED_BY_AGENT", "technicalMessage": parser_error_msg_this_llm_call or "Agent端JSON校验失败。", "isDirectLlmFailure": False, "failedValidationPoints": parsed_failed_validation_points_this_llm_call }, "executionPhase": "planning", "thoughtProcess": "Agent在解析或验证LLM上一次规划输出时发现以下问题,将请求LLM修正。", "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content":""}}}
                                 try: self.memory_manager.add_to_short_term({"role": "assistant", "content": json.dumps(sim_err_plan_content, ensure_ascii=False)})
                                 except Exception as e_mem_add_parse_err: self.logger.error(f"{log_prefix} 添加Agent解析错误到记忆失败: {e_mem_add_parse_err}")
                    except Exception as e_llm_call_level: 
                        self.logger.error(f"{log_prefix} LLM调用或规划解析时发生严重错误 (LLM Call Attempt {llm_call_attempt_inner + 1}): {e_llm_call_level}", exc_info=True)
                        parser_error_msg_this_llm_call = f"LLM调用/解析严重错误: {str(e_llm_call_level)[:1000]}"
                        parsed_failed_validation_points_this_llm_call = [{"jsonPath":"root.llmCallOrParse", "issue_description": parser_error_msg_this_llm_call}]
                        if llm_call_attempt_inner < self.planning_llm_retries: await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "llm_error_retrying", "message": f"与大脑沟通时发生严重错误,尝试重新连接 ({parser_error_msg_this_llm_call})", "details": {"llm_call_attempt": llm_call_attempt_inner + 1}})
                    llm_call_attempt_inner += 1
                    if agent_accepted_latest_plan_for_action: break 
                
                if not agent_accepted_latest_plan_for_action: 
                    error_summary_final_planning_llm_attempt = parser_error_msg_this_llm_call or "在多次LLM调用尝试后,未能从LLM获取可接受的规划。"
                    if parsed_failed_validation_points_this_llm_call: error_summary_final_planning_llm_attempt += " 最后一次校验失败点(部分): " + json.dumps(parsed_failed_validation_points_this_llm_call[:2], ensure_ascii=False)
                    await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "failed_after_llm_retries", "message": f"规划失败: {error_summary_final_planning_llm_attempt[:1000]}", "details": {"final_parser_error": parser_error_msg_this_llm_call, "final_validation_failures_count": len(parsed_failed_validation_points_this_llm_call), "thinking_log_from_last_attempt": parsed_plan_camelcase_json_this_llm_call.get("thoughtProcess") if parsed_plan_camelcase_json_this_llm_call else "N/A"}})
                    if replanning_loop_count >= self.max_replanning_attempts: 
                        self.logger.critical(f"{log_prefix} 已达最大重规划尝试次数,且本次规划最终失败。中止。")
                        final_reply_for_user = f"抱歉,多次尝试后未能为您的请求 '{user_request[:50]}...' 制定有效计划。错误: {error_summary_final_planning_llm_attempt[:500]}"
                        final_llm_interaction_id_for_user = active_llm_interaction_id or f"error_max_replan_{str(uuid4())[:6]}"
                        final_llm_camelcase_json_for_reply = None; break 
                    else: 
                        sim_fail_plan_content_for_replan = { "requestId": self.current_request_id, "llmInteractionId": f"agent_replan_trigger_{active_llm_interaction_id or str(uuid4())[:6]}", "timestampUtc": datetime.now(timezone.utc).isoformat(), "status": "failure", "errorDetails": {"errorType": "LLM_OUTPUT_VALIDATION_ERROR", "errorCode": "PLAN_VALIDATION_FAILED_IN_ATTEMPT", "technicalMessage": error_summary_final_planning_llm_attempt, "isDirectLlmFailure": False, "failedValidationPoints": parsed_failed_validation_points_this_llm_call }, "executionPhase": "planning", "thoughtProcess": f"Agent在第 {current_planning_attempt_num} 次规划尝试失败,将重规划。错误: {error_summary_final_planning_llm_attempt}", "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content":""}}}
                        try: self.memory_manager.add_to_short_term({"role": "assistant", "content": json.dumps(sim_fail_plan_content_for_replan, ensure_ascii=False)})
                        except Exception as e_mem_add_replan_trigger: self.logger.error(f"{log_prefix} 添加重规划触发信息到记忆出错: {e_mem_add_replan_trigger}")
                        replanning_loop_count += 1; continue 

                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "completed_and_validated", "message": "规划完成,准备执行或直接回复。", "details": {"plan_llm_id": current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else None}})
                
                tool_requests_from_plan = current_llm_plan_camelcase_json_obj.get("decision", {}).get("toolCallRequests", []) if current_llm_plan_camelcase_json_obj else []
                if isinstance(tool_requests_from_plan, list) and current_llm_plan_camelcase_json_obj and current_llm_plan_camelcase_json_obj.get("decision",{}).get("isCallTools") is True:
                    plan_details_for_ui = []
                    for req_idx, tool_req_in_plan in enumerate(tool_requests_from_plan): plan_details_for_ui.append({ "tool_call_id": tool_req_in_plan.get("toolCallId"), "tool_name": tool_req_in_plan.get("toolName"), "tool_arguments": tool_req_in_plan.get("toolArguments", {}), "ui_hints": tool_req_in_plan.get("uiHints", {}), "status": "pending", "order": req_idx + 1 })
                    await status_callback({ "type": "plan_details", "request_id": self.current_request_id, "llm_interaction_id": current_llm_plan_camelcase_json_obj.get("llmInteractionId"), "plan": plan_details_for_ui })
                
                decision_from_plan = current_llm_plan_camelcase_json_obj.get("decision", {}) if current_llm_plan_camelcase_json_obj else {}
                should_call_tools = decision_from_plan.get("isCallTools", False) 
                response_user_obj_from_plan = decision_from_plan.get("responseToUser")
                # tool_execution_results_for_llm_history: List[Dict[str, Any]] = [] # 已移到循环外

                if should_call_tools: 
                    tool_count_in_plan = len(tool_requests_from_plan) if isinstance(tool_requests_from_plan, list) else 0
                    self.logger.info(f"{log_prefix} 决策: 执行 {tool_count_in_plan} 个工具。")
                    await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "action_execution", "status": "started", "message": f"开始执行 {tool_count_in_plan} 个操作...", "details": {"tool_count": tool_count_in_plan}})
                    if isinstance(response_user_obj_from_plan, dict) and response_user_obj_from_plan.get("content","").strip():
                        transitional_reply_content = response_user_obj_from_plan["content"]
                        await status_callback({"type": "interim_response", "request_id": self.current_request_id, "llm_interaction_id": current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else None, "content": transitional_reply_content})
                    if not isinstance(tool_requests_from_plan, list) or not tool_requests_from_plan:
                        err_msg_list_tools_critical = "内部规划错误: isCallTools为True但toolCallRequests无效或为空。"
                        self.logger.error(f"{log_prefix} {err_msg_list_tools_critical}")
                        tool_execution_results_for_llm_history = [{"role":"tool", "tool_call_id":f"plan_integrity_err_{str(uuid4())[:6]}", "name":"plan_integrity_checker", "content":json.dumps({"status":"failure", "message":err_msg_list_tools_critical, "error": {"error_type":"INTERNAL_AGENT_ERROR", "error_code":"INVALID_TOOL_REQUEST_LIST", "technical_message": err_msg_list_tools_critical}})}]
                        try: self.memory_manager.add_to_short_term(tool_execution_results_for_llm_history[0])
                        except Exception as e_mem_add_integrity_err: self.logger.error(f"{log_prefix} 添加规划完整性错误到记忆失败: {e_mem_add_integrity_err}")
                        if replanning_loop_count >= self.max_replanning_attempts: final_reply_for_user = f"抱歉,系统准备执行操作时遇内部问题: {err_msg_list_tools_critical}"; final_llm_interaction_id_for_user = current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else active_llm_interaction_id; final_llm_camelcase_json_for_reply = None; break 
                        else: replanning_loop_count += 1; continue
                    
                    current_tool_exec_results_for_llm_hist = await self.tool_executor.execute_tool_calls( tool_requests_from_plan, status_callback )
                    tool_execution_results_for_llm_history.extend(current_tool_exec_results_for_llm_hist) 
                    
                    if tool_execution_results_for_llm_history: 
                        for res_msg_tool in tool_execution_results_for_llm_history:
                            try: self.memory_manager.add_to_short_term(res_msg_tool)
                            except Exception as e_mem_add_tool_res: self.logger.error(f"{log_prefix} 添加工具结果 {res_msg_tool.get('tool_call_id')} 到记忆失败: {e_mem_add_tool_res}")
                    
                    any_tool_failed_persistently = False; last_failed_tool_message_for_user = "一个或多个操作未能成功完成。" 
                    if tool_execution_results_for_llm_history:
                        for tool_res_for_hist in tool_execution_results_for_llm_history:
                            try:
                                tool_res_content_dict = json.loads(tool_res_for_hist.get("content","{}"))
                                if tool_res_content_dict.get("status") != "success": any_tool_failed_persistently = True; last_failed_tool_message_for_user = tool_res_content_dict.get("message", last_failed_tool_message_for_user)
                            except json.JSONDecodeError: self.logger.error(f"{log_prefix} 无法解析工具结果JSON: {str(tool_res_for_hist.get('content'))[:200]}"); any_tool_failed_persistently = True; last_failed_tool_message_for_user = "一个操作的结果格式不正确。"
                    
                    if any_tool_failed_persistently:
                        self.logger.warning(f"{log_prefix} 工具执行中发生持久性失败。")
                        await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "action_execution", "status": "tool_failure_detected", "message": "部分操作失败,准备评估是否重规划。", "details": {"last_error_message": last_failed_tool_message_for_user}})
                        if replanning_loop_count < self.max_replanning_attempts: replanning_loop_count += 1; continue 
                        else: self.logger.critical(f"{log_prefix} 已达最大重规划尝试次数,但工具执行仍失败。中止。"); final_reply_for_user = f"抱歉,执行请求时遇问题: {last_failed_tool_message_for_user} 请检查指令或稍后再试。"; final_llm_interaction_id_for_user = current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else active_llm_interaction_id; final_llm_camelcase_json_for_reply = None; break 
                    else: self.logger.info(f"{log_prefix} 所有工具成功执行。准备生成最终回复。"); break  # 成功则跳出重规划循环
                else: 
                    self.logger.info(f"{log_prefix} 决策: 直接回复。")
                    if isinstance(response_user_obj_from_plan, dict) and response_user_obj_from_plan.get("content") is not None and \
                       (isinstance(response_user_obj_from_plan.get("content"), str) and response_user_obj_from_plan.get("content","").strip()):
                        final_llm_camelcase_json_for_reply = current_llm_plan_camelcase_json_obj 
                        self.logger.info(f"{log_prefix} 规划阶段决定直接回复,内容有效。使用此JSON作最终输出。LLM_ID: {final_llm_camelcase_json_for_reply.get('llmInteractionId')}")
                        break # 直接回复成功，跳出重规划循环
                    else: 
                        err_msg_direct_content_critical = "内部规划错误: isCallTools为False但responseToUser.content无效或为空。"
                        self.logger.error(f"{log_prefix} {err_msg_direct_content_critical}")
                        tool_execution_results_for_llm_history = [{"role":"tool", "tool_call_id":f"direct_reply_integrity_err_{str(uuid4())[:6]}", "name":"direct_reply_integrity_checker", "content":json.dumps({"status":"failure", "message":err_msg_direct_content_critical, "error": {"error_type":"INTERNAL_AGENT_ERROR", "error_code":"INVALID_DIRECT_RESPONSE_CONTENT", "technical_message": err_msg_direct_content_critical}})}]
                        try: self.memory_manager.add_to_short_term(tool_execution_results_for_llm_history[0])
                        except Exception as e_mem_add_direct_reply_err: self.logger.error(f"{log_prefix} 添加直接回复完整性错误到记忆失败: {e_mem_add_direct_reply_err}")
                        if replanning_loop_count >= self.max_replanning_attempts: final_reply_for_user = f"抱歉,系统准备直接回复时遇内部问题: {err_msg_direct_content_critical}"; final_llm_interaction_id_for_user = current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else active_llm_interaction_id; final_llm_camelcase_json_for_reply = None; break 
                        else: replanning_loop_count += 1; continue
            
            self.logger.debug(f"[Orchestrator - ReqID:{self.current_request_id}] 重规划循环结束。")
            
            resp_gen_llm_retries = self.response_generation_llm_retries 

            # 只有在规划成功、需要调用工具、且工具执行也成功后，才进入响应生成阶段
            # 或者规划成功且是直接回复 (final_llm_camelcase_json_for_reply 已被设置)
            if final_llm_camelcase_json_for_reply is None and \
               current_llm_plan_camelcase_json_obj and \
               current_llm_plan_camelcase_json_obj.get("status") == "success" and \
               current_llm_plan_camelcase_json_obj.get("decision",{}).get("isCallTools") is True: 
                
                self.logger.info(f"[Orchestrator - ReqID:{self.current_request_id}] 工具执行流程完成,开始生成最终响应 (LLM: {self.current_llm_identifier}, 中文思考: {self.current_enable_chinese_thinking}, LLM重试上限: {resp_gen_llm_retries})...")
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "response_generation", "status": "started", "message": "正在总结结果并生成最终回复...", "details": {"reason": "Tool execution phase completed."}})
                memory_context_resp_gen = self.memory_manager.get_memory_context_for_prompt( recent_long_term_count=self.config_loader.get_config("agent_settings.memory.recent_long_term_count_for_prompt", 7) )
                tool_schemas_resp_gen = get_tool_schemas_for_prompt(self.tools_registry) 
                system_prompt_resp_gen = get_response_generation_prompt( 
                    memory_context=memory_context_resp_gen, 
                    tool_schemas_desc=tool_schemas_resp_gen, 
                    request_id=self.current_request_id,
                    enable_deep_thinking_chinese=self.current_enable_chinese_thinking
                )
                messages_for_resp_gen = [{"role": "system", "content": system_prompt_resp_gen}] + self.memory_manager.short_term
                
                llm_call_attempt_resp_gen = 0; parsed_final_camelcase_resp_json_this_attempt: Optional[Dict[str, Any]] = None
                while llm_call_attempt_resp_gen <= resp_gen_llm_retries:
                    self.logger.info(f"[Orchestrator - ReqID:{self.current_request_id}] 调用响应生成 LLM (模型: {self.current_llm_identifier}, 尝试 {llm_call_attempt_resp_gen + 1}/{resp_gen_llm_retries + 1})...")
                    try:
                        llm_response_final_gen_raw = await self.llm_interface.call_llm( 
                            messages=messages_for_resp_gen, 
                            execution_phase="response_generation", 
                            status_callback=status_callback,
                            selected_model_identifier=self.current_llm_identifier
                        )
                        if not llm_response_final_gen_raw or not hasattr(llm_response_final_gen_raw, 'choices') or not llm_response_final_gen_raw.choices: 
                            raise ConnectionError("LLM最终响应生成阶段响应无效。")
                        
                        llm_msg_obj_final_gen = llm_response_final_gen_raw.choices[0].message
                        parsed_final_camelcase_resp_json_this_attempt, final_parser_err_resp, final_validation_failures_resp = \
                            self.output_parser.parse_llm_response_to_structured_json(llm_msg_obj_final_gen, "response_generation")
                        
                        if parsed_final_camelcase_resp_json_this_attempt:
                            active_llm_interaction_id = parsed_final_camelcase_resp_json_this_attempt.get("llmInteractionId")
                            final_resp_thought_process = parsed_final_camelcase_resp_json_this_attempt.get("thoughtProcess")
                            if final_resp_thought_process: await status_callback({"type": "thinking_log", "request_id": self.current_request_id, "llm_interaction_id": active_llm_interaction_id, "stage": "response_generation", "content": final_resp_thought_process})
                        
                        if parsed_final_camelcase_resp_json_this_attempt and not final_parser_err_resp and not final_validation_failures_resp and \
                           parsed_final_camelcase_resp_json_this_attempt.get("status") == "success":
                            final_llm_camelcase_json_for_reply = parsed_final_camelcase_resp_json_this_attempt; final_llm_interaction_id_for_user = active_llm_interaction_id
                            self.logger.info(f"[Orchestrator - ReqID:{self.current_request_id}] 成功解析最终响应V1.0-JSON (LLM_ID: {final_llm_interaction_id_for_user})。")
                            try: 
                                if hasattr(llm_msg_obj_final_gen, 'model_dump'):
                                    self.memory_manager.add_to_short_term(llm_msg_obj_final_gen.model_dump(exclude_unset=True))
                                elif isinstance(llm_msg_obj_final_gen, dict):
                                     self.memory_manager.add_to_short_term(llm_msg_obj_final_gen)
                                else:
                                    self.memory_manager.add_to_short_term(llm_msg_obj_final_gen.dict(exclude_unset=True)) # type: ignore
                            except AttributeError as e_attr:
                                self.logger.error(f"添加最终LLM响应到记忆时，message对象缺少model_dump或dict方法: {e_attr}。")
                            except Exception as e_mem_add_final_resp: self.logger.error(f"添加最终LLM响应到记忆失败: {e_mem_add_final_resp}")
                            break 
                        else: 
                            err_msg_final_resp_gen = final_parser_err_resp or "V1.0.0最终响应JSON校验失败。"
                            if final_validation_failures_resp: err_msg_final_resp_gen += " 失败点(部分): " + json.dumps(final_validation_failures_resp[:2], ensure_ascii=False)
                            elif parsed_final_camelcase_resp_json_this_attempt and parsed_final_camelcase_resp_json_this_attempt.get("status") == "failure": err_msg_final_resp_gen = parsed_final_camelcase_resp_json_this_attempt.get("errorDetails",{}).get("technicalMessage", err_msg_final_resp_gen)
                            self.logger.error(f"[Orchestrator - ReqID:{self.current_request_id}] LLM未能生成有效最终回复 (尝试 {llm_call_attempt_resp_gen + 1}): {err_msg_final_resp_gen}")
                            if llm_call_attempt_resp_gen >= resp_gen_llm_retries: 
                                final_reply_for_user = f"抱歉,总结操作结果时发生问题。错误(部分): {err_msg_final_resp_gen[:500]}... "
                                final_llm_interaction_id_for_user = active_llm_interaction_id or (current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else f"error_resp_gen_{str(uuid4())[:6]}")
                                final_llm_camelcase_json_for_reply = None 
                                break 
                            try: 
                                if hasattr(llm_msg_obj_final_gen, 'model_dump'):
                                    self.memory_manager.add_to_short_term(llm_msg_obj_final_gen.model_dump(exclude_unset=True))
                                elif isinstance(llm_msg_obj_final_gen, dict):
                                     self.memory_manager.add_to_short_term(llm_msg_obj_final_gen)
                                else:
                                    self.memory_manager.add_to_short_term(llm_msg_obj_final_gen.dict(exclude_unset=True)) # type: ignore
                            except: pass 
                    except Exception as e_llm_final_gen_call: 
                        self.logger.critical(f"[Orchestrator - ReqID:{self.current_request_id}] LLM最终响应调用失败 (尝试 {llm_call_attempt_resp_gen + 1}): {e_llm_final_gen_call}", exc_info=True)
                        if llm_call_attempt_resp_gen >= resp_gen_llm_retries: 
                            final_reply_for_user = f"抱歉,系统准备最终报告时遇严重错误: {str(e_llm_final_gen_call)[:500]}... "
                            final_llm_interaction_id_for_user = (current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else active_llm_interaction_id or f"critical_err_resp_gen_{str(uuid4())[:6]}")
                            final_llm_camelcase_json_for_reply = None 
                            break 
                    llm_call_attempt_resp_gen +=1
            
            elif final_llm_camelcase_json_for_reply and final_llm_camelcase_json_for_reply.get("status") == "success" and \
                 final_llm_camelcase_json_for_reply.get("decision",{}).get("isCallTools") is False:
                self.logger.info(f"[Orchestrator - ReqID:{self.current_request_id}] 使用规划阶段的直接回复JSON作最终输出。")
                final_llm_interaction_id_for_user = final_llm_camelcase_json_for_reply.get("llmInteractionId")

            elif not final_llm_camelcase_json_for_reply : 
                 self.logger.error(f"[Orchestrator - ReqID:{self.current_request_id}] 流程结束时,final_llm_camelcase_json_for_reply为空,表明处理失败。")

            user_facing_thought_process_final_summary = "综合思考过程已在之前的日志中发送。" 
            if final_llm_camelcase_json_for_reply and final_llm_camelcase_json_for_reply.get("status") == "success":
                user_facing_thought_process_final_summary = final_llm_camelcase_json_for_reply.get("thoughtProcess", user_facing_thought_process_final_summary)
                resp_user_obj_final = final_llm_camelcase_json_for_reply.get("decision", {}).get("responseToUser", {})
                final_reply_for_user = resp_user_obj_final.get("content", final_reply_for_user) 
            
            await status_callback({ "type": "general_status", "request_id": self.current_request_id, "stage": "finalization", "status": "completed" if (final_llm_camelcase_json_for_reply and final_llm_camelcase_json_for_reply.get("status") == "success") else "failed", "message": "请求处理流程已结束。" })
            await status_callback({ "type": "final_response", "request_id": self.current_request_id, "llm_interaction_id": final_llm_interaction_id_for_user, "content": final_reply_for_user.strip() if final_reply_for_user else "抱歉,未能生成有效回复。", "final_camelcase_json_if_success": final_llm_camelcase_json_for_reply })
            
            if not (final_llm_camelcase_json_for_reply and final_llm_camelcase_json_for_reply.get("status") == "success"):
                final_assistant_synthetic_error_message_camelcase_json = { "requestId": self.current_request_id, "llmInteractionId": final_llm_interaction_id_for_user or f"agent_synth_final_err_{str(uuid4())[:6]}", "timestampUtc": datetime.now(timezone.utc).isoformat(), "status": "failure", "errorDetails": {"errorType": "AGENT_PROCESSING_FAILURE", "errorCode": "OVERALL_REQUEST_HANDLING_FAILED", "messageToUser": final_reply_for_user, "technicalMessage": "Agent failed to complete user request.", "isDirectLlmFailure": False }, "executionPhase": "final_error_synthesis", "thoughtProcess": user_facing_thought_process_final_summary or "Agent最终处理失败。", "decision": {"isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content": final_reply_for_user}}}
                try: self.memory_manager.add_to_short_term({"role": "assistant", "content": json.dumps(final_assistant_synthetic_error_message_camelcase_json, ensure_ascii=False)})
                except Exception as e_mem_add_synth_err: self.logger.error(f"添加Agent合成的最终错误到记忆失败: {e_mem_add_synth_err}")
        # --- END OF ORCHESTRATION LOGIC ---
        except Exception as e_process_top_level: 
            request_id_for_fatal = self.current_request_id or f"fatal_err_no_req_id_{str(uuid4())[:6]}"
            self.logger.critical(f"[Orchestrator - ReqID:{request_id_for_fatal}] 处理用户请求时发生顶层未捕获异常: {e_process_top_level}", exc_info=True)
            error_msg_for_user_fatal = self.config_loader.get_config("agent_settings.general.default_user_facing_error_message", "抱歉,处理您的请求时发生严重内部系统错误。")
            tb_str_for_thinking_log_fatal = traceback.format_exc().replace('\n', ' | ') 
            thinking_log_content_fatal = f"请求处理流程中发生顶层致命错误: {e_process_top_level}。Traceback: {tb_str_for_thinking_log_fatal[:1000]}..."
            fatal_llm_interaction_id = f"fatal_agent_err_{str(uuid4())[:6]}" 
            try:
                await status_callback({"type": "thinking_log", "request_id": request_id_for_fatal, "llm_interaction_id": fatal_llm_interaction_id, "stage": "fatal_error_capture", "content": thinking_log_content_fatal})
                await status_callback({"type": "general_status", "request_id": request_id_for_fatal, "stage": "fatal_error_handler", "status": "error", "message": f"请求处理失败,发生致命错误: {str(e_process_top_level)[:1000]}", "details": {"error_type": type(e_process_top_level).__name__}})
                await status_callback({"type": "final_response", "request_id": request_id_for_fatal, "llm_interaction_id": fatal_llm_interaction_id, "content": error_msg_for_user_fatal, "final_camelcase_json_if_success": None})
            except Exception as e_cb_fatal: self.logger.error(f"发送顶层致命错误的回调失败: {e_cb_fatal}", exc_info=True)
        finally:
            request_end_time = time.monotonic()
            duration_total = request_end_time - request_start_time
            self.logger.info(f"\n{'='*25} CircuitAgent 请求处理完毕 (ReqID: {self.current_request_id or 'N/A'}, 模型: {self.current_llm_identifier}, 总耗时: {duration_total:.3f} 秒) {'='*25}\n")
            self.current_request_id = None 
            self.current_llm_identifier = self.default_llm_identifier
            self.current_enable_chinese_thinking = self.default_enable_chinese_thinking

--- END: circuitmanus/agent.py ---

--- START: circuitmanus/__init__.py ---
# IDT_AGENT_Pro/circuitmanus/__init__.py
"""
CircuitManus Agent Core Package.
This package contains all the core logic for the CircuitManus agent,
including domain models, memory management, LLM interaction, tools, and orchestration.
"""
import logging

# 可以在这里预先导入一些最顶层的类，方便外部直接从 circuitmanus 包导入
# 例如: from .agent import CircuitAgent
# 但为了保持模块间的解耦，也可以不在顶层 __init__ 中暴露过多内部实现

logger = logging.getLogger(__name__)
logger.info("CircuitManus core package initialized.")

# 版本信息可以放在这里
__version__ = "1.0.0_refactored"
--- END: circuitmanus/__init__.py ---

--- START: circuitmanus/circuit_domain/circuit.py ---
# IDT_AGENT_NATIVE/circuitmanus/circuit_domain/circuit.py
import re
import logging
from typing import Dict, Set, Tuple, Optional, Any, List

# 从同一个子包 (circuit_domain) 中的 components.py 文件导入 CircuitComponent 类
# 这是正确的相对导入方式，确保模块间的依赖清晰。
from .components import CircuitComponent

logger = logging.getLogger(__name__)

class Circuit:
    """
    代表一个电路板，包含多个元件及其之间的连接。

    Attributes:
        components (Dict[str, CircuitComponent]): 一个字典，存储电路中的所有元件。
                                                  键是元件的ID (大写)，值是 CircuitComponent 对象。
        connections (Set[Tuple[str, str]]): 一个集合，存储元件之间的连接。
                                             每个连接是一个包含两个已排序元件ID的元组，
                                             以确保 (ID1, ID2) 和 (ID2, ID1) 被视为同一连接。
        _component_counters (Dict[str, int]): 一个内部字典，用于为不同类型的元件生成唯一的ID后缀。
                                              键是元件类型的前缀代码 (例如 "R", "C")，值是当前的计数。
    """
    def __init__(self):
        """初始化一个空的电路。"""
        logger.info("[Circuit] 初始化电路实体...")
        self.components: Dict[str, CircuitComponent] = {}
        self.connections: Set[Tuple[str, str]] = set()
        # 预定义一些常见的元件类型前缀及其计数器
        # 这些前缀用于自动生成元件ID，例如 R1, R2, C1, L1 等。
        self._component_counters: Dict[str, int] = {
            'R': 0, 'L': 0, 'B': 0, 'S': 0, 'C': 0, 'V': 0, 'G': 0, 'U': 0, 'O': 0,
            'I': 0, 'A': 0, 'D': 0, 'P': 0, 'F': 0, 'H': 0,
            'T': 0, 'N': 0, 'IN': 0, 'OUT': 0,
            'SRCH': 0  # 用于搜索记录这类特殊 "元件"
        }
        logger.info("[Circuit] 电路实体初始化完成。")

    def add_component(self, component: CircuitComponent) -> None:
        """
        向电路中添加一个新元件。

        Args:
            component (CircuitComponent): 要添加的元件对象。

        Raises:
            TypeError: 如果要添加的对象不是 CircuitComponent 的实例。
            ValueError: 如果具有相同ID的元件已存在于电路中。
        """
        if not isinstance(component, CircuitComponent):
            logger.error(f"尝试添加非 CircuitComponent 对象到电路: {type(component)}")
            raise TypeError("要添加的对象必须是 CircuitComponent 的实例。")
            
        if component.id in self.components:
            logger.warning(f"[Circuit] 尝试添加已存在的元件 ID '{component.id}'。")
            raise ValueError(f"元件 ID '{component.id}' 已被占用。")
        
        self.components[component.id] = component
        logger.debug(f"[Circuit] 元件 '{component.id}' ({component.type}) 已添加到电路。")

    def remove_component(self, component_id: str) -> Tuple[Dict[str, Any], int]:
        """
        从电路中移除一个元件及其所有相关的连接。

        Args:
            component_id (str): 要移除的元件的ID (不区分大小写，内部会转为大写)。

        Returns:
            Tuple[Dict[str, Any], int]: 一个元组，包含：
                - 被移除元件的详细信息 (字典格式，通过 component.to_dict() 获得)。
                - 被移除的连接数量。

        Raises:
            ValueError: 如果指定的元件ID在电路中不存在。
        """
        comp_id_upper = component_id.strip().upper()
        if comp_id_upper not in self.components:
            logger.warning(f"[Circuit] 尝试移除不存在的元件 ID '{comp_id_upper}'。")
            raise ValueError(f"元件 '{comp_id_upper}' 在电路中不存在。")
        
        # 获取待移除元件的字典表示，以便返回
        removed_component_details = self.components[comp_id_upper].to_dict()
        del self.components[comp_id_upper] # 从字典中删除元件
        
        # 查找并移除所有与该元件相关的连接
        connections_to_remove = set() # 使用集合避免重复记录要移除的连接
        for conn in self.connections:
            if comp_id_upper in conn: # 检查元件ID是否在连接元组中
                connections_to_remove.add(conn)
        
        removed_connections_count = len(connections_to_remove)
        for conn_to_remove in connections_to_remove: # 遍历要移除的连接集合
            if conn_to_remove in self.connections: # 再次确认连接存在（理论上应该存在）
                self.connections.remove(conn_to_remove)
                logger.debug(f"[Circuit] 移除了涉及元件 '{comp_id_upper}' 的连接 {conn_to_remove}。")
            else: # 防御性代码，理论上不应执行
                logger.warning(f"[Circuit] 尝试移除连接 {conn_to_remove} 时发现其已不存在。")

        logger.debug(f"[Circuit] 元件 '{comp_id_upper}' 及其相关 {removed_connections_count} 个连接已从电路中移除。")
        return removed_component_details, removed_connections_count

    def connect_components(self, id1: str, id2: str) -> bool:
        """
        连接电路中的两个元件。

        Args:
            id1 (str): 第一个元件的ID (不区分大小写)。
            id2 (str): 第二个元件的ID (不区分大小写)。

        Returns:
            bool: 如果成功创建了新的连接则返回 True，如果连接已存在则返回 False。

        Raises:
            ValueError: 如果任一元件ID不存在，或者尝试将元件连接到自身。
        """
        id1_upper = id1.strip().upper()
        id2_upper = id2.strip().upper()

        if id1_upper == id2_upper:
            logger.warning(f"[Circuit] 尝试将元件 '{id1_upper}' 连接到自身。")
            raise ValueError(f"不能将元件 '{id1_upper}' 连接到它自己。")
        if id1_upper not in self.components:
            logger.warning(f"[Circuit] 尝试连接时，元件 '{id1_upper}' 不存在。")
            raise ValueError(f"元件 '{id1_upper}' 在电路中不存在。")
        if id2_upper not in self.components:
            logger.warning(f"[Circuit] 尝试连接时，元件 '{id2_upper}' 不存在。")
            raise ValueError(f"元件 '{id2_upper}' 在电路中不存在。")
        
        # 使用排序后的元组作为连接的唯一标识，确保 (id1, id2) 和 (id2, id1) 等价
        connection = tuple(sorted((id1_upper, id2_upper)))
        if connection in self.connections:
             logger.info(f"[Circuit] 连接 '{id1_upper}' <--> '{id2_upper}' 已存在，无需重复添加。")
             return False  # 连接已存在
        
        self.connections.add(connection)
        logger.debug(f"[Circuit] 添加了连接: {id1_upper} <--> {id2_upper}。")
        return True # 成功添加新连接

    def disconnect_components(self, id1: str, id2: str) -> bool:
        """
        断开电路中两个元件之间的连接。

        Args:
            id1 (str): 第一个元件的ID (不区分大小写)。
            id2 (str): 第二个元件的ID (不区分大小写)。

        Returns:
            bool: 如果成功断开了连接则返回 True，如果连接原本就不存在则返回 False。
        """
        id1_upper = id1.strip().upper()
        id2_upper = id2.strip().upper()

        # 注意：此方法不显式检查元件 id1_upper 和 id2_upper 是否存在于 self.components 中。
        # 它的主要职责是处理 self.connections 集合。
        # 如果需要，调用者（例如工具函数）应该在调用此方法前验证元件的存在性。

        connection = tuple(sorted((id1_upper, id2_upper)))
        if connection not in self.connections:
             logger.info(f"[Circuit] 连接 '{id1_upper}' <--> '{id2_upper}' 不存在,无需断开。")
             return False # 连接不存在
        
        self.connections.remove(connection)
        logger.debug(f"[Circuit] 断开了连接: {id1_upper} <--> {id2_upper}。")
        return True # 成功断开连接

    def get_state_description(self) -> str:
        """
        生成当前电路状态的文本描述。

        Returns:
            str: 多行字符串，描述电路中的所有元件和连接。
                 如果电路为空，则返回特定消息。
        """
        logger.debug("[Circuit] 正在生成电路状态描述...")
        num_components = len(self.components)
        num_connections = len(self.connections)

        if num_components == 0 and num_connections == 0:
            return "【当前电路状态】: 电路为空。"

        desc_lines = ["【当前电路状态】:"]
        desc_lines.append(f"  - 元件 ({num_components}):")
        if self.components:
            # 按ID排序元件，确保输出顺序稳定
            sorted_ids = sorted(self.components.keys())
            for cid in sorted_ids:
                # 调用 CircuitComponent 实例的 __str__ 方法获取其描述
                desc_lines.append(f"    - {str(self.components[cid])}")
        else:
            desc_lines.append("    (无)")

        desc_lines.append(f"  - 连接 ({num_connections}):")
        if self.connections:
            # 按连接对排序，确保输出顺序稳定
            # (c1, c2) 元组本身就是可比较的，可以直接排序
            sorted_connections = sorted(list(self.connections)) 
            for c1, c2 in sorted_connections:
                desc_lines.append(f"    - {c1} <--> {c2}")
        else:
            desc_lines.append("    (无)")

        description = "\n".join(desc_lines)
        logger.debug("[Circuit] 电路状态描述生成完毕。")
        return description

    def generate_component_id(self, component_type: str) -> str:
        """
        为指定类型的元件生成一个唯一的ID。
        ID格式通常为 "类型前缀代码" + "数字计数"。 例如 "R1", "C5"。

        Args:
            component_type (str): 元件的类型 (例如 "电阻", "LED", "chip")。
                                  此函数会尝试将常见类型名映射到标准前缀。

        Returns:
            str: 生成的唯一元件ID。

        Raises:
            RuntimeError: 如果在多次尝试后仍未能生成唯一的ID (非常罕见)。
        """
        logger.debug(f"[Circuit] 正在为类型 '{component_type}' 生成唯一 ID...")
        
        # 元件类型关键字到其ID前缀的映射表。
        # 键是小写关键字，值是ID前缀代码。
        type_map = {
            "resistor": "R", "电阻": "R",
            "capacitor": "C", "电容": "C",
            "battery": "B", "电池": "B",
            "voltage source": "V", "voltage": "V", "电压源": "V", "电压": "V",
            "led": "L", "发光二极管": "L",
            "switch": "S", "开关": "S",
            "ground": "G", "地": "G",
            "ic": "U", "chip": "U", "芯片": "U", "集成电路": "U",
            "inductor": "I", "电感": "I",
            "current source": "A", "电流源": "A",
            "diode": "D", "二极管": "D",
            "potentiometer": "P", "电位器": "P",
            "fuse": "F", "保险丝": "F",
            "header": "H", "排针": "H",
            "terminal": "T", "端子": "T",
            "connection point": "P", # 与电位器 'P' 共享前缀，若要区分，需调整
            "node": "N", "节点": "N",
            "input": "IN", "输入": "IN",
            "output": "OUT", "输出": "OUT",
            "search_record": "SRCH", "搜索记录": "SRCH",
            "component": "O", "元件": "O",
        }

        # 确保所有在 type_map 中定义的前缀代码都在 _component_counters 中有初始计数
        for code in type_map.values():
            if code not in self._component_counters:
                 self._component_counters[code] = 0

        cleaned_type = component_type.strip().lower() # 清理并转小写以便匹配
        type_code = "O"  # 默认为通用元件前缀 "O" (Other)
        best_match_len = 0 # 用于找到最长（最具体）的关键字匹配

        # 特殊关键字优先处理或有特定逻辑
        if cleaned_type == "input": type_code = "IN"
        elif cleaned_type == "output": type_code = "OUT"
        elif cleaned_type == "ground" or cleaned_type == "地": type_code = "G"
        else:
            # 遍历映射表，查找最长匹配的关键字来确定类型代码
            for keyword, code in type_map.items():
                if keyword in cleaned_type and len(keyword) > best_match_len:
                    type_code = code
                    best_match_len = len(keyword)

        if type_code == "O" and cleaned_type not in ["component", "元件"]:
             logger.warning(f"[Circuit] 未找到类型 '{component_type}' 的特定前缀,将使用通用前缀 'O'。")

        MAX_ID_ATTEMPTS = 10000 # 防止无限循环的保护措施
        for attempt in range(MAX_ID_ATTEMPTS):
            self._component_counters[type_code] += 1 # 增加对应类型代码的计数器
            gen_id = f"{type_code}{self._component_counters[type_code]}" # 构造ID
            if gen_id not in self.components: # 检查生成的ID是否已存在
                logger.debug(f"[Circuit] 生成唯一 ID: '{gen_id}' (尝试 {attempt + 1})。")
                return gen_id
            logger.debug(f"[Circuit] ID '{gen_id}' 已存在,尝试下一个。(尝试 {attempt + 1})。")

        # 如果循环了 MAX_ID_ATTEMPTS 次仍然没有找到唯一的ID，则抛出运行时错误。
        logger.error(f"未能为类型 '{component_type}' (代码 '{type_code}') 生成唯一 ID ({MAX_ID_ATTEMPTS} 次尝试后)。")
        raise RuntimeError(f"未能为类型 '{component_type}' (代码 '{type_code}') 生成唯一 ID ({MAX_ID_ATTEMPTS} 次尝试后)。")

    def clear(self) -> None:
        """
        清空整个电路，移除所有元件和连接，并将所有元件ID计数器重置为0。
        此操作是不可逆的。
        """
        logger.info("[Circuit] 正在清空电路状态...")
        comp_count = len(self.components)
        conn_count = len(self.connections)

        self.components.clear() # 清空元件字典
        self.connections.clear() # 清空连接集合
        
        # 重置所有元件ID计数器
        for key in self._component_counters:
            self._component_counters[key] = 0
        # 或者更简洁: self._component_counters = {k: 0 for k in self._component_counters}

        logger.info(f"[Circuit] 电路状态已清空 (移除了 {comp_count} 个元件, {conn_count} 个连接,并重置了所有 ID 计数器)。")
--- END: circuitmanus/circuit_domain/circuit.py ---

--- START: circuitmanus/circuit_domain/components.py ---
# IDT_AGENT_Pro/circuitmanus/circuit_domain/components.py
from typing import Optional, Dict, Any
import logging

# 使用特定于此模块的 logger，而不是根 logger，便于追踪日志来源
logger = logging.getLogger(__name__)

class CircuitComponent:
    """
    代表电路中的一个基本元件。

    Attributes:
        id (str): 元件的唯一标识符 (通常是大写)。这是元件在电路中的主键。
        type (str): 元件的类型 (例如: "resistor", "capacitor", "led")。
        value (Optional[str]): 元件的可选值 (例如: "1kΩ", "10uF", "3V")。
                               如果元件没有特定值 (如地线、连接点)，则为 None。
    """
    # 使用 __slots__ 可以略微优化内存使用，并限制实例的属性，防止意外添加新属性。
    # 这对于频繁创建大量此类对象的场景比较有用。
    __slots__ = ['id', 'type', 'value']

    def __init__(self, component_id: str, component_type: str, value: Optional[str] = None):
        """
        初始化 CircuitComponent 实例。

        Args:
            component_id (str): 元件的ID。会被转换为大写并去除首尾空格。
                                 此ID在电路中应该是唯一的。
            component_type (str): 元件的类型。会被去除首尾空格。
            value (Optional[str]): 元件的值。如果提供，会被转换为字符串并去除首尾空格。
                                    如果传入 None 或空白字符串，最终 self.value 会是 None。

        Raises:
            ValueError: 如果 component_id 或 component_type 为空或无效。
        """
        if not isinstance(component_id, str) or not component_id.strip():
            # 元件ID是核心标识，必须有效
            logger.error(f"尝试创建元件时，ID无效: '{component_id}'")
            raise ValueError("元件 ID 必须是有效的非空字符串。")
        if not isinstance(component_type, str) or not component_type.strip():
            # 元件类型也是基本信息，不能为空
            logger.error(f"尝试创建元件 (ID: {component_id}) 时，类型无效: '{component_type}'")
            raise ValueError("元件类型必须是有效的非空字符串。")

        self.id: str = component_id.strip().upper()
        self.type: str = component_type.strip()
        
        # 处理元件值：确保空字符串或仅包含空格的字符串也被视作 None
        processed_value = str(value).strip() if value is not None and str(value).strip() else None
        self.value: Optional[str] = processed_value
        
        # logger.debug(f"CircuitComponent initialized: ID='{self.id}', Type='{self.type}', Value='{self.value}'")

    def __str__(self) -> str:
        """
        返回元件的字符串表示形式，方便阅读。
        例如: "元件: Resistor (ID: R1) (值: 1kΩ)" 或 "元件: LED (ID: LED1)"
        """
        value_str = f" (值: {self.value})" if self.value else ""
        return f"元件: {self.type} (ID: {self.id}){value_str}"

    def __repr__(self) -> str:
        """
        返回元件的官方字符串表示形式，通常用于调试。
        它应该能够被用来重新创建对象 (虽然这里没有完全做到，因为 value 可能为 None)。
        例如: "CircuitComponent(id='R1', type='Resistor', value='1kΩ')"
        """
        return f"CircuitComponent(id='{self.id}', type='{self.type}', value={repr(self.value)})"

    def to_dict(self) -> Dict[str, Any]:
        """
        将元件对象转换为字典格式，方便序列化 (例如转换为JSON)。

        Returns:
            Dict[str, Any]: 包含元件 id, type, 和 value 的字典。
        """
        return {"id": self.id, "type": self.type, "value": self.value}
--- END: circuitmanus/circuit_domain/components.py ---

--- START: circuitmanus/circuit_domain/__init__.py ---
# IDT_AGENT_Pro/circuitmanus/circuit_domain/__init__.py
"""
Circuit Domain Models.
This sub-package contains classes and concepts related to the electrical circuit itself,
such as components and the circuit board representation.
"""
from .components import CircuitComponent
from .circuit import Circuit

__all__ = ["CircuitComponent", "Circuit"]
--- END: circuitmanus/circuit_domain/__init__.py ---

--- START: circuitmanus/llm/interface.py ---
# IDT_AGENT_NATIVE/circuitmanus/llm/interface.py
import time
import json
import asyncio
import logging
from typing import List, Dict, Any, Optional, Callable, Awaitable

try:
    from zhipuai import ZhipuAI, ZhipuAIError
    ZHIPUAI_SDK_AVAILABLE = True
except ImportError:
    logging.getLogger(__name__).warning("无法导入 'zhipuai' SDK。智谱AI模型功能将不可用。")
    ZHIPUAI_SDK_AVAILABLE = False
    class ZhipuAI: pass
    class ZhipuAIAPIError(Exception): pass 

try:
    from openai import OpenAI, APIError as OpenAIApiError
    OPENAI_SDK_AVAILABLE = True
except ImportError:
    logging.getLogger(__name__).warning("无法导入 'openai' SDK。DeepSeek 模型功能将不可用。")
    OPENAI_SDK_AVAILABLE = False
    class OpenAI: pass
    class OpenAIApiError(Exception): pass 

import httpx 

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ..agent import CircuitAgent 

logger = logging.getLogger(__name__)

class LLMInterface:
    def __init__(self, 
                 agent_instance: 'CircuitAgent', 
                 default_temperature: float = 0.01, 
                 default_max_tokens: int = 8190,
                 api_timeout_seconds: int = 120, 
                 enable_detailed_llm_message_logging: bool = False 
                 ):
        
        self.agent_instance: 'CircuitAgent' = agent_instance
        self.config_loader = self.agent_instance.config_loader 
        
        self.default_temperature: float = self.config_loader.get_config("agent_settings.llm.default_temperature", default_temperature)
        self.default_max_tokens: int = self.config_loader.get_config("agent_settings.llm.default_max_tokens", default_max_tokens)
        self.api_timeout_seconds: float = float(self.config_loader.get_config("agent_settings.llm.api_timeout_seconds", api_timeout_seconds))
        self.enable_detailed_llm_message_logging: bool = self.config_loader.get_config("agent_settings.feature_flags.enable_detailed_llm_message_logging", enable_detailed_llm_message_logging)

        logger.info(f"[LLMInterface V1.1.1 DynamicAvailability] 初始化LLM接口。通用设置 - 温度: {self.default_temperature}, 最大Tokens: {self.default_max_tokens}, API超时: {self.api_timeout_seconds}s。")

        # 新增：用于存储各模型客户端的可用状态
        self.model_client_availability: Dict[str, bool] = {
            "zhipu-ai": False,
            "deepseek": False
            # 将来可以扩展更多模型
        }

        # 初始化 ZhipuAI 客户端
        self.zhipu_client: Optional[ZhipuAI] = None
        if ZHIPUAI_SDK_AVAILABLE:
            zhipu_api_key = self.agent_instance.api_key 
            if zhipu_api_key:
                try:
                    self.zhipu_client = ZhipuAI(api_key=zhipu_api_key, timeout=self.api_timeout_seconds) # type: ignore
                    logger.info(f"智谱AI客户端初始化成功 (Key: ...{zhipu_api_key[-4:] if len(zhipu_api_key) > 4 else '****'})。")
                    self.model_client_availability["zhipu-ai"] = True # 标记智谱客户端可用
                except Exception as e:
                    logger.error(f"初始化智谱AI客户端失败: {e}", exc_info=True)
            else:
                logger.warning("未找到ZHIPUAI_API_KEY，智谱AI模型将不可用。")
        
        # 初始化 DeepSeek (OpenAI) 客户端
        self.deepseek_client: Optional[OpenAI] = None
        if OPENAI_SDK_AVAILABLE:
            deepseek_api_key = self.config_loader.get_env_var("DEEPSEEK_API_KEY")
            deepseek_base_url = self.config_loader.get_config("agent_settings.llm.deepseek_settings.base_url", "https://api.deepseek.com/v1")
            if deepseek_api_key:
                try:
                    self.deepseek_client = OpenAI(api_key=deepseek_api_key, base_url=deepseek_base_url, timeout=self.api_timeout_seconds) # type: ignore
                    logger.info(f"DeepSeek客户端初始化成功 (Base URL: {deepseek_base_url}, Key: ...{deepseek_api_key[-4:] if len(deepseek_api_key) > 4 else '****'})。")
                    self.model_client_availability["deepseek"] = True # 标记DeepSeek客户端可用
                except Exception as e:
                    logger.error(f"初始化DeepSeek客户端失败: {e}", exc_info=True)
            else:
                logger.warning("未找到DEEPSEEK_API_KEY，DeepSeek模型将不可用。")

        if not any(self.model_client_availability.values()): # 检查是否有任何一个客户端可用
            logger.critical("LLMInterface: 没有任何LLM客户端成功初始化！Agent将无法调用任何大模型。")

    def get_model_availability(self) -> Dict[str, bool]:
        """新增方法：返回各模型客户端的可用状态。"""
        return self.model_client_availability

    async def call_llm(self, 
                       messages: List[Dict[str, Any]], 
                       execution_phase: str, 
                       status_callback: Optional[Callable[[Dict], Awaitable[None]]] = None,
                       selected_model_identifier: Optional[str] = None 
                       ) -> Any: 
        
        model_id_to_use = selected_model_identifier or self.config_loader.get_config("agent_settings.llm.default_model_identifier", "zhipu-ai")

        current_client: Any = None
        actual_model_name_for_api: Optional[str] = None
        is_deepseek_call = False

        if model_id_to_use == "zhipu-ai":
            if self.zhipu_client: # 检查客户端是否已初始化
                current_client = self.zhipu_client
                actual_model_name_for_api = self.config_loader.get_config("agent_settings.llm.zhipuai_settings.model_name", "glm-4") 
                logger.info(f"LLM调用将使用智谱AI模型: {actual_model_name_for_api}")
            else:
                logger.error("尝试使用智谱AI模型，但客户端未初始化。请检查API Key或SDK安装。")
                raise ConnectionError("智谱AI客户端未初始化或不可用。")
        elif model_id_to_use == "deepseek":
            if self.deepseek_client: # 检查客户端是否已初始化
                current_client = self.deepseek_client
                actual_model_name_for_api = self.config_loader.get_config("agent_settings.llm.deepseek_settings.model_name", "deepseek-chat")
                is_deepseek_call = True
                logger.info(f"LLM调用将使用DeepSeek模型: {actual_model_name_for_api}")
            else:
                logger.error("尝试使用DeepSeek模型，但客户端未初始化。请检查API Key或SDK安装。")
                raise ConnectionError("DeepSeek客户端未初始化或不可用。")
        else:
            logger.error(f"未知的模型标识符: '{model_id_to_use}'。无法选择LLM客户端。")
            raise ValueError(f"不支持的模型标识符: {model_id_to_use}")

        if not actual_model_name_for_api: 
            logger.error(f"未能确定用于API调用的实际模型名称 (标识符: {model_id_to_use})。")
            raise ValueError("无法确定API调用的模型名称。")

        call_args = {
            "model": actual_model_name_for_api,
            "messages": messages,
            "temperature": self.default_temperature,
            "max_tokens": self.default_max_tokens,
            "stream": False, 
        }

        logger.info(f"[LLMInterface V1.1.1] 准备异步调用 LLM ({actual_model_name_for_api}, 阶段: {execution_phase})...")
        if self.enable_detailed_llm_message_logging and logger.isEnabledFor(logging.DEBUG):
             try:
                 full_messages_json = json.dumps(messages, ensure_ascii=False, indent=2)
                 logger.debug(f"[LLMInterface V1.1.1] [DETAILED_LOG] 发送给 LLM 的完整消息列表 ({actual_model_name_for_api}):\n{full_messages_json}")
             except Exception as e_json_full:
                 logger.warning(f"[LLMInterface V1.1.1] 无法序列化完整消息列表进行详细调试日志: {e_json_full}")
        elif logger.isEnabledFor(logging.DEBUG) and messages: 
             try:
                 messages_content_for_log = []
                 for m_idx, m in enumerate(messages):
                     role = m.get("role")
                     content = str(m.get("content","")) 
                     if role == "system": content_preview = content[:5000] + ("..." if len(content) > 5000 else "")
                     else: content_preview = content[:500] + ("..." if len(content) > 500 else "") 
                     messages_content_for_log.append({ "index": m_idx, "role": role, "content_preview_length": len(content), "content_preview": content_preview })
                 messages_summary = json.dumps(messages_content_for_log, ensure_ascii=False, indent=2)
                 logger.debug(f"[LLMInterface V1.1.1] 发送给 LLM 的消息列表 (预览, {actual_model_name_for_api}):\n{messages_summary}")
             except Exception as e_json_preview:
                 logger.warning(f"[LLMInterface V1.1.1] 无法序列化消息列表预览进行调试日志: {e_json_preview}")


        request_id_to_send = getattr(self.agent_instance, 'current_request_id', None)
        
        if status_callback:
            await status_callback({ "type": "llm_communication_status", "request_id": request_id_to_send, "llm_phase": execution_phase, "status": "started", "message": f"正在与智能大脑 ({actual_model_name_for_api}) 沟通 ({execution_phase})..." })

        response_from_sdk = None
        try:
            start_time = time.monotonic()
            response_from_sdk = await asyncio.to_thread(current_client.chat.completions.create, **call_args)
            duration = time.monotonic() - start_time
            logger.info(f"[LLMInterface V1.1.1] LLM ({actual_model_name_for_api}) 异步调用成功。耗时: {duration:.3f} 秒。")
            
            if status_callback:
                await status_callback({ "type": "llm_communication_status", "request_id": request_id_to_send, "llm_phase": execution_phase, "status": "completed", "message": f"与智能大脑 ({actual_model_name_for_api}) 沟通完成 ({execution_phase})。", "details": {"duration_seconds": duration} })

            if response_from_sdk:
                if hasattr(response_from_sdk, 'usage') and response_from_sdk.usage:
                    prompt_tokens = getattr(response_from_sdk.usage, 'prompt_tokens', 'N/A')
                    completion_tokens = getattr(response_from_sdk.usage, 'completion_tokens', 'N/A')
                    total_tokens = getattr(response_from_sdk.usage, 'total_tokens', 'N/A')
                    logger.info(f"[LLMInterface V1.1.1] Token 统计 ({actual_model_name_for_api}): Prompt={prompt_tokens}, Completion={completion_tokens}, Total={total_tokens}")

                raw_llm_content = "" 
                if hasattr(response_from_sdk, 'choices') and response_from_sdk.choices and len(response_from_sdk.choices) > 0:
                    first_choice = response_from_sdk.choices[0]
                    finish_reason = getattr(first_choice, 'finish_reason', 'N/A')
                    logger.info(f"[LLMInterface V1.1.1] 完成原因 ({actual_model_name_for_api}): {finish_reason}")
                    if finish_reason == 'length': 
                        logger.warning(f"[LLMInterface V1.1.1] LLM ({actual_model_name_for_api}) 响应因达到最大 token 限制而被截断！")
                    
                    if hasattr(first_choice, 'message') and first_choice.message:
                        raw_llm_content = getattr(first_choice.message, 'content', "") or ""
                    else:
                        logger.warning(f"[LLMInterface V1.1.1] LLM ({actual_model_name_for_api}) 响应的choices[0]中缺少message对象。")
                else: 
                    logger.warning(f"[LLMInterface V1.1.1] LLM ({actual_model_name_for_api}) 响应中缺少 'choices' 字段或choices为空。")

                if self.enable_detailed_llm_message_logging and logger.isEnabledFor(logging.DEBUG): 
                    logger.debug(f"[LLMInterface V1.1.1] [DETAILED_LOG] LLM ({actual_model_name_for_api}) 原始响应内容 (完整):\n{raw_llm_content}")
                elif logger.isEnabledFor(logging.DEBUG): 
                    logger.debug(f"[LLMInterface V1.1.1] LLM ({actual_model_name_for_api}) 原始响应内容 (预览):\n{raw_llm_content[:1000]}{'...' if len(raw_llm_content) > 1000 else ''}")
            else:
                 logger.error(f"[LLMInterface V1.1.1] LLM ({actual_model_name_for_api}) API 调用返回了 None！")
                 raise ConnectionError(f"LLM API ({actual_model_name_for_api}) 调用返回 None。")
            
            return response_from_sdk 
        
        except Exception as e:
            error_type_name = type(e).__name__
            error_message_str = str(e)
            error_details_for_cb = {"error": error_message_str, "error_type": error_type_name}
            
            if is_deepseek_call and OPENAI_SDK_AVAILABLE and isinstance(e, OpenAIApiError):
                status_code = getattr(e, 'status_code', 'N/A_SDK_STATUS_CODE')
                sdk_error_code = getattr(e, 'code', 'N/A_SDK_ERROR_CODE') 
                sdk_error_type = getattr(e, 'type', 'N/A_SDK_ERROR_TYPE') 
                logger.error(f"[LLMInterface V1.1.1] DeepSeek API ({actual_model_name_for_api}) 调用失败: "
                             f"HTTP Status={status_code}, SDK Error Type='{sdk_error_type}', SDK Code='{sdk_error_code}', Message='{error_message_str}'", 
                             exc_info=False) 
                error_details_for_cb.update({"sdk_error_code": sdk_error_code, "sdk_error_type": sdk_error_type, "http_status": status_code})
                if sdk_error_type in ['api_connection_error', 'internal_error', 'rate_limit_error']: 
                    raise ConnectionError(f"DeepSeek API Error ({sdk_error_type} - {sdk_error_code}): {error_message_str}") from e
                else: 
                    raise 
            elif not is_deepseek_call and ZHIPUAI_SDK_AVAILABLE and isinstance(e, ZhipuAIAPIError):
                error_code_val = getattr(e, 'code', 'UNKNOWN_ZHIPU_SDK_ERROR_CODE')
                logger.error(f"[LLMInterface V1.1.1] ZhipuAI API ({actual_model_name_for_api}) 调用失败: "
                             f"Code={error_code_val}, Message='{error_message_str}'", 
                             exc_info=False)
                error_details_for_cb.update({"sdk_error_code_zhipu": error_code_val})
                raise ConnectionError(f"ZhipuAI API Error (Code: {error_code_val}): {error_message_str}") from e
            elif isinstance(e, httpx.TimeoutException): 
                logger.error(f"[LLMInterface V1.1.1] LLM API ({actual_model_name_for_api}) 调用超时 (配置超时: {self.api_timeout_seconds}s): {error_message_str}", exc_info=True)
                raise ConnectionError(f"LLM API ({actual_model_name_for_api}) 调用在 {self.api_timeout_seconds}s 后超时。") from e
            elif isinstance(e, ConnectionError): 
                logger.error(f"[LLMInterface V1.1.1] LLM API ({actual_model_name_for_api}) 发生连接错误: {error_message_str}", exc_info=True)
                raise
            else: 
                logger.error(f"[LLMInterface V1.1.1] LLM API ({actual_model_name_for_api}) 异步调用发生未知失败: {error_message_str}", exc_info=True)
                raise RuntimeError(f"LLM调用 ({actual_model_name_for_api}) 期间发生未知错误: {error_message_str}") from e
            
            # 此处 status_callback 的调用实际上在 raise 之后不会执行，正确的做法是在每个 raise 之前调用
            # 但为了保持逻辑结构，如果需要，可以在每个raise之前添加status_callback调用
            # if status_callback:
            #      await status_callback({ ... })

--- END: circuitmanus/llm/interface.py ---

--- START: circuitmanus/llm/parser.py ---
# IDT_AGENT_Pro/circuitmanus/llm/parser.py
import re
import json
import logging
from uuid import uuid4
from typing import Tuple, Optional, Dict, Any, List

logger = logging.getLogger(__name__)

class OutputParser:
    """
    OutputParser - V1.0.0
    负责解析来自LLM的响应 (通常是包含 <think> 块和后续 JSON 对象的字符串)，
    将其转换为结构化的 Python 字典，并进行初步的模式验证。
    此版本特别适配 ManusLLMResponse-V1.0.0 CamelCase JSON 结构。
    """
    def __init__(self, agent_tools_registry: Optional[Dict[str, Dict[str, Any]]] = None):
        """
        初始化 OutputParser。

        Args:
            agent_tools_registry (Optional[Dict[str, Dict[str, Any]]]):
                Agent 的工具注册表。用于在解析工具调用请求时，验证工具名称和参数的有效性。
                键是工具的Python函数名，值是工具的Schema字典。
        """
        logger.info("[OutputParser] 初始化输出解析器 (适配 ManusLLMResponse-V1.0.0 CamelCase JSON结构,提取 <think> 标签,增强布尔解析)。")
        self.agent_tools_registry = agent_tools_registry if agent_tools_registry else {}
        if not self.agent_tools_registry:
            logger.warning("[OutputParser] 初始化时未提供工具注册表。工具参数校验功能将受限。")

    def _validate_tool_arguments(self, tool_name: str, tool_arguments: Dict[str, Any], tool_call_id: str) -> List[Dict[str, str]]:
        """
        内部辅助方法：根据工具注册表验证LLM生成的工具参数。

        Args:
            tool_name (str): LLM请求调用的工具名称。
            tool_arguments (Dict[str, Any]): LLM为该工具提供的参数字典。
            tool_call_id (str): 当前工具调用的ID，用于错误报告。

        Returns:
            List[Dict[str, str]]: 验证失败点的列表。每个失败点是一个字典，
                                   包含 "jsonPath" 和 "issue_description"。
                                   如果验证通过，则返回空列表。
        """
        validation_errors: List[Dict[str, str]] = []
        
        # 检查工具是否存在于注册表中
        if not self.agent_tools_registry or tool_name not in self.agent_tools_registry:
            validation_errors.append({
                "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolName",
                "issue_description": f"工具 '{tool_name}' 未在 Agent 的注册表中找到。"
            })
            # 如果工具名无效，后续参数校验意义不大，直接返回
            return validation_errors

        tool_schema = self.agent_tools_registry[tool_name]
        param_schema_props = tool_schema.get("parameters", {}).get("properties", {})
        required_params = tool_schema.get("parameters", {}).get("required", [])

        # 检查必需参数是否缺失
        for req_param in required_params:
            if req_param not in tool_arguments:
                validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{req_param}",
                    "issue_description": f"工具 '{tool_name}' 的必需参数 '{req_param}' 缺失。"
                })

        # 检查提供的参数是否符合Schema定义 (名称、类型)
        for arg_name, arg_value in tool_arguments.items():
            if arg_name not in param_schema_props:
                # LLM可能生成了Schema中未定义的参数
                validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                    "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 是未在 Schema 中定义的未知参数。"
                })
                continue # 跳过对此未知参数的类型检查

            expected_type_str = param_schema_props[arg_name].get("type")
            
            # 处理可选参数且值为 None 的情况：通常允许 null 值用于可选参数
            is_optional_and_null_like = (arg_name not in required_params) and (arg_value is None)

            # 类型校验逻辑 (与原版保持一致)
            if expected_type_str == "string":
                if not isinstance(arg_value, str) and not is_optional_and_null_like:
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是字符串,但得到的是 {type(arg_value).__name__} (值: '{str(arg_value)[:50]}...')."
                    })
            elif expected_type_str == "integer":
                 if not isinstance(arg_value, int) and not is_optional_and_null_like: 
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是整数,但得到的是 {type(arg_value).__name__} (值: '{str(arg_value)[:50]}...')."
                    })
            elif expected_type_str == "number": # number 可以是 int 或 float
                 if not isinstance(arg_value, (int, float)) and not is_optional_and_null_like:
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是数字 (整数或浮点数),但得到的是 {type(arg_value).__name__} (值: '{str(arg_value)[:50]}...')."
                    })
            elif expected_type_str == "boolean":
                 if not isinstance(arg_value, bool): # 布尔值通常不接受 null 作为有效值，除非 schema 明确定义
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是布尔值 (true/false),但得到的是 {type(arg_value).__name__} (值: '{str(arg_value)[:50]}...')."
                    })
            elif expected_type_str == "object":
                 if not isinstance(arg_value, dict) and not is_optional_and_null_like:
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是对象(字典),但得到的是 {type(arg_value).__name__}."
                    })
            elif expected_type_str == "array":
                 if not isinstance(arg_value, list) and not is_optional_and_null_like:
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是数组(列表),但得到的是 {type(arg_value).__name__}."
                    })
            # 可以根据需要添加对其他类型 (如 null, enum) 的校验
        return validation_errors


    def parse_llm_response_to_structured_json(self, 
                                              llm_api_response_message: Any, # 来自 ZhipuAI SDK 的 Message 对象
                                              execution_phase: str
                                              ) -> Tuple[Optional[Dict[str, Any]], str, List[Dict[str,str]]]:
        """
        解析LLM API的响应消息，提取 <think> 块和后续的 JSON 对象。
        同时对提取的JSON对象进行V1.0.0-CamelCase规范的结构和基本内容校验。

        Args:
            llm_api_response_message (Any): LLM API返回的原始消息对象 
                                           (期望是 ZhipuAI SDK 的 `Message` 类型，至少包含 `content` 属性)。
            execution_phase (str): 当前的执行阶段 ("planning" 或 "response_generation")，
                                   用于校验LLM响应中的 `executionPhase` 字段。

        Returns:
            Tuple[Optional[Dict[str, Any]], str, List[Dict[str,str]]]:
            - 第一个元素: 如果解析和初步校验成功，则为解析后的JSON对象 (Python字典)；否则为 None。
                         此字典中的 `thoughtProcess` 字段会被优先替换为从 `<think>` 块提取的内容。
            - 第二个元素: 如果发生错误，则为错误消息字符串；否则为空字符串。
            - 第三个元素: 包含详细校验失败点的列表 (如果校验失败)；否则为空列表。
        """
        # 为每次解析生成一个唯一的ID，方便在日志中追踪特定解析过程
        parser_id = f"parse_{str(uuid4())[:8]}"
        logger.debug(f"[{parser_id}-OutputParser] 开始解析 LLM 响应 (阶段: {execution_phase})...")
        
        parsed_json_dict: Optional[Dict[str, Any]] = None
        error_message: str = ""
        failed_validation_points_list: List[Dict[str, str]] = [] # 存储结构或内容校验失败的点
        extracted_thought_process: Optional[str] = None

        # 1. 检查输入是否有效
        if llm_api_response_message is None or not hasattr(llm_api_response_message, 'content'):
            error_message = "LLM 响应对象 (Message) 为 None 或缺少 'content' 属性。"
            logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message}")
            return None, error_message, [{"jsonPath": "root.messageObject", "issue_description": error_message}]

        raw_content = getattr(llm_api_response_message, 'content', None)
        if not isinstance(raw_content, str) or not raw_content.strip(): # 确保是字符串且非空
            error_message = "LLM 响应内容 (content 字段) 为空、非字符串或仅包含空白字符。"
            logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message} (类型: {type(raw_content)})")
            return None, error_message, [{"jsonPath": "messageObject.content", "issue_description": error_message}]

        logger.debug(f"[{parser_id}-OutputParser] 接收到的原始 LLM content (完整):\n{raw_content}")

        # 2. 提取 <think>...</think> 块 (如果存在)
        content_to_parse_for_json = raw_content # 默认情况下，整个内容用于JSON解析
        # 使用 re.DOTALL 使 '.' 匹配换行符，re.IGNORECASE 忽略大小写
        think_match = re.search(r"<think>(.*?)</think>", raw_content, re.DOTALL | re.IGNORECASE)

        if think_match:
            extracted_thought_process = think_match.group(1).strip()
            # JSON内容被认为是 <think> 块之后的部分
            content_to_parse_for_json = raw_content[think_match.end():].strip() 
            logger.info(f"[{parser_id}-OutputParser] 成功提取到 <think>...</think> 内容。")
            logger.debug(f"[{parser_id}-OutputParser] 提取的思考过程 (预览):\n{extracted_thought_process[:1000]}...")
            logger.debug(f"[{parser_id}-OutputParser] 剩余内容待解析为JSON (预览):\n{content_to_parse_for_json[:1000]}...")
            if not content_to_parse_for_json: # 如果 <think> 块后没有任何内容
                 error_message = "LLM 响应包含 <think> 块但之后没有内容可解析为 JSON。"
                 logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message}")
                 return None, error_message, [{"jsonPath": "root_after_think_block", "issue_description": error_message}]
        else:
            logger.warning(f"[{parser_id}-OutputParser] 未在LLM响应中找到有效的 <think>...</think> 块。将尝试按旧方式解析整个内容为JSON。")

        # 3. 预处理 JSON 字符串 (移除 Markdown 代码块标记等)
        json_string_to_parse = content_to_parse_for_json.strip()
        
        # 尝试从 Markdown JSON 代码块中提取 (```json ... ```)
        # re.DOTALL 使得 '.' 可以匹配换行符，这对于跨越多行的JSON块很重要
        match_md_json = re.search(r"```json\s*(.*?)\s*```", json_string_to_parse, re.DOTALL | re.IGNORECASE)
        if match_md_json:
            json_string_to_parse = match_md_json.group(1).strip()
            logger.debug(f"[{parser_id}-OutputParser] 从 Markdown 代码块中提取到 JSON 字符串。")
        else:
            # 如果没有 Markdown 代码块，检查 JSON 是否被前缀文本污染
            first_brace = json_string_to_parse.find('{')
            # 确保找到的 '{' 确实是 JSON 对象的开始，而不是某个字符串值内部的 '{'
            # 简单的启发式：如果 '{' 前面有大量非空白文本，可能需要剥离
            if first_brace > 0 : # 如果 '{' 不是第一个字符
                # 检查 '{' 之前的文本是否真的是 "垃圾" 前缀
                # 一个更稳健的方法可能是尝试从第一个 '{' 开始解析，如果失败，再尝试其他策略
                # 但这里我们先采用原版的简单逻辑：如果前面有东西，就警告并尝试从 '{' 开始
                prefix_content = json_string_to_parse[:first_brace].strip()
                if prefix_content: # 只有当确有非空白前缀时才警告
                    logger.warning(f"[{parser_id}-OutputParser] 在预期的 JSON 开头 '{{' 之前检测到非空白内容: '{prefix_content[:1000]}...'。将尝试从 '{{' 开始解析。")
                json_string_to_parse = json_string_to_parse[first_brace:]
            elif first_brace == -1 : # 如果连 '{' 都找不到
                error_message = "无法在 LLM 响应内容 (post-<think>或完整) 中找到 JSON 对象的起始 '{'。"
                logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message} 原始响应预览 (post-<think>或完整): {json_string_to_parse[:1000]}...")
                return None, error_message, [{"jsonPath": "content_for_json_parsing", "issue_description": error_message}]
        
        # (可选) 进一步清理：移除可能存在的尾随非JSON字符，例如LLM有时会在JSON后添加额外的注释或句子
        # 但这需要更复杂的逻辑，例如找到匹配的最后一个 '}'，并确保其后的内容确实是多余的。
        # 为保持与原版一致，此处暂不添加此复杂清理。

        logger.debug(f"[{parser_id}-OutputParser] 预处理后,准备解析的 JSON 字符串 (完整):\n{json_string_to_parse}")

        # 4. 解析 JSON 字符串
        try:
            parsed_json_dict = json.loads(json_string_to_parse)
            logger.info(f"[{parser_id}-OutputParser] JSON 字符串成功解析为字典。")
        except json.JSONDecodeError as json_err:
            error_message = f"JSON 解析失败: {json_err}。"
            # 记录错误时，包含出错位置和部分原始字符串，有助于调试
            logger.error(f"[{parser_id}-OutputParser] {error_message} (位置: {json_err.pos}, 行: {json_err.lineno}, 列: {json_err.colno}). Raw JSON string (截断): '{json_string_to_parse[:1000]}...'")
            return None, error_message, [{"jsonPath": "root_json_parsing", "issue_description": f"JSONDecodeError: {json_err.msg} at pos {json_err.pos}"}]
        except Exception as e: # 捕获其他可能的解析时错误
            error_message = f"解析 LLM 响应时发生未知错误: {e}"
            logger.error(f"[{parser_id}-OutputParser] 解析时未知错误: {error_message}", exc_info=True)
            return None, error_message, [{"jsonPath": "root_json_parsing", "issue_description": f"Unexpected parsing error: {e}"}]

        # 5. 结构和内容校验 (针对V1.0.0-CamelCase规范)
        if not isinstance(parsed_json_dict, dict):
            error_message = "解析后的结果不是一个 JSON 对象 (字典)。"
            logger.error(f"[{parser_id}-OutputParser] 结构验证失败: {error_message} (得到类型: {type(parsed_json_dict)})")
            # 返回解析出的非字典内容，可能有助于调试LLM的输出
            return parsed_json_dict, error_message, [{"jsonPath": "root_json_parsing", "issue_description": error_message}]


        # 将提取的 <think> 块内容合并到解析后的 JSON 中
        if extracted_thought_process is not None:
            if "thoughtProcess" in parsed_json_dict and parsed_json_dict["thoughtProcess"] and \
               parsed_json_dict["thoughtProcess"].strip() != extracted_thought_process: # 检查是否与JSON内部已有的不同
                logger.warning(f"[{parser_id}-OutputParser] LLM提供了<think>块和JSON内部的thoughtProcess字段,内容不完全一致。将优先使用<think>块内容。JSON内部原文(部分): '{str(parsed_json_dict['thoughtProcess'])[:200]}...'")
            parsed_json_dict["thoughtProcess"] = extracted_thought_process
            logger.info(f"[{parser_id}-OutputParser] 已将<think>块内容置于parsed_json_dict['thoughtProcess']。")
        elif "thoughtProcess" not in parsed_json_dict or not parsed_json_dict.get("thoughtProcess", "").strip():
             # 如果没有<think>块，且JSON内部的thoughtProcess也为空或缺失
             logger.warning(f"[{parser_id}-OutputParser] LLM未提供<think>块,且JSON内部的thoughtProcess为空或缺失。思考过程可能不完整。")


        # --- 开始详细的字段校验 ---
        # 校验顶级必需字段
        required_top_level_fields = ["requestId", "llmInteractionId", "timestampUtc", "status", "executionPhase", "thoughtProcess", "decision"]
        for field in required_top_level_fields:
            if field not in parsed_json_dict:
                failed_validation_points_list.append({"jsonPath": field, "issue_description": f"缺少必需的顶级字段 '{field}'。"})

        # 校验 'status' 字段
        status_val = parsed_json_dict.get("status")
        if status_val not in ["success", "failure"]:
            failed_validation_points_list.append({"jsonPath": "status", "issue_description": f"字段 'status' 的值 '{status_val}' 无效,必须是 'success' 或 'failure'。"})

        # 校验 'executionPhase' 字段
        exec_phase_val = parsed_json_dict.get("executionPhase")
        if exec_phase_val not in ["planning", "response_generation"]:
            failed_validation_points_list.append({"jsonPath": "executionPhase", "issue_description": f"字段 'executionPhase' 的值 '{exec_phase_val}' 无效,必须是 'planning' 或 'response_generation'。"})
        elif exec_phase_val != execution_phase: # 确保LLM报告的阶段与Agent期望的阶段一致
             failed_validation_points_list.append({"jsonPath": "executionPhase", "issue_description": f"LLM报告的 'executionPhase' ('{exec_phase_val}') 与 Agent 期望的阶段 ('{execution_phase}') 不匹配。"})

        # 校验 'errorDetails' (当 status 为 'failure' 时)
        if status_val == "failure":
            error_details_obj = parsed_json_dict.get("errorDetails")
            if not isinstance(error_details_obj, dict):
                failed_validation_points_list.append({"jsonPath": "errorDetails", "issue_description": "当 'status' 为 'failure' 时, 'errorDetails' 必须是一个对象。"})
            else:
                # 检查 errorDetails 内部的必需字段
                if not isinstance(error_details_obj.get("errorType"), str) or not error_details_obj.get("errorType","").strip():
                    failed_validation_points_list.append({"jsonPath": "errorDetails.errorType", "issue_description": "'errorDetails' 对象中缺少有效的 'errorType' 字符串。"})
                if not isinstance(error_details_obj.get("errorCode"), str) or not error_details_obj.get("errorCode","").strip():
                    failed_validation_points_list.append({"jsonPath": "errorDetails.errorCode", "issue_description": "'errorDetails' 对象中缺少有效的 'errorCode' 字符串。"})
                if not isinstance(error_details_obj.get("technicalMessage"), str) or not error_details_obj.get("technicalMessage","").strip():
                    failed_validation_points_list.append({"jsonPath": "errorDetails.technicalMessage", "issue_description": "'errorDetails' 对象中缺少有效的 'technicalMessage' 字符串。"})
                # isDirectLlmFailure 字段是布尔型，必须存在
                if "isDirectLlmFailure" not in error_details_obj or not isinstance(error_details_obj.get("isDirectLlmFailure"), bool):
                    logger.warning(f"[{parser_id}-OutputParser] 'errorDetails.isDirectLlmFailure' 字段缺失或类型不为布尔。Agent将假定为False。LLM输出应包含此字段。")
                    failed_validation_points_list.append({"jsonPath": "errorDetails.isDirectLlmFailure", "issue_description": "'errorDetails' 对象中缺少有效的布尔字段 'isDirectLlmFailure'。"})
        elif status_val == "success" and parsed_json_dict.get("errorDetails") is not None: # status 为 success 时, errorDetails 应为 null
             failed_validation_points_list.append({"jsonPath": "errorDetails", "issue_description": "当 'status' 为 'success' 时, 'errorDetails' 字段必须为 null 或不存在。"})

        # 校验 'thoughtProcess' 字段 (即使优先用 <think> 块，JSON中的也应符合类型)
        if "thoughtProcess" in parsed_json_dict: # 检查字段是否存在
            if not isinstance(parsed_json_dict.get("thoughtProcess"), str):
                 # 如果存在但类型不正确 (例如 LLM 错误地给了一个对象或null以外的非字符串)
                 # 注意: 如果 <think> 块存在，它已经被强制设为字符串了。这里主要针对没有 <think> 块的情况。
                logger.warning(f"[{parser_id}-OutputParser] JSON内部的 'thoughtProcess' 字段存在但类型不正确 (应为字符串，得到 {type(parsed_json_dict.get('thoughtProcess')).__name__})。")
                failed_validation_points_list.append({"jsonPath": "thoughtProcess", "issue_description": "'thoughtProcess' 字段如果存在,必须是字符串。"})
            # 空字符串是允许的
        # 如果 thoughtProcess 字段不存在 (但它是必需的)，上面的 required_top_level_fields 检查会捕捉到。

        # 校验 'decision' 对象及其内部结构
        decision_obj = parsed_json_dict.get("decision")
        if not isinstance(decision_obj, dict):
            failed_validation_points_list.append({"jsonPath": "decision", "issue_description": "'decision' 字段必须是一个对象。"})
        else:
            # 校验 'decision.isCallTools'，并尝试转换字符串 'true'/'false' 为布尔值
            raw_is_call_tools_val = decision_obj.get("isCallTools")
            is_call_tools_val_parsed: Optional[bool] = None # 用于存储解析后的布尔值
            
            if isinstance(raw_is_call_tools_val, bool):
                is_call_tools_val_parsed = raw_is_call_tools_val
            elif isinstance(raw_is_call_tools_val, str):
                # 不区分大小写地比较
                if raw_is_call_tools_val.lower() == 'true':
                    is_call_tools_val_parsed = True
                elif raw_is_call_tools_val.lower() == 'false':
                    is_call_tools_val_parsed = False
            
            if is_call_tools_val_parsed is None: # 如果无法解析为布尔值
                failed_validation_points_list.append({"jsonPath": "decision.isCallTools", "issue_description": f"'decision.isCallTools' 值 '{raw_is_call_tools_val}' (类型: {type(raw_is_call_tools_val).__name__}) 无效。必须是布尔类型或可解析为布尔的字符串('true'/'false')。"})
            else:
                # 用解析后的布尔值覆盖原始值，方便后续处理
                decision_obj["isCallTools"] = is_call_tools_val_parsed 
                logger.debug(f"[{parser_id}-OutputParser] 'isCallTools' (原始值: {raw_is_call_tools_val}, 类型: {type(raw_is_call_tools_val).__name__}) 被解析为布尔值: {is_call_tools_val_parsed}。")

            # 校验 'decision.toolCallRequests'
            tool_call_requests = decision_obj.get("toolCallRequests")
            if is_call_tools_val_parsed is True: # 仅当计划调用工具时才深入校验
                if not isinstance(tool_call_requests, list):
                    failed_validation_points_list.append({"jsonPath": "decision.toolCallRequests", "issue_description": "当 'isCallTools' 为 True 时, 'toolCallRequests' 必须是一个列表。"})
                elif not tool_call_requests: # 列表为空但 isCallTools 为 True
                    logger.warning(f"[{parser_id}-OutputParser] 'isCallTools' 为 True 但 'toolCallRequests' 列表为空。这可能是一个规划逻辑问题，但符合 schema (空列表)。")
                    # 根据需求，这里也可以视为一个校验失败点，如果业务逻辑不允许这种情况
                elif tool_call_requests: # 列表非空，校验每一项
                    for i, tool_req_item in enumerate(tool_call_requests):
                        item_path_prefix = f"decision.toolCallRequests[{i}]"
                        if not isinstance(tool_req_item, dict):
                            failed_validation_points_list.append({"jsonPath": item_path_prefix, "issue_description": "列表中的每个工具调用请求必须是对象。"}); continue # 跳过对此项的后续校验

                        tool_call_id = tool_req_item.get("toolCallId")
                        if not isinstance(tool_call_id, str) or not tool_call_id.strip():
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.toolCallId", "issue_description": "缺少有效的 'toolCallId' 字符串。"})

                        tool_name = tool_req_item.get("toolName")
                        if not isinstance(tool_name, str) or not tool_name.strip():
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.toolName", "issue_description": "缺少有效的 'toolName' 字符串。"})

                        tool_arguments = tool_req_item.get("toolArguments")
                        if not isinstance(tool_arguments, dict):
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.toolArguments", "issue_description": "'toolArguments' 必须是一个对象。"})
                        elif tool_name and isinstance(tool_name, str) and tool_name.strip(): # 仅当工具名有效时才校验参数
                            # 使用内部方法校验工具参数 (需要 agent_tools_registry)
                            arg_validation_errors = self._validate_tool_arguments(
                                tool_name, 
                                tool_arguments, 
                                tool_call_id if (tool_call_id and isinstance(tool_call_id, str) and tool_call_id.strip()) else f"index_{i}"
                            )
                            failed_validation_points_list.extend(arg_validation_errors)
                        
                        # uiHints 是可选的，但如果存在，必须是对象
                        ui_hints = tool_req_item.get("uiHints")
                        if ui_hints is not None and not isinstance(ui_hints, dict):
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.uiHints", "issue_description": "'uiHints' 如果存在,必须是一个对象。"})

            elif is_call_tools_val_parsed is False: # 如果不调用工具
                # toolCallRequests 应该是 null 或空列表
                if tool_call_requests is not None and (not isinstance(tool_call_requests, list) or tool_call_requests): # 不是null, 也不是空列表
                    failed_validation_points_list.append({"jsonPath": "decision.toolCallRequests", "issue_description": "当 'isCallTools' 为 False 时, 'toolCallRequests' 必须是 null 或空列表 []。"})

            # 校验 'decision.responseToUser' 对象
            response_user_obj = decision_obj.get("responseToUser")
            if not isinstance(response_user_obj, dict):
                failed_validation_points_list.append({"jsonPath": "decision.responseToUser", "issue_description": "'responseToUser' 必须是一个对象。"})
            else:
                if not isinstance(response_user_obj.get("contentType"), str) or not response_user_obj.get("contentType","").strip():
                     failed_validation_points_list.append({"jsonPath": "decision.responseToUser.contentType", "issue_description": "'responseToUser' 对象缺少有效的 'contentType' 字符串。"})

                resp_content = response_user_obj.get("content") # content 可以是空字符串
                if not isinstance(resp_content, str): # 但必须是字符串类型
                     failed_validation_points_list.append({"jsonPath": "decision.responseToUser.content", "issue_description": "'responseToUser.content' 必须是字符串。"})
                
                # 特定逻辑：如果直接回复用户 (isCallTools=False)，则 content 不应为空（除非在规划阶段且有过渡消息）
                # 这个校验更偏向业务逻辑而非纯粹的schema校验，但LLM被指示这么做
                if is_call_tools_val_parsed is False and (resp_content is None or resp_content.strip() == ""):
                     # 在响应生成阶段，如果直接回复，content 必须非空
                     if execution_phase == "response_generation":
                         failed_validation_points_list.append({"jsonPath": "decision.responseToUser.content", "issue_description": "在响应生成阶段,当不调用工具时, 'responseToUser.content' 必须是有效的非空字符串。"})
                     # 在规划阶段，如果直接回复 (isCallTools=False)，content 也应该非空
                     # 但原版代码似乎对规划阶段的过渡消息 content 为空有容忍，这里保持一致，只在 response_generation 阶段强校验
                     # 若要更严格：else: failed_validation_points_list.append(...) for planning phase direct reply

                # 校验 'suggestionsForNextSteps' (可选)
                suggestions = response_user_obj.get("suggestionsForNextSteps")
                if suggestions is not None: # 如果存在
                    if not isinstance(suggestions, list):
                        failed_validation_points_list.append({"jsonPath": "decision.responseToUser.suggestionsForNextSteps", "issue_description": "'suggestionsForNextSteps' 如果存在,必须是一个列表。"})
                    else:
                        for j, sugg_item in enumerate(suggestions):
                            sugg_path_prefix = f"decision.responseToUser.suggestionsForNextSteps[{j}]"
                            if not isinstance(sugg_item, dict):
                                failed_validation_points_list.append({"jsonPath": sugg_path_prefix, "issue_description": "列表中的每个建议必须是对象。"}); continue
                            if not isinstance(sugg_item.get("textForUser"), str) or not sugg_item.get("textForUser","").strip():
                                failed_validation_points_list.append({"jsonPath": f"{sugg_path_prefix}.textForUser", "issue_description": "建议对象缺少有效的 'textForUser' 字符串。"})
                            # 可以添加对 actionType, actionPayload 等字段的进一步校验

                # 校验 'requiresUserClarificationForCurrentRequest' (可选)
                clarification_flag = response_user_obj.get("requiresUserClarificationForCurrentRequest")
                if clarification_flag is not None and not isinstance(clarification_flag, bool):
                     failed_validation_points_list.append({"jsonPath": "decision.responseToUser.requiresUserClarificationForCurrentRequest", "issue_description": "'requiresUserClarificationForCurrentRequest' 如果存在,必须是布尔类型。"})

        # 校验 'diagnostics' 对象 (可选)
        diagnostics_obj = parsed_json_dict.get("diagnostics")
        if diagnostics_obj is not None and not isinstance(diagnostics_obj, dict):
            failed_validation_points_list.append({"jsonPath": "diagnostics", "issue_description": "'diagnostics' 如果存在,必须是一个对象。"})
            # 可以添加对 diagnostics 内部字段的校验，如 llmConfidenceScoreForThisOutput 类型等

        # 6. 根据校验结果返回
        if failed_validation_points_list:
            # 构建包含所有失败点的错误消息
            error_message_parts = [f"JSON 结构或内容验证失败 (共 {len(failed_validation_points_list)} 点):"]
            for err_point in failed_validation_points_list:
                error_message_parts.append(f"  -路径 '{err_point['jsonPath']}': {err_point['issue_description']}")
            error_message = "\n".join(error_message_parts)

            # 记录详细错误和部分JSON内容
            json_content_for_log = "(无法序列化进行日志记录)"
            try:
                json_content_for_log = json.dumps(parsed_json_dict, indent=2, ensure_ascii=False)
            except Exception:
                json_content_for_log = str(parsed_json_dict)[:2000] # 尽力记录

            logger.error(f"[{parser_id}-OutputParser]\n{error_message}\n解析的 JSON 内容 (可能不完整或无效):\n{json_content_for_log}")
            # 返回解析出的字典（即使有错，可能部分有用），错误消息，和失败点列表
            return parsed_json_dict, error_message, failed_validation_points_list

        # 如果所有校验通过
        logger.info(f"[{parser_id}-OutputParser] LLM 响应 (阶段: {execution_phase}, LLM_ID: {parsed_json_dict.get('llmInteractionId', 'N/A')}) 已成功解析并验证为 ManusLLMResponse-V1.0.0兼容结构 (思考过程来源: {'<think> block' if extracted_thought_process else 'JSON field'})！")
        return parsed_json_dict, "", [] # 成功，无错误消息，无失败点
--- END: circuitmanus/llm/parser.py ---

--- START: circuitmanus/llm/__init__.py ---
# IDT_AGENT_Pro/circuitmanus/llm/__init__.py
"""
LLM Interaction and Output Parsing.
Contains modules for communicating with the Language Model and
parsing its structured responses.
"""
from .interface import LLMInterface
from .parser import OutputParser

__all__ = ["LLMInterface", "OutputParser"]
--- END: circuitmanus/llm/__init__.py ---

--- START: circuitmanus/memory/manager.py ---
# IDT_AGENT_Pro/circuitmanus/memory/manager.py
import logging
from typing import List, Dict, Any

# 从 circuit_domain 导入 Circuit 类
# 这是跨子包导入，使用相对导入 '.' 表示当前包 (circuitmanus), '..' 表示上级包
# 如果 manager.py 直接在 circuitmanus 下，可以用 from .circuit_domain.circuit import Circuit
# 如果此文件在 circuitmanus/memory/ 下，则需要 from ..circuit_domain.circuit import Circuit
from ..circuit_domain.circuit import Circuit #  memory 和 circuit_domain 都是 circuitmanus 的子包

logger = logging.getLogger(__name__)

class MemoryManager:
    """
    管理 Agent 的记忆，包括短期对话历史、长期知识和当前的电路状态。

    Attributes:
        max_short_term_items (int): 短期记忆中允许存储的最大消息条数。
        max_long_term_items (int): 长期记忆中允许存储的最大知识片段条数。
        short_term (List[Dict[str, Any]]): 存储对话历史的列表，每条消息是一个字典 (通常包含 'role' 和 'content')。
        long_term (List[str]): 存储长期知识片段的列表，每个片段是一个字符串。
        circuit (Circuit): 一个 Circuit 类的实例，代表当前 Agent 正在操作的电路。
    """
    def __init__(self, max_short_term_items: int = 30, max_long_term_items: int = 200):
        """
        初始化 MemoryManager。

        Args:
            max_short_term_items (int): 短期记忆的最大条目数。必须大于1。
            max_long_term_items (int): 长期记忆的最大条目数。

        Raises:
            ValueError: 如果 max_short_term_items 小于或等于1。
        """
        logger.info("[MemoryManager] 初始化记忆模块...")
        if not isinstance(max_short_term_items, int) or max_short_term_items <= 1:
            # 短期记忆如果太小（比如只有1条），在LLM交互中通常没有意义，
            # 因为至少需要保留一条用户消息和一条系统消息/助手消息才能形成上下文。
            logger.error(f"max_short_term_items ({max_short_term_items}) 无效，必须是大于1的整数。")
            raise ValueError("参数 'max_short_term_items' 必须大于 1。")
        if not isinstance(max_long_term_items, int) or max_long_term_items < 0:
            logger.error(f"max_long_term_items ({max_long_term_items}) 无效，必须是非负整数。")
            raise ValueError("参数 'max_long_term_items' 必须是非负整数。")


        self.max_short_term_items: int = max_short_term_items
        self.max_long_term_items: int = max_long_term_items
        self.short_term: List[Dict[str, Any]] = []
        self.long_term: List[str] = []
        
        # 每个 MemoryManager 实例都拥有并管理一个独立的 Circuit 实例。
        # 这是核心设计，Agent 的所有电路操作都通过其 MemoryManager 间接作用于这个 Circuit 对象。
        self.circuit: Circuit = Circuit()

        logger.info(f"[MemoryManager] 记忆模块初始化完成。短期记忆上限: {max_short_term_items} 条, 长期记忆上限: {max_long_term_items} 条。")

    def add_to_short_term(self, message: Dict[str, Any]) -> None:
        """
        向短期记忆中添加一条消息，并根据需要进行修剪以保持在最大限制内。
        修剪策略：移除最旧的非系统 ('system' role) 消息。

        Args:
            message (Dict[str, Any]): 要添加的消息字典，通常包含 'role' 和 'content'。
        """
        if not isinstance(message, dict) or "role" not in message or "content" not in message:
            logger.warning(f"[MemoryManager] 尝试添加格式无效的消息到短期记忆: {message}")
            return # 或者可以抛出异常，取决于严格性要求

        logger.debug(f"[MemoryManager] 添加消息到短期记忆 (Role: {message.get('role', 'N/A')})。当前数量: {len(self.short_term)}。")
        self.short_term.append(message)
        
        current_size = len(self.short_term)
        if current_size > self.max_short_term_items:
            items_to_remove_count = current_size - self.max_short_term_items
            logger.debug(f"[MemoryManager] 短期记忆超限 ({current_size}/{self.max_short_term_items}),需要移除 {items_to_remove_count} 条消息。")
            
            # 查找可以被移除的非系统消息的索引
            # 通常，我们希望保留系统提示 (role='system')，它们通常位于列表的开头或具有特殊意义。
            # 因此，修剪时优先移除旧的用户 (role='user') 或助手 (role='assistant'/'tool') 消息。
            non_system_indices = [i for i, msg in enumerate(self.short_term) if msg.get("role") != "system"]
            
            num_to_actually_remove = min(items_to_remove_count, len(non_system_indices))

            if num_to_actually_remove > 0:
                # 从最旧的非系统消息开始移除
                indices_to_remove_set = set(non_system_indices[:num_to_actually_remove])
                
                removed_roles = [self.short_term[i].get('role', 'N/A') for i in sorted(list(indices_to_remove_set))]
                
                # 构建新的短期记忆列表，排除被选中的旧消息
                new_short_term = [msg for i, msg in enumerate(self.short_term) if i not in indices_to_remove_set]
                self.short_term = new_short_term
                
                logger.info(f"[MemoryManager] 短期记忆修剪完成,移除了 {num_to_actually_remove} 条最旧的非系统消息 (角色: {removed_roles})。")
            elif items_to_remove_count > 0:
                 # 如果需要移除，但所有消息都是系统消息，或者非系统消息不够移除
                 logger.warning(f"[MemoryManager] 短期记忆超限 ({current_size}/{self.max_short_term_items}) 但未能找到足够的非系统消息进行移除 ({len(non_system_indices)}条非系统消息存在)。这可能表示系统消息过多或max_short_term_items设置过小。")
        
        logger.debug(f"[MemoryManager] 添加后短期记忆数量: {len(self.short_term)}。")

    def add_to_long_term(self, knowledge_snippet: str) -> None:
        """
        向长期记忆中添加一个知识片段，并根据需要进行修剪。
        修剪策略：移除最早添加的知识片段。

        Args:
            knowledge_snippet (str): 要添加的知识字符串。
        """
        MAX_SNIPPET_LENGTH = 10000 # 限制单个长期记忆片段的最大长度，防止过大的条目。
        if not isinstance(knowledge_snippet, str):
            logger.warning(f"[MemoryManager] 尝试添加非字符串类型的知识到长期记忆: {type(knowledge_snippet)}")
            return

        if len(knowledge_snippet) > MAX_SNIPPET_LENGTH:
            logger.warning(f"[MemoryManager] 尝试添加的长期记忆片段过长 ({len(knowledge_snippet)} 字符),已截断为 {MAX_SNIPPET_LENGTH} 字符。")
            knowledge_snippet = knowledge_snippet[:MAX_SNIPPET_LENGTH] + "... (已截断)"

        logger.debug(f"[MemoryManager] 添加知识到长期记忆 (预览: '{knowledge_snippet[:100]}{'...' if len(knowledge_snippet) > 100 else ''}'). 当前数量: {len(self.long_term)}。")
        self.long_term.append(knowledge_snippet)
        
        if len(self.long_term) > self.max_long_term_items:
            removed_snippet = self.long_term.pop(0) # 移除列表头部的最旧条目
            logger.info(f"[MemoryManager] 长期记忆超限 ({len(self.long_term)}/{self.max_long_term_items}), 移除最旧知识 (预览: '{removed_snippet[:50]}...').")
        
        logger.debug(f"[MemoryManager] 添加后长期记忆数量: {len(self.long_term)}。")

    def get_circuit_state_description(self) -> str:
        """
        获取当前电路状态的文本描述。
        这是对 self.circuit.get_state_description() 的一个便捷封装。

        Returns:
            str: 电路状态的描述字符串。
        """
        return self.circuit.get_state_description()

    def get_memory_context_for_prompt(self, recent_long_term_count: int = 7) -> str:
        """
        格式化记忆上下文，用于构建LLM的系统提示。
        包含当前电路状态描述和最近的长期记忆片段。

        Args:
            recent_long_term_count (int): 要包含在上下文中的最近长期记忆条目数量。

        Returns:
            str: 格式化后的记忆上下文字符串。
        """
        logger.debug("[MemoryManager] 正在格式化记忆上下文用于 Prompt...")
        circuit_desc = self.get_circuit_state_description()
        
        long_term_str = ""
        if self.long_term:
            # 确保请求的数量不超过实际存在的长期记忆数量
            actual_count = min(recent_long_term_count, len(self.long_term))
            if actual_count > 0:
                # 获取列表末尾的N条最新记录
                recent_items = self.long_term[-actual_count:]
                # 在提示中，通常最新的信息放在最前面，所以倒序排列
                long_term_str = "\n\n【近期经验总结 (仅显示最近 N 条,按时间倒序排列,最新在前)】\n" + "\n".join(f"- {item}" for item in reversed(recent_items))
                logger.debug(f"[MemoryManager] 已提取最近 {len(recent_items)} 条长期记忆 (倒序)。")
        
        # 未来可以加入基于相关性检索的注释，提醒LLM当前记忆检索的局限性
        long_term_str += "\n(注: 当前仅使用最近期记忆,未来版本将实现基于相关性的检索。)"
        
        context = f"{circuit_desc}{long_term_str}".strip()
        logger.debug(f"[MemoryManager] 记忆上下文 (电路+长期) 格式化完成。")
        return context
--- END: circuitmanus/memory/manager.py ---

--- START: circuitmanus/memory/__init__.py ---
# IDT_AGENT_Pro/circuitmanus/memory/__init__.py
"""
Memory Management for the Agent.
Handles short-term conversation history and long-term knowledge.
"""
from .manager import MemoryManager

__all__ = ["MemoryManager"]
--- END: circuitmanus/memory/__init__.py ---

--- START: circuitmanus/prompts/templates.py ---
# IDT_AGENT_NATIVE/circuitmanus/prompts/templates.py
import logging
from uuid import uuid4
from datetime import datetime, timezone
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

def get_tool_schemas_for_prompt(tools_registry: Dict[str, Dict[str, Any]]) -> str:
    """
    根据 Agent 的工具注册表，生成一段格式化的文本描述，供 LLM 在提示中使用。
    这段文本详细说明了每个可用工具的名称、描述和参数规范。
    (此函数无需修改，保持原样)
    """
    if not tools_registry:
        logger.warning("[PromptHelper] tools_registry 为空，将返回无可用工具的提示。")
        return "  (当前无可用工具)"
    
    tool_schemas_parts = []
    sorted_tool_names = sorted(tools_registry.keys()) 

    for tool_name in sorted_tool_names:
        schema = tools_registry[tool_name]
        desc = schema.get('description', '无描述。')
        params_schema = schema.get('parameters', {})
        props_schema = params_schema.get('properties', {})
        req_params = params_schema.get('required', [])

        param_desc_segments = []
        if props_schema:
            sorted_param_names = sorted(props_schema.keys())
            for param_name in sorted_param_names: 
                param_details_dict = props_schema[param_name]
                param_type = param_details_dict.get('type','any')
                is_required_str = "必须 (required)" if param_name in req_params else "可选 (optional)"
                param_description = param_details_dict.get('description','无参数描述')
                
                enum_values = param_details_dict.get('enum')
                enum_desc = ""
                if enum_values and isinstance(enum_values, list):
                    # 使用 repr(v) 来确保字符串值被正确引用，例如 "option1" 而不是 option1
                    enum_desc = f" 可选值: {', '.join(map(repr, enum_values))}。" 
                
                param_desc_segments.append(
                    f"    - 参数名 `{param_name}`:\n"
                    f"      - 类型: `{param_type}`\n"
                    f"      - 是否必需: {is_required_str}\n"
                    f"      - 描述: {param_description}{enum_desc}"
                )
        elif params_schema.get("type") == "object" and not props_schema :
             param_desc_segments = ["    - 此工具不接受任何参数(参数对象 `toolArguments` 应为空对象 `{}`)。"]
        else:
             param_desc_segments = ["    - (此工具的参数定义似乎不完整或无参数)"]

        tool_schemas_parts.append(
            f"  - 工具名称: `{tool_name}`\n"
            f"    工具描述: {desc}\n"
            f"  工具参数详情 (这些参数应放在 `toolArguments` 对象内部):\n"
            f"{chr(10).join(param_desc_segments)}" # 使用换行符 chr(10) 以确保格式正确
        )
    
    return "\n\n".join(tool_schemas_parts)


def get_planning_prompt(tool_schemas_desc: str,
                             memory_context: str,
                             is_replanning: bool = False,
                             request_id: Optional[str] = None,
                             # 新增参数: 是否启用中文深度思考
                             enable_deep_thinking_chinese: bool = False 
                             ) -> str:
    current_timestamp_utc = datetime.now(timezone.utc).isoformat()
    llm_interaction_id_example_plan_prefix = f"plan_ex_llm_id_{str(uuid4())[:6]}"
    example_prev_tool_call_id = f"tc_ex_prev_fail_{str(uuid4())[:6]}"

    # 根据 enable_deep_thinking_chinese 动态调整 <think> 块和 thoughtProcess JSON字段的语言提示后缀
    think_block_language_instruction = "并且【请使用中文进行思考和阐述此部分内容】" if enable_deep_thinking_chinese else ""
    json_thought_process_language_note = "（如果<think>块使用中文思考，此总结也建议使用中文）" if enable_deep_thinking_chinese else ""


    reasoning_model_instructions = (
        "\n【重要: Reasoning Model 输出规范 (V1.0.0)】\n"
        f"1.  **思考过程**: 您的详细思考过程、分析、逐步推理和决策逻辑【必须】包含在 `<think>...</think>` 标签内{think_block_language_instruction}，并放在您回复的最开始部分。\n"
        "2.  **JSON 输出**: 在 `</think>` 标签之后,您【必须】输出一个严格符合下面描述的V1.0-CamelCaseJSON格式的单个JSON对象。此JSON对象应被三个反引号和'json'标记包围 (即 ```json ... ```)。JSON中所有key【必须】使用camelCase (例如: `isCallTools`, `toolCallRequests`, `requestId`).\n"
        f"3.  **`thoughtProcess` 字段 (in JSON)**: JSON对象内部的 `thoughtProcess` 字段现在是次要的。它可以是一个简短的总结或留空 ( `\"\"` ){json_thought_process_language_note}，因为您的主要思考过程已在 `<think>...</think>` 块中。Agent将优先使用 `<think>` 块中的内容作为思考日志。\n"
    )

    replanning_guidance_think_instruction = f"请在您的 `<think>...</think>` 块中{think_block_language_instruction}：\n"
    replanning_guidance = ""
    if is_replanning:
        replanning_guidance = (
            "\n【重要: 重规划指示 (V1.0.0 - Reasoning Model)】\n"
            f"您当前正在进行重规划。这意味着您之前的规划或工具执行遇到了问题。{replanning_guidance_think_instruction}"
            "1.  **仔细分析失败原因**: 详细检查对话历史中的 `role: tool` 消息 (`content` JSON内的 `status: \"failure\"`, `message`, `errorDetails`) 和 `role: assistant` 消息中可能的Agent解析/校验错误 (`errorDetails.failedValidationPoints`)。\n"
            "2.  **参考当前电路状态**: 【务必】仔细查阅 `memory_context` 中的【当前电路状态】。您的新计划【必须】基于当前实际存在的元件和连接。不要不必要地重新添加已存在的元件。\n"
            "3.  **处理抽象节点**: 若涉及连接到 'INPUT', 'OUTPUT', 'GND' 等未作为元件存在的抽象节点失败,优先规划使用 `add_component_tool` (如 `component_type: 'Terminal'`) 创建它们,然后再连接。\n"
            "4.  **制定修正计划**: 基于以上分析,制定一个【全新的、修正了先前问题的计划】。这应在您的 `<think>...</think>` 块中清晰阐述。\n"
            "然后,在 `</think>` 之后输出符合V1.0-CamelCaseJSON规范的JSON。如果这个【新JSON本身的顶层 `status` 字段必须设置为 `'success'`】(因为您成功地为【当前这次思考和规划】输出了一个结构完整且逻辑合理的V1.0-CamelCaseJSON JSON)。\n"
            "5.  **无法解决的情况**: 如果分析后认为无法完成用户核心请求,则在 `<think>...</think>` 中解释,并在 `</think>` 后的JSON中制定一个【直接回复用户并解释情况的计划】 (`status: 'success'`, `isCallTools: False`).\n"
            "6.  **真正意义上的规划失败**: 只有当您在【当前这次重规划尝试中】,由于自身的理解困难、无法形成任何有效的 `<think>...</think>` 块或后续的V1.0-CamelCaseJSON JSON结构时,才应将后续JSON的顶层 `status` 字段设为 `'failure'`。\n"
            "**核心原则**: 不要因为*过去*的工具执行失败,就将您*当前新制定*的计划的JSON标记为 `status: 'failure'`. `status` 反映的是您【当前这次生成JSON这个行为本身】的成功与否。\n"
        )

    # JSON Schema 描述 (保持不变，此处不重复粘贴，确保与原文件一致)
    json_schema_description_for_prompt = """
```json
{
  "requestId": "string_or_null_当前用户请求周期的ID_如果系统提示中提供了此值请原样返回_否则为null",
  "llmInteractionId": "string_必须是本次LLM响应的唯一ID_例如_plan_llm_id_后跟8位随机字符_如_plan_llm_id_a1b2c3d4",
  "timestampUtc": "string_当前UTC时间戳_ISO_8601格式_例如_2024-07-16T12:00:00.000Z",
  "status": "string_必须是 'success' 或 'failure'._表示本次JSON输出是否由LLM为当前阶段成功生成。",
  "errorDetails": { 
    "errorType": "string_enum_高级错误类别_例如_PLANNING_ERROR_LLM_OUTPUT_VALIDATION_ERROR_INTERNAL_LOGIC_ERROR",
    "errorCode": "string_特定错误代码_例如_JSON_MALFORMED_MISSING_REQUIRED_FIELD_TOOL_PARAMS_INVALID",
    "messageToUser": "string_用户友好的解释_如果此错误与用户操作直接相关或适合用户查看。否则为通用Agent错误消息。",
    "technicalMessage": "string_详细的技术错误消息_用于日志记录和调试_这是LLM认为其自身输出生成过程中出现的问题。",
    "isDirectLlmFailure": "boolean_如果LLM明确表示无法完成请求或为本次尝试生成有效JSON则为True。如果错误是由于Agent端对LLM输出的JSON进行校验失败(即使JSON本身语法有效)_或LLM在格式良好的JSON中报告逻辑失败_则为False。",
    "failedValidationPoints": [ 
      {
        "jsonPath": "string_例如_decision.toolCallRequests[0].toolArguments.component_id",
        "issue_description": "string_例如_必需字段缺失_或_值必须是字符串但得到的是整数"
      }
    ]
  },
  "executionPhase": "string_对于此任务_必须是 'planning'",
  "thoughtProcess": "string_此字段现在是次要的_您的主要详细推理必须在初始的 `<think>...</think>` 块中_此JSON字段可以是简短总结或为空_Agent将优先使用 `<think>` 块内容。",
  "decision": {
    "isCallTools": "boolean_如果需要调用工具则为True_否则为False_也接受不区分大小写的字符串 'true'/'false'",
    "toolCallRequests": [ 
      {
        "toolCallId": "string_由您为本次特定工具调用生成的唯一ID_例如_tc_add_resistor_xyz123",
        "toolName": "string_要调用的工具名称_从可用工具列表中选择 (例如 add_component_tool)",
        "toolArguments": { 
        },
        "uiHints": { 
            "displayNameForTool": "string_optional_更用户友好的工具调用名称_例如_添加电阻R1",
            "estimatedDurationCategory": "string_enum_optional_short_medium_long_very_long",
            "showProgressGranularly": "boolean_optional_如果为True_UI可能会显示更细粒度的进度(如果工具支持)_默认为False"
        },
        "estimatedComplexityOrNotes": "string_optional_LLM对此调用的内部注释_依赖关系或置信度。"
      }
    ],
    "responseToUser": {
      "contentType": "string_例如_text/plain_或_application/markdown",
      "content": "string_如果isCallTools为False_这是您对用户的直接且完整的回复_它必须非空。如果isCallTools为True_这应该是一条有意义的过渡消息_反映计划的操作_例如_好的_我将添加元件X然后连接到Y_如果确实不需要过渡消息则可以为空字符串_但为了用户体验首选提供一条好的消息。",
      "suggestionsForNextSteps": [ 
        {
          "suggestionId": "string_optional_此建议的唯一ID_例如_sugg_ask_about_led_color",
          "textForUser": "string_向用户显示的建议文本_例如_您想指定LED颜色吗",
          "actionType": "string_enum_optional_USER_INPUT_EXPECTED_or_PREDEFINED_AGENT_ACTION_or_UI_NAVIGATION",
          "actionPayload": "object_or_string_optional_如果类型是PREDEFINED_AGENT_ACTION_这可能是简化的请求对象或命令字符串_供Agent在用户选择后处理"
        }
      ],
      "requiresUserClarificationForCurrentRequest": "boolean_optional_如果当前请求需要用户进一步输入才能继续_并且content正在请求该澄清_则设置为True_默认为False"
    }
  },
  "diagnostics": { 
      "llmConfidenceScoreForThisOutput": "float_optional_0.0_到_1.0_LLM对此JSON输出的正确性和完整性的自评估置信度",
      "alternativePlansConsideredCount": "integer_optional_如果LLM在确定此计划前考虑了多个计划",
      "parsingFeedbackFromPreviousAttemptId": "string_or_null_如果这是对先前格式错误的JSON的修正_则为该失败尝试的llmInteractionId"
  },
  "usageMetadata": null
}
```
"""
    # 示例中的 <think> 块也相应调整
    direct_qa_example_think_block_text = "用户询问电容的定义。这是一个概念性问题，我将直接回答，无需调用工具。我会解释电容的基本作用、单位和常见类型。"
    if enable_deep_thinking_chinese:
        direct_qa_example_think_block_text = "用户询问电容的定义。这是一个概念性问题，我将直接回答，无需调用工具。我会解释电容的基本作用、单位和常见类型。" # 这里已经是中文，如果需要特定指示，可以再强化
    else: # 如果不要求中文思考，可以用英文或模型的默认语言
        direct_qa_example_think_block_text = "The user is asking for the definition of a capacitor. This is a conceptual question that does not require any circuit design tools. I can answer it directly based on my knowledge base. I will provide an explanation of its basic function, unit, and common types, and offer a suggestion for a next step. My response will be clear and direct."


    direct_qa_example = (
        "\n【通用示例1: 直接回答用户问题 (无需工具) - V1.0.0 Reasoning Model Output】\n"
        "如果用户问: “你好,什么是电容？”\n"
        "您的输出应类似 (ID和时间戳会变化): \n"
        f"<think>\n{direct_qa_example_think_block_text}\n</think>\n"
        "```json\n"
        "{\n"
        "  \"requestId\": \"" + (request_id or "userReqExampleId123") + "\",\n"
        "  \"llmInteractionId\": \"" + llm_interaction_id_example_plan_prefix + "_directQaCap\",\n"
        "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
        "  \"status\": \"success\",\n"
        "  \"errorDetails\": null,\n"
        "  \"executionPhase\": \"planning\",\n"
        "  \"thoughtProcess\": \"用户询问电容定义,直接回答。(主要思考过程在 <think> 块中)\",\n"
        "  \"decision\": {\n"
        "    \"isCallTools\": false,\n"
        "    \"toolCallRequests\": [],\n"
        "    \"responseToUser\": {\n"
        "      \"contentType\": \"text/plain\",\n"
        "      \"content\": \"电容是一种能够储存电荷的电子元件,由两块导体板中间夹一层绝缘介质构成。它的主要特性是电容量,单位是法拉(F),常用单位有微法(μF)、纳法(nF)和皮法(pF). 电容在电路中常用于滤波、耦合、隔直流、储能等.\",\n"
        "      \"suggestionsForNextSteps\": [\n"
        "        {\"textForUser\": \"您想了解电容在具体电路中的应用吗？\", \"actionType\": \"USER_INPUT_EXPECTED\"},\n"
        "        {\"textForUser\": \"需要我帮您在当前电路中添加一个电容吗？\", \"actionType\": \"USER_INPUT_EXPECTED\", \"actionPayload\": \"请帮我添加一个10uF的电解电容\"}\n"
        "      ],\n"
        "      \"requiresUserClarificationForCurrentRequest\": false\n"
        "    }\n"
        "  },\n"
        "  \"diagnostics\": {\"llmConfidenceScoreForThisOutput\": 0.95},\n"
        "  \"usageMetadata\": null\n"
        "}\n"
        "```\n"
    )

    tool_call_example_think_block_text = "用户要求添加R1电阻，使用DuckDuckGo搜索“什么是LED”并返回2条结果，然后将R1连接到GND。我将按顺序规划这些工具调用，确保每个toolCallId唯一，并给用户过渡回复。GND可能需要先添加。"
    if enable_deep_thinking_chinese:
        tool_call_example_think_block_text = "用户需要执行三个操作: 1. 添加电阻R1 (1kΩ)。 2. 使用DuckDuckGo搜索'什么是LED'并明确要求返回2条结果。3. 添加GND (如果不存在)并连接R1和GND。我将按顺序规划这三个/四个工具调用。确保为每个工具调用生成唯一的toolCallId。并为用户提供一个过渡性的回复,表明我理解了请求并正在处理。电路状态目前为空,元件GND可能需要先添加。"
    else:
        tool_call_example_think_block_text = "The user wants to perform three actions: 1. Add resistor R1 (1kΩ). 2. Search 'what is LED' using DuckDuckGo and get 2 results. 3. Add GND (if it doesn't exist) and connect R1 to GND. I will plan these three/four tool calls sequentially. I'll ensure unique toolCallIds for each. I will also provide a transitional message to the user indicating I've understood and am processing the request. The circuit is currently empty, so GND might need to be added first."


    tool_call_example = (
        "\n【通用示例2: 需要调用工具时的输出V1.0-CamelCaseJSON Reasoning Model Output】\n"
        "如果用户说: “帮我加一个1k欧姆的电阻R1,再用DuckDuckGo搜索'什么是LED'并返回2条结果,然后把R1连到GND。”\n"
        "您的输出应类似 (ID和时间戳会变化,每个toolCallId必须唯一,由您生成): \n"
        f"<think>\n{tool_call_example_think_block_text}\n</think>\n"
        "```json\n"
        "{\n"
        "  \"requestId\": \"" + (request_id or "userReqExampleId456") + "\",\n"
        "  \"llmInteractionId\": \"" + llm_interaction_id_example_plan_prefix + "_multiToolSearchFix2\",\n"
        "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
        "  \"status\": \"success\",\n"
        "  \"errorDetails\": null,\n"
        "  \"executionPhase\": \"planning\",\n"
        "  \"thoughtProcess\": \"规划添加R1,搜索,连接GND。(主要思考过程在 <think> 块中)\",\n"
        "  \"decision\": {\n"
        "    \"isCallTools\": true,\n"
        "    \"toolCallRequests\": [\n"
        "      {\n"
        "        \"toolCallId\": \"tc_add_r1_" + str(uuid4())[:8] + "\",\n"
        "        \"toolName\": \"add_component_tool\",\n"
        "        \"toolArguments\": {\"component_type\": \"电阻\", \"component_id\": \"R1\", \"value\": \"1kΩ\"},\n"
        "        \"uiHints\": {\"displayNameForTool\": \"添加电阻 R1 (1kΩ)\"}\n"
        "      },\n"
        "      {\n"
        "        \"toolCallId\": \"tc_search_led_" + str(uuid4())[:8] + "\",\n"
        "        \"toolName\": \"duckduckgo_search_tool\",\n"
        "        \"toolArguments\": {\"query\": \"什么是LED\", \"num_results\": 2},\n"
        "        \"uiHints\": {\"displayNameForTool\": \"搜索LED定义(2条结果)\"}\n"
        "      },\n"
        "      {\n"
        "        \"toolCallId\": \"tc_add_gnd_" + str(uuid4())[:8] + "\",\n"
        "        \"toolName\": \"add_component_tool\",\n"
        "        \"toolArguments\": {\"component_type\": \"地\", \"component_id\": \"GND\"},\n"
        "        \"uiHints\": {\"displayNameForTool\": \"添加地线 GND (如果需要)\"}\n"
        "      },\n"
        "      {\n"
        "        \"toolCallId\": \"tc_conn_r1gnd_" + str(uuid4())[:8] + "\",\n"
        "        \"toolName\": \"connect_components_tool\",\n"
        "        \"toolArguments\": {\"comp1_id\": \"R1\", \"comp2_id\": \"GND\"},\n"
        "        \"uiHints\": {\"displayNameForTool\": \"连接 R1 与 GND\"}\n"
        "      }\n"
        "    ],\n"
        "    \"responseToUser\": {\n"
        "      \"contentType\": \"text/plain\",\n"
        "      \"content\": \"好的,我正在为您添加电阻R1 (1kΩ),搜索LED的定义(2条结果),并准备连接R1到GND。请稍候...\",\n"
        "      \"suggestionsForNextSteps\": []\n"
        "    }\n"
        "  },\n"
        "  \"diagnostics\": null,\n"
        "  \"usageMetadata\": null\n"
        "}\n"
        "```\n"
    )
    
    replan_example_think_block_text = "重规划开始。分析历史：用户想连接R10和C5。上一个计划调用 connect_components_tool 失败，原因是元件 'R10' 不存在。当前电路状态确认R10不存在，但C5存在。因此，新计划是首先添加R10（默认为1kΩ电阻），然后再连接R10和C5。本次规划逻辑清晰，JSON状态应为 'success'。"
    if enable_deep_thinking_chinese:
        replan_example_think_block_text = "重规划开始。分析历史: 用户想连接R10和C5。上一个计划 (llmInteractionId: " + example_prev_tool_call_id + "_plan) 中调用connect_components_tool (toolCallId: " + example_prev_tool_call_id + "_tool) 失败了,工具报告原因是元件 'R10' 在电路中不存在。当前电路状态也确认R10不在电路中，但C5存在。因此,我的新计划是首先添加R10 (用户未指定类型或值,我将默认为电阻,并提供一个常用值如1kΩ). 然后再调用connect_components_tool连接新创建的R10和已存在的C5。本次规划逻辑清晰，后续的JSON应标记为status: 'success'."
    else:
        replan_example_think_block_text = "Replanning started. Analyzing history: User wanted to connect R10 and C5. Previous plan (llmInteractionId: " + example_prev_tool_call_id + "_plan) called connect_components_tool (toolCallId: " + example_prev_tool_call_id + "_tool) which failed because component 'R10' does not exist in the circuit. Current circuit state also confirms R10 is missing, but C5 exists. Therefore, my new plan is to first add R10 (user didn't specify type/value, I'll default to resistor and a common value like 1kΩ). Then, I'll call connect_components_tool to connect the newly created R10 and existing C5. This plan is logically sound, so the subsequent JSON should be marked status: 'success'."


    replan_example = ""
    if is_replanning:
        replan_example = (
            "\n【重规划示例 (V1.0.0 Reasoning Model Output): 工具失败后,成功重规划并调用新/修正的工具】\n"
            "假设历史记录中有如下用户请求和失败的工具调用: \n"
            "  User: \"连接 R10 和 C5\"\n"
            "  Assistant (Previous Plan JSON): ... (Planned connect_components_tool for R10, C5, llmInteractionId: " + example_prev_tool_call_id + "_plan) ...\n"
            "  Tool (connect_components_tool, toolCallId: " + example_prev_tool_call_id + "_tool, name: connect_components_tool) result (in history): { \"role\": \"tool\", ..., \"content\": \"{\\\"status\\\": \\\"failure\\\", \\\"message\\\": \\\"错误: 元件 'R10' 在电路中不存在. \\\", \\\"error\\\": { \\\"error_type\\\": \\\"CIRCUIT_OPERATION_ERROR\\\", \\\"error_code\\\": \\\"COMPONENT_NOT_FOUND_FOR_CONNECTION\\\", ... }}\" }\n"
            "  Current Circuit State (in memory_context): (R10 does not exist, C5 exists)\n"
            "您在【当前重规划】时,您的新V1.0-CamelCaseJSON 输出应类似: \n"
            f"<think>\n{replan_example_think_block_text}\n</think>\n"
            "```json\n"
            "{\n"
            "  \"requestId\": \"" + (request_id or "userReqExampleId789Replan") + "\",\n"
            "  \"llmInteractionId\": \"" + llm_interaction_id_example_plan_prefix + "_replanAddConnectFix2\",\n"
            "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
            "  \"status\": \"success\",\n"
            "  \"errorDetails\": null,\n"
            "  \"executionPhase\": \"planning\",\n"
            "  \"thoughtProcess\": \"R10不存在,先添加再连接。(主要思考过程在 <think> 块中)\",\n"
            "  \"decision\": {\n"
            "    \"isCallTools\": true,\n"
            "    \"toolCallRequests\": [\n"
            "      {\n"
            "        \"toolCallId\": \"tc_replan_add_r10_" + str(uuid4())[:8] + "\",\n"
            "        \"toolName\": \"add_component_tool\",\n"
            "        \"toolArguments\": {\"component_type\": \"电阻\", \"component_id\": \"R10\", \"value\": \"1k\"},\n"
            "        \"uiHints\": {\"displayNameForTool\": \"(修正) 添加电阻 R10 (1kΩ)\"}\n"
            "      },\n"
            "      {\n"
            "        \"toolCallId\": \"tc_replan_connect_r10c5_" + str(uuid4())[:8] + "\",\n"
            "        \"toolName\": \"connect_components_tool\",\n"
            "        \"toolArguments\": {\"comp1_id\": \"R10\", \"comp2_id\": \"C5\"},\n"
            "        \"uiHints\": {\"displayNameForTool\": \"(修正) 连接 R10 与 C5\"}\n"
            "      }\n"
            "    ],\n"
            "    \"responseToUser\": {\n"
            "      \"contentType\": \"text/plain\",\n"
            "      \"content\": \"检测到元件R10之前不存在。我将先为您添加一个1kΩ的电阻R10,然后再将它与C5连接。\",\n"
            "      \"suggestionsForNextSteps\": [\n"
            "        {\"textForUser\": \"操作完成后显示电路状态.\"}\n"
            "      ],\n"
            "      \"requiresUserClarificationForCurrentRequest\": false\n"
            "    }\n"
            "  },\n"
            "  \"diagnostics\": {\"parsingFeedbackFromPreviousAttemptId\": \"" + example_prev_tool_call_id + "_plan\"},\n"
            "  \"usageMetadata\": null\n"
            "}\n"
            "```\n"
        )
    
    important_instructions_think_block_main = f"您的详细逐步推理**必须**在 `<think>...</think>` 标签内{think_block_language_instruction}，并置于回复最开始。"
    important_instructions_json_thought_process_main = f"此JSON字段现在是次要的。它可以是简短总结或空字符串 `\"\"`{json_thought_process_language_note}。`<think>...</think>` 块中的内容是主要的思考过程。"
    
    final_emphasize_think_block_main = f"您的输出【必须】以 `<think>...</think>` 块开始{think_block_language_instruction}，后跟一个被 ```json ... ``` 包围的、严格符合上述V1.0-CamelCaseJSON规范 (所有key使用camelCase) 的单个JSON对象。"


    prompt_parts = [
        "您是一位初版电路设计编程助理 (Agent Version V1.0.0, 11 Tools)。您的任务是理解用户指令,并据此规划行动或直接回复。\n",
        reasoning_model_instructions,
        "\n【核心任务: 规划阶段 (V1.0.0)】\n"
        f"请首先在 `<think>...</think>` 标签内深入分析用户的最新指令、完整的对话历史、当前的电路状态和记忆{think_block_language_instruction}。然后,在 `</think>` 标签之后,生成一个符合V1.0-CamelCaseJSON规范的JSON对象作为您的行动计划或直接回复。JSON中所有key【必须】使用camelCase (例如: `isCallTools`, `toolCallRequests`, `requestId`).\n",
        replanning_guidance if is_replanning else "",
        "【V1.0.0 输出格式规范 (在</think>之后输出, 必须严格遵守)】:\n",
        json_schema_description_for_prompt,
        "\n【重要指令与检查清单 (V1.0.0 - Planning)】:\n"
        f"1.  **`<think>` Block First**: {important_instructions_think_block_main}\n"
        "2.  **JSON After `</think>`**: V1.0.0 对象 (用 ```json ... ``` 包裹) **必须**紧跟 `</think>` 标签。此JSON中的所有键名必须是 camelCase (例如, `requestId`, `isCallTools`, `toolCallRequests`)。`toolArguments` 内部的键名 (例如, `component_type`) 应遵循下面工具 Schema 中提供的 snake_case 命名。\n"
        f"3.  **JSON `thoughtProcess` Field**: {important_instructions_json_thought_process_main}\n"
        "4.  **`decision.isCallTools`**: JSON中的此字段**必须**是布尔值 (`true` 或 `false`)。大小写不敏感的字符串 \"True\" 或 \"true\" 也可接受,Agent会将其解析为布尔值。\n"
        "5.  **其他 JSON 字段**: 严格遵循V1.0-CamelCaseJSON Schema 的JSON部分。\n"
        "6.  **电路状态感知**: 在规划涉及现有元件的工具调用前,请在 `memory_context` (当前电路状态) 中确认它们的存在。如果需要连接像 'INPUT' 这样的抽象节点而它们并非作为元件存在,请首先规划添加它们 (例如,作为 'Terminal')。\n\n",
        direct_qa_example,
        tool_call_example,
    ]
    if is_replanning:
        prompt_parts.append(replan_example)

    prompt_parts.extend([
        "\n【可用工具列表与参数规范 (V1.0.0 - 11 Tools)】:\n",
        tool_schemas_desc,
        "\n\n【当前上下文信息 (V1.0.0)】:\n"
        f"Current Request ID (如果可用,请在JSON的requestId字段中原样返回): {request_id or 'N/A_NOT_PROVIDED_IN_PROMPT_SET_TO_NULL'}\n"
        f"Current UTC Time (供您生成timestampUtc参考): {current_timestamp_utc}\n"
        f"当前电路与记忆摘要:\n{memory_context}\n\n"
        f"【最后再次强调】: {final_emphasize_think_block_main}JSON对象之外不应有任何其他文本。请务必仔细检查 `<think>` 块的使用以及JSON的语法和所有字段的类型及条件要求！"
    ])
    return "".join(prompt_parts)


def get_response_generation_prompt(memory_context: str,
                                        tool_schemas_desc: str,
                                        request_id: Optional[str] = None,
                                        # 新增参数: 是否启用中文深度思考
                                        enable_deep_thinking_chinese: bool = False 
                                        ) -> str:
    current_timestamp_utc = datetime.now(timezone.utc).isoformat()
    llm_interaction_id_example_resp_prefix = f"resp_ex_llm_id_{str(uuid4())[:6]}"

    think_block_language_instruction_resp = "，并且【请使用中文进行思考和阐述此部分内容】" if enable_deep_thinking_chinese else ""
    json_thought_process_language_note_resp = "（如果<think>块使用中文思考，此总结也建议使用中文）" if enable_deep_thinking_chinese else ""

    reasoning_model_instructions_resp_phase = (
        "\n【重要: Reasoning Model 输出规范 (V1.0.0 - Response Generation)】\n"
        f"1.  **思考过程**: 您的详细思考过程 (如何分析工具结果或决定直接回复, 以及如何构思最终回复) 【必须】包含在 `<think>...</think>` 标签内{think_block_language_instruction_resp}，并放在您回复的最开始部分。\n"
        "2.  **JSON 输出**: 在 `</think>` 标签之后,您【必须】输出一个严格符合下面描述的V1.0-CamelCaseJSON格式的单个JSON对象。此JSON对象应被三个反引号和'json'标记包围 (即 ```json ... ```)。JSON中所有key【必须】使用camelCase.\n"
        f"3.  **`thoughtProcess` 字段 (in JSON)**: JSON对象内部的 `thoughtProcess` 字段现在是次要的。它可以是一个简短的总结或留空 ( `\"\"` ){json_thought_process_language_note_resp}，因为您的主要思考过程已在 `<think>...</think>` 块中。Agent将优先使用 `<think>` 块中的内容作为思考日志。\n"
    )
    
    # JSON Schema 描述 (保持不变)
    json_schema_description_for_resp_phase = """
```json
{
  "requestId": "string_or_null_当前用户请求周期的ID_如果系统提示中提供了此值请原样返回_否则为null",
  "llmInteractionId": "string_必须是本次LLM响应的唯一ID_例如_resp_llm_id_后跟8位随机字符_如_resp_llm_id_e5f6g7h8",
  "timestampUtc": "string_当前UTC时间戳_ISO_8601格式_例如_2024-07-16T12:05:00.000Z",
  "status": "string_必须是 'success' 或 'failure'_表示您是否为本次尝试成功生成了此最终响应JSON_如果您现在无法构思出合适的摘要或回复_则设为failure",
  "errorDetails": {
    "errorType": "string_enum_例如_RESPONSE_GENERATION_ERROR_LLM_OUTPUT_VALIDATION_ERROR",
    "errorCode": "string_例如_JSON_MALFORMED_SUMMARY_LOGIC_ERROR",
    "messageToUser": "string_optional_用户友好的消息_如果适用",
    "technicalMessage": "string_本次响应生成尝试的详细技术错误消息。",
    "isDirectLlmFailure": "boolean_如果LLM明确表示无法完成请求或为本次尝试生成有效JSON则为True。如果错误是由于Agent端对LLM输出的JSON进行校验失败(即使JSON本身语法有效)_或LLM在格式良好的JSON中报告逻辑失败_则为False。",
    "failedValidationPoints": [ { "jsonPath": "...", "issue_description": "..." } ]
  },
  "executionPhase": "string_对于此任务_必须是 'response_generation'",
  "thoughtProcess": "string_此字段现在是次要的_您的主要详细推理必须在初始的 `<think>...</think>` 块中_此JSON字段可以是简短总结或为空_Agent将优先使用 `<think>` 块内容。",
  "decision": {
    "isCallTools": "boolean_在此响应生成阶段必须为false_也接受不区分大小写的字符串 'true'/'false'",
    "toolCallRequests": [],
    "responseToUser": {
      "contentType": "string_例如_text/plain_或_application/markdown",
      "content": "string_这是您对用户的最终且完整的回复_它必须非空。它应总结已采取的操作_报告结果_并根据工具输出(如果最初未调用工具_则根据您的直接知识)回应用户的原始请求。此内容是用户将看到的。",
      "suggestionsForNextSteps": [
        {
          "suggestionId": "string_optional_此建议的唯一ID_例如_sugg_ask_about_led_color",
          "textForUser": "string_向用户显示的建议文本_例如_您想指定LED颜色吗",
          "actionType": "string_enum_optional_USER_INPUT_EXPECTED_or_PREDEFINED_AGENT_ACTION_or_UI_NAVIGATION",
          "actionPayload": "object_or_string_optional_如果类型是PREDEFINED_AGENT_ACTION_这可能是简化的请求对象或命令字符串_供Agent在用户选择后处理"
        }
      ],
      "requiresUserClarificationForCurrentRequest": "boolean_optional_如果当前请求需要用户进一步输入才能继续_并且content正在请求该澄清_则设置为True_默认为False"
    }
  },
  "diagnostics": {
      "llmConfidenceScoreForThisOutput": "float_optional_0.0_到_1.0",
      "alternativePlansConsideredCount": "integer_optional",
      "parsingFeedbackFromPreviousAttemptId": "string_or_null"
  },
  "usageMetadata": null
}
```
"""
    # 示例中的 <think> 块也相应调整
    response_gen_example_think_block_text = "回顾工具执行结果：add_component_tool 成功添加了电阻R1。duckduckgo_search_tool 成功搜索了“LED”并返回结果。我将向用户清晰报告这两个操作的成功，并简要提及搜索到的信息。最终回复将整合这些信息，保持友好。"
    if enable_deep_thinking_chinese:
        response_gen_example_think_block_text = "回顾工具执行结果: add_component_tool (toolCallId: tc_xyz_add_r1) 成功添加了电阻R1。duckduckgo_search_tool (toolCallId: tc_abc_search_led) 成功搜索了'LED'并返回了结果。我需要向用户清晰地报告这两个操作的成功,并简要提及搜索到的信息。最终的回复将整合这些信息,保持友好和乐于助人的语气。"
    else:
        response_gen_example_think_block_text = "Reviewing tool execution results: add_component_tool (toolCallId: tc_xyz_add_r1) successfully added resistor R1. duckduckgo_search_tool (toolCallId: tc_abc_search_led) successfully searched for 'LED' and returned results. I need to clearly report the success of both operations to the user and briefly mention the information found. The final reply will integrate this information in a friendly and helpful tone."


    response_gen_example = (
        "\n【示例 (V1.0.0 Reasoning Model Output): 总结工具结果并生成最终回复】\n"
        "假设对话历史中包含以下工具执行结果 (工具1成功, 工具2是搜索工具也成功):\n"
        "  Tool Message 1 (for toolCallId: tc_xyz_add_r1): { \"role\": \"tool\", ..., \"content\": \"{\\\"status\\\": \\\"success\\\", \\\"message\\\": \\\"已添加电阻R1\\\", ...}\" }\n"
        "  Tool Message 2 (for toolCallId: tc_abc_search_led): { \"role\": \"tool\", ..., \"content\": \"{\\\"status\\\": \\\"success\\\", \\\"message\\\": \\\"已完成对'LED'的DuckDuckGo搜索,找到2条相关信息。\\\", \\\"data\\\": {\\\"query\\\": \\\"LED\\\", \\\"num_results_returned\\\": 2, \\\"results_json_string\\\": \\\"[{\\\\\\\"title\\\\\\\":\\\\\\\"LED - Wikipedia\\\\\\\", ...}]\\\"}}\" }\n"
        "您的输出V1.0-CamelCaseJSON JSON应类似 (ID和时间戳会变化): \n"
        f"<think>\n{response_gen_example_think_block_text}\n</think>\n"
        "```json\n"
        "{\n"
        "  \"requestId\": \"" + (request_id or "userReqExampleIdResp123") + "\",\n"
        "  \"llmInteractionId\": \"" + llm_interaction_id_example_resp_prefix + "_finalSummaryRSearchFix2\",\n" 
        "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
        "  \"status\": \"success\",\n"
        "  \"errorDetails\": null,\n"
        "  \"executionPhase\": \"response_generation\",\n"
        "  \"thoughtProcess\": \"总结R1添加成功,LED搜索成功。(主要思考过程在 <think> 块中)\",\n"
        "  \"decision\": {\n"
        "    \"isCallTools\": false, \n"
        "    \"toolCallRequests\": [], \n"
        "    \"responseToUser\": {\n"
        "      \"contentType\": \"text/plain\",\n"
        "      \"content\": \"您好,我已经成功为您添加了电阻R1。关于LED的DuckDuckGo搜索也已完成,我找到了2条相关信息,例如 'LED - Wikipedia'。您想了解更多搜索到的细节吗？\",\n"
        "      \"suggestionsForNextSteps\": [\n"
        "        {\"suggestionId\": \"sugg_show_search_details\", \"textForUser\": \"显示LED搜索结果的详细信息\", \"actionType\": \"USER_INPUT_EXPECTED\"},\n"
        "        {\"suggestionId\": \"sugg_view_circuit\", \"textForUser\": \"查看当前电路中已有的元件列表。\", \"actionType\": \"USER_INPUT_EXPECTED\", \"actionPayload\": \"当前电路什么样\"}\n"
        "      ],\n"
        "      \"requiresUserClarificationForCurrentRequest\": false \n"
        "    }\n"
        "  },\n"
        "  \"diagnostics\": {\"llmConfidenceScoreForThisOutput\": 0.98},\n"
        "  \"usageMetadata\": null\n"
        "}\n"
        "```\n"
    )
    
    important_instructions_resp_think_block_main = f"您的详细工具结果分析和回复构思**必须**在 `<think>...</think>` 标签内{think_block_language_instruction_resp}。"
    final_emphasize_resp_think_block_main = f"您的输出【必须】以 `<think>...</think>` 块开始{think_block_language_instruction_resp}，后跟一个被 ```json ... ``` 包围的、严格符合上述V1.0-CamelCaseJSON规范 (所有key使用camelCase) 的单个JSON对象。"

    return (
        "您是一位初版电路设计编程助理 (Agent Version V1.0.0, 11 Tools), 经验丰富,技术精湛,并且极其擅长清晰、准确、诚实地汇报工作结果。\n"
        f"{reasoning_model_instructions_resp_phase}\n"
        "【核心任务: 响应生成阶段 (V1.0.0)】\n"
        f"您当前的任务是: 基于到目前为止的【完整对话历史】(包括用户最初的指令、您在规划阶段生成的V1.0-CamelCaseJSON计划、以及所有【已执行工具的结果详情】,这些工具结果是以 'role: tool', 'toolCallId: ...', 'name: ...', 'content: JSON_string_of_tool_output' 的格式存在于历史记录中的), 首先在 `<think>...</think>` 标签内进行思考和总结{think_block_language_instruction_resp}, 然后在 `</think>` 之后生成【最终的、面向用户的V1.0-CamelCaseJSON回复】。JSON中所有key【必须】使用camelCase.\n\n"
        "【V1.0.0 输出格式规范 (在</think>之后输出, 与规划阶段结构相同,但有特定值要求 - 再次强调)】:\n"
        f"{json_schema_description_for_resp_phase}\n"
        "【重要指令与检查清单 (V1.0.0 - 响应生成阶段特定要求)】:\n"
        f"1.  **`<think>` Block First**: {important_instructions_resp_think_block_main}\n"
        "2.  **JSON After `</think>`**: V1.0.0 对象 (用 ```json ... ``` 包裹) **必须**紧跟 `</think>` 标签。此JSON中的所有键名必须是 camelCase。\n"
        "3.  **`executionPhase`**: 在此阶段,此值【必须】是 `\"response_generation\"`。\n"
        "4.  **`decision.isCallTools`**: 在此响应生成阶段,此值【必须】为 `false` (或可解析为`false`的字符串)。\n"
        "5.  **`decision.toolCallRequests`**: 在此响应生成阶段,此列表【必须】为 `[]` (空数组) 或 `null`。\n"
        "6.  **`decision.responseToUser.content`**: 这是您基于所有先前步骤生成的【最终、完整、友好】的文本回复。它【不能】为空字符串或仅包含空白。\n"
        "7.  **回顾工具结果**: 仔细检查对话历史中 `role: tool` 的消息。您的最终回复必须准确反映这些结果。\n\n"
        f"{response_gen_example}\n"
        "【上下文参考信息 (仅供你回顾 - V1.0.0)】:\n"
        f"Current Request ID (如果可用,请在JSON的requestId字段中原样返回): {request_id or 'N/A_NOT_PROVIDED_IN_PROMPT_SET_TO_NULL'}\n"
        f"Current UTC Time (供您生成timestampUtc参考): {current_timestamp_utc}\n"
        f"当前电路与记忆摘要:\n{memory_context}\n"
        f"我的可用工具列表 (共11个, 仅供你参考,此阶段不应再调用它们):\n{tool_schemas_desc}\n\n"
        f"【最后再次强调】: {final_emphasize_resp_think_block_main}在这个阶段,您【绝对不能】再请求调用任何新工具。您的任务是总结并回复。"
    )

--- END: circuitmanus/prompts/templates.py ---

--- START: circuitmanus/prompts/__init__.py ---
# IDT_AGENT_Pro/circuitmanus/prompts/__init__.py
"""
Prompt Engineering for LLM Interactions.
Contains helper functions or classes for generating system prompts
for different phases of agent execution.
"""
from .templates import (
    get_tool_schemas_for_prompt,
    get_planning_prompt,
    get_response_generation_prompt,
)

__all__ = [
    "get_tool_schemas_for_prompt",
    "get_planning_prompt",
    "get_response_generation_prompt",
]
--- END: circuitmanus/prompts/__init__.py ---

--- START: circuitmanus/tools/base.py ---
# IDT_AGENT_Pro/circuitmanus/tools/base.py
import functools
import inspect
from typing import Dict, Any, Callable, Awaitable, Union

# 这个模块主要提供工具注册的装饰器
# 未来如果需要通用的工具基类或接口，也可以放在这里

def register_tool(description: str, parameters: Dict[str, Any]):
    """
    一个装饰器，用于将一个 Agent 的方法注册为一个可被 LLM 调用的工具。

    被装饰的函数会被添加一个 `_is_tool` 属性 (设为 True) 和一个
    `_tool_schema` 属性，其中包含提供给 LLM 的工具描述和参数规范。

    Args:
        description (str): 对工具功能的自然语言描述，供 LLM 理解工具的用途。
        parameters (Dict[str, Any]): 一个符合 JSON Schema 规范的字典，
                                     描述工具接受的参数。通常包含:
                                     - "type": "object"
                                     - "properties": 一个字典，键是参数名 (snake_case)，
                                                     值是该参数的 schema (例如 {"type": "string", "description": "..."})。
                                     - "required": 一个可选的列表，包含所有必需参数的名称。

    Returns:
        Callable: 返回一个包装器函数，该函数会保留原函数的功能并添加额外的元数据。
                  如果原函数是异步的，包装器也是异步的；同步亦然。
    """
    if not isinstance(description, str) or not description.strip():
        raise ValueError("工具描述 (description) 必须是一个有效的非空字符串。")
    if not isinstance(parameters, dict): # 基本的类型检查
        raise ValueError("工具参数规范 (parameters) 必须是一个字典。")
    # 可以添加更严格的 parameters schema 校验，例如检查是否包含 'type': 'object' 和 'properties'
    # 但这里保持与原版一致的宽松度

    def decorator(func: Callable[..., Union[Dict[str, Any], Awaitable[Dict[str, Any]]]]) -> Callable:
        # 将 schema 附加到函数对象上
        func._tool_schema = {"description": description, "parameters": parameters}
        func._is_tool = True # 标记这是一个已注册的工具

        # 使用 functools.wraps 来保留原函数的元数据 (如名称, docstring, 注解)，
        # 这对于 inspect.iscoroutinefunction 等内省机制正确工作非常重要。
        # 尤其是当装饰器本身返回一个新的函数（包装器）时。
        
        # 根据原函数是同步还是异步，创建相应的包装器
        # 这是为了确保装饰器能正确处理异步和同步函数，并保持其原始的调用方式 (awaitable or not)
        # 对于 Agent 工具，它们最终都应该返回一个 Dict[str, Any] 的结果。
        
        if inspect.iscoroutinefunction(func):
            @functools.wraps(func)
            async def async_wrapper(*args, **kwargs) -> Dict[str, Any]:
                # 对于异步工具，直接 await 它
                # 这里的 args[0] 通常是 self (Agent 实例)
                # kwargs 通常是 { "arguments": {...} }
                return await func(*args, **kwargs)
            return async_wrapper
        else:
            @functools.wraps(func)
            def sync_wrapper(*args, **kwargs) -> Dict[str, Any]:
                # 对于同步工具，直接调用它
                return func(*args, **kwargs)
            return sync_wrapper
            
    return decorator
--- END: circuitmanus/tools/base.py ---

--- START: circuitmanus/tools/circuit_ops.py ---
# IDT_AGENT_Pro/circuitmanus/tools/circuit_ops.py
import re
import logging
import traceback
from typing import Dict, Any, Tuple, TYPE_CHECKING

# 导入 register_tool 装饰器
from .base import register_tool

# TYPE_CHECKING 用于类型提示，避免运行时循环导入
if TYPE_CHECKING:
    from ..agent import CircuitAgent # 指向 agent.py 中的 CircuitAgent
    from ..circuit_domain.components import CircuitComponent # 指向 components.py

logger = logging.getLogger(__name__)

# 注意：以下所有工具函数的第一个参数 'self' 都期望是 CircuitAgent 的一个实例。
# ToolExecutor 在调用时会确保这一点，因为它通过 getattr(agent_instance, tool_name) 获取方法。

@register_tool(
    description="添加一个新的电路元件 (例如: 电阻, 电容, 电池, LED, 开关, 芯片, 地线, 端子/连接点等)。如果用户未指定 ID,系统会自动为其生成一个。",
    parameters={"type": "object", "properties": {"component_type": {"type": "string", "description": "元件的类型 (例如: '电阻', 'LED', 'Terminal', 'INPUT', 'GND')。"}, "component_id": {"type": "string", "description": "可选的用户为元件指定的ID。如果提供,则使用此ID; 如果不提供或提供格式无效,则由系统自动生成。"}, "value": {"type": "string", "description": "可选的元件值 (例如: '1k', '10uF', '3V')。"}}, "required": ["component_type"]}
)
def add_component_tool(self: 'CircuitAgent', arguments: Dict[str, Any]) -> Dict[str, Any]:
    """
    Agent工具：向当前电路中添加一个新元件。
    LLM通过'toolArguments'提供元件类型、可选ID和可选值。
    如果ID未提供或无效，则由系统根据类型自动生成。
    """
    # 使用 self.current_request_id 和 self.memory_manager
    tool_call_logger_prefix = f"[Action-AddComponentTool-ReqID:{self.current_request_id or 'N/A'}]"
    logger.info(f"{tool_call_logger_prefix} 执行添加元件操作。")
    logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
    
    component_type = arguments.get("component_type")
    component_id_req = arguments.get("component_id") # 用户请求的ID
    value_req = arguments.get("value") # 用户请求的元件值

    # 1. 验证输入参数的有效性 (基本类型和存在性)
    if not component_type or not isinstance(component_type, str) or not component_type.strip():
        err_msg = "元件类型是必需的,并且必须是有效的非空字符串。"
        logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
        return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_TYPE", "technical_message": err_msg}}

    target_id_final: str # 最终确定的元件ID，确保它在后续逻辑中一定会被赋值
    id_was_generated_by_system = False
    user_provided_id_was_validated: str = "" # 用来记录用户提供的且通过验证的ID

    # 2. 确定元件ID：优先使用用户提供的ID (如果有效且不冲突)，否则自动生成
    if component_id_req and isinstance(component_id_req, str) and component_id_req.strip():
        user_provided_id_cleaned = component_id_req.strip().upper()
        # 简单的ID格式校验：允许字母、数字、下划线、连字符，且不能以下划线或连字符开头（除非是特定关键字）
        # 或者是一些预定义的特殊ID，如 "INPUT", "OUTPUT", "GND"
        if re.match(r'^[a-zA-Z0-9_][a-zA-Z0-9_-]*$', user_provided_id_cleaned) or \
           user_provided_id_cleaned in ["INPUT", "OUTPUT", "GND"]: # GND等特殊ID允许
            if user_provided_id_cleaned in self.memory_manager.circuit.components:
                err_msg = f"您提供的元件 ID '{user_provided_id_cleaned}' 已被占用。"
                logger.error(f"{tool_call_logger_prefix} ID 冲突: {err_msg}")
                return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "CIRCUIT_STATE_ERROR", "error_code": "COMPONENT_ID_CONFLICT", "technical_message": err_msg, "conflicting_id": user_provided_id_cleaned}}
            else:
                target_id_final = user_provided_id_cleaned
                user_provided_id_was_validated = target_id_final
                logger.debug(f"{tool_call_logger_prefix} 将使用用户提供的有效 ID: '{target_id_final}'。")
        else:
            logger.warning(f"{tool_call_logger_prefix} 用户提供的 ID '{component_id_req}' 格式无效。将自动生成 ID。")
            # 标记需要生成ID
            target_id_final = "" # 临时置空，下面会生成
            id_was_generated_by_system = True
    else:
        # 用户未提供ID，需要系统生成
        target_id_final = "" # 临时置空
        id_was_generated_by_system = True

    if id_was_generated_by_system: # 或者 target_id_final == ""
        try:
            # 调用 Circuit 对象的ID生成方法
            target_id_final = self.memory_manager.circuit.generate_component_id(component_type)
            logger.debug(f"{tool_call_logger_prefix} 已自动为类型 '{component_type}' 生成 ID: '{target_id_final}'。")
        except RuntimeError as e_gen_id:
            err_msg = f"无法自动为类型 '{component_type}' 生成唯一 ID: {e_gen_id}"
            logger.error(f"{tool_call_logger_prefix} ID 生成失败: {err_msg}", exc_info=True)
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "INTERNAL_AGENT_ERROR", "error_code": "COMPONENT_ID_GENERATION_FAILED", "technical_message": str(e_gen_id)}}
    
    # 3. 处理元件值
    # 如果 value_req 是 None 或者清理后是空字符串，则 processed_value 为 None
    processed_value = str(value_req).strip() if value_req is not None and str(value_req).strip() else None
    # 特殊情况：如果LLM明确传递了 "value": null (在JSON中)，arguments.get("value")会是None。
    # 如果LLM传递了 "value": "" (空字符串)，arguments.get("value")会是""。
    # 上述的 processed_value 逻辑都能正确处理这些情况，将其统一为 None 或非空字符串。

    # 4. 创建并添加元件
    try:
        # 确保 target_id_final 此时一定有值
        if not target_id_final: # 防御性编程，理论上不会到这里
            raise ValueError("内部错误: 在尝试创建元件之前,未能最终确定有效的元件 ID。")

        # 需要导入 CircuitComponent 类
        from ..circuit_domain.components import CircuitComponent
        new_component = CircuitComponent(target_id_final, component_type, processed_value)
        self.memory_manager.circuit.add_component(new_component)

        logger.info(f"{tool_call_logger_prefix} 成功添加元件 '{new_component.id}' ({new_component.type}) 到电路。")
        
        # 构建成功消息
        success_message_parts = [f"操作成功: 已添加元件 {str(new_component)}。"]
        if id_was_generated_by_system and not user_provided_id_was_validated: # 明确是系统生成的
            success_message_parts.append(f"(系统自动分配 ID '{new_component.id}')")
        elif user_provided_id_was_validated: # 明确是用户提供的且通过验证的
             success_message_parts.append(f"(使用了您指定的 ID '{user_provided_id_was_validated}')")
        final_success_message = " ".join(success_message_parts)
        
        # 添加到长期记忆
        self.memory_manager.add_to_long_term(f"添加了元件: {str(new_component)} (请求ID: {self.current_request_id or 'N/A'})")
        
        return {"status": "success", "message": final_success_message, "data": new_component.to_dict()}

    except ValueError as ve_comp: # 可能来自 CircuitComponent 构造或 circuit.add_component
        err_msg = f"创建或添加元件对象时发生内部验证错误: {ve_comp}"
        logger.error(f"{tool_call_logger_prefix} 元件创建/添加错误: {err_msg}", exc_info=True)
        return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_CREATION_OR_ADDITION_VALIDATION_FAILED", "technical_message": str(ve_comp)}}
    except Exception as e_add_comp: # 捕获其他未知异常
        err_msg = f"添加元件时发生未知的内部错误: {e_add_comp}"
        logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
        return {"status": "failure", "message": "错误: 添加元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "ADD_COMPONENT_UNEXPECTED_FAILURE", "technical_message": str(e_add_comp), "exception_details": traceback.format_exc(limit=3)}}

@register_tool(
    description="使用两个已存在元件的 ID 将它们连接起来。",
    parameters={"type": "object", "properties": {"comp1_id": {"type": "string", "description": "第一个元件的 ID。"}, "comp2_id": {"type": "string", "description": "第二个元件的 ID。"}}, "required": ["comp1_id", "comp2_id"]}
)
def connect_components_tool(self: 'CircuitAgent', arguments: Dict[str, Any]) -> Dict[str, Any]:
    tool_call_logger_prefix = f"[Action-ConnectComponentsTool-ReqID:{self.current_request_id or 'N/A'}]"
    logger.info(f"{tool_call_logger_prefix} 执行连接元件操作。")
    logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")

    comp1_id_req = arguments.get("comp1_id")
    comp2_id_req = arguments.get("comp2_id")

    if not comp1_id_req or not isinstance(comp1_id_req, str) or not comp1_id_req.strip() or \
       not comp2_id_req or not isinstance(comp2_id_req, str) or not comp2_id_req.strip():
        err_msg = "必须提供两个有效的、非空的元件 ID 字符串。"
        logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
        return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_IDS_FOR_CONNECTION", "technical_message": err_msg}}

    id1_cleaned = comp1_id_req.strip().upper()
    id2_cleaned = comp2_id_req.strip().upper()

    try:
        # 调用 Circuit 对象的连接方法
        connection_was_new = self.memory_manager.circuit.connect_components(id1_cleaned, id2_cleaned)
        if connection_was_new:
            logger.info(f"{tool_call_logger_prefix} 成功添加新连接: {id1_cleaned} <--> {id2_cleaned}。")
            self.memory_manager.add_to_long_term(f"连接了元件: {id1_cleaned} <--> {id2_cleaned} (请求ID: {self.current_request_id or 'N/A'})")
            return {"status": "success", "message": f"操作成功: 已将元件 '{id1_cleaned}' 与 '{id2_cleaned}' 连接起来。", "data": {"connection": sorted((id1_cleaned, id2_cleaned))}}
        else:
            # 连接已存在
            msg_exists = f"元件 '{id1_cleaned}' 和 '{id2_cleaned}' 之间已经存在连接。无需重复操作。"
            logger.info(f"{tool_call_logger_prefix} 连接已存在: {msg_exists}")
            return {"status": "success", "message": f"注意: {msg_exists}", "data": {"connection": sorted((id1_cleaned, id2_cleaned)), "already_existed": True}}
    except ValueError as ve_connect: # 来自 circuit.connect_components 的校验错误
        err_msg_val = str(ve_connect)
        logger.error(f"{tool_call_logger_prefix} 连接验证错误: {err_msg_val}")
        # 根据错误消息内容细化错误代码
        error_code_detail = "GENERIC_CIRCUIT_VALIDATION_ERROR"
        if "不存在" in err_msg_val: error_code_detail = "COMPONENT_NOT_FOUND_FOR_CONNECTION"
        elif "连接到它自己" in err_msg_val: error_code_detail = "SELF_CONNECTION_ATTEMPTED"
        return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": error_code_detail, "technical_message": err_msg_val}}
    except Exception as e_connect:
        err_msg = f"连接元件时发生未知的内部错误: {e_connect}"
        logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
        return {"status": "failure", "message": "错误: 连接元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "CONNECT_COMPONENTS_UNEXPECTED_FAILURE", "technical_message": str(e_connect), "exception_details": traceback.format_exc(limit=3)}}

@register_tool(description="获取当前电路的详细描述,包括所有元件及其连接情况。", parameters={"type": "object", "properties": {}})
def describe_circuit_tool(self: 'CircuitAgent', arguments: Dict[str, Any]) -> Dict[str, Any]:
    tool_call_logger_prefix = f"[Action-DescribeCircuitTool-ReqID:{self.current_request_id or 'N/A'}]"
    logger.info(f"{tool_call_logger_prefix} 执行描述电路操作。")
    try:
        # 调用 MemoryManager (间接调用 Circuit) 的方法
        description = self.memory_manager.get_circuit_state_description()
        logger.info(f"{tool_call_logger_prefix} 成功生成电路描述。")
        return {"status": "success", "message": "已成功获取当前电路的描述。", "data": {"description": description}}
    except Exception as e_describe:
        err_msg = f"生成电路描述时发生意外的内部错误: {e_describe}"
        logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
        return {"status": "failure", "message": "错误: 获取电路描述时发生未知错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "DESCRIBE_CIRCUIT_UNEXPECTED_FAILURE", "technical_message": str(e_describe), "exception_details": traceback.format_exc(limit=3)}}

@register_tool(description="彻底清空当前的电路设计,移除所有已添加的元件和它们之间的所有连接。此操作不可逆。", parameters={"type": "object", "properties": {}})
def clear_circuit_tool(self: 'CircuitAgent', arguments: Dict[str, Any]) -> Dict[str, Any]:
    tool_call_logger_prefix = f"[Action-ClearCircuitTool-ReqID:{self.current_request_id or 'N/A'}]"
    logger.info(f"{tool_call_logger_prefix} 执行清空电路操作。")
    try:
        # 调用 Circuit 对象的清空方法
        self.memory_manager.circuit.clear()
        logger.info(f"{tool_call_logger_prefix} 电路状态已成功清空。")
        self.memory_manager.add_to_long_term(f"执行了清空电路操作 (请求ID: {self.current_request_id or 'N/A'})。")
        return {"status": "success", "message": "操作成功: 当前电路已彻底清空。"}
    except Exception as e_clear:
        err_msg = f"清空电路时发生意外的内部错误: {e_clear}"
        logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
        return {"status": "failure", "message": "错误: 清空电路时发生未知错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "CLEAR_CIRCUIT_UNEXPECTED_FAILURE", "technical_message": str(e_clear), "exception_details": traceback.format_exc(limit=3)}}

@register_tool(
    description="从电路中移除一个指定的元件及其所有相关的连接。",
    parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要移除的元件的 ID。"}}, "required": ["component_id"]}
)
def remove_component_tool(self: 'CircuitAgent', arguments: Dict[str, Any]) -> Dict[str, Any]:
    tool_call_logger_prefix = f"[Action-RemoveComponentTool-ReqID:{self.current_request_id or 'N/A'}]"
    logger.info(f"{tool_call_logger_prefix} 执行移除元件操作。")
    logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
    component_id_req = arguments.get("component_id")

    if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
        err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
        logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
        return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_REMOVAL", "technical_message": err_msg}}

    id_cleaned = component_id_req.strip().upper()
    try:
        # 调用 Circuit 对象的移除方法
        removed_comp_details, removed_conn_count = self.memory_manager.circuit.remove_component(id_cleaned)
        logger.info(f"{tool_call_logger_prefix} 成功移除元件 '{id_cleaned}' 及其 {removed_conn_count} 个连接。")
        self.memory_manager.add_to_long_term(f"移除了元件: ID '{id_cleaned}', 类型 '{removed_comp_details.get('type', 'N/A')}' (请求ID: {self.current_request_id or 'N/A'})")
        return {"status": "success", "message": f"操作成功: 已移除元件 '{id_cleaned}' 及其所有 {removed_conn_count} 个连接。", "data": {"removed_component": removed_comp_details, "connections_removed_count": removed_conn_count}}
    except ValueError as ve_remove: # 来自 circuit.remove_component
        err_msg_val = str(ve_remove)
        logger.error(f"{tool_call_logger_prefix} 移除验证错误: {err_msg_val}")
        # 通常是元件不存在
        return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_REMOVAL", "technical_message": err_msg_val}}
    except Exception as e_remove:
        err_msg = f"移除元件时发生未知的内部错误: {e_remove}"
        logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
        return {"status": "failure", "message": "错误: 移除元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "REMOVE_COMPONENT_UNEXPECTED_FAILURE", "technical_message": str(e_remove), "exception_details": traceback.format_exc(limit=3)}}

@register_tool(
    description="断开两个指定元件之间的连接。如果它们之间原本就没有连接,则不执行任何操作。",
    parameters={"type": "object", "properties": {"comp1_id": {"type": "string", "description": "第一个元件的 ID。"}, "comp2_id": {"type": "string", "description": "第二个元件的 ID。"}}, "required": ["comp1_id", "comp2_id"]}
)
def disconnect_components_tool(self: 'CircuitAgent', arguments: Dict[str, Any]) -> Dict[str, Any]:
    tool_call_logger_prefix = f"[Action-DisconnectComponentsTool-ReqID:{self.current_request_id or 'N/A'}]"
    logger.info(f"{tool_call_logger_prefix} 执行断开元件连接操作。")
    logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
    comp1_id_req = arguments.get("comp1_id")
    comp2_id_req = arguments.get("comp2_id")

    if not comp1_id_req or not isinstance(comp1_id_req, str) or not comp1_id_req.strip() or \
       not comp2_id_req or not isinstance(comp2_id_req, str) or not comp2_id_req.strip():
        err_msg = "必须提供两个有效的、非空的元件 ID 字符串。"
        logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
        return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_IDS_FOR_DISCONNECTION", "technical_message": err_msg}}

    id1_cleaned = comp1_id_req.strip().upper()
    id2_cleaned = comp2_id_req.strip().upper()

    if id1_cleaned == id2_cleaned: # 不能断开自身与自身的连接（它们也不可能连接）
        err_msg = "不能断开一个元件与它自身的连接（它们本来就不可能连接）。"
        logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
        return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "SELF_DISCONNECTION_ATTEMPTED", "technical_message": err_msg}}
    
    try:
        # 在工具层面检查元件是否存在，Circuit.disconnect_components 本身可能不检查
        if id1_cleaned not in self.memory_manager.circuit.components:
            raise ValueError(f"元件 '{id1_cleaned}' 在电路中不存在,无法执行断开操作。")
        if id2_cleaned not in self.memory_manager.circuit.components:
            raise ValueError(f"元件 '{id2_cleaned}' 在电路中不存在,无法执行断开操作。")

        disconnected_successfully = self.memory_manager.circuit.disconnect_components(id1_cleaned, id2_cleaned)
        if disconnected_successfully:
            logger.info(f"{tool_call_logger_prefix} 成功断开连接: {id1_cleaned} <--> {id2_cleaned}。")
            self.memory_manager.add_to_long_term(f"断开了元件连接: {id1_cleaned} <--> {id2_cleaned} (请求ID: {self.current_request_id or 'N/A'})")
            return {"status": "success", "message": f"操作成功: 已断开元件 '{id1_cleaned}' 与 '{id2_cleaned}' 之间的连接。", "data": {"disconnected_pair": sorted((id1_cleaned, id2_cleaned))}}
        else:
            # 连接原本就不存在
            msg_not_exist = f"元件 '{id1_cleaned}' 和 '{id2_cleaned}' 之间原本就没有连接,无需断开。"
            logger.info(f"{tool_call_logger_prefix} 连接不存在: {msg_not_exist}")
            return {"status": "success", "message": f"注意: {msg_not_exist}", "data": {"disconnected_pair": sorted((id1_cleaned, id2_cleaned)), "already_disconnected_or_not_connected": True}}
    except ValueError as ve_disconnect: # 来自上面的元件存在性检查
        err_msg_val = str(ve_disconnect)
        logger.error(f"{tool_call_logger_prefix} 断开连接验证错误: {err_msg_val}")
        return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_DISCONNECTION", "technical_message": err_msg_val}}
    except Exception as e_disconnect:
        err_msg = f"断开元件连接时发生未知的内部错误: {e_disconnect}"
        logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
        return {"status": "failure", "message": "错误: 断开元件连接时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "DISCONNECT_COMPONENTS_UNEXPECTED_FAILURE", "technical_message": str(e_disconnect), "exception_details": traceback.format_exc(limit=3)}}

@register_tool(
    description="更新电路中一个已存在元件的值 (例如电阻的欧姆值, 电容的法拉值, 电池的电压等)。",
    parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要更新值的元件的 ID。"}, "new_value": {"type": "string", "description": "元件的新值。如果想要清除该元件的值,可以传入 null 或一个空字符串。"}}, "required": ["component_id", "new_value"]}
)
def update_component_value_tool(self: 'CircuitAgent', arguments: Dict[str, Any]) -> Dict[str, Any]:
    tool_call_logger_prefix = f"[Action-UpdateComponentValueTool-ReqID:{self.current_request_id or 'N/A'}]"
    logger.info(f"{tool_call_logger_prefix} 执行更新元件值操作。")
    logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
    component_id_req = arguments.get("component_id")
    new_value_req = arguments.get("new_value") # new_value 可以是 null (JSON) -> None (Python)

    if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
        err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
        logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
        return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_UPDATE", "technical_message": err_msg}}
    
    # new_value 可以是字符串或 None (用于清除值)。空字符串也会被处理成 None。
    if not isinstance(new_value_req, (str, type(None))):
        err_msg = f"元件的新值 'new_value' 必须是字符串或 null (用于清除值)。收到类型: {type(new_value_req).__name__}"
        logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
        return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "INVALID_NEW_VALUE_TYPE", "technical_message": err_msg}}

    id_cleaned = component_id_req.strip().upper()
    # 处理 new_value: 如果是 None 或清理后为空字符串，则设为 None，否则为清理后的字符串
    final_new_value = str(new_value_req).strip() if new_value_req is not None and str(new_value_req).strip() else None

    try:
        if id_cleaned not in self.memory_manager.circuit.components:
            raise ValueError(f"元件 '{id_cleaned}' 在电路中不存在,无法更新其值。")
        
        component_to_update = self.memory_manager.circuit.components[id_cleaned]
        old_value = component_to_update.value # 记录旧值用于消息反馈
        component_to_update.value = final_new_value # 直接更新 CircuitComponent 对象的 value 属性
        
        logger.info(f"{tool_call_logger_prefix} 成功更新元件 '{id_cleaned}' 的值从 '{old_value}' 到 '{final_new_value}'。")
        self.memory_manager.add_to_long_term(f"更新了元件 '{id_cleaned}' 的值: 旧值 '{old_value}', 新值 '{final_new_value}' (请求ID: {self.current_request_id or 'N/A'})")
        
        # 返回更新后的元件信息
        return {"status": "success", "message": f"操作成功: 元件 '{id_cleaned}' 的值已从 '{old_value if old_value else '(无值)'}' 更新为 '{final_new_value if final_new_value else '(无值)'}'。", "data": component_to_update.to_dict()}
    except ValueError as ve_update: # 来自上面的元件存在性检查
        err_msg_val = str(ve_update)
        logger.error(f"{tool_call_logger_prefix} 更新值验证错误: {err_msg_val}")
        return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_VALUE_UPDATE", "technical_message": err_msg_val}}
    except Exception as e_update:
        err_msg = f"更新元件值时发生未知的内部错误: {e_update}"
        logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
        return {"status": "failure", "message": "错误: 更新元件值时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "UPDATE_COMPONENT_VALUE_UNEXPECTED_FAILURE", "technical_message": str(e_update), "exception_details": traceback.format_exc(limit=3)}}

@register_tool(
    description="根据提供的 ID 查找电路中的一个特定元件,并返回其详细信息 (类型、ID、值)。",
    parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要查找的元件的 ID。"}}, "required": ["component_id"]}
)
def find_component_by_id_tool(self: 'CircuitAgent', arguments: Dict[str, Any]) -> Dict[str, Any]:
    tool_call_logger_prefix = f"[Action-FindComponentByIdTool-ReqID:{self.current_request_id or 'N/A'}]"
    logger.info(f"{tool_call_logger_prefix} 执行查找元件操作。")
    logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
    component_id_req = arguments.get("component_id")

    if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
        err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
        logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
        return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_FIND", "technical_message": err_msg}}

    id_cleaned = component_id_req.strip().upper()
    try:
        if id_cleaned in self.memory_manager.circuit.components:
            component_found = self.memory_manager.circuit.components[id_cleaned]
            logger.info(f"{tool_call_logger_prefix} 成功找到元件 '{id_cleaned}'。")
            return {"status": "success", "message": f"操作成功: 已找到元件 '{id_cleaned}'。", "data": component_found.to_dict()}
        else:
            # 元件未找到，这是一种预期的“失败”情况，但对于工具执行来说，应明确告知LLM
            logger.info(f"{tool_call_logger_prefix} 未找到元件 '{id_cleaned}'。")
            # 对于 "find" 操作，找不到元件通常不应是 status: "success"。
            # 应该返回一个明确的失败或未找到的状态，让LLM知道。
            # 原代码中没有明确的失败分支，这里补充。
            return {"status": "failure", "message": f"错误: 电路中不存在 ID 为 '{id_cleaned}' 的元件。", "error": {"error_type": "CIRCUIT_QUERY_ERROR", "error_code": "COMPONENT_NOT_FOUND_BY_ID", "technical_message": f"Component with ID '{id_cleaned}' not found in circuit."}}
    except Exception as e_find:
        err_msg = f"查找元件时发生未知的内部错误: {e_find}"
        logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
        return {"status": "failure", "message": "错误: 查找元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "FIND_COMPONENT_UNEXPECTED_FAILURE", "technical_message": str(e_find), "exception_details": traceback.format_exc(limit=3)}}

@register_tool(
    description="列出电路中所有属于指定类型的元件及其详细信息。",
    parameters={"type": "object", "properties": {"component_type": {"type": "string", "description": "要筛选的元件类型 (例如: '电阻', 'LED', '电池')。此匹配不区分大小写。"}}, "required": ["component_type"]}
)
def list_components_by_type_tool(self: 'CircuitAgent', arguments: Dict[str, Any]) -> Dict[str, Any]:
    tool_call_logger_prefix = f"[Action-ListComponentsByTypeTool-ReqID:{self.current_request_id or 'N/A'}]"
    logger.info(f"{tool_call_logger_prefix} 执行按类型列出元件操作。")
    logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
    component_type_req = arguments.get("component_type")

    if not component_type_req or not isinstance(component_type_req, str) or not component_type_req.strip():
        err_msg = "必须提供一个有效的、非空的元件类型字符串。"
        logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
        return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_TYPE_FOR_LIST", "technical_message": err_msg}}
    
    type_cleaned = component_type_req.strip().lower() # 类型匹配不区分大小写
    
    try:
        found_components = []
        for comp_id in self.memory_manager.circuit.components: # 遍历字典的键
            comp = self.memory_manager.circuit.components[comp_id]
            if comp.type.lower() == type_cleaned:
                found_components.append(comp.to_dict())
        
        if found_components:
            logger.info(f"{tool_call_logger_prefix} 成功找到 {len(found_components)} 个类型为 '{component_type_req}' 的元件。")
            return {"status": "success", "message": f"操作成功: 找到 {len(found_components)} 个类型为 '{component_type_req}' 的元件。", "data": {"components": found_components, "count": len(found_components)}}
        else:
            # 未找到匹配类型的元件，这是一种正常情况，应返回成功状态和空列表
            logger.info(f"{tool_call_logger_prefix} 未找到类型为 '{component_type_req}' 的元件。")
            return {"status": "success", "message": f"提示: 电路中没有找到类型为 '{component_type_req}' 的元件。", "data": {"components": [], "count": 0}}
    except Exception as e_list:
        err_msg = f"按类型列出元件时发生未知的内部错误: {e_list}"
        logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
        return {"status": "failure", "message": "错误: 按类型列出元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "LIST_COMPONENTS_UNEXPECTED_FAILURE", "technical_message": str(e_list), "exception_details": traceback.format_exc(limit=3)}}

@register_tool(
    description="获取指定元件当前连接到其他元件的数量。",
    parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要查询连接数量的元件的 ID。"}}, "required": ["component_id"]}
)
def get_component_connection_count_tool(self: 'CircuitAgent', arguments: Dict[str, Any]) -> Dict[str, Any]:
    tool_call_logger_prefix = f"[Action-GetComponentConnectionCountTool-ReqID:{self.current_request_id or 'N/A'}]"
    logger.info(f"{tool_call_logger_prefix} 执行获取元件连接数操作。")
    logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
    component_id_req = arguments.get("component_id")

    if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
        err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
        logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
        return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_CONNECTION_COUNT", "technical_message": err_msg}}

    id_cleaned = component_id_req.strip().upper()
    try:
        if id_cleaned not in self.memory_manager.circuit.components:
            raise ValueError(f"元件 '{id_cleaned}' 在电路中不存在,无法查询其连接数。")
        
        connection_count = 0
        # 遍历电路中的所有连接
        for conn_pair_tuple in self.memory_manager.circuit.connections:
            # conn_pair_tuple 是一个排序后的ID元组，例如 ('ID1', 'ID2')
            if id_cleaned in conn_pair_tuple:
                connection_count += 1
        
        logger.info(f"{tool_call_logger_prefix} 元件 '{id_cleaned}' 有 {connection_count} 个连接。")
        return {"status": "success", "message": f"操作成功: 元件 '{id_cleaned}' 当前有 {connection_count} 个连接。", "data": {"component_id": id_cleaned, "connection_count": connection_count}}
    except ValueError as ve_count: # 来自上面的元件存在性检查
        err_msg_val = str(ve_count)
        logger.error(f"{tool_call_logger_prefix} 获取连接数验证错误: {err_msg_val}")
        return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_QUERY_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_CONNECTION_COUNT", "technical_message": err_msg_val}}
    except Exception as e_count:
        err_msg = f"获取元件连接数时发生未知的内部错误: {e_count}"
        logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
        return {"status": "failure", "message": "错误: 获取元件连接数时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "GET_CONNECTION_COUNT_UNEXPECTED_FAILURE", "technical_message": str(e_count), "exception_details": traceback.format_exc(limit=3)}}
--- END: circuitmanus/tools/circuit_ops.py ---

--- START: circuitmanus/tools/executor.py ---
# IDT_AGENT_Pro/circuitmanus/tools/executor.py
import asyncio
import json
import logging
import traceback
import inspect # 用于检查工具方法是否为协程
from uuid import uuid4
from typing import List, Dict, Any, Optional, Callable, Awaitable

# 再次使用 TYPE_CHECKING 来避免直接的循环导入
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ..agent import CircuitAgent # 指向 agent.py 中的 CircuitAgent
    from ..memory.manager import MemoryManager # 指向 memory/manager.py 中的 MemoryManager

logger = logging.getLogger(__name__)

class ToolExecutor:
    """
    ToolExecutor (工具执行器) - V1.0.0 (深化修复异步调用)
    负责根据LLM的规划，执行一个或多个工具调用。
    它处理工具的查找、参数传递、执行 (包括异步工具的 await)、结果收集、
    重试逻辑、以及向UI发送状态更新。
    """
    def __init__(self, 
                 agent_instance: 'CircuitAgent', 
                 max_tool_retries: int = 3, # 与原代码 agent.__init__ 默认值不同，原为3
                 tool_retry_delay_seconds: float = 10.0):
        """
        初始化 ToolExecutor。

        Args:
            agent_instance (CircuitAgent): 对 CircuitAgent 主实例的引用。
                                           工具方法通常是 Agent 实例的方法。
            max_tool_retries (int): 单个工具执行失败时的最大重试次数。
            tool_retry_delay_seconds (float): 工具重试之间的延迟时间 (秒)。

        Raises:
            TypeError: 如果 agent_instance 不是 CircuitAgent 类型或缺少 MemoryManager。
        """
        # 在运行时进行类型检查，确保 agent_instance 的有效性
        # 注意：由于 'CircuitAgent' 可能尚未完全定义（如果此文件先被导入），
        # 这里的 isinstance 检查可能需要在 agent_instance 确实是 CircuitAgent 的最终实现后才可靠。
        # 更稳妥的方式是检查 agent_instance 是否具有预期的属性/方法。
        # from ..agent import CircuitAgent # 延迟导入以进行运行时检查
        # if not isinstance(agent_instance, CircuitAgent): # 这行可能会导致循环导入
        #    raise TypeError("ToolExecutor 需要一个 CircuitAgent 实例。")
        # 改为检查核心依赖
        if not hasattr(agent_instance, 'memory_manager') or \
           not hasattr(agent_instance, 'api_key'): # api_key 只是一个例子，代表它是 Agent
            # from ..memory.manager import MemoryManager # 延迟导入
            # if not isinstance(getattr(agent_instance, 'memory_manager', None), MemoryManager):
            #    raise TypeError("Agent 实例缺少有效的 MemoryManager。")
            # 上述 isinstance 检查同样有循环导入风险，改为鸭子类型检查或相信调用者
            logger.warning("[ToolExecutor] 初始化时 agent_instance 类型未严格校验为 CircuitAgent，依赖于调用者确保其兼容性。")


        logger.info("[ToolExecutor] 初始化工具执行器 (支持异步, 重试, 失败中止, UI回调增强 V1.0.0)。")
        self.agent_instance: 'CircuitAgent' = agent_instance
        
        # 获取 MemoryManager 的引用，虽然当前 ToolExecutor 本身不直接用，但这是 Agent 的核心组件
        # 保留此检查是为了与原代码结构对齐，并可能用于未来扩展
        if not hasattr(agent_instance, 'memory_manager'): # 再次检查以防万一
             raise TypeError("Agent 实例在 ToolExecutor 初始化时必须具有 'memory_manager' 属性。")
        # from ..memory.manager import MemoryManager # 延迟导入
        # if not isinstance(self.agent_instance.memory_manager, MemoryManager):
        #    raise TypeError("Agent 实例的 'memory_manager' 不是有效的 MemoryManager 类型。")


        self.verbose_mode: bool = getattr(agent_instance, 'verbose_mode', True) # 从Agent获取详细模式设置
        self.max_tool_retries: int = max(0, max_tool_retries) # 确保非负
        self.tool_retry_delay_seconds: float = max(0.1, tool_retry_delay_seconds) # 确保有最小延迟

        logger.info(f"[ToolExecutor] 工具执行配置: 每个工具最多重试 {self.max_tool_retries} 次,重试间隔 {self.tool_retry_delay_seconds} 秒。详细模式: {self.verbose_mode}。")

    async def _send_tool_status_update(
        self,
        status_callback: Optional[Callable[[Dict], Awaitable[None]]],
        tool_call_id: str,
        tool_name: str,
        tool_status: str, # e.g., "running", "succeeded", "failed", "retrying", "aborted_..."
        message: str,
        tool_arguments: Optional[Dict] = None,
        details: Optional[Dict] = None
    ) -> None:
        """
        内部辅助方法：发送工具执行状态更新到UI回调。
        """
        if status_callback:
            # 从 Agent 实例获取当前的请求ID
            request_id_to_send = getattr(self.agent_instance, 'current_request_id', None)
            
            arguments_summary_str = "N/A"
            if tool_arguments:
                try:
                    args_parts = []
                    for k, v in tool_arguments.items():
                        v_str = str(v) if v is not None else "None"
                        # 截断过长的参数值以优化状态消息
                        v_preview = v_str[:30] + '...' if len(v_str) > 30 else v_str
                        args_parts.append(f"{k}: {v_preview}")
                    arguments_summary_str = "; ".join(args_parts)
                    if not arguments_summary_str: arguments_summary_str = "(无参数)"
                except Exception as e_sum:
                    logger.warning(f"生成工具参数摘要时出错: {e_sum}")
                    arguments_summary_str = "(参数摘要生成错误)"
            
            update_payload = {
                "type": "tool_status_update",
                "request_id": request_id_to_send,
                "tool_call_id": tool_call_id,
                "tool_name": tool_name,
                "tool_arguments_summary_str": arguments_summary_str,
                "status": tool_status,
                "message": message,
                "details": details if details else {}
            }
            try:
                await status_callback(update_payload)
            except Exception as e_cb:
                logger.error(f"发送工具状态更新回调失败 (Tool: {tool_name}, Status: {tool_status}): {e_cb}", exc_info=True)


    async def execute_tool_calls(self, 
                                 tool_call_requests_from_plan: List[Dict[str, Any]], 
                                 status_callback: Optional[Callable[[Dict], Awaitable[None]]] = None
                                 ) -> List[Dict[str, Any]]:
        """
        执行LLM规划的一系列工具调用请求。

        Args:
            tool_call_requests_from_plan (List[Dict[str, Any]]): 
                一个列表，其中每个字典代表一个工具调用请求。
                每个请求字典应包含 "toolCallId", "toolName", "toolArguments", 和可选的 "uiHints"。
            status_callback (Optional[Callable[[Dict], Awaitable[None]]]): 
                用于发送实时状态更新的异步回调函数。

        Returns:
            List[Dict[str, Any]]: 
                一个列表，其中每个字典是符合LLM历史记录格式的工具结果消息。
                例如: {"role": "tool", "tool_call_id": ..., "name": ..., "content": JSON_string_of_result}
                如果某个工具失败并导致后续工具中止，中止的工具也会有对应的失败结果条目。
        """
        # 为本次执行批次生成唯一ID，方便日志追踪
        executor_id = f"exec_v1_1_3_{str(uuid4())[:8]}" 
        logger.info(f"[{executor_id}-ToolExecutor] 准备异步执行 {len(tool_call_requests_from_plan)} 个工具调用请求 (V1.0.0)...")
        
        execution_results_for_llm_history: List[Dict[str, Any]] = []

        if not tool_call_requests_from_plan:
            logger.info(f"[{executor_id}-ToolExecutor] 没有工具需要执行。")
            return []

        total_tools_in_plan = len(tool_call_requests_from_plan)

        for i, tool_request in enumerate(tool_call_requests_from_plan):
            # 从LLM的计划中提取工具调用信息
            llm_generated_tool_call_id = tool_request.get('toolCallId', f'fallback_tool_id_{str(uuid4())[:8]}')
            python_function_name = tool_request.get('toolName', 'unknown_function')
            parsed_arguments = tool_request.get('toolArguments', {}) # LLM提供的参数
            ui_hints_from_plan = tool_request.get('uiHints', {}) # LLM提供的UI提示
            
            # 构造一个用户友好的工具显示名称
            tool_display_name = ui_hints_from_plan.get('displayNameForTool') or \
                                python_function_name.replace('_tool', '').replace('_', ' ').title()

            action_result_final_for_tool: Optional[Dict[str, Any]] = None # 存储此工具最终的执行结果
            
            logger.info(f"[{executor_id}-ToolExecutor] 处理工具调用 {i + 1}/{total_tools_in_plan}: Name='{python_function_name}', LLM_ToolCallID='{llm_generated_tool_call_id}'。")
            logger.debug(f"[{executor_id}-ToolExecutor] 待执行工具 '{python_function_name}' 的参数: {parsed_arguments}。")

            # 发送 "正在运行" 状态更新
            await self._send_tool_status_update(
                status_callback, 
                llm_generated_tool_call_id, 
                python_function_name,
                "running", # 状态: 正在运行
                f"开始执行操作: {tool_display_name}...",
                tool_arguments=parsed_arguments,
                details={"ui_hints": ui_hints_from_plan}
            )

            # 从 Agent 实例中获取实际的工具方法
            tool_action_method = getattr(self.agent_instance, python_function_name, None)
            
            # 检查工具方法是否存在且是否被 @register_tool 正确标记
            if not callable(tool_action_method) or not getattr(tool_action_method, '_is_tool', False):
                err_msg_not_found = f"Agent 未实现名为 '{python_function_name}' 的已注册工具方法 (ID: {llm_generated_tool_call_id})。"
                logger.error(f"[{executor_id}-ToolExecutor] 工具未实现或未注册: {err_msg_not_found}")
                action_result_final_for_tool = {
                    "status": "failure", 
                    "message": err_msg_not_found, 
                    "error": {
                        "error_type": "TOOL_IMPLEMENTATION_ERROR", 
                        "error_code": "TOOL_NOT_FOUND_OR_NOT_REGISTERED", 
                        "technical_message": f"Action method '{python_function_name}' not found or not a registered tool in Agent."
                    }
                }
            else: # 工具方法有效，开始执行（包括重试逻辑）
                for retry_attempt in range(self.max_tool_retries + 1): # +1 因为第一次尝试不算重试
                    current_attempt_num = retry_attempt + 1 # 尝试编号从1开始
                    
                    if retry_attempt > 0: # 如果是重试
                        logger.warning(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 执行失败,正在进行第 {retry_attempt}/{self.max_tool_retries} 次重试...")
                        await self._send_tool_status_update(
                            status_callback, 
                            llm_generated_tool_call_id, 
                            python_function_name,
                            "retrying", # 状态: 正在重试
                            f"操作 '{tool_display_name}' 失败,等待 {self.tool_retry_delay_seconds} 秒后重试 (尝试 {current_attempt_num})...",
                            tool_arguments=parsed_arguments, 
                            details={"retry_count": retry_attempt, "max_retries": self.max_tool_retries, "ui_hints": ui_hints_from_plan}
                        )
                        await asyncio.sleep(self.tool_retry_delay_seconds) # 等待一段时间再重试

                    action_result_this_attempt: Optional[Dict[str, Any]] = None
                    try:
                        # 检查工具方法是同步还是异步
                        # inspect.iscoroutinefunction 需要检查原始函数，@functools.wraps 很重要
                        is_coro = inspect.iscoroutinefunction(tool_action_method)
                        logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) 调用工具 '{python_function_name}'. 是否为协程: {is_coro}.")
                        
                        if is_coro:
                            # 如果是异步工具，直接 await 调用
                            # 工具方法被期望接收一个名为 'arguments' 的字典参数
                            logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) 直接 awaiting coroutine: {python_function_name} with args: {parsed_arguments}")
                            action_result_this_attempt = await tool_action_method(arguments=parsed_arguments)
                        else:
                            # 如果是同步工具，使用 asyncio.to_thread 在单独线程中运行，避免阻塞事件循环
                            logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) running sync tool in thread: {python_function_name} with args: {parsed_arguments}")
                            action_result_this_attempt = await asyncio.to_thread(tool_action_method, arguments=parsed_arguments)
                        
                        logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) 工具 '{python_function_name}' 返回结果类型: {type(action_result_this_attempt)}, 内容预览: {str(action_result_this_attempt)[:500]}...")

                        # 校验工具返回结果的基本结构 (是否为字典，是否包含 'status' 和 'message')
                        if not isinstance(action_result_this_attempt, dict) or \
                           'status' not in action_result_this_attempt or \
                           'message' not in action_result_this_attempt:
                            err_msg_struct = f"工具 '{python_function_name}' 返回的内部结果结构无效。期望字典包含 'status' 和 'message'。"
                            logger.error(f"[{executor_id}-ToolExecutor] 工具返回结构错误 (尝试 {current_attempt_num}): {err_msg_struct}. 实际返回类型: {type(action_result_this_attempt)}, 内容(部分): {str(action_result_this_attempt)[:200]}")
                            # 强制转换为标准的失败结构，以便统一处理
                            action_result_this_attempt = { 
                                "status": "failure", 
                                "message": f"错误: 工具 '{python_function_name}' 内部返回结果结构无效。", 
                                "error": {
                                    "error_type": "TOOL_IMPLEMENTATION_ERROR", 
                                    "error_code": "INVALID_TOOL_ACTION_RESULT_STRUCTURE", 
                                    "technical_message": err_msg_struct, 
                                    "actual_return_type": str(type(action_result_this_attempt)), 
                                    "actual_return_preview": str(action_result_this_attempt)[:200]
                                }
                            }
                        else:
                            logger.info(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' 执行完毕 (尝试 {current_attempt_num})。状态: {action_result_this_attempt.get('status', 'N/A')}。")

                        # 检查工具执行是否成功
                        if action_result_this_attempt.get("status") == "success":
                            action_result_final_for_tool = action_result_this_attempt
                            break # 成功执行，跳出重试循环
                        else: # status 不是 "success" (例如 "failure" 或其他自定义失败状态)
                            logger.warning(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 执行失败 (尝试 {current_attempt_num})。报告状态: {action_result_this_attempt.get('status')}, 消息: {action_result_this_attempt.get('message')}")
                            action_result_final_for_tool = action_result_this_attempt # 保存本次失败的结果，如果后续重试都失败，这将是最终结果

                    except TypeError as te:
                        # 通常是工具方法期望的参数与LLM提供的参数不匹配 (例如数量、名称或类型)
                        # 或者工具内部在处理参数时发生类型错误
                        err_msg_type = f"调用工具 '{python_function_name}' 时参数不匹配或内部类型错误: {te}。"
                        logger.error(f"[{executor_id}-ToolExecutor] 工具调用参数/类型错误 (尝试 {current_attempt_num}): {err_msg_type}", exc_info=True)
                        action_result_final_for_tool = {
                            "status": "failure", 
                            "message": f"错误: 调用工具 '{python_function_name}' 时参数或内部类型错误。", 
                            "error": {
                                "error_type": "TOOL_EXECUTION_ERROR", 
                                "error_code": "ARGUMENT_TYPE_MISMATCH_OR_INTERNAL_TYPE_ERROR", 
                                "technical_message": err_msg_type, 
                                "exception_details": traceback.format_exc(limit=3) # 包含部分堆栈信息
                            }
                        }
                        break # 参数错误通常是结构性问题，重试意义不大，直接跳出重试
                    except Exception as exec_err:
                        # 工具执行过程中发生未预期的其他异常
                        err_msg_exec = f"工具 '{python_function_name}' 执行期间发生意外内部错误 (尝试 {current_attempt_num}): {exec_err}"
                        logger.error(f"[{executor_id}-ToolExecutor] 工具执行内部错误: {err_msg_exec}", exc_info=True)
                        action_result_final_for_tool = {
                            "status": "failure", 
                            "message": f"错误: 执行工具 '{python_function_name}' 时发生内部错误。", 
                            "error": {
                                "error_type": "UNEXPECTED_TOOL_ERROR", 
                                "error_code": "UNEXPECTED_TOOL_EXECUTION_FAILURE", 
                                "technical_message": err_msg_exec, 
                                "exception_details": traceback.format_exc(limit=3)
                            }
                        }
                        # 对于未知错误，重试可能有效，所以不在这里 break，让重试循环继续（除非是最后一次尝试）
                    
                    # 如果这是最后一次允许的尝试 (包括初次尝试和所有重试)
                    if retry_attempt == self.max_tool_retries:
                        # 无论这次尝试是成功还是失败，它都将是此工具的最终结果
                        # action_result_final_for_tool 已经被设为最后一次尝试的结果
                        break # 退出重试循环

            # 确保 action_result_final_for_tool 有值 (理论上在循环结束后应该总是有值的)
            if action_result_final_for_tool is None:
                 # 这是一个防御性代码，正常逻辑下不应到达这里
                 logger.error(f"[{executor_id}-ToolExecutor] 内部逻辑错误: 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 在所有重试后 action_result_final_for_tool 仍为 None。")
                 action_result_final_for_tool = {
                     "status": "failure", 
                     "message": f"错误: 工具 '{python_function_name}' 未能确定最终结果。", 
                     "error": {
                         "error_type": "TOOL_EXECUTION_ERROR", 
                         "error_code": "MISSING_TOOL_RESULT_LOGIC_ERROR", 
                         "technical_message": "Tool action_result_final_for_tool was None after retry loop."
                        }
                    }

            # 判断此工具最终是否成功
            tool_succeeded_this_cycle = (action_result_final_for_tool.get("status") == "success")

            # 发送最终状态更新 (成功或失败)
            final_tool_status_str_for_cb = "succeeded" if tool_succeeded_this_cycle else "failed"
            status_message_for_cb = action_result_final_for_tool.get('message', '操作处理完成,但无特定消息。')
            
            details_for_cb: Dict[str, Any] = {"ui_hints": ui_hints_from_plan}
            if not tool_succeeded_this_cycle: # 如果失败，附带错误信息
                details_for_cb["error"] = action_result_final_for_tool.get("error", {"error_type": "UNKNOWN_FAILURE", "technical_message": "工具最终失败,无详细错误信息。"})
            elif action_result_final_for_tool.get("data") is not None: # 如果成功且有数据，预览数据
                 try: 
                     # 尝试序列化数据并预览，避免状态消息过大
                     details_for_cb["result_data_preview"] = json.dumps(action_result_final_for_tool["data"], ensure_ascii=False, default=str, indent=None)[:1000]
                 except Exception: 
                     details_for_cb["result_data_preview"] = "(工具返回的 data 字段无法序列化进行预览)"

            await self._send_tool_status_update(
                status_callback, 
                llm_generated_tool_call_id, 
                python_function_name,
                final_tool_status_str_for_cb, 
                status_message_for_cb,
                tool_arguments=parsed_arguments, # 再次发送参数，以便UI在最终状态时仍能看到
                details=details_for_cb
            )

            # 构建用于LLM历史记录的工具结果消息
            tool_result_message_for_llm = {
                "role": "tool",
                "tool_call_id": llm_generated_tool_call_id, # 必须与LLM规划中的toolCallId对应
                "name": python_function_name, # 工具的名称
                "content": json.dumps(action_result_final_for_tool, ensure_ascii=False, default=str) # 将工具的完整结果 (包括status, message, error, data) 序列化为JSON字符串
            }
            execution_results_for_llm_history.append(tool_result_message_for_llm)
            logger.debug(f"[{executor_id}-ToolExecutor] 已记录工具 '{llm_generated_tool_call_id}' 的最终执行结果 (状态: {final_tool_status_str_for_cb}) 到LLM历史。")

            # 如果此工具执行失败，则中止后续所有工具的执行 (串行执行的关键逻辑)
            if not tool_succeeded_this_cycle:
                logger.warning(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 在所有重试后仍然失败。将中止后续计划中的工具执行。")
                # 如果当前失败的工具不是计划中的最后一个工具
                if i + 1 < total_tools_in_plan:
                    for k_aborted in range(i + 1, total_tools_in_plan):
                        aborted_tool_req = tool_call_requests_from_plan[k_aborted]
                        aborted_tool_id = aborted_tool_req.get('toolCallId', f'fallback_aborted_id_{str(uuid4())[:8]}')
                        aborted_tool_name = aborted_tool_req.get('toolName', 'unknown_aborted_tool')
                        aborted_ui_hints = aborted_tool_req.get('uiHints', {})
                        aborted_tool_display_name = aborted_ui_hints.get('displayNameForTool') or \
                                                    aborted_tool_name.replace('_tool','').replace('_',' ').title()

                        # 为被中止的工具发送状态更新
                        await self._send_tool_status_update(
                            status_callback, 
                            aborted_tool_id, 
                            aborted_tool_name,
                            "aborted_due_to_previous_failure", # 特殊状态
                            f"操作 '{aborted_tool_display_name}' 已中止,因为先前的工具 '{tool_display_name}' 执行失败。",
                            tool_arguments=aborted_tool_req.get('toolArguments',{}), # 发送其原计划参数
                            details={
                                "reason": f"Aborted due to failure of tool '{python_function_name}' (ID: {llm_generated_tool_call_id})", 
                                "ui_hints": aborted_ui_hints
                            }
                        )
                        # 为被中止的工具也生成一个失败的LLM历史记录条目
                        aborted_tool_result_for_llm_content = {
                                "status": "failure",
                                "message": f"工具 '{aborted_tool_name}' 未执行,因为前序工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 失败。",
                                "error": {
                                    "error_type": "TOOL_CHAIN_ABORTED", 
                                    "error_code": "PRECEDING_TOOL_FAILURE", 
                                    "technical_message": f"Execution of '{aborted_tool_name}' was skipped due to the failure of tool '{python_function_name}' (ID: {llm_generated_tool_call_id})."
                                }
                            }
                        execution_results_for_llm_history.append({
                            "role": "tool", 
                            "tool_call_id": aborted_tool_id, 
                            "name": aborted_tool_name,
                            "content": json.dumps(aborted_tool_result_for_llm_content, ensure_ascii=False)
                        })
                        logger.info(f"[{executor_id}-ToolExecutor] 为中止的工具 '{aborted_tool_name}' (ID: {aborted_tool_id}) 添加了模拟失败记录到LLM历史。")
                break # 跳出主工具循环，不再执行后续工具

        total_processed_tools = len(execution_results_for_llm_history)
        logger.info(f"[{executor_id}-ToolExecutor] 工具执行流程完成。共处理/记录了 {total_processed_tools}/{total_tools_in_plan} 个计划中的工具调用 (可能因失败提前中止)。")
        return execution_results_for_llm_history
--- END: circuitmanus/tools/executor.py ---

--- START: circuitmanus/tools/web_search.py ---
# IDT_AGENT_NATIVE/circuitmanus/tools/web_search.py
import os # 需要导入 os 来读取环境变量
import asyncio
import json
import logging
import traceback
from typing import Dict, Any, List, TYPE_CHECKING, Optional # 导入 Optional 和 List

from duckduckgo_search import DDGS # 仅导入 DDGS，这是核心功能

# --- SerpApi 相关导入和可用性检查 ---
SERPAPI_AVAILABLE = False
GoogleSearch = None # 初始化为None
try:
    from serpapi import GoogleSearch # type: ignore
    SERPAPI_AVAILABLE = True
    logger_serp_init = logging.getLogger(__name__) # 在 try 块内获取 logger
    logger_serp_init.info("SerpApi client (google-search-results) 导入成功。serpapi_google_search_tool 将可用 (如果配置了API Key)。")
except ImportError:
    # 如果导入失败，也需要一个 logger 实例来记录警告
    # 确保 logger 在任何情况下都已初始化
    logging.getLogger(__name__).warning( # 直接使用 logging.getLogger
        "SerpApi client (google-search-results) 未安装。"
        "serpapi_google_search_tool 将不可用。"
        "请运行 'pip install google-search-results' 来安装它。"
    )
    # GoogleSearch 保持为 None

from .base import register_tool

if TYPE_CHECKING:
    from ..agent import CircuitAgent 
    from ..utils.config_loader import ConfigLoader # 导入 ConfigLoader 类型提示

logger = logging.getLogger(__name__) # 模块级 logger

@register_tool(
    description="使用 DuckDuckGo 搜索引擎在互联网上搜索与给定查询词相关的信息。用于获取通用知识、技术细节或背景资料。如果遇到速率限制，可能会失败。",
    parameters={
        "type": "object",
        "properties": {
            "query": {"type": "string", "description": "要搜索的关键词或问题。"},
            "num_results": {"type": "integer", "description": "期望返回的搜索结果数量 (例如: 1 到 10)。如果未提供或无效,将使用配置文件中的默认值 (通常是3)。"}
        },
        "required": ["query"]
    }
)
async def duckduckgo_search_tool(self: 'CircuitAgent', arguments: Dict[str, Any]) -> Dict[str, Any]:
    """
    Agent工具：使用 DuckDuckGo 进行网络搜索。
    现在会从配置中读取默认结果数和超时时间。
    """
    tool_call_logger_prefix = f"[Action-DuckDuckGoSearchTool-ReqID:{self.current_request_id or 'N/A'}]"
    logger.info(f"{tool_call_logger_prefix} 执行 DuckDuckGo 搜索操作 (Configurable)...")
    
    query = arguments.get("query")
    num_results_from_llm = arguments.get("num_results") 
    
    logger.debug(f"{tool_call_logger_prefix} 收到搜索查询: '{query}', LLM请求结果数: {num_results_from_llm}。")

    tool_result = { 
        "status": "failure", 
        "message": "DuckDuckGo 搜索工具发生未知内部错误。", 
        "error": { "error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "DUCKDUCKGO_TOOL_UNKNOWN_FAILURE", 
                   "technical_message": "Tool did not complete successfully." }
    }

    if not query or not isinstance(query, str) or not query.strip():
        err_msg = "必须提供一个有效的、非空的搜索查询词。"
        logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
        tool_result["message"] = f"错误: {err_msg}"
        tool_result["error"] = {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_SEARCH_QUERY", "technical_message": err_msg}
        return tool_result

    config_loader: 'ConfigLoader' = self.config_loader 
    
    default_num_results_cfg = config_loader.get_config(
        "agent_settings.tools.specific_tools.duckduckgo_search.default_num_results", 3
    )
    timeout_seconds_cfg = config_loader.get_config(
        "agent_settings.tools.specific_tools.duckduckgo_search.timeout_seconds", 20
    )
    # (可选) 如果需要从配置读取 region 和 safesearch
    # region_cfg = config_loader.get_config("agent_settings.tools.specific_tools.duckduckgo_search.region", "wt-wt")
    # safe_search_cfg = config_loader.get_config("agent_settings.tools.specific_tools.duckduckgo_search.safe_search", "moderate")


    num_results_to_fetch: int
    if num_results_from_llm is not None:
        if isinstance(num_results_from_llm, int) and 1 <= num_results_from_llm <= 10:
            num_results_to_fetch = num_results_from_llm
            logger.debug(f"{tool_call_logger_prefix} 使用LLM提供的结果数: {num_results_to_fetch}.")
        else:
            logger.warning(f"{tool_call_logger_prefix} LLM提供的 num_results ('{num_results_from_llm}') 无效或超出范围(1-10)。将使用配置的默认值: {default_num_results_cfg}.")
            num_results_to_fetch = default_num_results_cfg
    else: 
        num_results_to_fetch = default_num_results_cfg
        logger.debug(f"{tool_call_logger_prefix} LLM未提供结果数，使用配置的默认值: {num_results_to_fetch}.")
            
    search_results_list: List[Dict[str, Any]] = [] # 明确类型提示
    try:
        def sync_ddgs_operation(current_query: str, max_r: int, timeout_s: int) -> List[Dict[str, Any]]: # 返回类型调整
            _internal_results: List[Dict[str, Any]] = []
            logger.debug(f"{tool_call_logger_prefix} [sync_ddgs_op_internal] 开始DDGS同步搜索: query='{current_query}', max_results={max_r}, timeout={timeout_s}s")
            
            with DDGS(timeout=float(timeout_s)) as ddgs_instance: 
                # ddgs_params_for_sdk = {}
                # if region_cfg: ddgs_params_for_sdk["region"] = region_cfg
                # if safe_search_cfg: ddgs_params_for_sdk["safesearch"] = safe_search_cfg
                # # ... 其他可能的参数
                # fetched_results_iterator = ddgs_instance.text(keywords=current_query, max_results=max_r, **ddgs_params_for_sdk)
                fetched_results_iterator = ddgs_instance.text(keywords=current_query, max_results=max_r) # 保持简单
                
                count = 0
                for r_item in fetched_results_iterator:
                    if count >= max_r: 
                        break
                    _internal_results.append({
                        "title": str(r_item.get('title', 'N/A')), 
                        "snippet": str(r_item.get('body', 'N/A')), 
                        "link": str(r_item.get('href', '#'))      
                    })
                    count += 1
            logger.debug(f"{tool_call_logger_prefix} [sync_ddgs_op_internal] DDGS内部处理后得到 {len(_internal_results)} 个结果。")
            return _internal_results

        logger.debug(f"{tool_call_logger_prefix} 准备将同步DDGS操作 (query='{query}', num_results={num_results_to_fetch}, timeout={timeout_seconds_cfg}s) 提交到线程池...")
        search_results_list = await asyncio.to_thread(sync_ddgs_operation, query, num_results_to_fetch, timeout_seconds_cfg)
        logger.debug(f"{tool_call_logger_prefix} 同步DDGS操作完成，从线程返回了 {len(search_results_list)} 个结果。")

        search_results_json_str = json.dumps(search_results_list, ensure_ascii=False)
        success_message = f"已成功完成对“{query}”的 DuckDuckGo 搜索,找到 {len(search_results_list)} 条相关信息。"
        logger.info(f"{tool_call_logger_prefix} {success_message}")
        
        self.memory_manager.add_to_long_term(f"执行了 DuckDuckGo 搜索,查询词: '{query}', 返回了 {len(search_results_list)} 条结果 (请求ID: {self.current_request_id or 'N/A'})。")
        
        tool_result = {
            "status": "success",
            "message": success_message,
            "data": { 
                "query": query,
                "num_results_requested": num_results_to_fetch, 
                "num_results_returned": len(search_results_list), 
                "results_json_string": search_results_json_str 
            }
        }
        return tool_result
    
    except Exception as e_search: 
        err_msg = f"使用 DuckDuckGo 搜索时发生错误: {e_search}"
        logger.error(f"{tool_call_logger_prefix} {err_msg}", exc_info=True) 
        
        error_code = "DUCKDUCKGO_SEARCH_UNEXPECTED_FAILURE"
        error_type = "UNEXPECTED_TOOL_ERROR"

        # 尝试从错误消息中识别 Ratelimit (与您原版一致)
        # 注意：这种基于字符串匹配的错误识别可能不够稳健，如果库的错误消息格式改变，这里可能失效。
        # 更稳健的方式是捕获库抛出的特定异常类型（如果库有定义的话）。
        if "Ratelimit" in str(e_search).lower() or "rate limit" in str(e_search).lower() or \
           "429" in str(e_search) or "202" in str(e_search): # 扩展匹配条件
            error_code = "DUCKDUCKGO_RATELIMIT_ERROR"
            error_type = "EXTERNAL_SERVICE_ERROR"
            # 提供更具体的错误消息给用户或LLM
            err_msg = f"DuckDuckGo 搜索请求可能过于频繁或服务暂时受限。请稍后再试。 (原始错误: {e_search})"

        tool_result["message"] = f"错误: {err_msg}" 
        tool_result["error"] = {
            "error_type": error_type, 
            "error_code": error_code, 
            "technical_message": str(e_search), 
            "exception_details": traceback.format_exc(limit=3) 
            }
        return tool_result

# --- SerpApi Google 搜索工具 (保持与您原版一致的逻辑) ---
@register_tool(
    description="使用 SerpApi 通过 Google 搜索引擎在互联网上搜索信息。需要有效的 SerpApi API Key 配置。用于获取通用知识、技术细节或当 DuckDuckGo 不可用时作为备选。",
    parameters={
        "type": "object",
        "properties": {
            "query": {"type": "string", "description": "要搜索的关键词或问题。"},
            "num_results": {"type": "integer", "description": "期望返回的搜索结果数量 (例如: 1 到 10)。如果未提供或无效,默认为5。SerpApi的 'num' 参数控制返回结果。"}
        },
        "required": ["query"]
    }
)
async def serpapi_google_search_tool(self: 'CircuitAgent', arguments: Dict[str, Any]) -> Dict[str, Any]:
    tool_call_logger_prefix = f"[Action-SerpApiGoogleSearchTool-ReqID:{self.current_request_id or 'N/A'}]"
    logger.info(f"{tool_call_logger_prefix} 执行 SerpApi Google 搜索操作。")
    
    query = arguments.get("query")
    num_results_req = arguments.get("num_results")
    logger.debug(f"{tool_call_logger_prefix} 收到搜索查询: '{query}', 期望结果数 (原始请求): {num_results_req}。")

    tool_result = { # 标准返回结构
        "status": "failure",
        "message": "SerpApi Google 搜索工具初始化或执行失败。",
        "error": {"error_type": "TOOL_SETUP_OR_EXECUTION_ERROR", "error_code": "SERPAPI_UNKNOWN_FAILURE", "technical_message": "Tool did not complete successfully."}
    }

    if not SERPAPI_AVAILABLE: # 检查库是否成功导入
        err_msg = "SerpApi 客户端库 (google-search-results) 未安装或无法导入。"
        logger.error(f"{tool_call_logger_prefix} {err_msg}")
        tool_result["message"] = f"错误: {err_msg} Agent无法使用此工具。"
        tool_result["error"] = {"error_type": "TOOL_SETUP_ERROR", "error_code": "SERPAPI_LIBRARY_MISSING", "technical_message": err_msg}
        return tool_result

    # 从环境变量（由 ConfigLoader 辅助加载）获取 SerpApi Key
    # 注意：self.config_loader 是 Agent 的属性
    serpapi_api_key = self.config_loader.get_env_var("SERPAPI_API_KEY") 
    if not serpapi_api_key:
        err_msg = "SerpApi API Key (SERPAPI_API_KEY) 未在环境变量中设置。"
        logger.error(f"{tool_call_logger_prefix} {err_msg}")
        tool_result["message"] = f"错误: {err_msg} Agent无法使用此工具。"
        tool_result["error"] = {"error_type": "TOOL_SETUP_ERROR", "error_code": "SERPAPI_API_KEY_MISSING", "technical_message": err_msg}
        return tool_result

    if not query or not isinstance(query, str) or not query.strip():
        err_msg = "必须提供一个有效的、非空的搜索查询词。"
        logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
        tool_result["message"] = f"错误: {err_msg}"
        tool_result["error"] = {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_SEARCH_QUERY", "technical_message": err_msg}
        return tool_result

    # SerpApi 的结果数和超时也可以从配置中读取，如果需要的话
    # 例如： default_num_results_serpapi = self.config_loader.get_config("agent_settings.tools.specific_tools.serpapi_google.default_num_results", 5)
    # timeout_serpapi = self.config_loader.get_config("agent_settings.tools.specific_tools.serpapi_google.timeout_seconds", 30)
    # 这里暂时使用您原版的默认值和范围
    num_results_actual = 5 
    if num_results_req is not None:
        if isinstance(num_results_req, int) and 1 <= num_results_req <= 20: # SerpApi 的 'num' 通常支持到100，但这里保守一些
            num_results_actual = num_results_req
        else:
            logger.warning(f"{tool_call_logger_prefix} num_results 参数 '{num_results_req}' 无效或超出范围(1-20 for SerpApi), 将使用默认值 {num_results_actual}。")
    else:
        logger.debug(f"{tool_call_logger_prefix} 未提供 num_results 参数, 将使用默认值 {num_results_actual}。")

    search_params = {
        "q": query,
        "api_key": serpapi_api_key,
        "num": str(num_results_actual),  # SerpApi 的 num 参数期望是字符串
        "hl": "zh-cn", # 语言设置为中文（中国）
        "gl": "cn",     # 地理位置设置为中国
        # "engine": "google" # 默认为 google，可以显式指定
    }

    search_results_processed: List[Dict[str, Any]] = []
    try:
        def sync_serpapi_operation(params: Dict[str, str]) -> dict:
            logger.debug(f"{tool_call_logger_prefix} [sync_serpapi_op_internal] 开始执行SerpApi同步搜索: query='{params.get('q')}', num='{params.get('num')}'")
            if GoogleSearch is None: # 再次检查，尽管 SERPAPI_AVAILABLE 应该已经处理了
                raise RuntimeError("SerpApi GoogleSearch class is not available (GoogleSearch is None).")
            search = GoogleSearch(params) # 使用从 serpapi 导入的 GoogleSearch
            results = search.get_dict() # 获取原始字典结果
            logger.debug(f"{tool_call_logger_prefix} [sync_serpapi_op_internal] SerpApi返回了原始字典。")
            return results

        logger.debug(f"{tool_call_logger_prefix} 准备将同步SerpApi操作提交到线程池...")
        raw_serpapi_results: Dict[str, Any] = await asyncio.to_thread(sync_serpapi_operation, search_params)
        logger.debug(f"{tool_call_logger_prefix} 同步SerpApi操作完成。")

        # 处理 SerpApi 返回的结果
        if raw_serpapi_results and "organic_results" in raw_serpapi_results:
            for res_item in raw_serpapi_results["organic_results"][:num_results_actual]: # 再次确保不超过请求数量
                snippet = res_item.get("snippet", "N/A")
                # 有时 snippet 可能在 link_type_result 中，如您原代码所示
                if snippet == "N/A" and "link_type_result" in res_item and isinstance(res_item["link_type_result"], dict):
                    snippet = res_item["link_type_result"].get("snippet", "N/A")
                
                search_results_processed.append({
                    "title": str(res_item.get("title", "N/A")),
                    "snippet": str(snippet), 
                    "link": str(res_item.get("link", "#")),
                    "source": "Google (via SerpApi)" # 标明来源
                })
            
            search_results_json_str = json.dumps(search_results_processed, ensure_ascii=False)
            success_message = f"已成功通过 SerpApi 完成对“{query}”的 Google 搜索,找到 {len(search_results_processed)} 条相关信息。"
            logger.info(f"{tool_call_logger_prefix} {success_message}")
            
            self.memory_manager.add_to_long_term(f"执行了 SerpApi Google 搜索,查询词: '{query}', 返回了 {len(search_results_processed)} 条结果 (请求ID: {self.current_request_id or 'N/A'})。")

            tool_result = {
                "status": "success",
                "message": success_message,
                "data": {
                    "query": query,
                    "num_results_requested": num_results_actual,
                    "num_results_returned": len(search_results_processed),
                    "results_json_string": search_results_json_str
                }
            }
            return tool_result
        elif raw_serpapi_results and "error" in raw_serpapi_results: # SerpApi 返回了错误信息
            api_error_message = str(raw_serpapi_results["error"])
            logger.error(f"{tool_call_logger_prefix} SerpApi 返回错误: {api_error_message}")
            tool_result["message"] = f"SerpApi 错误: {api_error_message}"
            tool_result["error"] = {"error_type": "EXTERNAL_SERVICE_API_ERROR", "error_code": "SERPAPI_API_ERROR_RESPONSE", "technical_message": api_error_message}
            return tool_result
        else: # 返回结果结构不符合预期
            logger.warning(f"{tool_call_logger_prefix} SerpApi 搜索未返回 'organic_results' 或 'error' 字段。响应(部分): {str(raw_serpapi_results)[:500]}")
            tool_result["message"] = "SerpApi 搜索未返回预期的结果结构。"
            tool_result["error"] = {"error_type": "EXTERNAL_SERVICE_ERROR", "error_code": "SERPAPI_UNEXPECTED_RESPONSE_STRUCTURE", "technical_message": "No 'organic_results' or 'error' in SerpApi response."}
            return tool_result

    except Exception as e_serpapi:
        err_msg = f"使用 SerpApi Google 搜索时发生错误: {e_serpapi}"
        logger.error(f"{tool_call_logger_prefix} {err_msg}", exc_info=True)
        tool_result["message"] = f"错误: {err_msg}"
        tool_result["error"] = {
            "error_type": "EXTERNAL_SERVICE_ERROR", 
            "error_code": "SERPAPI_SEARCH_UNEXPECTED_FAILURE", 
            "technical_message": str(e_serpapi), 
            "exception_details": traceback.format_exc(limit=3)
        }
        return tool_result
--- END: circuitmanus/tools/web_search.py ---

--- START: circuitmanus/tools/__init__.py ---
# IDT_AGENT_Pro/circuitmanus/tools/__init__.py
"""
Agent Tools: Definitions, Registration, and Execution.
This sub-package manages the tools available to the agent,
how they are registered, and how they are executed.
"""
from .base import register_tool
from .executor import ToolExecutor
# 具体工具函数将在各自模块定义，由 Agent 类导入和使用

__all__ = ["register_tool", "ToolExecutor"]
--- END: circuitmanus/tools/__init__.py ---

--- START: circuitmanus/utils/async_setup.py ---
# IDT_AGENT_Pro/circuitmanus/utils/async_setup.py
import asyncio
import logging

logger = logging.getLogger(__name__) # 使用当前模块的 logger

_initialized_loop = None # 模块级变量，存储我们设置的循环

def get_event_loop() -> asyncio.AbstractEventLoop:
    """
    Ensures an asyncio event loop is available and set for the current context.
    If a loop is already running, it returns that loop.
    Otherwise, it creates a new loop, sets it as the current loop for the main thread,
    and returns it.
    
    This function aims to provide a consistent way to get a loop,
    especially when the script might be run in different environments
    (e.g., as a standalone script vs. part of a larger asyncio application).
    """
    global _initialized_loop
    try:
        # 尝试获取当前正在运行的事件循环
        loop = asyncio.get_running_loop()
        logger.debug("get_event_loop: Found an already running event loop.")
        if _initialized_loop is None: # 如果是第一次在这个模块发现运行中的循环
            _initialized_loop = loop # 记录它
    except RuntimeError:  # 'RuntimeError: There is no current event loop...'
        logger.debug("get_event_loop: No running event loop found, creating a new one.")
        # 如果之前通过此函数创建并设置过循环，则尝试复用
        if _initialized_loop and not _initialized_loop.is_closed():
            loop = _initialized_loop
            logger.debug("get_event_loop: Reusing previously initialized loop.")
        else:
            loop = asyncio.new_event_loop()
            logger.debug("get_event_loop: New event loop created.")
            _initialized_loop = loop
        
        try:
            asyncio.set_event_loop(loop)
            logger.debug("get_event_loop: New event loop set as the current event loop for this thread.")
        except RuntimeError as e:
            # 这通常发生在非主线程尝试设置事件循环，而策略不允许时
            # 或者一个循环已经在其他地方被设置了
            logger.warning(f"get_event_loop: Could not set the event loop: {e}. This might be an issue if running in a non-main thread without a loop already set.")
            # 在这种情况下，我们仍然返回我们创建/获取的loop，调用者需要意识到它可能不是“当前”的
    
    return loop

# 在模块加载时，可以调用一次以确保主线程的事件循环被初始化
# loop = get_event_loop() # 同样，根据需要决定是否在导入时执行
--- END: circuitmanus/utils/async_setup.py ---

--- START: circuitmanus/utils/config_loader.py ---
# IDT_AGENT_NATIVE/circuitmanus/utils/config_loader.py
import os
import yaml 
import logging
from typing import Any, Optional, Dict
from dotenv import load_dotenv 

logger = logging.getLogger(__name__)

class ConfigLoader:
    _instance = None 
    _initialized_once = False # 确保__init__的核心逻辑只在首次创建时执行

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(ConfigLoader, cls).__new__(cls)
        return cls._instance

    def __init__(self, 
                 yaml_config_path: str = "config.yaml", 
                 dotenv_path: Optional[str] = None,
                 reload_config: bool = False):
        
        # 这个构造函数可能会因为 __new__ 返回已存在的实例而被多次调用（在同一个实例上）。
        # 我们需要确保核心的加载逻辑只在第一次初始化或强制重载时执行。
        if ConfigLoader._initialized_once and not reload_config:
            # 如果不是第一次，并且没有要求重载，我们检查传入的路径是否与已加载的路径相同。
            # 如果不同，可能需要警告或决定是否重载。为简单起见，目前不改变已加载配置。
            if hasattr(self, 'yaml_config_path') and self.yaml_config_path != yaml_config_path:
                logger.warning(f"ConfigLoader already initialized with YAML path '{self.yaml_config_path}'. "
                               f"New path '{yaml_config_path}' provided but not reloading without reload_config=True.")
            if hasattr(self, 'dotenv_path') and self.dotenv_path != dotenv_path:
                 logger.warning(f"ConfigLoader already initialized with .env path '{self.dotenv_path}'. "
                               f"New path '{dotenv_path}' provided but not reloading without reload_config=True.")
            return

        logger.info(f"Initializing ConfigLoader (yaml: '{yaml_config_path}', dotenv: '{dotenv_path or 'Default locations'}', reload: {reload_config})...")
        self.yaml_config_path = os.path.abspath(yaml_config_path) # 存储绝对路径
        self.dotenv_path = os.path.abspath(dotenv_path) if dotenv_path else None # 存储绝对路径
        self.config: Dict[str, Any] = {}

        self._load_dotenv_file() # 重命名以区分 load_dotenv 库函数
        self._load_yaml_config_file() # 重命名
        
        ConfigLoader._initialized_once = True # 标记核心初始化已完成一次
        logger.info(f"ConfigLoader initialized. Loaded YAML from: '{self.yaml_config_path if os.path.exists(self.yaml_config_path) else 'Not Found'}'. .env load attempt from: '{self.dotenv_path or 'Default locations'}'")

    def _load_dotenv_file(self) -> None:
        """加载 .env 文件到环境变量中。"""
        # python-dotenv的load_dotenv()会查找.env文件，如果dotenv_path参数为None，它会从当前工作目录开始向上查找。
        # 如果提供了dotenv_path，则只加载指定的文件。
        # override=True 表示如果.env文件中的变量已存在于环境中，则覆盖它们。
        
        path_to_load = self.dotenv_path # 使用实例变量中存储的（可能是绝对）路径
        loaded = False
        
        if path_to_load: # 如果在__init__中指定了dotenv_path
            if os.path.exists(path_to_load) and os.path.isfile(path_to_load):
                loaded = load_dotenv(dotenv_path=path_to_load, override=True)
                if loaded:
                    logger.info(f".env file loaded successfully from specified path: '{path_to_load}'.")
                else: # 文件存在但加载失败（例如空文件或权限问题，虽然load_dotenv通常不报错）
                    logger.warning(f"Specified .env file at '{path_to_load}' exists but python-dotenv reported no variables loaded (or load failed silently).")
            else:
                logger.warning(f".env file specified at '{path_to_load}' but not found or not a file. Skipping explicit load.")
                # 即使指定路径失败，我们仍然可以让 load_dotenv(override=True) 尝试其默认查找
                # 但这可能与用户指定路径的意图冲突，所以这里选择不这样做。
                # 如果用户指定了路径但文件不存在，我们就不应再去默认位置找。
        else: # 如果__init__中未指定dotenv_path (dotenv_path=None)，则让load_dotenv使用其默认查找行为
            # load_dotenv() 返回 True 如果它找到并加载了一个 .env 文件，否则 False
            if load_dotenv(override=True):
                # 无法简单知道它从哪个具体路径加载的，因为它会向上搜索
                logger.info(".env file loaded successfully by python-dotenv from one of its default search locations (e.g., current working directory or parent directories).")
                loaded = True
            else:
                logger.info("No .env file found by python-dotenv in default search locations. Environment variables will be used directly if set.")
        
        # 可以在这里添加一些日志来确认关键环境变量是否已加载（但不打印值）
        # for key_var in ["ZHIPUAI_API_KEY", "HF_TOKEN"]:
        #     if key_var in os.environ:
        #         logger.debug(f"Environment variable '{key_var}' is set after .env load attempt.")
        #     else:
        #         logger.debug(f"Environment variable '{key_var}' is NOT set after .env load attempt.")


    def _load_yaml_config_file(self) -> None:
        """加载 YAML 配置文件。"""
        # 使用实例变量中存储的（可能是绝对）路径
        if not os.path.exists(self.yaml_config_path) or not os.path.isfile(self.yaml_config_path):
            logger.error(f"YAML config file not found or not a file at '{self.yaml_config_path}'. Agent will use hardcoded defaults or fail if defaults are not robust.")
            self.config = {} 
            return

        try:
            with open(self.yaml_config_path, 'r', encoding='utf-8') as f:
                loaded_yaml = yaml.safe_load(f)
            if isinstance(loaded_yaml, dict):
                self.config = loaded_yaml
                logger.info(f"YAML config loaded successfully from '{self.yaml_config_path}'.")
            else:
                logger.error(f"YAML config file '{self.yaml_config_path}' did not load as a dictionary (loaded as {type(loaded_yaml)}). Configuration will be empty.")
                self.config = {}
        except yaml.YAMLError as e: # 捕获PyYAML解析错误
            logger.error(f"Error parsing YAML config file '{self.yaml_config_path}': {e}", exc_info=True)
            self.config = {}
        except IOError as e: # 捕获文件读写错误
            logger.error(f"Error reading YAML config file '{self.yaml_config_path}': {e}", exc_info=True)
            self.config = {}
        except Exception as e: # 捕获其他未知错误
            logger.error(f"An unexpected error occurred while loading YAML config from '{self.yaml_config_path}': {e}", exc_info=True)
            self.config = {}

    def get_config(self, key_path: str, default: Any = None) -> Any:
        if not isinstance(key_path, str):
            logger.warning(f"Invalid key_path type for get_config: {type(key_path)}. Must be string. Path: '{key_path}'")
            return default
            
        keys = key_path.split('.')
        current_level_value = self.config # 从顶层配置字典开始查找
        try:
            for key_segment in keys:
                if isinstance(current_level_value, dict):
                    current_level_value = current_level_value[key_segment] # 逐级深入
                else: # 如果路径中的某个层级不是字典，则无法继续查找
                    logger.debug(f"Config key '{key_path}' not found (path segment '{key_segment}' is not a dictionary in the traversed structure). Returning default: {default}")
                    return default
            return current_level_value # 成功找到值
        except KeyError: # 如果某个key_segment在当前层级的字典中不存在
            logger.debug(f"Config key '{key_path}' not found (a segment was missing). Returning default: {default}")
            return default
        except Exception as e: # 其他意外错误
            logger.warning(f"Error accessing config key '{key_path}': {e}. Returning default: {default}", exc_info=True)
            return default

    def get_env_var(self, var_name: str, default: Optional[str] = None) -> Optional[str]:
        value = os.environ.get(var_name) # 先尝试直接获取
        if value is not None:
            # logger.debug(f"Environment variable '{var_name}' found in environment.")
            return value
        elif default is not None:
            # logger.debug(f"Environment variable '{var_name}' not found. Using provided default value.")
            return default
        else:
            # logger.debug(f"Environment variable '{var_name}' not found and no default provided. Returning None.")
            return None


    def reload_all_configs(self) -> None:
        """强制重新加载所有配置文件 (.env 和 YAML)。"""
        logger.info("Force reloading all configurations...")
        # 重置 _initialized_once 状态可能不是单例模式所期望的，
        # 除非是想让下一次 ConfigLoader() 调用也执行完整初始化。
        # 这里我们只是重新加载文件内容到当前实例。
        # ConfigLoader._initialized_once = False # 如果希望下次 new() 时重新初始化
        self._load_dotenv_file()
        self._load_yaml_config_file()
        logger.info("Configurations reloaded for the current ConfigLoader instance.")
--- END: circuitmanus/utils/config_loader.py ---

--- START: circuitmanus/utils/logging_config.py ---
# IDT_AGENT_NATIVE/circuitmanus/utils/logging_config.py
import os
import sys
import logging
from datetime import datetime
from typing import Optional # 导入 Optional
import traceback

LOG_DIR = "WebUIAgentLogs"  # 默认日志目录，可以被覆盖
console_handler: Optional[logging.StreamHandler] = None # 类型提示
file_handler: Optional[logging.FileHandler] = None    # 类型提示

def setup_logging(
    console_log_level: int = logging.INFO, 
    file_log_level: int = logging.DEBUG, 
    log_dir_override: Optional[str] = None,
    # verbose_mode is effectively replaced by direct console_log_level setting
    # but we keep it for now if Agent's self.verbose_mode directly maps to DEBUG for console
    # For a cleaner approach, Agent should pass the resolved console_log_level directly.
    # Let's assume Agent will pass the desired console_log_level.
    # If verbose_mode is still used by Agent to mean "console=DEBUG", Agent __init__ should resolve it.
) -> logging.Logger:
    """
    Configures the root logger and a specific logger for the application.
    Now accepts explicit console and file log levels, and a log directory override.

    Args:
        console_log_level (int): The logging level for the console.
        file_log_level (int): The logging level for the file.
        log_dir_override (Optional[str]): If provided, overrides the default LOG_DIR.

    Returns:
        logging.Logger: The configured logger instance for the 'circuitmanus' application.
    """
    global console_handler, file_handler, LOG_DIR # 声明我们要修改全局变量

    # 如果提供了 log_dir_override，则使用它
    if log_dir_override:
        current_log_dir = log_dir_override
    else:
        current_log_dir = LOG_DIR # 使用模块级默认值

    try:
        if not os.path.exists(current_log_dir):
            os.makedirs(current_log_dir)
    except OSError as e:
        sys.stderr.write(f"严重错误: 无法创建日志目录 '{current_log_dir}'. 错误信息: {e}\n")
        sys.stderr.write("文件日志功能可能不可用。程序将仅使用控制台日志继续运行。\n")

    current_time_for_log = datetime.now()
    log_file_name = os.path.join(
        current_log_dir, # 使用 current_log_dir
        f"agent_log_v1_1_3_async_call_fix_{current_time_for_log.strftime('%Y%m%d_%H%M%S')}_{current_time_for_log.microsecond // 1000:03d}_P{os.getpid()}.log"
    )

    log_format = '%(asctime)s - %(name)s - %(levelname)s [%(module)s.%(funcName)s:%(lineno)d] - %(message)s'
    formatter = logging.Formatter(log_format)

    root_logger = logging.getLogger() # 获取根 logger
    
    # --- 控制台日志处理器 ---
    # 清理可能存在的旧的同名控制台处理器
    if console_handler and console_handler in root_logger.handlers:
        root_logger.removeHandler(console_handler)
        console_handler.close() # 关闭旧的处理器
        console_handler = None
    
    # 创建新的控制台处理器
    console_handler = logging.StreamHandler(sys.stderr)
    console_handler.setFormatter(formatter)
    console_handler.setLevel(console_log_level) # 直接使用传入的级别
    root_logger.addHandler(console_handler)

    # --- 文件日志处理器 ---
    # 清理可能存在的旧的文件处理器
    if file_handler and file_handler in root_logger.handlers:
        root_logger.removeHandler(file_handler)
        file_handler.close()
        file_handler = None
        
    try:
        file_handler = logging.FileHandler(log_file_name, mode='a', encoding='utf-8')
        file_handler.setLevel(file_log_level) # 直接使用传入的级别
        file_handler.setFormatter(formatter)
        root_logger.addHandler(file_handler)
    except Exception as e:
        # 如果文件日志配置失败，通过控制台日志报告错误
        # 创建一个临时logger或直接使用print，因为标准logger可能还未完全配置好
        sys.stderr.write(f"严重错误(setup_logging): 配置日志文件到 '{log_file_name}' 失败。错误信息: {e}\nTraceback: {traceback.format_exc()}\n")
        sys.stderr.write("Agent 将仅使用控制台日志继续运行。\n")
        file_handler = None # 确保 file_handler 为 None

    # 设置根日志级别为所有处理器中最低的级别，以确保消息能被考虑
    # (DEBUG is 10, INFO is 20, etc.)
    effective_root_level = min(console_log_level, file_log_level)
    # 如果 file_handler 失败了，则根级别只考虑 console
    if file_handler is None:
        effective_root_level = console_log_level
        
    root_logger.setLevel(effective_root_level)

    # 获取一个特定的 logger 实例供应用主模块使用
    app_logger = logging.getLogger("circuitmanus") 
    
    # 抑制第三方库的冗余日志 (保持不变)
    logging.getLogger("zhipuai").setLevel(logging.WARNING)
    logging.getLogger("httpx").setLevel(logging.WARNING)
    logging.getLogger("duckduckgo_search").setLevel(logging.WARNING)

    # 最终确认日志配置状态
    if file_handler:
        app_logger.info(f"文件日志配置成功。级别: {logging.getLevelName(file_handler.level)}, 文件: {os.path.abspath(log_file_name)}")
    else:
        app_logger.warning("文件日志未配置成功。")
    app_logger.info(f"控制台日志配置成功。级别: {logging.getLevelName(console_handler.level)}")
    app_logger.info(f"Root logger 级别设置为: {logging.getLevelName(root_logger.level)}")
    
    return app_logger
--- END: circuitmanus/utils/logging_config.py ---

--- START: circuitmanus/utils/__init__.py ---
# IDT_AGENT_Pro/circuitmanus/utils/__init__.py
"""
Utility Functions and Configurations.
Provides common utilities like logging setup and other helper modules.
"""
from .logging_config import setup_logging, LOG_DIR, console_handler, file_handler # 导出console_handler等是为了在server.py中可能也需要访问
from .async_setup import get_event_loop

__all__ = ["setup_logging", "get_event_loop", "LOG_DIR", "console_handler", "file_handler"]
--- END: circuitmanus/utils/__init__.py ---

--- START: Otherfiles/CircuitManusCore.py ---

# @FileName: circuitmanus.py
# @Version: V1.0.0 - 核心电路交互逻辑与DuckDuckGo搜索工具集 (深化修复ToolExecutor异步调用新)
# @Author: 您的专属程序员 (致力于构建稳定、清晰、可扩展的智能助手核心)
# @Date: [当前日期] - 深化修复ToolExecutor对异步工具的调用，确保协程被正确await。
# @License: MIT License
# @Description:
# ==============================================================================================
#  Manus 系统 V1.0.0 技术实现说明 (附带11个工具)
# ==============================================================================================
# (V1.0.0 变更日志:
#  - 针对ToolExecutor中异步工具返回协程对象而非执行结果的问题，进行了更直接的await调用修复。
#  - 强化日志，在ToolExecutor调用工具前后打印更多关于工具方法类型和返回类型的信息。
#  - 确保duckduckgo_search_tool的返回结构在所有路径下都符合预期。)
# ==============================================================================================

# --- 基础库导入 ---
import re
import os
import json
import time
import logging
import sys
import asyncio
import traceback
import inspect
import functools
from datetime import datetime, timezone
from typing import List, Dict, Any, Optional, Tuple, Set, Union, Callable, Awaitable
from uuid import uuid4
from zhipuai import ZhipuAI
import httpx
from duckduckgo_search import DDGS

# --- 全局异步事件循环 ---
try:
    loop = asyncio.get_running_loop()
except RuntimeError:
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

# --- 日志系统配置 ---
LOG_DIR = "WebUIAgentLogs"
try:
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)
except OSError as e:
    sys.stderr.write(f"严重错误: 无法创建日志目录 '{LOG_DIR}'. 错误信息: {e}\n")
    sys.stderr.write("文件日志功能可能不可用。程序将仅使用控制台日志继续运行。\n")

current_time_for_log = datetime.now()
# 更新日志文件名以反映版本
log_file_name = os.path.join(
    LOG_DIR,
    f"agent_log_v1_1_3_async_call_fix_{current_time_for_log.strftime('%Y%m%d_%H%M%S')}_{current_time_for_log.microsecond // 1000:03d}_P{os.getpid()}.log"
)

log_format = '%(asctime)s - %(name)s - %(levelname)s [%(module)s.%(funcName)s:%(lineno)d] - %(message)s'

console_handler = logging.StreamHandler(sys.stderr)
console_handler.setLevel(logging.DEBUG)
console_handler.setFormatter(logging.Formatter(log_format))

root_logger = logging.getLogger()
root_logger.setLevel(logging.DEBUG)
root_logger.addHandler(console_handler)

logger = logging.getLogger(__name__)

try:
    file_handler = logging.FileHandler(log_file_name, mode='a', encoding='utf-8')
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(logging.Formatter(log_format))
    root_logger.addHandler(file_handler)
    logger.info(f"文件日志配置成功。日志消息也将保存至: {os.path.abspath(log_file_name)}")
except Exception as e:
    logger.error(f"严重错误: 配置日志文件到 '{log_file_name}' 失败。错误信息: {e}", exc_info=True)
    logger.error("Agent 将仅使用控制台日志继续运行。")

logging.getLogger("zhipuai").setLevel(logging.WARNING)
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("duckduckgo_search").setLevel(logging.WARNING)


# --- 电路元件数据类 ---
class CircuitComponent:
    __slots__ = ['id', 'type', 'value']
    def __init__(self, component_id: str, component_type: str, value: Optional[str] = None):
        if not isinstance(component_id, str) or not component_id.strip():
            raise ValueError("元件 ID 必须是有效的非空字符串。")
        if not isinstance(component_type, str) or not component_type.strip():
            raise ValueError("元件类型必须是有效的非空字符串。")
        
        self.id: str = component_id.strip().upper()
        self.type: str = component_type.strip()
        self.value: Optional[str] = str(value).strip() if value is not None and str(value).strip() else None

    def __str__(self) -> str:
        value_str = f" (值: {self.value})" if self.value else ""
        return f"元件: {self.type} (ID: {self.id}){value_str}"

    def __repr__(self) -> str:
        return f"CircuitComponent(id='{self.id}', type='{self.type}', value={repr(self.value)})"

    def to_dict(self) -> Dict[str, Any]:
        return {"id": self.id, "type": self.type, "value": self.value}

# --- 电路实体类 ---
class Circuit:
    def __init__(self):
        logger.info("[Circuit] 初始化电路实体...")
        self.components: Dict[str, CircuitComponent] = {}
        self.connections: Set[Tuple[str, str]] = set()
        self._component_counters: Dict[str, int] = {
            'R': 0, 'L': 0, 'B': 0, 'S': 0, 'C': 0, 'V': 0, 'G': 0, 'U': 0, 'O': 0,
            'I': 0, 'A': 0, 'D': 0, 'P': 0, 'F': 0, 'H': 0,
            'T': 0, 'N': 0, 'IN': 0, 'OUT': 0,
            'SRCH': 0 
        }
        logger.info("[Circuit] 电路实体初始化完成。")

    def add_component(self, component: CircuitComponent):
        if component.id in self.components:
            raise ValueError(f"元件 ID '{component.id}' 已被占用。")
        self.components[component.id] = component
        logger.debug(f"[Circuit] 元件 '{component.id}' ({component.type}) 已添加到电路。")

    def remove_component(self, component_id: str) -> Tuple[Dict[str, Any], int]:
        comp_id_upper = component_id.strip().upper()
        if comp_id_upper not in self.components:
            raise ValueError(f"元件 '{comp_id_upper}' 在电路中不存在。")
        
        removed_component_details = self.components[comp_id_upper].to_dict()
        del self.components[comp_id_upper]
        
        connections_to_remove = {conn for conn in self.connections if comp_id_upper in conn}
        removed_connections_count = len(connections_to_remove)
        for conn in connections_to_remove:
            self.connections.remove(conn)
            logger.debug(f"[Circuit] 移除了涉及元件 '{comp_id_upper}' 的连接 {conn}。")
        
        logger.debug(f"[Circuit] 元件 '{comp_id_upper}' 及其相关 {removed_connections_count} 个连接已从电路中移除。")
        return removed_component_details, removed_connections_count


    def connect_components(self, id1: str, id2: str) -> bool:
        id1_upper = id1.strip().upper()
        id2_upper = id2.strip().upper()
        if id1_upper == id2_upper: raise ValueError(f"不能将元件 '{id1_upper}' 连接到它自己。")
        if id1_upper not in self.components: raise ValueError(f"元件 '{id1_upper}' 在电路中不存在。")
        if id2_upper not in self.components: raise ValueError(f"元件 '{id2_upper}' 在电路中不存在。")
        
        connection = tuple(sorted((id1_upper, id2_upper)))
        if connection in self.connections:
             logger.warning(f"[Circuit] 连接 '{id1_upper}' <--> '{id2_upper}' 已存在。")
             return False
        self.connections.add(connection)
        logger.debug(f"[Circuit] 添加了连接: {id1_upper} <--> {id2_upper}。")
        return True

    def disconnect_components(self, id1: str, id2: str) -> bool:
        id1_upper = id1.strip().upper()
        id2_upper = id2.strip().upper()
        connection = tuple(sorted((id1_upper, id2_upper)))
        if connection not in self.connections:
             logger.warning(f"[Circuit] 连接 '{id1_upper}' <--> '{id2_upper}' 不存在,无需断开。")
             return False
        self.connections.remove(connection)
        logger.debug(f"[Circuit] 断开了连接: {id1_upper} <--> {id2_upper}。")
        return True

    def get_state_description(self) -> str:
        logger.debug("[Circuit] 正在生成电路状态描述...")
        num_components = len(self.components)
        num_connections = len(self.connections)

        if num_components == 0 and num_connections == 0:
            return "【当前电路状态】: 电路为空。"

        desc_lines = ["【当前电路状态】:"]
        desc_lines.append(f"  - 元件 ({num_components}):")
        if self.components:
            sorted_ids = sorted(self.components.keys())
            for cid in sorted_ids:
                desc_lines.append(f"    - {str(self.components[cid])}")
        else:
            desc_lines.append("    (无)")

        desc_lines.append(f"  - 连接 ({num_connections}):")
        if self.connections:
            sorted_connections = sorted(list(self.connections))
            for c1, c2 in sorted_connections:
                desc_lines.append(f"    - {c1} <--> {c2}")
        else:
            desc_lines.append("    (无)")

        description = "\n".join(desc_lines)
        logger.debug("[Circuit] 电路状态描述生成完毕。")
        return description

    def generate_component_id(self, component_type: str) -> str:
        logger.debug(f"[Circuit] 正在为类型 '{component_type}' 生成唯一 ID...")
        type_map = {
            "resistor": "R", "电阻": "R", "capacitor": "C", "电容": "C",
            "battery": "B", "电池": "B", "voltage source": "V", "voltage": "V",
            "电压源": "V", "电压": "V", "led": "L", "发光二极管": "L", "switch": "S",
            "开关": "S", "ground": "G", "地": "G", "ic": "U", "chip": "U", "芯片": "U",
            "集成电路": "U", "inductor": "I", "电感": "I", "current source": "A",
            "电流源": "A", "diode": "D", "二极管": "D", "potentiometer": "P", "电位器": "P",
            "fuse": "F", "保险丝": "F", "header": "H", "排针": "H",
            "terminal": "T", "端子": "T", "connection point": "P", "连接点": "P",
            "node": "N", "节点": "N",
            "input": "IN", "输入": "IN", "output": "OUT", "输出": "OUT",
            "search_record": "SRCH", "搜索记录": "SRCH", 
            "component": "O", "元件": "O",
        }

        for code in type_map.values():
            if code not in self._component_counters:
                 self._component_counters[code] = 0

        cleaned_type = component_type.strip().lower()
        type_code = "O"
        best_match_len = 0

        if cleaned_type == "input": type_code = "IN"
        elif cleaned_type == "output": type_code = "OUT"
        elif cleaned_type == "ground" or cleaned_type == "地": type_code = "G"
        else:
            for keyword, code in type_map.items():
                if keyword in cleaned_type and len(keyword) > best_match_len:
                    type_code = code
                    best_match_len = len(keyword)

        if type_code == "O" and cleaned_type not in ["component", "元件"]:
             logger.warning(f"[Circuit] 未找到类型 '{component_type}' 的特定前缀,将使用通用前缀 'O'。")

        MAX_ID_ATTEMPTS = 10000
        for attempt in range(MAX_ID_ATTEMPTS):
            self._component_counters[type_code] += 1
            gen_id = f"{type_code}{self._component_counters[type_code]}"
            if gen_id not in self.components:
                logger.debug(f"[Circuit] 生成唯一 ID: '{gen_id}' (尝试 {attempt + 1})。")
                return gen_id
            logger.debug(f"[Circuit] ID '{gen_id}' 已存在,尝试下一个。(尝试 {attempt + 1})。")

        raise RuntimeError(f"未能为类型 '{component_type}' (代码 '{type_code}') 生成唯一 ID ({MAX_ID_ATTEMPTS} 次尝试后)。")

    def clear(self):
        logger.info("[Circuit] 正在清空电路状态...")
        comp_count = len(self.components)
        conn_count = len(self.connections)

        self.components = {}
        self.connections = set()
        self._component_counters = {k: 0 for k in self._component_counters}

        logger.info(f"[Circuit] 电路状态已清空 (移除了 {comp_count} 个元件, {conn_count} 个连接,并重置了所有 ID 计数器)。")

# --- 工具注册装饰器 ---
def register_tool(description: str, parameters: Dict[str, Any]):
    def decorator(func):
        func._tool_schema = {"description": description, "parameters": parameters}
        func._is_tool = True
        # functools.wraps is important to preserve metadata, especially for inspect.iscoroutinefunction
        @functools.wraps(func)
        async def async_wrapper(*args, **kwargs): # if original func is async
            return await func(*args, **kwargs)
        
        @functools.wraps(func)
        def sync_wrapper(*args, **kwargs): # if original func is sync
            return func(*args, **kwargs)

        if inspect.iscoroutinefunction(func):
            return async_wrapper
        else:
            return sync_wrapper
    return decorator

# --- 模块化组件: MemoryManager (记忆管理器) ---
class MemoryManager:
    def __init__(self, max_short_term_items: int = 30, max_long_term_items: int = 200):
        logger.info("[MemoryManager] 初始化记忆模块...")
        if max_short_term_items <= 1:
            raise ValueError("参数 'max_short_term_items' 必须大于 1。")

        self.max_short_term_items = max_short_term_items
        self.max_long_term_items = max_long_term_items
        self.short_term: List[Dict[str, Any]] = []
        self.long_term: List[str] = []
        self.circuit: Circuit = Circuit()

        logger.info(f"[MemoryManager] 记忆模块初始化完成。短期记忆上限: {max_short_term_items} 条, 长期记忆上限: {max_long_term_items} 条。")

    def add_to_short_term(self, message: Dict[str, Any]):
        logger.debug(f"[MemoryManager] 添加消息到短期记忆 (Role: {message.get('role', 'N/A')})。当前数量: {len(self.short_term)}。")
        self.short_term.append(message)
        current_size = len(self.short_term)
        if current_size > self.max_short_term_items:
            logger.debug(f"[MemoryManager] 短期记忆超限 ({current_size}/{self.max_short_term_items}),执行修剪...")
            items_to_remove_count = current_size - self.max_short_term_items
            non_system_indices = [i for i, msg in enumerate(self.short_term) if msg.get("role") != "system"]
            num_to_actually_remove = min(items_to_remove_count, len(non_system_indices))

            if num_to_actually_remove > 0:
                indices_to_remove_set = set(non_system_indices[:num_to_actually_remove])
                removed_roles = [self.short_term[i].get('role', 'N/A') for i in sorted(list(indices_to_remove_set))]
                new_short_term = [msg for i, msg in enumerate(self.short_term) if i not in indices_to_remove_set]
                self.short_term = new_short_term
                logger.info(f"[MemoryManager] 短期记忆修剪完成,移除了 {num_to_actually_remove} 条最旧的非系统消息 (角色: {removed_roles})。")
            elif items_to_remove_count > 0:
                 logger.warning(f"[MemoryManager] 短期记忆超限 ({current_size}/{self.max_short_term_items}) 但未能找到足够的非系统消息进行移除。")
        logger.debug(f"[MemoryManager] 添加后短期记忆数量: {len(self.short_term)}。")

    def add_to_long_term(self, knowledge_snippet: str):
        MAX_SNIPPET_LENGTH = 10000
        if len(knowledge_snippet) > MAX_SNIPPET_LENGTH:
            logger.warning(f"[MemoryManager] 尝试添加的长期记忆片段过长 ({len(knowledge_snippet)} 字符),已截断为 {MAX_SNIPPET_LENGTH} 字符。")
            knowledge_snippet = knowledge_snippet[:MAX_SNIPPET_LENGTH] + "... (已截断)"

        logger.debug(f"[MemoryManager] 添加知识到长期记忆: '{knowledge_snippet[:1000]}{'...' if len(knowledge_snippet) > 100 else ''}'。当前数量: {len(self.long_term)}。")
        self.long_term.append(knowledge_snippet)
        if len(self.long_term) > self.max_long_term_items:
            removed_snippet = self.long_term.pop(0)
            logger.info(f"[MemoryManager] 长期记忆超限 ({self.max_long_term_items}), 移除最旧知识: '{removed_snippet[:50]}...'。")
        logger.debug(f"[MemoryManager] 添加后长期记忆数量: {len(self.long_term)}。")

    def get_circuit_state_description(self) -> str:
        return self.circuit.get_state_description()

    def get_memory_context_for_prompt(self, recent_long_term_count: int = 7) -> str:
        logger.debug("[MemoryManager] 正在格式化记忆上下文用于 Prompt...")
        circuit_desc = self.get_circuit_state_description()
        long_term_str = ""
        if self.long_term:
            actual_count = min(recent_long_term_count, len(self.long_term))
            if actual_count > 0:
                recent_items = self.long_term[-actual_count:]
                long_term_str = "\n\n【近期经验总结 (仅显示最近 N 条,按时间倒序排列,最新在前)】\n" + "\n".join(f"- {item}" for item in reversed(recent_items))
                logger.debug(f"[MemoryManager] 已提取最近 {len(recent_items)} 条长期记忆 (倒序)。")
        long_term_str += "\n(注: 当前仅使用最近期记忆,未来版本将实现基于相关性的检索。)"
        context = f"{circuit_desc}{long_term_str}".strip()
        logger.debug(f"[MemoryManager] 记忆上下文 (电路+长期) 格式化完成。")
        return context

# --- 模块化组件: LLMInterface (LLM 交互接口) ---
class LLMInterface:
    def __init__(self, agent_instance: 'CircuitAgent', model_name: str = "glm-z1-flash", default_temperature: float = 0.01, default_max_tokens: int = 8190):
        logger.info(f"[LLMInterface V1.0.0] 初始化 LLM 接口,目标模型: {model_name}。")
        if not agent_instance or not hasattr(agent_instance, 'api_key'):
             raise ValueError("LLMInterface 需要一个包含 'api_key' 属性的 Agent 实例。")
        self.agent_instance = agent_instance
        api_key = self.agent_instance.api_key
        if not api_key: raise ValueError("智谱 AI API Key 不能为空。")
        try:
            self.client = ZhipuAI(api_key=api_key)
            logger.info("[LLMInterface V1.0.0] 智谱 AI 客户端初始化成功。")
        except Exception as e:
            logger.critical(f"[LLMInterface V1.0.0] 初始化智谱 AI 客户端失败: {e}", exc_info=True)
            raise ConnectionError(f"初始化智谱 AI 客户端失败: {e}") from e

        self.model_name = model_name
        self.default_temperature = default_temperature
        self.default_max_tokens = default_max_tokens
        logger.info(f"[LLMInterface V1.0.0] LLM 接口初始化完成 (模型: {model_name}, 温度: {default_temperature}, 最大Token数: {default_max_tokens}, 流式输出: False)。")

    async def call_llm(self, messages: List[Dict[str, Any]], execution_phase: str, status_callback: Optional[Callable[[Dict], Awaitable[None]]] = None) -> Any:
        call_args = {
            "model": self.model_name,
            "messages": messages,
            "temperature": self.default_temperature,
            "max_tokens": self.default_max_tokens,
            "stream": False,
        }

        logger.info(f"[LLMInterface V1.0.0] 准备异步调用 LLM ({self.model_name}, 阶段: {execution_phase}, 期望输出格式: <think> 标签后跟 JSON)...")
        logger.debug(f"[LLMInterface V1.0.0] 发送的消息条数: {len(messages)}。")
        if logger.isEnabledFor(logging.DEBUG) and len(messages) > 0:
             try:
                 messages_content_for_log = []
                 for m_idx, m in enumerate(messages):
                     role = m.get("role")
                     content = str(m.get("content",""))
                     if role == "system":
                         content_preview = content[:10000] + ("..." if len(content) > 10000 else "")
                     else:
                         content_preview = content[:1000] + ("..." if len(content) > 200 else "")
                     messages_content_for_log.append({"index": m_idx, "role": role, "content_preview_length": len(content), "content_preview": content_preview})
                 messages_summary = json.dumps(messages_content_for_log, ensure_ascii=False, indent=2)
                 logger.debug(f"[LLMInterface V1.0.0] 发送给 LLM 的消息列表 (预览):\n{messages_summary}")
             except Exception as e_json:
                 logger.debug(f"[LLMInterface V1.0.0] 无法序列化消息列表进行调试日志: {e_json}")

        request_id_to_send = self.agent_instance.current_request_id if hasattr(self.agent_instance, 'current_request_id') else None
        if status_callback:
            await status_callback({
                "type": "llm_communication_status",
                "request_id": request_id_to_send,
                "llm_phase": execution_phase,
                "status": "started",
                "message": f"正在与智能大脑 ({self.model_name}) 沟通 ({execution_phase})..."
            })

        response = None
        try:
            start_time = time.monotonic()
            response = await asyncio.to_thread(self.client.chat.completions.create, **call_args)
            duration = time.monotonic() - start_time
            logger.info(f"[LLMInterface V1.0.0] LLM 异步调用成功。耗时: {duration:.3f} 秒。")
            if status_callback:
                await status_callback({
                    "type": "llm_communication_status",
                    "request_id": request_id_to_send,
                    "llm_phase": execution_phase,
                    "status": "completed",
                    "message": f"与智能大脑 ({self.model_name}) 沟通完成 ({execution_phase})。",
                    "details": {"duration_seconds": duration}
                })

            if response:
                if response.usage: logger.info(f"[LLMInterface V1.0.0] Token 统计: Prompt={response.usage.prompt_tokens}, Completion={response.usage.completion_tokens}, Total={response.usage.total_tokens}")
                if response.choices:
                    finish_reason = response.choices[0].finish_reason
                    logger.info(f"[LLMInterface V1.0.0] 完成原因: {finish_reason}")
                    if finish_reason == 'length': logger.warning("[LLMInterface V1.0.0] LLM 响应因达到最大 token 限制而被截断！这可能导致输出不完整！")
                    raw_llm_content = response.choices[0].message.content
                    logger.debug(f"[LLMInterface V1.0.0] LLM 原始响应内容 (完整):\n{raw_llm_content}")
                else:
                    logger.warning("[LLMInterface V1.0.0] LLM 响应中缺少 'choices' 字段。")
            else:
                 logger.error("[LLMInterface V1.0.0] LLM API 调用返回了 None！")
                 raise ConnectionError("LLM API call returned None.")
            return response
        except Exception as e:
            logger.error(f"[LLMInterface V1.0.0] LLM API 异步调用失败: {e}", exc_info=True)
            if status_callback:
                 await status_callback({
                    "type": "llm_communication_status",
                    "request_id": request_id_to_send,
                    "llm_phase": execution_phase,
                    "status": "error",
                    "message": f"与智能大脑 ({self.model_name}) 沟通失败 ({execution_phase})。",
                    "details": {"error": str(e), "error_type": type(e).__name__}
                 })
            raise

# --- 模块化组件: OutputParser (输出解析器) ---
class OutputParser:
    def __init__(self, agent_tools_registry: Optional[Dict[str, Dict[str, Any]]] = None):
        logger.info("[OutputParser] 初始化输出解析器 (适配 ManusLLMResponse-V1.0.0 CamelCase JSON结构,提取 <think> 标签,增强布尔解析)。")
        self.agent_tools_registry = agent_tools_registry if agent_tools_registry else {}

    def _validate_tool_arguments(self, tool_name: str, tool_arguments: Dict[str, Any], tool_call_id: str) -> List[Dict[str, str]]:
        validation_errors: List[Dict[str, str]] = []
        if not self.agent_tools_registry or tool_name not in self.agent_tools_registry:
            validation_errors.append({
                "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolName",
                "issue_description": f"工具 '{tool_name}' 未在 Agent 的注册表中找到。"
            })
            return validation_errors

        tool_schema = self.agent_tools_registry[tool_name]
        param_schema_props = tool_schema.get("parameters", {}).get("properties", {})
        required_params = tool_schema.get("parameters", {}).get("required", [])

        for req_param in required_params:
            if req_param not in tool_arguments:
                validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{req_param}",
                    "issue_description": f"工具 '{tool_name}' 的必需参数 '{req_param}' 缺失。"
                })

        for arg_name, arg_value in tool_arguments.items():
            if arg_name not in param_schema_props:
                validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                    "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 是未在 Schema 中定义的未知参数。"
                })
                continue

            expected_type_str = param_schema_props[arg_name].get("type")
            is_optional_and_null_like = (arg_name not in required_params) and (arg_value is None)

            if expected_type_str == "string" and not isinstance(arg_value, str):
                if not is_optional_and_null_like:
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是字符串,但得到的是 {type(arg_value).__name__}。"
                    })
            elif expected_type_str == "integer" and not isinstance(arg_value, int):
                 if not (is_optional_and_null_like and expected_type_str == "integer"): 
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是整数,但得到的是 {type(arg_value).__name__}。"
                    })
            elif expected_type_str == "number" and not isinstance(arg_value, (int, float)):
                 if not (is_optional_and_null_like and expected_type_str == "number"):
                    validation_errors.append({
                        "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                        "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是数字,但得到的是 {type(arg_value).__name__}。"
                    })
            elif expected_type_str == "boolean" and not isinstance(arg_value, bool):
                 validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                    "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是布尔值,但得到的是 {type(arg_value).__name__}。"
                })
            elif expected_type_str == "object" and not isinstance(arg_value, dict):
                 validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                    "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是对象(字典),但得到的是 {type(arg_value).__name__}。"
                })
            elif expected_type_str == "array" and not isinstance(arg_value, list):
                 validation_errors.append({
                    "jsonPath": f"decision.toolCallRequests[toolCallId={tool_call_id}].toolArguments.{arg_name}",
                    "issue_description": f"工具 '{tool_name}' 的参数 '{arg_name}' 期望是数组(列表),但得到的是 {type(arg_value).__name__}。"
                })
        return validation_errors


    def parse_llm_response_to_structured_json(self, llm_api_response_message: Any, execution_phase: str) -> Tuple[Optional[Dict[str, Any]], str, List[Dict[str,str]]]:
        parser_id = f"parse{str(uuid4())[:8]}"
        logger.debug(f"[{parser_id}-OutputParser] 开始解析 LLM 响应 (阶段: {execution_phase})...")
        parsed_json_dict: Optional[Dict[str, Any]] = None
        error_message: str = ""
        failed_validation_points_list: List[Dict[str, str]] = []
        extracted_thought_process: Optional[str] = None

        if llm_api_response_message is None:
            error_message = "LLM 响应对象 (Message) 为 None。"
            logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message}")
            return None, error_message, [{"jsonPath": "root", "issue_description": error_message}]

        raw_content = getattr(llm_api_response_message, 'content', None)
        if not raw_content or not raw_content.strip():
            error_message = "LLM 响应内容 (content 字段) 为空或仅包含空白字符。"
            logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message}")
            return None, error_message, [{"jsonPath": "content", "issue_description": error_message}]

        logger.debug(f"[{parser_id}-OutputParser] 接收到的原始 LLM content (完整):\n{raw_content}")

        content_to_parse_for_json = raw_content
        think_match = re.search(r"<think>(.*?)</think>", raw_content, re.DOTALL | re.IGNORECASE)

        if think_match:
            extracted_thought_process = think_match.group(1).strip()
            content_to_parse_for_json = raw_content[think_match.end():].strip()
            logger.info(f"[{parser_id}-OutputParser] 成功提取到 <think>...</think> 内容。")
            logger.debug(f"[{parser_id}-OutputParser] 提取的思考过程 (预览):\n{extracted_thought_process[:1000]}...")
            logger.debug(f"[{parser_id}-OutputParser] 剩余内容待解析为JSON (预览):\n{content_to_parse_for_json[:1000]}...")
            if not content_to_parse_for_json:
                 error_message = "LLM 响应包含 <think> 块但之后没有内容可解析为 JSON。"
                 logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message}")
                 return None, error_message, [{"jsonPath": "root_after_think_block", "issue_description": error_message}]
        else:
            logger.warning(f"[{parser_id}-OutputParser] 未在LLM响应中找到有效的 <think>...</think> 块,将尝试按旧方式解析整个内容。")

        json_string_to_parse = content_to_parse_for_json.strip()
        match_md_json = re.search(r"```json\s*(.*?)\s*```", json_string_to_parse, re.DOTALL | re.IGNORECASE)
        if match_md_json:
            json_string_to_parse = match_md_json.group(1).strip()
            logger.debug(f"[{parser_id}-OutputParser] 从 Markdown 代码块中提取到 JSON 字符串。")
        else:
            first_brace = json_string_to_parse.find('{')
            last_brace = json_string_to_parse.rfind('}')
            if first_brace > 0 and (last_brace == -1 or first_brace > last_brace) :
                prefix_content = json_string_to_parse[:first_brace].strip()
                logger.warning(f"[{parser_id}-OutputParser] 在预期的 JSON 开头 '{{' 之前检测到非空白内容: '{prefix_content[:1000]}...'。将尝试从 '{{' 开始解析。")
                json_string_to_parse = json_string_to_parse[first_brace:]
            elif first_brace == -1 :
                error_message = "无法在 LLM 响应内容 (post-<think>或完整) 中找到 JSON 对象的起始 '{'。"
                logger.error(f"[{parser_id}-OutputParser] 解析失败: {error_message} 原始响应预览 (post-<think>或完整): {json_string_to_parse[:1000]}...")
                return None, error_message, [{"jsonPath": "content_for_json_parsing", "issue_description": error_message}]

        logger.debug(f"[{parser_id}-OutputParser] 预处理后,准备解析的 JSON 字符串 (完整):\n{json_string_to_parse}")

        try:
            parsed_json_dict = json.loads(json_string_to_parse)
            logger.info(f"[{parser_id}-OutputParser] JSON 字符串成功解析为字典。")
        except json.JSONDecodeError as json_err:
            error_message = f"JSON 解析失败: {json_err}。"
            logger.error(f"[{parser_id}-OutputParser] {error_message} Raw JSON string (截断): '{json_string_to_parse[:1000]}...'")
            return None, error_message, [{"jsonPath": "root_json_parsing", "issue_description": f"JSONDecodeError: {json_err}"}]
        except Exception as e:
            error_message = f"解析 LLM 响应时发生未知错误: {e}"
            logger.error(f"[{parser_id}-OutputParser] 解析时未知错误: {error_message}", exc_info=True)
            return None, error_message, [{"jsonPath": "root_json_parsing", "issue_description": f"Unexpected parsing error: {e}"}]

        if not isinstance(parsed_json_dict, dict):
            error_message = "解析后的结果不是一个 JSON 对象 (字典)。"
            logger.error(f"[{parser_id}-OutputParser] 结构验证失败: {error_message}")
            return None, error_message, [{"jsonPath": "root_json_parsing", "issue_description": error_message}]

        if extracted_thought_process is not None:
            if "thoughtProcess" in parsed_json_dict and parsed_json_dict["thoughtProcess"] and parsed_json_dict["thoughtProcess"] != extracted_thought_process:
                logger.warning(f"[{parser_id}-OutputParser] LLM提供了<think>块和JSON内部的thoughtProcess。将优先使用<think>块内容。")
            parsed_json_dict["thoughtProcess"] = extracted_thought_process
            logger.info(f"[{parser_id}-OutputParser] 已将<think>块内容置于parsed_json_dict['thoughtProcess']。")
        elif "thoughtProcess" not in parsed_json_dict or not parsed_json_dict.get("thoughtProcess", "").strip():
             logger.warning(f"[{parser_id}-OutputParser] LLM未提供<think>块,且JSON内部的thoughtProcess为空或缺失。思考过程可能不完整。")

        required_top_level_fields = ["requestId", "llmInteractionId", "timestampUtc", "status", "executionPhase", "thoughtProcess", "decision"]
        for field in required_top_level_fields:
            if field not in parsed_json_dict:
                failed_validation_points_list.append({"jsonPath": field, "issue_description": f"缺少必需的顶级字段 '{field}'。"})

        status_val = parsed_json_dict.get("status")
        if status_val not in ["success", "failure"]:
            failed_validation_points_list.append({"jsonPath": "status", "issue_description": f"字段 'status' 的值 '{status_val}' 无效,必须是 'success' 或 'failure'。"})

        exec_phase_val = parsed_json_dict.get("executionPhase")
        if exec_phase_val not in ["planning", "response_generation"]:
            failed_validation_points_list.append({"jsonPath": "executionPhase", "issue_description": f"字段 'executionPhase' 的值 '{exec_phase_val}' 无效,必须是 'planning' 或 'response_generation'。"})
        elif exec_phase_val != execution_phase:
             failed_validation_points_list.append({"jsonPath": "executionPhase", "issue_description": f"LLM报告的 'executionPhase' ('{exec_phase_val}') 与 Agent 期望的阶段 ('{execution_phase}') 不匹配。"})

        if status_val == "failure":
            error_details_obj = parsed_json_dict.get("errorDetails")
            if not isinstance(error_details_obj, dict):
                failed_validation_points_list.append({"jsonPath": "errorDetails", "issue_description": "当 'status' 为 'failure' 时, 'errorDetails' 必须是一个对象。"})
            else:
                if not isinstance(error_details_obj.get("errorType"), str) or not error_details_obj.get("errorType","").strip():
                    failed_validation_points_list.append({"jsonPath": "errorDetails.errorType", "issue_description": "'errorDetails' 对象中缺少有效的 'errorType' 字符串。"})
                if not isinstance(error_details_obj.get("errorCode"), str) or not error_details_obj.get("errorCode","").strip():
                    failed_validation_points_list.append({"jsonPath": "errorDetails.errorCode", "issue_description": "'errorDetails' 对象中缺少有效的 'errorCode' 字符串。"})
                if not isinstance(error_details_obj.get("technicalMessage"), str) or not error_details_obj.get("technicalMessage","").strip():
                    failed_validation_points_list.append({"jsonPath": "errorDetails.technicalMessage", "issue_description": "'errorDetails' 对象中缺少有效的 'technicalMessage' 字符串。"})
                if "isDirectLlmFailure" not in error_details_obj or not isinstance(error_details_obj.get("isDirectLlmFailure"), bool):
                    logger.warning(f"[{parser_id}-OutputParser] 'errorDetails.isDirectLlmFailure' 字段缺失或类型不为布尔。Agent将假定为False。LLM输出应包含此字段。")
                    failed_validation_points_list.append({"jsonPath": "errorDetails.isDirectLlmFailure", "issue_description": "'errorDetails' 对象中缺少有效的布尔字段 'isDirectLlmFailure'。"})
        elif status_val == "success" and parsed_json_dict.get("errorDetails") is not None:
             failed_validation_points_list.append({"jsonPath": "errorDetails", "issue_description": "当 'status' 为 'success' 时, 'errorDetails' 字段必须为 null 或不存在。"})

        if not isinstance(parsed_json_dict.get("thoughtProcess"), str):
            if parsed_json_dict.get("thoughtProcess") is not None:
                logger.warning(f"[{parser_id}-OutputParser] 'thoughtProcess' 字段存在但类型不正确 (应为字符串)。")
                failed_validation_points_list.append({"jsonPath": "thoughtProcess", "issue_description": "'thoughtProcess' 字段如果存在,必须是字符串。"})
        elif not parsed_json_dict.get("thoughtProcess","").strip() and extracted_thought_process is None:
            logger.warning(f"[{parser_id}-OutputParser] LLM未提供<think>块,且JSON内部的thoughtProcess为空或缺失。思考过程可能不完整。")

        decision_obj = parsed_json_dict.get("decision")
        if not isinstance(decision_obj, dict):
            failed_validation_points_list.append({"jsonPath": "decision", "issue_description": "'decision' 字段必须是一个对象。"})
        else:
            raw_is_call_tools_val = decision_obj.get("isCallTools")
            is_call_tools_val = None
            if isinstance(raw_is_call_tools_val, bool):
                is_call_tools_val = raw_is_call_tools_val
            elif isinstance(raw_is_call_tools_val, str):
                if raw_is_call_tools_val.lower() == 'true':
                    is_call_tools_val = True
                elif raw_is_call_tools_val.lower() == 'false':
                    is_call_tools_val = False
            
            if is_call_tools_val is None:
                failed_validation_points_list.append({"jsonPath": "decision.isCallTools", "issue_description": f"'decision.isCallTools' 值 '{raw_is_call_tools_val}' 无效。必须是布尔类型或可解析为布尔的字符串('true'/'false')。"})
            else:
                decision_obj["isCallTools"] = is_call_tools_val
                logger.debug(f"[{parser_id}-OutputParser] 'isCallTools' (原始值: {raw_is_call_tools_val}) 被解析为布尔值: {is_call_tools_val}。")

            tool_call_requests = decision_obj.get("toolCallRequests")
            if is_call_tools_val is True:
                if not isinstance(tool_call_requests, list):
                    failed_validation_points_list.append({"jsonPath": "decision.toolCallRequests", "issue_description": "当 'isCallTools' 为 True 时, 'toolCallRequests' 必须是一个列表。"})
                elif not tool_call_requests:
                    logger.warning(f"[{parser_id}-OutputParser] 'isCallTools' 为 True 但 'toolCallRequests' 列表为空。这可能是一个规划逻辑问题。")
                elif tool_call_requests:
                    for i, tool_req_item in enumerate(tool_call_requests):
                        item_path_prefix = f"decision.toolCallRequests[{i}]"
                        if not isinstance(tool_req_item, dict):
                            failed_validation_points_list.append({"jsonPath": item_path_prefix, "issue_description": "列表中的每个工具调用请求必须是对象。"}); continue

                        tool_call_id = tool_req_item.get("toolCallId")
                        if not isinstance(tool_call_id, str) or not tool_call_id.strip():
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.toolCallId", "issue_description": "缺少有效的 'toolCallId' 字符串。"})

                        tool_name = tool_req_item.get("toolName")
                        if not isinstance(tool_name, str) or not tool_name.strip():
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.toolName", "issue_description": "缺少有效的 'toolName' 字符串。"})

                        tool_arguments = tool_req_item.get("toolArguments")
                        if not isinstance(tool_arguments, dict):
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.toolArguments", "issue_description": "'toolArguments' 必须是一个对象。"})
                        elif tool_name and isinstance(tool_name, str) and tool_name.strip():
                            arg_validation_errors = self._validate_tool_arguments(tool_name, tool_arguments, tool_call_id if (tool_call_id and isinstance(tool_call_id, str) and tool_call_id.strip()) else f"index_{i}")
                            failed_validation_points_list.extend(arg_validation_errors)

                        ui_hints = tool_req_item.get("uiHints")
                        if ui_hints is not None and not isinstance(ui_hints, dict):
                            failed_validation_points_list.append({"jsonPath": f"{item_path_prefix}.uiHints", "issue_description": "'uiHints' 如果存在,必须是一个对象。"})

            elif is_call_tools_val is False:
                if tool_call_requests is not None and (not isinstance(tool_call_requests, list) or tool_call_requests):
                    failed_validation_points_list.append({"jsonPath": "decision.toolCallRequests", "issue_description": "当 'isCallTools' 为 False 时, 'toolCallRequests' 必须是 null 或空列表 []。"})

            response_user_obj = decision_obj.get("responseToUser")
            if not isinstance(response_user_obj, dict):
                failed_validation_points_list.append({"jsonPath": "decision.responseToUser", "issue_description": "'responseToUser' 必须是一个对象。"})
            else:
                if not isinstance(response_user_obj.get("contentType"), str) or not response_user_obj.get("contentType","").strip():
                     failed_validation_points_list.append({"jsonPath": "decision.responseToUser.contentType", "issue_description": "'responseToUser' 对象缺少有效的 'contentType' 字符串。"})

                resp_content = response_user_obj.get("content")
                if not isinstance(resp_content, str):
                     failed_validation_points_list.append({"jsonPath": "decision.responseToUser.content", "issue_description": "'responseToUser.content' 必须是字符串。"})

                if is_call_tools_val is False and (not resp_content or resp_content.strip() == ""):
                     if execution_phase == "response_generation":
                         failed_validation_points_list.append({"jsonPath": "decision.responseToUser.content", "issue_description": "在响应生成阶段,当不调用工具时, 'responseToUser.content' 必须是有效的非空字符串。"})
                     else:
                        failed_validation_points_list.append({"jsonPath": "decision.responseToUser.content", "issue_description": "当 'isCallTools' 为 False (直接回复) 时, 'responseToUser.content' 必须是有效的非空字符串。"})

                suggestions = response_user_obj.get("suggestionsForNextSteps")
                if suggestions is not None:
                    if not isinstance(suggestions, list):
                        failed_validation_points_list.append({"jsonPath": "decision.responseToUser.suggestionsForNextSteps", "issue_description": "'suggestionsForNextSteps' 如果存在,必须是一个列表。"})
                    else:
                        for j, sugg_item in enumerate(suggestions):
                            sugg_path_prefix = f"decision.responseToUser.suggestionsForNextSteps[{j}]"
                            if not isinstance(sugg_item, dict):
                                failed_validation_points_list.append({"jsonPath": sugg_path_prefix, "issue_description": "列表中的每个建议必须是对象。"}); continue
                            if not isinstance(sugg_item.get("textForUser"), str) or not sugg_item.get("textForUser","").strip():
                                failed_validation_points_list.append({"jsonPath": f"{sugg_path_prefix}.textForUser", "issue_description": "建议对象缺少有效的 'textForUser' 字符串。"})

                clarification_flag = response_user_obj.get("requiresUserClarificationForCurrentRequest")
                if clarification_flag is not None and not isinstance(clarification_flag, bool):
                     failed_validation_points_list.append({"jsonPath": "decision.responseToUser.requiresUserClarificationForCurrentRequest", "issue_description": "'requiresUserClarificationForCurrentRequest' 如果存在,必须是布尔类型。"})

        diagnostics_obj = parsed_json_dict.get("diagnostics")
        if diagnostics_obj is not None and not isinstance(diagnostics_obj, dict):
            failed_validation_points_list.append({"jsonPath": "diagnostics", "issue_description": "'diagnostics' 如果存在,必须是一个对象。"})

        if failed_validation_points_list:
            error_message_parts = [f"JSON 结构或内容验证失败 (共 {len(failed_validation_points_list)} 点):"]
            for err_point in failed_validation_points_list:
                error_message_parts.append(f"  -路径 '{err_point['jsonPath']}': {err_point['issue_description']}")
            error_message = "\n".join(error_message_parts)

            json_content_for_log = json.dumps(parsed_json_dict, indent=2, ensure_ascii=False) if parsed_json_dict else json_string_to_parse[:1000]
            logger.error(f"[{parser_id}-OutputParser]\n{error_message}\n解析的 JSON 内容 (可能不完整或无效):\n{json_content_for_log}")
            return None, error_message, failed_validation_points_list

        logger.info(f"[{parser_id}-OutputParser] LLM 响应 (阶段: {execution_phase}, LLM_ID: {parsed_json_dict.get('llmInteractionId', 'N/A')}) 已成功解析并验证为 ManusLLMResponse-V1.0.0兼容结构 (思考过程来源: {'<think> block' if extracted_thought_process else 'JSON field'})！")
        return parsed_json_dict, "", []


# --- 模块化组件: ToolExecutor (工具执行器) ---
class ToolExecutor:
    def __init__(self, agent_instance: 'CircuitAgent', max_tool_retries: int = 1, tool_retry_delay_seconds: float = 1.0):
        logger.info("[ToolExecutor] 初始化工具执行器 (支持异步, 重试, 失败中止, UI回调增强 V1.0.0)。") # Version update
        if not isinstance(agent_instance, CircuitAgent):
            raise TypeError("ToolExecutor 需要一个 CircuitAgent 实例。")
        self.agent_instance = agent_instance
        if not hasattr(agent_instance, 'memory_manager') or not isinstance(agent_instance.memory_manager, MemoryManager):
            raise TypeError("Agent 实例缺少有效的 MemoryManager。")

        self.verbose_mode = getattr(agent_instance, 'verbose_mode', True)
        self.max_tool_retries = max(0, max_tool_retries)
        self.tool_retry_delay_seconds = max(0.1, tool_retry_delay_seconds)

        logger.info(f"[ToolExecutor] 工具执行配置: 每个工具最多重试 {self.max_tool_retries} 次,重试间隔 {self.tool_retry_delay_seconds} 秒。详细模式: {self.verbose_mode}。")

    async def _send_tool_status_update(
        self,
        status_callback: Optional[Callable[[Dict], Awaitable[None]]],
        tool_call_id: str,
        tool_name: str,
        tool_status: str,
        message: str,
        tool_arguments: Optional[Dict] = None,
        details: Optional[Dict] = None
    ):
        if status_callback:
            request_id_to_send = self.agent_instance.current_request_id if hasattr(self.agent_instance, 'current_request_id') else None
            arguments_summary_str = "N/A"
            if tool_arguments:
                try:
                    args_parts = []
                    for k, v in tool_arguments.items():
                        v_str = str(v) if v is not None else "None"
                        v_preview = v_str[:30] + '...' if len(v_str) > 30 else v_str
                        args_parts.append(f"{k}: {v_preview}")
                    arguments_summary_str = "; ".join(args_parts)
                    if not arguments_summary_str: arguments_summary_str = "(无参数)"
                except Exception as e_sum:
                    logger.warning(f"生成工具参数摘要时出错: {e_sum}")
                    arguments_summary_str = "(参数摘要生成错误)"
            await status_callback({
                "type": "tool_status_update",
                "request_id": request_id_to_send,
                "tool_call_id": tool_call_id,
                "tool_name": tool_name,
                "tool_arguments_summary_str": arguments_summary_str,
                "status": tool_status,
                "message": message,
                "details": details if details else {}
            })

    async def execute_tool_calls(self, tool_call_requests_from_plan: List[Dict[str, Any]], status_callback: Optional[Callable[[Dict], Awaitable[None]]] = None) -> List[Dict[str, Any]]:
        executor_id = f"exec_v1_1_3_{str(uuid4())[:8]}" 
        logger.info(f"[{executor_id}-ToolExecutor] 准备异步执行 {len(tool_call_requests_from_plan)} 个工具调用请求 (V1.0.0)...")
        execution_results_for_llm_history: List[Dict[str, Any]] = []

        if not tool_call_requests_from_plan:
            logger.info(f"[{executor_id}-ToolExecutor] 没有工具需要执行。")
            return []

        total_tools_in_plan = len(tool_call_requests_from_plan)

        for i, tool_request in enumerate(tool_call_requests_from_plan):
            llm_generated_tool_call_id = tool_request.get('toolCallId', f'fallback_tool_id_{str(uuid4())[:8]}')
            python_function_name = tool_request.get('toolName', 'unknown_function')
            parsed_arguments = tool_request.get('toolArguments', {})
            ui_hints_from_plan = tool_request.get('uiHints', {})
            tool_display_name = ui_hints_from_plan.get('displayNameForTool') or python_function_name.replace('_tool', '').replace('_', ' ').title()

            action_result_final_for_tool: Optional[Dict[str, Any]] = None
            
            logger.info(f"[{executor_id}-ToolExecutor] 处理工具调用 {i + 1}/{total_tools_in_plan}: Name='{python_function_name}', LLM_ToolCallID='{llm_generated_tool_call_id}'。")
            logger.debug(f"[{executor_id}-ToolExecutor] 待执行工具 '{python_function_name}' 的参数: {parsed_arguments}。")

            await self._send_tool_status_update(
                status_callback, llm_generated_tool_call_id, python_function_name,
                "running", f"开始执行操作: {tool_display_name}...",
                tool_arguments=parsed_arguments,
                details={"ui_hints": ui_hints_from_plan}
            )

            tool_action_method = getattr(self.agent_instance, python_function_name, None)
            
            # 检查工具方法是否存在且可调用
            if not callable(tool_action_method) or not getattr(tool_action_method, '_is_tool', False):
                err_msg_not_found = f"Agent 未实现名为 '{python_function_name}' 的已注册工具方法 (ID: {llm_generated_tool_call_id})。"
                logger.error(f"[{executor_id}-ToolExecutor] 工具未实现或未注册: {err_msg_not_found}")
                action_result_final_for_tool = {"status": "failure", "message": err_msg_not_found, "error": {"error_type": "TOOL_IMPLEMENTATION_ERROR", "error_code": "TOOL_NOT_FOUND_OR_NOT_REGISTERED", "technical_message": f"Action method '{python_function_name}' not found or not a registered tool in Agent."}}
            else: # 工具方法存在且已注册
                for retry_attempt in range(self.max_tool_retries + 1): # +1 to include the initial attempt
                    current_attempt_num = retry_attempt + 1
                    if retry_attempt > 0: # If this is a retry
                        logger.warning(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 执行失败,正在进行第 {retry_attempt}/{self.max_tool_retries} 次重试...")
                        await self._send_tool_status_update(
                            status_callback, llm_generated_tool_call_id, python_function_name,
                            "retrying", f"操作 '{tool_display_name}' 失败,等待 {self.tool_retry_delay_seconds} 秒后重试 (尝试 {current_attempt_num})...",
                            tool_arguments=parsed_arguments, details={"retry_count": retry_attempt, "max_retries": self.max_tool_retries, "ui_hints": ui_hints_from_plan}
                        )
                        await asyncio.sleep(self.tool_retry_delay_seconds)

                    action_result_this_attempt: Optional[Dict[str, Any]] = None
                    try:
                        is_coro = inspect.iscoroutinefunction(tool_action_method)
                        logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) 调用工具 '{python_function_name}'. 是否为协程: {is_coro}.")
                        
                        if is_coro:
                            # 直接 await 异步工具方法
                            logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) 直接 awaiting coroutine: {python_function_name}")
                            action_result_this_attempt = await tool_action_method(arguments=parsed_arguments)
                        else:
                            # 在线程中运行同步工具方法
                            logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) running sync tool in thread: {python_function_name}")
                            action_result_this_attempt = await asyncio.to_thread(tool_action_method, arguments=parsed_arguments)
                        
                        logger.debug(f"[{executor_id}-ToolExecutor] (尝试 {current_attempt_num}) 工具 '{python_function_name}' 返回结果类型: {type(action_result_this_attempt)}, 内容预览: {str(action_result_this_attempt)[:500]}...")

                        if not isinstance(action_result_this_attempt, dict) or \
                           'status' not in action_result_this_attempt or \
                           'message' not in action_result_this_attempt:
                            err_msg_struct = f"工具 '{python_function_name}' 返回的内部结果结构无效。期望字典包含 'status' 和 'message'。"
                            logger.error(f"[{executor_id}-ToolExecutor] 工具返回结构错误 (尝试 {current_attempt_num}): {err_msg_struct}. 实际返回类型: {type(action_result_this_attempt)}, 内容(部分): {str(action_result_this_attempt)[:200]}")
                            action_result_this_attempt = { # 强制转换为标准失败结构
                                "status": "failure", 
                                "message": f"错误: 工具 '{python_function_name}' 内部返回结果结构无效。", 
                                "error": {"error_type": "TOOL_IMPLEMENTATION_ERROR", "error_code": "INVALID_TOOL_ACTION_RESULT_STRUCTURE", "technical_message": err_msg_struct, "actual_return_type": str(type(action_result_this_attempt)), "actual_return_preview": str(action_result_this_attempt)[:200]}
                            }
                        else:
                            logger.info(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' 执行完毕 (尝试 {current_attempt_num})。状态: {action_result_this_attempt.get('status', 'N/A')}。")

                        if action_result_this_attempt.get("status") == "success":
                            action_result_final_for_tool = action_result_this_attempt
                            break # 成功，退出重试循环
                        else: # status 不是 "success"
                            logger.warning(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 执行失败 (尝试 {current_attempt_num})。报告状态: {action_result_this_attempt.get('status')}, 消息: {action_result_this_attempt.get('message')}")
                            action_result_final_for_tool = action_result_this_attempt # 保存本次失败的结果

                    except TypeError as te:
                        err_msg_type = f"调用工具 '{python_function_name}' 时参数不匹配或内部类型错误: {te}。"
                        logger.error(f"[{executor_id}-ToolExecutor] 工具调用参数/类型错误 (尝试 {current_attempt_num}): {err_msg_type}", exc_info=True)
                        action_result_final_for_tool = {"status": "failure", "message": f"错误: 调用工具 '{python_function_name}' 时参数或内部类型错误。", "error": {"error_type": "TOOL_EXECUTION_ERROR", "error_code": "ARGUMENT_TYPE_MISMATCH_OR_INTERNAL_TYPE_ERROR", "technical_message": err_msg_type, "exception_details": traceback.format_exc(limit=3)}}
                        break # 严重错误，无需重试
                    except Exception as exec_err:
                        err_msg_exec = f"工具 '{python_function_name}' 执行期间发生意外内部错误 (尝试 {current_attempt_num}): {exec_err}"
                        logger.error(f"[{executor_id}-ToolExecutor] 工具执行内部错误: {err_msg_exec}", exc_info=True)
                        action_result_final_for_tool = {"status": "failure", "message": f"错误: 执行工具 '{python_function_name}' 时发生内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "UNEXPECTED_TOOL_EXECUTION_FAILURE", "technical_message": err_msg_exec, "exception_details": traceback.format_exc(limit=3)}}
                    
                    # 如果是最后一次尝试，无论结果如何，都将是最终结果
                    if retry_attempt == self.max_tool_retries:
                        # action_result_final_for_tool 已经被设为最后一次尝试的结果
                        break # 退出重试循环

            # 确保 action_result_final_for_tool 有值
            if action_result_final_for_tool is None:
                 logger.error(f"[{executor_id}-ToolExecutor] 内部逻辑错误: 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 在所有重试后 action_result_final_for_tool 仍为 None。")
                 action_result_final_for_tool = {"status": "failure", "message": f"错误: 工具 '{python_function_name}' 未能确定最终结果。", "error": {"error_type": "TOOL_EXECUTION_ERROR", "error_code": "MISSING_TOOL_RESULT_LOGIC_ERROR", "technical_message": "Tool action_result_final_for_tool was None after retry loop."}}

            tool_succeeded_this_cycle = (action_result_final_for_tool.get("status") == "success")

            final_tool_status_str_for_cb = "succeeded" if tool_succeeded_this_cycle else "failed"
            status_message_for_cb = action_result_final_for_tool.get('message', '操作处理完成,但无特定消息。')
            details_for_cb: Dict[str, Any] = {"ui_hints": ui_hints_from_plan}
            if not tool_succeeded_this_cycle:
                details_for_cb["error"] = action_result_final_for_tool.get("error", {"error_type": "UNKNOWN_FAILURE", "technical_message": "工具最终失败,无详细错误信息。"})
            elif action_result_final_for_tool.get("data") is not None:
                 try: details_for_cb["result_data_preview"] = json.dumps(action_result_final_for_tool["data"], ensure_ascii=False, default=str, indent=None)[:1000]
                 except: details_for_cb["result_data_preview"] = "(数据无法序列化预览)"

            await self._send_tool_status_update(
                status_callback, llm_generated_tool_call_id, python_function_name,
                final_tool_status_str_for_cb, status_message_for_cb,
                details=details_for_cb
            )

            tool_result_message_for_llm = {
                "role": "tool",
                "tool_call_id": llm_generated_tool_call_id,
                "name": python_function_name,
                "content": json.dumps(action_result_final_for_tool, ensure_ascii=False, default=str)
            }
            execution_results_for_llm_history.append(tool_result_message_for_llm)
            logger.debug(f"[{executor_id}-ToolExecutor] 已记录工具 '{llm_generated_tool_call_id}' 的最终执行结果 (状态: {final_tool_status_str_for_cb}) 到LLM历史。")

            if not tool_succeeded_this_cycle:
                logger.warning(f"[{executor_id}-ToolExecutor] 工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 在所有重试后仍然失败。中止后续工具执行。")
                if i + 1 < total_tools_in_plan:
                    for k_aborted in range(i + 1, total_tools_in_plan):
                        aborted_tool_req = tool_call_requests_from_plan[k_aborted]
                        aborted_tool_id = aborted_tool_req.get('toolCallId', f'fallback_aborted_id_{str(uuid4())[:8]}')
                        aborted_tool_name = aborted_tool_req.get('toolName', 'unknown_aborted_tool')
                        aborted_ui_hints = aborted_tool_req.get('uiHints', {})
                        aborted_tool_display_name = aborted_ui_hints.get('displayNameForTool') or aborted_tool_name.replace('_tool','').replace('_',' ').title()

                        await self._send_tool_status_update(
                            status_callback, aborted_tool_id, aborted_tool_name,
                            "aborted_due_to_previous_failure",
                            f"操作 '{aborted_tool_display_name}' 已中止,因为先前的工具 '{tool_display_name}' 执行失败。",
                            details={"reason": f"Aborted due to failure of tool '{python_function_name}' (ID: {llm_generated_tool_call_id})", "ui_hints": aborted_ui_hints}
                        )
                        aborted_tool_result_for_llm_content = {
                                "status": "failure",
                                "message": f"工具 '{aborted_tool_name}' 未执行,因为前序工具 '{python_function_name}' (ID: {llm_generated_tool_call_id}) 失败。",
                                "error": {"error_type": "TOOL_CHAIN_ABORTED", "error_code": "PRECEDING_TOOL_FAILURE", "technical_message": f"Execution of '{aborted_tool_name}' was skipped due to the failure of tool '{python_function_name}' (ID: {llm_generated_tool_call_id})."}
                            }
                        execution_results_for_llm_history.append({
                            "role": "tool", "tool_call_id": aborted_tool_id, "name": aborted_tool_name,
                            "content": json.dumps(aborted_tool_result_for_llm_content, ensure_ascii=False)
                        })
                        logger.info(f"[{executor_id}-ToolExecutor] 为中止的工具 '{aborted_tool_name}' (ID: {aborted_tool_id}) 添加了模拟失败记录到LLM历史。")
                break 

        total_processed_tools = len(execution_results_for_llm_history)
        logger.info(f"[{executor_id}-ToolExecutor] 工具执行流程完成。共处理/记录了 {total_processed_tools}/{total_tools_in_plan} 个计划中的工具调用 (可能因失败提前中止)。")
        return execution_results_for_llm_history

# --- Agent 核心类 (V1.0.0 - 11 Tools) ---
class CircuitAgent:
    def __init__(self, api_key: str, model_name: str = "glm-z1-flash",
                 max_short_term_items: int = 30, max_long_term_items: int = 75,
                 planning_llm_retries: int = 5, max_tool_retries: int = 3,
                 tool_retry_delay_seconds: float = 1.0, max_replanning_attempts: int = 3,
                 verbose: bool = True):
        logger.info(f"\n{'='*30} CircuitAgent 初始化开始 (V1.0.0 - 11 Tools) {'='*30}") # Version update
        self.api_key = api_key
        self.verbose_mode = verbose
        self.current_request_id: Optional[str] = None

        global console_handler
        console_log_level = logging.DEBUG if self.verbose_mode else logging.INFO
        if console_handler:
            console_handler.setLevel(console_log_level)
            logger.info(f"[AgentV1_1_3 Init] 控制台日志级别已设置为: {logging.getLevelName(console_log_level)} (详细模式: {self.verbose_mode})。")
        else:
            logger.warning("[AgentV1_1_3 Init] 未找到控制台日志处理器,无法动态设置日志级别。")

        self.tools_registry: Dict[str, Dict[str, Any]] = {}
        logger.info("[AgentV1_1_3 Init] 正在动态发现并注册工具...")
        for name, method in inspect.getmembers(self, predicate=inspect.ismethod):
            # 重要: 确保 inspect.ismethod 能正确处理被 @register_tool (特别是被 functools.wraps) 装饰的方法
            if hasattr(method, '_is_tool') and method._is_tool:
                schema = getattr(method, '_tool_schema', None)
                if schema and isinstance(schema, dict) and 'description' in schema and 'parameters' in schema:
                    self.tools_registry[name] = schema
                    # 记录工具是否为异步
                    is_async_tool = inspect.iscoroutinefunction(method)
                    logger.info(f"[AgentV1_1_3 Init] ✓ 已注册工具: '{name}' (异步: {is_async_tool})。")
                else:
                    logger.warning(f"[AgentV1_1_3 Init] 发现工具 '{name}' 但其 Schema 结构不完整或无效,已跳过注册。")
        if not self.tools_registry:
            logger.warning("[AgentV1_1_3 Init] 未发现任何通过 @register_tool 注册的工具！Agent 将主要依赖直接问答。")
        else:
            logger.info(f"[AgentV1_1_3 Init] 共发现并注册了 {len(self.tools_registry)} 个工具。")
            if logger.isEnabledFor(logging.DEBUG):
                try: logger.debug(f"[AgentV1_1_3 Init] 工具注册表详情:\n{json.dumps(self.tools_registry, indent=2, ensure_ascii=False)}")
                except Exception as e_dump: logger.debug(f"无法序列化工具注册表进行日志记录: {e_dump}")

        try:
            self.memory_manager = MemoryManager(max_short_term_items, max_long_term_items)
            self.llm_interface = LLMInterface(agent_instance=self, model_name=model_name)
            self.output_parser = OutputParser(agent_tools_registry=self.tools_registry)
            self.tool_executor = ToolExecutor(
                agent_instance=self,
                max_tool_retries=max_tool_retries,
                tool_retry_delay_seconds=tool_retry_delay_seconds
            )
        except (ValueError, ConnectionError, TypeError) as e:
            logger.critical(f"[AgentV1_1_3 Init] 核心模块初始化失败: {e}", exc_info=True)
            raise

        self.planning_llm_retries = max(0, planning_llm_retries)
        self.max_replanning_attempts = max(0, max_replanning_attempts)
        logger.info(f"[AgentV1_1_3 Init] 规划LLM重试次数: {self.planning_llm_retries}, 工具执行重试次数: {max_tool_retries}, 最大重规划尝试次数: {self.max_replanning_attempts}。")
        logger.info(f"\n{'='*30} CircuitAgent 初始化成功 (V1.0.0 - 11 Tools) {'='*30}\n")

    # --- Action Implementations (Tool methods) ---
    @register_tool(
        description="添加一个新的电路元件 (例如: 电阻, 电容, 电池, LED, 开关, 芯片, 地线, 端子/连接点等)。如果用户未指定 ID,系统会自动为其生成一个。",
        parameters={"type": "object", "properties": {"component_type": {"type": "string", "description": "元件的类型 (例如: '电阻', 'LED', 'Terminal', 'INPUT', 'GND')。"}, "component_id": {"type": "string", "description": "可选的用户为元件指定的ID。如果提供,则使用此ID; 如果不提供或提供格式无效,则由系统自动生成。"}, "value": {"type": "string", "description": "可选的元件值 (例如: '1k', '10uF', '3V')。"}}, "required": ["component_type"]}
    )
    def add_component_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-AddComponentTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行添加元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        
        component_type = arguments.get("component_type")
        component_id_req = arguments.get("component_id")
        value_req = arguments.get("value")

        if not component_type or not isinstance(component_type, str) or not component_type.strip():
            err_msg = "元件类型是必需的,并且必须是有效的非空字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_TYPE", "technical_message": err_msg}}

        target_id_final: Optional[str] = None
        id_was_generated_by_system = False
        user_provided_id_was_validated: Optional[str] = None

        if component_id_req and isinstance(component_id_req, str) and component_id_req.strip():
            user_provided_id_cleaned = component_id_req.strip().upper()
            if re.match(r'^[a-zA-Z0-9_][a-zA-Z0-9_-]*$', user_provided_id_cleaned) or user_provided_id_cleaned in ["INPUT", "OUTPUT", "GND"]:
                if user_provided_id_cleaned in self.memory_manager.circuit.components:
                    err_msg = f"您提供的元件 ID '{user_provided_id_cleaned}' 已被占用。"
                    logger.error(f"{tool_call_logger_prefix} ID 冲突: {err_msg}")
                    return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "CIRCUIT_STATE_ERROR", "error_code": "COMPONENT_ID_CONFLICT", "technical_message": err_msg, "conflicting_id": user_provided_id_cleaned}}
                else:
                    target_id_final = user_provided_id_cleaned
                    user_provided_id_was_validated = target_id_final
                    logger.debug(f"{tool_call_logger_prefix} 将使用用户提供的有效 ID: '{target_id_final}'。")
            else:
                logger.warning(f"{tool_call_logger_prefix} 用户提供的 ID '{component_id_req}' 格式无效。将自动生成 ID。")

        if target_id_final is None:
            try:
                target_id_final = self.memory_manager.circuit.generate_component_id(component_type)
                id_was_generated_by_system = True
                logger.debug(f"{tool_call_logger_prefix} 已自动为类型 '{component_type}' 生成 ID: '{target_id_final}'。")
            except RuntimeError as e_gen_id:
                err_msg = f"无法自动为类型 '{component_type}' 生成唯一 ID: {e_gen_id}"
                logger.error(f"{tool_call_logger_prefix} ID 生成失败: {err_msg}", exc_info=True)
                return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "INTERNAL_AGENT_ERROR", "error_code": "COMPONENT_ID_GENERATION_FAILED", "technical_message": str(e_gen_id)}}

        processed_value = str(value_req).strip() if value_req is not None and str(value_req).strip() else None
        if value_req is None and "value" in arguments:
            processed_value = None

        try:
            if target_id_final is None:
                raise ValueError("内部错误: 在尝试创建元件之前,未能最终确定有效的元件 ID。")

            new_component = CircuitComponent(target_id_final, component_type, processed_value)
            self.memory_manager.circuit.add_component(new_component)

            logger.info(f"{tool_call_logger_prefix} 成功添加元件 '{new_component.id}' ({new_component.type}) 到电路。")
            success_message_parts = [f"操作成功: 已添加元件 {str(new_component)}。"]
            if id_was_generated_by_system:
                success_message_parts.append(f"(系统自动分配 ID '{new_component.id}')")
            elif user_provided_id_was_validated:
                 success_message_parts.append(f"(使用了您指定的 ID '{user_provided_id_was_validated}')")
            final_success_message = " ".join(success_message_parts)
            self.memory_manager.add_to_long_term(f"添加了元件: {str(new_component)} (请求ID: {self.current_request_id or 'N/A'})")
            return {"status": "success", "message": final_success_message, "data": new_component.to_dict()}

        except ValueError as ve_comp:
            err_msg = f"创建或添加元件对象时发生内部验证错误: {ve_comp}"
            logger.error(f"{tool_call_logger_prefix} 元件创建/添加错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_CREATION_OR_ADDITION_VALIDATION_FAILED", "technical_message": str(ve_comp)}}
        except Exception as e_add_comp:
            err_msg = f"添加元件时发生未知的内部错误: {e_add_comp}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 添加元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "ADD_COMPONENT_UNEXPECTED_FAILURE", "technical_message": str(e_add_comp), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="使用两个已存在元件的 ID 将它们连接起来。",
        parameters={"type": "object", "properties": {"comp1_id": {"type": "string", "description": "第一个元件的 ID。"}, "comp2_id": {"type": "string", "description": "第二个元件的 ID。"}}, "required": ["comp1_id", "comp2_id"]}
    )
    def connect_components_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-ConnectComponentsTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行连接元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")

        comp1_id_req = arguments.get("comp1_id")
        comp2_id_req = arguments.get("comp2_id")

        if not comp1_id_req or not isinstance(comp1_id_req, str) or not comp1_id_req.strip() or \
           not comp2_id_req or not isinstance(comp2_id_req, str) or not comp2_id_req.strip():
            err_msg = "必须提供两个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_IDS_FOR_CONNECTION", "technical_message": err_msg}}

        id1_cleaned = comp1_id_req.strip().upper()
        id2_cleaned = comp2_id_req.strip().upper()

        try:
            connection_was_new = self.memory_manager.circuit.connect_components(id1_cleaned, id2_cleaned)
            if connection_was_new:
                logger.info(f"{tool_call_logger_prefix} 成功添加新连接: {id1_cleaned} <--> {id2_cleaned}。")
                self.memory_manager.add_to_long_term(f"连接了元件: {id1_cleaned} <--> {id2_cleaned} (请求ID: {self.current_request_id or 'N/A'})")
                return {"status": "success", "message": f"操作成功: 已将元件 '{id1_cleaned}' 与 '{id2_cleaned}' 连接起来。", "data": {"connection": sorted((id1_cleaned, id2_cleaned))}}
            else:
                msg_exists = f"元件 '{id1_cleaned}' 和 '{id2_cleaned}' 之间已经存在连接。无需重复操作。"
                logger.info(f"{tool_call_logger_prefix} 连接已存在: {msg_exists}")
                return {"status": "success", "message": f"注意: {msg_exists}", "data": {"connection": sorted((id1_cleaned, id2_cleaned)), "already_existed": True}}
        except ValueError as ve_connect:
            err_msg_val = str(ve_connect)
            logger.error(f"{tool_call_logger_prefix} 连接验证错误: {err_msg_val}")
            error_code_detail = "GENERIC_CIRCUIT_VALIDATION_ERROR"
            if "不存在" in err_msg_val: error_code_detail = "COMPONENT_NOT_FOUND_FOR_CONNECTION"
            elif "连接到它自己" in err_msg_val: error_code_detail = "SELF_CONNECTION_ATTEMPTED"
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": error_code_detail, "technical_message": err_msg_val}}
        except Exception as e_connect:
            err_msg = f"连接元件时发生未知的内部错误: {e_connect}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 连接元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "CONNECT_COMPONENTS_UNEXPECTED_FAILURE", "technical_message": str(e_connect), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(description="获取当前电路的详细描述,包括所有元件及其连接情况。", parameters={"type": "object", "properties": {}})
    def describe_circuit_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-DescribeCircuitTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行描述电路操作。")
        try:
            description = self.memory_manager.circuit.get_state_description()
            logger.info(f"{tool_call_logger_prefix} 成功生成电路描述。")
            return {"status": "success", "message": "已成功获取当前电路的描述。", "data": {"description": description}}
        except Exception as e_describe:
            err_msg = f"生成电路描述时发生意外的内部错误: {e_describe}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 获取电路描述时发生未知错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "DESCRIBE_CIRCUIT_UNEXPECTED_FAILURE", "technical_message": str(e_describe), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(description="彻底清空当前的电路设计,移除所有已添加的元件和它们之间的所有连接。此操作不可逆。", parameters={"type": "object", "properties": {}})
    def clear_circuit_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-ClearCircuitTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行清空电路操作。")
        try:
            self.memory_manager.circuit.clear()
            logger.info(f"{tool_call_logger_prefix} 电路状态已成功清空。")
            self.memory_manager.add_to_long_term(f"执行了清空电路操作 (请求ID: {self.current_request_id or 'N/A'})。")
            return {"status": "success", "message": "操作成功: 当前电路已彻底清空。"}
        except Exception as e_clear:
            err_msg = f"清空电路时发生意外的内部错误: {e_clear}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 清空电路时发生未知错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "CLEAR_CIRCUIT_UNEXPECTED_FAILURE", "technical_message": str(e_clear), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="从电路中移除一个指定的元件及其所有相关的连接。",
        parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要移除的元件的 ID。"}}, "required": ["component_id"]}
    )
    def remove_component_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-RemoveComponentTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行移除元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_id_req = arguments.get("component_id")

        if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
            err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_REMOVAL", "technical_message": err_msg}}

        id_cleaned = component_id_req.strip().upper()
        try:
            removed_comp_details, removed_conn_count = self.memory_manager.circuit.remove_component(id_cleaned)
            logger.info(f"{tool_call_logger_prefix} 成功移除元件 '{id_cleaned}' 及其 {removed_conn_count} 个连接。")
            self.memory_manager.add_to_long_term(f"移除了元件: ID '{id_cleaned}', 类型 '{removed_comp_details.get('type', 'N/A')}' (请求ID: {self.current_request_id or 'N/A'})")
            return {"status": "success", "message": f"操作成功: 已移除元件 '{id_cleaned}' 及其所有 {removed_conn_count} 个连接。", "data": {"removed_component": removed_comp_details, "connections_removed_count": removed_conn_count}}
        except ValueError as ve_remove:
            err_msg_val = str(ve_remove)
            logger.error(f"{tool_call_logger_prefix} 移除验证错误: {err_msg_val}")
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_REMOVAL", "technical_message": err_msg_val}}
        except Exception as e_remove:
            err_msg = f"移除元件时发生未知的内部错误: {e_remove}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 移除元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "REMOVE_COMPONENT_UNEXPECTED_FAILURE", "technical_message": str(e_remove), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="断开两个指定元件之间的连接。如果它们之间原本就没有连接,则不执行任何操作。",
        parameters={"type": "object", "properties": {"comp1_id": {"type": "string", "description": "第一个元件的 ID。"}, "comp2_id": {"type": "string", "description": "第二个元件的 ID。"}}, "required": ["comp1_id", "comp2_id"]}
    )
    def disconnect_components_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-DisconnectComponentsTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行断开元件连接操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        comp1_id_req = arguments.get("comp1_id")
        comp2_id_req = arguments.get("comp2_id")

        if not comp1_id_req or not isinstance(comp1_id_req, str) or not comp1_id_req.strip() or \
           not comp2_id_req or not isinstance(comp2_id_req, str) or not comp2_id_req.strip():
            err_msg = "必须提供两个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_IDS_FOR_DISCONNECTION", "technical_message": err_msg}}

        id1_cleaned = comp1_id_req.strip().upper()
        id2_cleaned = comp2_id_req.strip().upper()

        if id1_cleaned == id2_cleaned:
            err_msg = "不能断开一个元件与它自身的连接（它们本来就不可能连接）。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "SELF_DISCONNECTION_ATTEMPTED", "technical_message": err_msg}}
        
        try:
            if id1_cleaned not in self.memory_manager.circuit.components:
                raise ValueError(f"元件 '{id1_cleaned}' 在电路中不存在。")
            if id2_cleaned not in self.memory_manager.circuit.components:
                raise ValueError(f"元件 '{id2_cleaned}' 在电路中不存在。")

            disconnected_successfully = self.memory_manager.circuit.disconnect_components(id1_cleaned, id2_cleaned)
            if disconnected_successfully:
                logger.info(f"{tool_call_logger_prefix} 成功断开连接: {id1_cleaned} <--> {id2_cleaned}。")
                self.memory_manager.add_to_long_term(f"断开了元件连接: {id1_cleaned} <--> {id2_cleaned} (请求ID: {self.current_request_id or 'N/A'})")
                return {"status": "success", "message": f"操作成功: 已断开元件 '{id1_cleaned}' 与 '{id2_cleaned}' 之间的连接。", "data": {"disconnected_pair": sorted((id1_cleaned, id2_cleaned))}}
            else:
                msg_not_exist = f"元件 '{id1_cleaned}' 和 '{id2_cleaned}' 之间原本就没有连接,无需断开。"
                logger.info(f"{tool_call_logger_prefix} 连接不存在: {msg_not_exist}")
                return {"status": "success", "message": f"注意: {msg_not_exist}", "data": {"disconnected_pair": sorted((id1_cleaned, id2_cleaned)), "already_disconnected_or_not_connected": True}}
        except ValueError as ve_disconnect:
            err_msg_val = str(ve_disconnect)
            logger.error(f"{tool_call_logger_prefix} 断开连接验证错误: {err_msg_val}")
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_DISCONNECTION", "technical_message": err_msg_val}}
        except Exception as e_disconnect:
            err_msg = f"断开元件连接时发生未知的内部错误: {e_disconnect}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 断开元件连接时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "DISCONNECT_COMPONENTS_UNEXPECTED_FAILURE", "technical_message": str(e_disconnect), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="更新电路中一个已存在元件的值 (例如电阻的欧姆值, 电容的法拉值, 电池的电压等)。",
        parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要更新值的元件的 ID。"}, "new_value": {"type": "string", "description": "元件的新值。如果想要清除该元件的值,可以传入 null 或一个空字符串。"}}, "required": ["component_id", "new_value"]}
    )
    def update_component_value_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-UpdateComponentValueTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行更新元件值操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_id_req = arguments.get("component_id")
        new_value_req = arguments.get("new_value")

        if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
            err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_UPDATE", "technical_message": err_msg}}
        
        if not isinstance(new_value_req, (str, type(None))):
            err_msg = "元件的新值 'new_value' 必须是字符串或 null (用于清除值)。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "INVALID_NEW_VALUE_TYPE", "technical_message": err_msg}}

        id_cleaned = component_id_req.strip().upper()
        final_new_value = str(new_value_req).strip() if new_value_req is not None and str(new_value_req).strip() else None

        try:
            if id_cleaned not in self.memory_manager.circuit.components:
                raise ValueError(f"元件 '{id_cleaned}' 在电路中不存在。")
            
            component_to_update = self.memory_manager.circuit.components[id_cleaned]
            old_value = component_to_update.value
            component_to_update.value = final_new_value
            
            logger.info(f"{tool_call_logger_prefix} 成功更新元件 '{id_cleaned}' 的值从 '{old_value}' 到 '{final_new_value}'。")
            self.memory_manager.add_to_long_term(f"更新了元件 '{id_cleaned}' 的值: 旧值 '{old_value}', 新值 '{final_new_value}' (请求ID: {self.current_request_id or 'N/A'})")
            return {"status": "success", "message": f"操作成功: 元件 '{id_cleaned}' 的值已从 '{old_value if old_value else '(无值)'}' 更新为 '{final_new_value if final_new_value else '(无值)'}'。", "data": component_to_update.to_dict()}
        except ValueError as ve_update:
            err_msg_val = str(ve_update)
            logger.error(f"{tool_call_logger_prefix} 更新值验证错误: {err_msg_val}")
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_OPERATION_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_VALUE_UPDATE", "technical_message": err_msg_val}}
        except Exception as e_update:
            err_msg = f"更新元件值时发生未知的内部错误: {e_update}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 更新元件值时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "UPDATE_COMPONENT_VALUE_UNEXPECTED_FAILURE", "technical_message": str(e_update), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="根据提供的 ID 查找电路中的一个特定元件,并返回其详细信息 (类型、ID、值)。",
        parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要查找的元件的 ID。"}}, "required": ["component_id"]}
    )
    def find_component_by_id_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-FindComponentByIdTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行查找元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_id_req = arguments.get("component_id")

        if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
            err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_FIND", "technical_message": err_msg}}

        id_cleaned = component_id_req.strip().upper()
        try:
            if id_cleaned in self.memory_manager.circuit.components:
                component_found = self.memory_manager.circuit.components[id_cleaned]
                logger.info(f"{tool_call_logger_prefix} 成功找到元件 '{id_cleaned}'。")
                return {"status": "success", "message": f"操作成功: 已找到元件 '{id_cleaned}'。", "data": component_found.to_dict()}
            else:
                logger.info(f"{tool_call_logger_prefix} 未找到元件 '{id_cleaned}'。")
                return {"status": "failure", "message": f"错误: 电路中不存在 ID 为 '{id_cleaned}' 的元件。", "error": {"error_type": "CIRCUIT_QUERY_ERROR", "error_code": "COMPONENT_NOT_FOUND_BY_ID", "technical_message": f"Component with ID '{id_cleaned}' not found in circuit."}}
        except Exception as e_find:
            err_msg = f"查找元件时发生未知的内部错误: {e_find}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 查找元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "FIND_COMPONENT_UNEXPECTED_FAILURE", "technical_message": str(e_find), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="列出电路中所有属于指定类型的元件及其详细信息。",
        parameters={"type": "object", "properties": {"component_type": {"type": "string", "description": "要筛选的元件类型 (例如: '电阻', 'LED', '电池')。此匹配不区分大小写。"}}, "required": ["component_type"]}
    )
    def list_components_by_type_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-ListComponentsByTypeTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行按类型列出元件操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_type_req = arguments.get("component_type")

        if not component_type_req or not isinstance(component_type_req, str) or not component_type_req.strip():
            err_msg = "必须提供一个有效的、非空的元件类型字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_TYPE_FOR_LIST", "technical_message": err_msg}}
        
        type_cleaned = component_type_req.strip().lower()
        
        try:
            found_components = []
            for comp in self.memory_manager.circuit.components.values():
                if comp.type.lower() == type_cleaned:
                    found_components.append(comp.to_dict())
            
            if found_components:
                logger.info(f"{tool_call_logger_prefix} 成功找到 {len(found_components)} 个类型为 '{component_type_req}' 的元件。")
                return {"status": "success", "message": f"操作成功: 找到 {len(found_components)} 个类型为 '{component_type_req}' 的元件。", "data": {"components": found_components, "count": len(found_components)}}
            else:
                logger.info(f"{tool_call_logger_prefix} 未找到类型为 '{component_type_req}' 的元件。")
                return {"status": "success", "message": f"提示: 电路中没有找到类型为 '{component_type_req}' 的元件。", "data": {"components": [], "count": 0}}
        except Exception as e_list:
            err_msg = f"按类型列出元件时发生未知的内部错误: {e_list}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 按类型列出元件时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "LIST_COMPONENTS_UNEXPECTED_FAILURE", "technical_message": str(e_list), "exception_details": traceback.format_exc(limit=3)}}

    @register_tool(
        description="获取指定元件当前连接到其他元件的数量。",
        parameters={"type": "object", "properties": {"component_id": {"type": "string", "description": "要查询连接数量的元件的 ID。"}}, "required": ["component_id"]}
    )
    def get_component_connection_count_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        tool_call_logger_prefix = f"[Action-GetComponentConnectionCountTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行获取元件连接数操作。")
        logger.debug(f"{tool_call_logger_prefix} 收到参数: {arguments}")
        component_id_req = arguments.get("component_id")

        if not component_id_req or not isinstance(component_id_req, str) or not component_id_req.strip():
            err_msg = "必须提供一个有效的、非空的元件 ID 字符串。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            return {"status": "failure", "message": f"错误: {err_msg}", "error": {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_COMPONENT_ID_FOR_CONNECTION_COUNT", "technical_message": err_msg}}

        id_cleaned = component_id_req.strip().upper()
        try:
            if id_cleaned not in self.memory_manager.circuit.components:
                raise ValueError(f"元件 '{id_cleaned}' 在电路中不存在,无法查询其连接数。")
            
            connection_count = 0
            for conn_pair in self.memory_manager.circuit.connections:
                if id_cleaned in conn_pair:
                    connection_count += 1
            
            logger.info(f"{tool_call_logger_prefix} 元件 '{id_cleaned}' 有 {connection_count} 个连接。")
            return {"status": "success", "message": f"操作成功: 元件 '{id_cleaned}' 当前有 {connection_count} 个连接。", "data": {"component_id": id_cleaned, "connection_count": connection_count}}
        except ValueError as ve_count:
            err_msg_val = str(ve_count)
            logger.error(f"{tool_call_logger_prefix} 获取连接数验证错误: {err_msg_val}")
            return {"status": "failure", "message": f"错误: {err_msg_val}", "error": {"error_type": "CIRCUIT_QUERY_ERROR", "error_code": "COMPONENT_NOT_FOUND_FOR_CONNECTION_COUNT", "technical_message": err_msg_val}}
        except Exception as e_count:
            err_msg = f"获取元件连接数时发生未知的内部错误: {e_count}"
            logger.error(f"{tool_call_logger_prefix} 未知错误: {err_msg}", exc_info=True)
            return {"status": "failure", "message": "错误: 获取元件连接数时发生未知内部错误。", "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "GET_CONNECTION_COUNT_UNEXPECTED_FAILURE", "technical_message": str(e_count), "exception_details": traceback.format_exc(limit=3)}}

    # --- DuckDuckGo 搜索工具 (确保返回期望的字典结构) ---
    @register_tool(
        description="使用 DuckDuckGo 搜索引擎在互联网上搜索与给定查询词相关的信息。用于获取通用知识、技术细节或背景资料。",
        parameters={
            "type": "object",
            "properties": {
                "query": {"type": "string", "description": "要搜索的关键词或问题。"},
                "num_results": {"type": "integer", "description": "期望返回的搜索结果数量 (例如: 1 到 5)。如果未提供或无效,默认为3。"}
            },
            "required": ["query"]
        }
    )
    async def duckduckgo_search_tool(self, arguments: Dict[str, Any]) -> Dict[str, Any]: # 标记为 async def
        tool_call_logger_prefix = f"[Action-DuckDuckGoSearchTool-ReqID:{self.current_request_id or 'N/A'}]"
        logger.info(f"{tool_call_logger_prefix} 执行 DuckDuckGo 搜索操作。")
        query = arguments.get("query")
        num_results_req = arguments.get("num_results")
        logger.debug(f"{tool_call_logger_prefix} 收到搜索查询: '{query}', 期望结果数 (原始请求): {num_results_req}。")

        # 预定义返回结构，确保status和message存在
        tool_result = {
            "status": "failure",
            "message": "DuckDuckGo 搜索工具初始化失败或发生未知错误。",
            "error": {"error_type": "UNEXPECTED_TOOL_ERROR", "error_code": "DUCKDUCKGO_UNKNOWN_FAILURE", "technical_message": "Tool did not complete successfully."}
        }

        if not query or not isinstance(query, str) or not query.strip():
            err_msg = "必须提供一个有效的、非空的搜索查询词。"
            logger.error(f"{tool_call_logger_prefix} 输入验证失败: {err_msg}")
            tool_result["message"] = f"错误: {err_msg}"
            tool_result["error"] = {"error_type": "USER_INPUT_VALIDATION_ERROR", "error_code": "MISSING_OR_INVALID_SEARCH_QUERY", "technical_message": err_msg}
            return tool_result

        num_results = 3 
        if num_results_req is not None:
            if isinstance(num_results_req, int) and 1 <= num_results_req <= 10:
                num_results = num_results_req
            else:
                logger.warning(f"{tool_call_logger_prefix} num_results 参数 '{num_results_req}' 无效或超出范围(1-10), 将使用默认值 {num_results}。")
        else:
            logger.debug(f"{tool_call_logger_prefix} 未提供 num_results 参数, 将使用默认值 {num_results}。")
            
        search_results_raw_list = []
        try:
            # 将实际的同步DDGS操作封装在一个内部函数中
            def sync_ddgs_operation():
                _internal_results = []
                logger.debug(f"{tool_call_logger_prefix} [sync_op_internal] 开始执行DDGS搜索 for '{query}', max_results={num_results}")
                with DDGS(timeout=20) as ddgs: # 确保每次调用都创建新的DDGS实例
                    # ddgs.text返回一个迭代器，我们需要将其物化为列表来获取所有结果
                    fetched_results = list(ddgs.text(keywords=query, max_results=num_results))
                    logger.debug(f"{tool_call_logger_prefix} [sync_op_internal] DDGS.text 返回了 {len(fetched_results)} 个原始条目。")
                    # 手动限制结果数量，因为max_results在DDGS中可能不是硬限制
                    for r_item in fetched_results[:num_results]:
                        _internal_results.append({
                            "title": r_item.get('title', 'N/A'),
                            "snippet": r_item.get('body', 'N/A'), # DDGS 使用 'body' 作为摘要
                            "link": r_item.get('href', '#')
                        })
                logger.debug(f"{tool_call_logger_prefix} [sync_op_internal] 处理后得到 {len(_internal_results)} 个结果。")
                return _internal_results

            logger.debug(f"{tool_call_logger_prefix} 准备将同步DDGS操作提交到线程池...")
            search_results_raw_list = await asyncio.to_thread(sync_ddgs_operation)
            logger.debug(f"{tool_call_logger_prefix} 同步DDGS操作完成，从线程返回了 {len(search_results_raw_list)} 个结果。")


            search_results_json_str = json.dumps(search_results_raw_list, ensure_ascii=False)
            success_message = f"已成功完成对“{query}”的 DuckDuckGo 搜索,找到 {len(search_results_raw_list)} 条相关信息。"
            logger.info(f"{tool_call_logger_prefix} {success_message}")
            
            self.memory_manager.add_to_long_term(f"执行了 DuckDuckGo 搜索,查询词: '{query}', 返回了 {len(search_results_raw_list)} 条结果 (请求ID: {self.current_request_id or 'N/A'})。")
            
            # 更新为成功的返回字典
            tool_result = {
                "status": "success",
                "message": success_message,
                "data": {
                    "query": query,
                    "num_results_requested": num_results,
                    "num_results_returned": len(search_results_raw_list),
                    "results_json_string": search_results_json_str 
                }
            }
            return tool_result

        except Exception as e_search:
            err_msg = f"使用 DuckDuckGo 搜索时发生错误: {e_search}"
            logger.error(f"{tool_call_logger_prefix} {err_msg}", exc_info=True)
            tool_result["message"] = f"错误: {err_msg}"
            tool_result["error"] = {"error_type": "EXTERNAL_SERVICE_ERROR", "error_code": "DUCKDUCKGO_SEARCH_FAILED", "technical_message": str(e_search), "exception_details": traceback.format_exc(limit=3)}
            return tool_result

    # --- Orchestration Layer Method (V1.0.0 - 核心调度逻辑) ---
    async def process_user_request(self, user_request: str, status_callback: Callable[[Dict[str, Any]], Awaitable[None]]) -> None:
        request_start_time = time.monotonic()
        self.current_request_id = f"req_{str(uuid4())[:12]}"

        final_llm_camelcase_json_for_reply: Optional[Dict[str, Any]] = None
        final_reply_for_user: str = "抱歉,处理您的请求时发生未知错误。"
        final_llm_interaction_id_for_user: Optional[str] = None
        active_llm_interaction_id: Optional[str] = None

        logger.info(f"\n{'='*25} CircuitAgent 开始处理用户请求 (ReqID: {self.current_request_id}) {'='*25}")
        logger.info(f"[OrchestratorV1_1_3] 收到用户指令: \"{user_request}\"")

        try:
            if not user_request or user_request.isspace():
                logger.info(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 用户指令为空。")
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "input_validation", "status": "ignored", "message": "用户输入为空,已忽略。"})
                empty_input_err_json = {
                    "requestId": self.current_request_id,
                    "llmInteractionId": f"agent_input_err_{str(uuid4())[:6]}",
                    "timestampUtc": datetime.now(timezone.utc).isoformat(),
                    "status": "failure",
                    "errorDetails": {
                        "errorType": "USER_INPUT_ERROR",
                        "errorCode": "EMPTY_USER_REQUEST",
                        "messageToUser": "您的指令似乎是空的,请重新输入！",
                        "technicalMessage": "User request was empty or whitespace.",
                        "isDirectLlmFailure": False
                    },
                    "executionPhase": "planning",
                    "thoughtProcess": "Agent检测到用户输入为空或仅包含空白字符,无需进一步处理。",
                    "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content": "您的指令似乎是空的,请重新输入！"}}
                }
                await status_callback({"type": "final_response", "request_id": self.current_request_id, "llm_interaction_id": empty_input_err_json["llmInteractionId"], "content": empty_input_err_json["decision"]["responseToUser"]["content"], "finaljson_if_success": None})
                return

            await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "input_validation", "status": "received", "message": "收到用户指令,开始处理...", "details": {"user_request_preview": user_request[:1000]}})
            try:
                self.memory_manager.add_to_short_term({"role": "user", "content": user_request})
            except Exception as e_mem_user:
                logger.error(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 添加用户消息到短期记忆时出错: {e_mem_user}", exc_info=True)
                err_msg_mem = f"记录用户指令时发生内部记忆错误: {e_mem_user}"
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "input_validation", "status": "error", "message": err_msg_mem})
                mem_err_json = {
                    "requestId": self.current_request_id, "llmInteractionId": f"agent_mem_err_{str(uuid4())[:6]}",
                    "timestampUtc": datetime.now(timezone.utc).isoformat(), "status": "failure",
                    "errorDetails": {"errorType": "INTERNAL_AGENT_ERROR", "errorCode": "MEMORY_ADD_USER_MSG_FAILED", "messageToUser": f"抱歉,我在记录您的指令时遇到了内部问题 ({e_mem_user})！请稍后重试。", "technicalMessage": err_msg_mem, "isDirectLlmFailure": False },
                    "executionPhase": "planning", "thoughtProcess": "Agent在将用户消息添加到短期记忆时遇到错误。",
                    "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content": f"抱歉,我在记录您的指令时遇到了内部问题 ({e_mem_user})！请稍后重试。" }}
                }
                await status_callback({"type": "final_response", "request_id": self.current_request_id, "llm_interaction_id": mem_err_json["llmInteractionId"], "content": mem_err_json["decision"]["responseToUser"]["content"], "finaljson_if_success": None})
                return

            replanning_loop_count = 0
            current_llm_plan_camelcase_json_obj: Optional[Dict[str, Any]] = None
            tool_execution_results_for_llm_history: List[Dict[str, Any]] = []
            agent_accepted_latest_plan_for_action = False

            while replanning_loop_count <= self.max_replanning_attempts:
                current_planning_attempt_num = replanning_loop_count + 1
                log_prefix = f"[OrchestratorV1_1_3 - PlanAttempt {current_planning_attempt_num} - ReqID: {self.current_request_id}]"
                logger.info(f"\n--- {log_prefix} 开始 ---")

                is_currently_replanning = (replanning_loop_count > 0)
                status_msg_planning_start = "正在分析指令并制定计划..." if not is_currently_replanning else f"正在尝试第 {replanning_loop_count}/{self.max_replanning_attempts} 次重规划..."
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "started", "message": status_msg_planning_start, "details": {"attempt_number": current_planning_attempt_num, "max_replanning_attempts": self.max_replanning_attempts}})

                memory_context = self.memory_manager.get_memory_context_for_prompt()
                tool_schemas = self._get_tool_schemas_for_prompt()
                system_prompt_planning = self._get_planning_prompt(tool_schemas, memory_context, is_currently_replanning, self.current_request_id)
                messages_for_planning = [{"role": "system", "content": system_prompt_planning}] + self.memory_manager.short_term

                llm_call_attempt_inner = 0
                parsed_plan_camelcase_json_this_llm_call: Optional[Dict[str, Any]] = None
                parser_error_msg_this_llm_call: str = ""
                parsed_failed_validation_points_this_llm_call: List[Dict[str,str]] = []
                agent_accepted_latest_plan_for_action = False

                while llm_call_attempt_inner <= self.planning_llm_retries:
                    logger.info(f"{log_prefix} 调用规划 LLM (LLM Call Attempt {llm_call_attempt_inner + 1} of {self.planning_llm_retries + 1})...")
                    try:
                        llm_response_planning_raw = await self.llm_interface.call_llm(messages_for_planning, "planning", status_callback)
                        if not llm_response_planning_raw or not llm_response_planning_raw.choices:
                            raise ConnectionError("LLM规划响应无效或缺少choices。这是LLMInterface层面的问题。")

                        llm_msg_obj_planning = llm_response_planning_raw.choices[0].message
                        parsed_plan_camelcase_json_this_llm_call, parser_error_msg_this_llm_call, parsed_failed_validation_points_this_llm_call = \
                            self.output_parser.parse_llm_response_to_structured_json(llm_msg_obj_planning, "planning")

                        if parsed_plan_camelcase_json_this_llm_call:
                            active_llm_interaction_id = parsed_plan_camelcase_json_this_llm_call.get("llmInteractionId")
                            current_thought_process = parsed_plan_camelcase_json_this_llm_call.get("thoughtProcess")
                            if current_thought_process:
                                await status_callback({"type": "thinking_log", "request_id": self.current_request_id, "llm_interaction_id": active_llm_interaction_id, "stage": "planning", "content": current_thought_process})

                        if parsed_plan_camelcase_json_this_llm_call and not parser_error_msg_this_llm_call and not parsed_failed_validation_points_this_llm_call:
                            if parsed_plan_camelcase_json_this_llm_call.get("status") == "success":
                                logger.info(f"{log_prefix} 成功解析并验证V1.0-CamelCaseJSON计划。LLM报告状态为 'success' (LLM_ID: {active_llm_interaction_id})。Agent采纳此计划。")
                                agent_accepted_latest_plan_for_action = True
                            elif is_currently_replanning and \
                                 parsed_plan_camelcase_json_this_llm_call.get("decision", {}).get("isCallTools") is True and \
                                 isinstance(parsed_plan_camelcase_json_this_llm_call.get("decision", {}).get("toolCallRequests"), list) and \
                                 parsed_plan_camelcase_json_this_llm_call.get("decision", {}).get("toolCallRequests"):
                                logger.warning(f"{log_prefix} LLM在重规划时提供了新的工具调用计划,但可能将其顶层status标记为 'failure' (LLM_ID: {active_llm_interaction_id})。Agent将审慎采纳此新计划以尝试修正。LLM报告的错误(如有): {parsed_plan_camelcase_json_this_llm_call.get('errorDetails')}")
                                agent_accepted_latest_plan_for_action = True
                            else:
                                error_detail_from_llm = parsed_plan_camelcase_json_this_llm_call.get("errorDetails", {}).get("technicalMessage", "LLM规划指示内部错误,但JSON结构有效。")
                                logger.warning(f"{log_prefix} LLM报告的V1.0-CamelCaseJSON计划状态为 'failure': {error_detail_from_llm} (LLM_ID: {active_llm_interaction_id})。Agent将不采纳此计划,并尝试让LLM修正(如果还有LLM调用重试次数)。")
                                parser_error_msg_this_llm_call = f"LLM主动报告规划失败: {error_detail_from_llm}"

                            if agent_accepted_latest_plan_for_action:
                                current_llm_plan_camelcase_json_obj = parsed_plan_camelcase_json_this_llm_call
                                try:
                                    self.memory_manager.add_to_short_term(llm_msg_obj_planning.model_dump(exclude_unset=True))
                                except Exception as e_mem_add: logger.error(f"{log_prefix} 添加LLM规划响应到记忆失败: {e_mem_add}")
                                break

                        if not agent_accepted_latest_plan_for_action and llm_call_attempt_inner < self.planning_llm_retries:
                            error_to_report_cb = parser_error_msg_this_llm_call or "V1.0.0结构或内容校验失败。"
                            if parsed_failed_validation_points_this_llm_call:
                                error_to_report_cb += " 失败点: " + json.dumps(parsed_failed_validation_points_this_llm_call[:2], ensure_ascii=False)
                            await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "llm_retry_needed", "message": f"大脑计划处理遇到问题,尝试重新沟通 ({error_to_report_cb[:1000]})", "details": {"llm_call_attempt": llm_call_attempt_inner + 1, "parser_error": parser_error_msg_this_llm_call, "validation_failures": parsed_failed_validation_points_this_llm_call}})
                            if parsed_plan_camelcase_json_this_llm_call and parsed_plan_camelcase_json_this_llm_call.get("status") == "failure":
                                try: self.memory_manager.add_to_short_term(llm_msg_obj_planning.model_dump(exclude_unset=True))
                                except Exception as e_mem_add_fail: logger.error(f"{log_prefix} 添加LLM失败规划到记忆失败: {e_mem_add_fail}")
                            elif parser_error_msg_this_llm_call or parsed_failed_validation_points_this_llm_call:
                                 sim_err_plan_content = {
                                    "requestId": self.current_request_id, "llmInteractionId": f"agent_parser_err_{active_llm_interaction_id or str(uuid4())[:6]}",
                                    "timestampUtc": datetime.now(timezone.utc).isoformat(), "status": "failure",
                                    "errorDetails": {"errorType": "LLM_OUTPUT_VALIDATION_ERROR", "errorCode": "V1_CAMELCASE_JSON_VALIDATION_FAILED", "technicalMessage": parser_error_msg_this_llm_call, "isDirectLlmFailure": False, "failedValidationPoints": parsed_failed_validation_points_this_llm_call },
                                    "executionPhase": "planning", "thoughtProcess": "Agent在解析或验证LLM上一次规划输出时发现以下问题,将请求LLM修正。",
                                    "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content":""}}
                                 }
                                 try: self.memory_manager.add_to_short_term({"role": "assistant", "content": json.dumps(sim_err_plan_content, ensure_ascii=False)})
                                 except Exception as e_mem_add_parse_err: logger.error(f"{log_prefix} 添加Agent解析错误到记忆失败: {e_mem_add_parse_err}")

                    except Exception as e_llm_call_level:
                        logger.error(f"{log_prefix} LLM调用或规划解析时发生严重错误 (LLM Call Attempt {llm_call_attempt_inner + 1}): {e_llm_call_level}", exc_info=True)
                        parser_error_msg_this_llm_call = f"LLM调用/解析严重错误: {str(e_llm_call_level)[:1000]}"
                        parsed_failed_validation_points_this_llm_call = [{"jsonPath":"root", "issue_description": parser_error_msg_this_llm_call}]
                        if llm_call_attempt_inner < self.planning_llm_retries:
                             await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "llm_error_retrying", "message": f"与大脑沟通时发生严重错误,尝试重新连接 ({parser_error_msg_this_llm_call})", "details": {"llm_call_attempt": llm_call_attempt_inner + 1}})

                    llm_call_attempt_inner += 1
                    if agent_accepted_latest_plan_for_action: break

                if not agent_accepted_latest_plan_for_action:
                    error_summary_final_planning_llm_attempt = parser_error_msg_this_llm_call or "在多次LLM调用尝试后,未能从LLM获取可接受的V1.0-CamelCaseJSON规划。"
                    if parsed_failed_validation_points_this_llm_call:
                         error_summary_final_planning_llm_attempt += " 最后一次校验失败点: " + json.dumps(parsed_failed_validation_points_this_llm_call[:2], ensure_ascii=False)

                    await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "failed_after_llm_retries", "message": f"规划失败 (在第 {current_planning_attempt_num} 次规划尝试中,LLM调用重试均失败): {error_summary_final_planning_llm_attempt}", "details": {"final_parser_error": parser_error_msg_this_llm_call, "final_validation_failures": parsed_failed_validation_points_this_llm_call, "thinking_log_from_last_attempt": parsed_plan_camelcase_json_this_llm_call.get("thoughtProcess") if parsed_plan_camelcase_json_this_llm_call else "无有效思考过程"}})

                    if replanning_loop_count >= self.max_replanning_attempts:
                        logger.critical(f"{log_prefix} 已达最大重规划尝试次数 ({self.max_replanning_attempts}),且本次规划尝试在LLM调用/解析层面最终失败。中止处理。")
                        final_reply_for_user = f"抱歉,即使经过多次尝试与智能大脑沟通,也未能为您的请求 '{user_request[:50]}...' 制定出有效的执行计划。错误详情: {error_summary_final_planning_llm_attempt}"
                        final_llm_interaction_id_for_user = active_llm_interaction_id or f"error_plan_max_replan_llm_fail_{str(uuid4())[:6]}"
                        final_llm_camelcase_json_for_reply = None
                        break
                    else:
                        sim_fail_plan_content_for_replan = {
                            "requestId": self.current_request_id, "llmInteractionId": f"agent_replan_trigger_{active_llm_interaction_id or str(uuid4())[:6]}",
                            "timestampUtc": datetime.now(timezone.utc).isoformat(), "status": "failure",
                            "errorDetails": {"errorType": "LLM_OUTPUT_VALIDATION_ERROR", "errorCode": "V1_CAMELCASE_JSON_VALIDATION_FAILED_IN_PLAN_ATTEMPT", "technicalMessage": error_summary_final_planning_llm_attempt, "isDirectLlmFailure": False, "failedValidationPoints": parsed_failed_validation_points_this_llm_call },
                            "executionPhase": "planning", "thoughtProcess": f"Agent在第 {current_planning_attempt_num} 次规划尝试的LLM调用/解析阶段遇到问题,将进行重规划。错误: {error_summary_final_planning_llm_attempt}",
                            "decision": { "isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content":""}}
                        }
                        try: self.memory_manager.add_to_short_term({"role": "assistant", "content": json.dumps(sim_fail_plan_content_for_replan, ensure_ascii=False)})
                        except Exception as e_mem_add_replan_trigger: logger.error(f"{log_prefix} 添加重规划触发信息到记忆出错: {e_mem_add_replan_trigger}")
                        replanning_loop_count += 1
                        continue

                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "planning", "status": "completed_and_validated", "message": "规划完成并通过验证,准备执行或直接回复。", "details": {"plan_llm_id": current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else None}})

                tool_requests_from_plan = current_llm_plan_camelcase_json_obj.get("decision", {}).get("toolCallRequests", []) if current_llm_plan_camelcase_json_obj else []
                if isinstance(tool_requests_from_plan, list) and current_llm_plan_camelcase_json_obj:
                    plan_details_for_ui = []
                    for req_idx, tool_req in enumerate(tool_requests_from_plan):
                        plan_details_for_ui.append({
                            "tool_call_id": tool_req.get("toolCallId"),
                            "tool_name": tool_req.get("toolName"),
                            "tool_arguments": tool_req.get("toolArguments", {}),
                            "ui_hints": tool_req.get("uiHints", {}),
                            "status": "pending",
                            "order": req_idx + 1
                        })
                    await status_callback({
                        "type": "plan_details",
                        "request_id": self.current_request_id,
                        "llm_interaction_id": current_llm_plan_camelcase_json_obj.get("llmInteractionId"),
                        "plan": plan_details_for_ui
                    })

                decision_from_plan = current_llm_plan_camelcase_json_obj.get("decision", {}) if current_llm_plan_camelcase_json_obj else {}
                should_call_tools = decision_from_plan.get("isCallTools", False)
                response_user_obj_from_plan = decision_from_plan.get("responseToUser")

                if should_call_tools:
                    tool_count_in_plan = len(tool_requests_from_plan) if isinstance(tool_requests_from_plan, list) else 0
                    logger.info(f"{log_prefix} 决策: 执行 {tool_count_in_plan} 个工具。")
                    await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "action_execution", "status": "started", "message": f"开始执行 {tool_count_in_plan} 个计划操作...", "details": {"tool_count": tool_count_in_plan}})

                    if isinstance(response_user_obj_from_plan, dict) and response_user_obj_from_plan.get("content","").strip():
                        transitional_reply_content = response_user_obj_from_plan["content"]
                        await status_callback({"type": "interim_response", "request_id": self.current_request_id, "llm_interaction_id": current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else None, "content": transitional_reply_content})

                    if not isinstance(tool_requests_from_plan, list) or not tool_requests_from_plan:
                        err_msg_list_tools_critical = "内部规划错误: isCallTools为True但toolCallRequests列表无效或为空。OutputParser应已校验。"
                        logger.error(f"{log_prefix} {err_msg_list_tools_critical}")
                        tool_execution_results_for_llm_history = [{"role":"tool", "tool_call_id":f"plan_integrity_err_{str(uuid4())[:6]}", "name":"plan_integrity_checker", "content":json.dumps({"status":"failure", "message":err_msg_list_tools_critical, "error": {"error_type":"INTERNAL_AGENT_ERROR", "error_code":"INVALID_TOOL_REQUEST_LIST_POST_VALIDATION", "technical_message": err_msg_list_tools_critical}})}]
                        try: self.memory_manager.add_to_short_term(tool_execution_results_for_llm_history[0])
                        except Exception as e_mem_add_integrity_err: logger.error(f"{log_prefix} 添加规划完整性错误到记忆失败: {e_mem_add_integrity_err}")

                        if replanning_loop_count >= self.max_replanning_attempts:
                            final_reply_for_user = f"抱歉,系统在准备执行操作时遇到内部规划结构问题。请稍后重试或联系技术支持。错误: {err_msg_list_tools_critical}"
                            final_llm_interaction_id_for_user = current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else active_llm_interaction_id
                            final_llm_camelcase_json_for_reply = None
                            break
                        else:
                            replanning_loop_count += 1; agent_accepted_latest_plan_for_action = False; continue

                    current_tool_exec_results_for_llm_hist = await self.tool_executor.execute_tool_calls(tool_requests_from_plan, status_callback)
                    tool_execution_results_for_llm_history = current_tool_exec_results_for_llm_hist

                    if tool_execution_results_for_llm_history:
                        for res_msg_tool in tool_execution_results_for_llm_history:
                            try: self.memory_manager.add_to_short_term(res_msg_tool)
                            except Exception as e_mem_add_tool_res: logger.error(f"{log_prefix} 添加工具结果 {res_msg_tool.get('tool_call_id')} 到记忆失败: {e_mem_add_tool_res}")

                    any_tool_failed_persistently = False
                    last_failed_tool_message_for_user = "一个或多个操作未能成功完成。"
                    if tool_execution_results_for_llm_history:
                        for tool_res_for_hist in tool_execution_results_for_llm_history:
                            try:
                                tool_res_content_dict = json.loads(tool_res_for_hist.get("content","{}"))
                                if tool_res_content_dict.get("status") != "success":
                                    any_tool_failed_persistently = True
                                    last_failed_tool_message_for_user = tool_res_content_dict.get("message", last_failed_tool_message_for_user)
                            except json.JSONDecodeError:
                                logger.error(f"{log_prefix} 无法解析工具结果的content JSON: {tool_res_for_hist.get('content')}")
                                any_tool_failed_persistently = True
                                last_failed_tool_message_for_user = "一个操作的结果格式不正确。"

                    if any_tool_failed_persistently:
                        logger.warning(f"{log_prefix} 工具执行过程中发生了一个或多个持久性失败。")
                        await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "action_execution", "status": "tool_failure_detected", "message": "部分操作失败,准备评估是否重规划。", "details": {"last_error_message": last_failed_tool_message_for_user}})
                        if replanning_loop_count < self.max_replanning_attempts:
                            replanning_loop_count += 1; agent_accepted_latest_plan_for_action = False; continue
                        else:
                            logger.critical(f"{log_prefix} 已达最大重规划尝试次数 ({self.max_replanning_attempts}),但工具执行仍有失败。中止处理。")
                            final_reply_for_user = f"抱歉,在执行您的请求时,即使经过多次尝试,仍遇到问题: {last_failed_tool_message_for_user} 请检查您的指令或稍后再试。"
                            final_llm_interaction_id_for_user = current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else active_llm_interaction_id
                            final_llm_camelcase_json_for_reply = None
                            break
                    else:
                        logger.info(f"{log_prefix} 所有计划中的工具均成功执行。准备生成最终回复。")
                        final_llm_camelcase_json_for_reply = current_llm_plan_camelcase_json_obj
                        break

                else:
                    logger.info(f"{log_prefix} 决策: 直接回复 (V1.0.0)。无需工具调用。")
                    if isinstance(response_user_obj_from_plan, dict) and response_user_obj_from_plan.get("content","").strip():
                        tool_execution_results_for_llm_history = []
                        final_llm_camelcase_json_for_reply = current_llm_plan_camelcase_json_obj
                        logger.info(f"{log_prefix} 规划阶段决定直接回复,内容有效。将使用此V1.0-CamelCaseJSON作为最终输出。LLM_ID: {final_llm_camelcase_json_for_reply.get('llmInteractionId')}")
                        break
                    else:
                        err_msg_direct_content_critical = "内部规划错误: isCallTools为False但responseToUser.content无效或为空。OutputParser应已校验。"
                        logger.error(f"{log_prefix} {err_msg_direct_content_critical}")
                        tool_execution_results_for_llm_history = [{"role":"tool", "tool_call_id":f"direct_reply_integrity_err_{str(uuid4())[:6]}", "name":"direct_reply_integrity_checker", "content":json.dumps({"status":"failure", "message":err_msg_direct_content_critical, "error": {"error_type":"INTERNAL_AGENT_ERROR", "error_code":"INVALID_DIRECT_RESPONSE_CONTENT_POST_VALIDATION", "technical_message": err_msg_direct_content_critical}})}]
                        try: self.memory_manager.add_to_short_term(tool_execution_results_for_llm_history[0])
                        except Exception as e_mem_add_direct_reply_err: logger.error(f"{log_prefix} 添加直接回复完整性错误到记忆失败: {e_mem_add_direct_reply_err}")

                        if replanning_loop_count >= self.max_replanning_attempts:
                            final_reply_for_user = f"抱歉,系统在准备直接回复时遇到内部规划结构问题。请稍后重试或联系技术支持。错误: {err_msg_direct_content_critical}"
                            final_llm_interaction_id_for_user = current_llm_plan_camelcase_json_obj.get("llmInteractionId") if current_llm_plan_camelcase_json_obj else active_llm_interaction_id
                            final_llm_camelcase_json_for_reply = None
                            break
                        else:
                            replanning_loop_count += 1; agent_accepted_latest_plan_for_action = False; continue
            
            logger.debug(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 重规划循环结束。采纳的计划: {agent_accepted_latest_plan_for_action}, 重规划次数: {replanning_loop_count}, 用于回复的最终LLM JSON是否已设置: {final_llm_camelcase_json_for_reply is not None}")
            
            if not agent_accepted_latest_plan_for_action and replanning_loop_count > self.max_replanning_attempts:
                logger.error(f"[OrchestratorV1_1_3 - FinalPrep - ReqID:{self.current_request_id}] 已达最大重规划次数,且最终规划尝试仍失败。将使用上次记录的错误信息。")
            
            logger.debug(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 响应生成检查前。最终JSON状态: {final_llm_camelcase_json_for_reply.get('status') if final_llm_camelcase_json_for_reply else 'N/A'}, isCallTools: {final_llm_camelcase_json_for_reply.get('decision', {}).get('isCallTools') if final_llm_camelcase_json_for_reply else 'N/A'}")

            if final_llm_camelcase_json_for_reply and \
               final_llm_camelcase_json_for_reply.get("status") == "success" and \
               final_llm_camelcase_json_for_reply.get("decision",{}).get("isCallTools") is True:
                logger.info(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 工具执行成功,开始生成最终响应...")
                await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "response_generation", "status": "started", "message": "正在总结操作结果并生成最终回复...", "details": {"reason": "Tool execution completed successfully. Generating final summary."}})

                system_prompt_resp_gen = self._get_response_generation_prompt(
                    self.memory_manager.get_memory_context_for_prompt(),
                    self._get_tool_schemas_for_prompt(),
                    self.current_request_id
                )
                messages_for_resp_gen = [{"role": "system", "content": system_prompt_resp_gen}] + self.memory_manager.short_term

                try:
                    llm_response_final_gen_raw = await self.llm_interface.call_llm(messages_for_resp_gen, "response_generation", status_callback)
                    if not llm_response_final_gen_raw or not llm_response_final_gen_raw.choices: raise ConnectionError("LLM最终响应生成阶段的响应无效或缺少choices。")

                    llm_msg_obj_final_gen = llm_response_final_gen_raw.choices[0].message
                    parsed_final_camelcase_resp_json, final_parser_err_resp, final_validation_failures_resp = \
                        self.output_parser.parse_llm_response_to_structured_json(llm_msg_obj_final_gen, "response_generation")

                    if parsed_final_camelcase_resp_json:
                        active_llm_interaction_id = parsed_final_camelcase_resp_json.get("llmInteractionId")
                        final_resp_thought_process = parsed_final_camelcase_resp_json.get("thoughtProcess")
                        if final_resp_thought_process:
                             await status_callback({"type": "thinking_log", "request_id": self.current_request_id, "llm_interaction_id": active_llm_interaction_id, "stage": "response_generation", "content": final_resp_thought_process})

                    if parsed_final_camelcase_resp_json and not final_parser_err_resp and not final_validation_failures_resp and parsed_final_camelcase_resp_json.get("status") == "success":
                        final_llm_camelcase_json_for_reply = parsed_final_camelcase_resp_json
                        final_llm_interaction_id_for_user = active_llm_interaction_id
                        logger.info(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 成功解析并验证最终响应V1.0-CamelCaseJSON (LLM_ID: {final_llm_interaction_id_for_user})。")
                        try:
                            self.memory_manager.add_to_short_term(llm_msg_obj_final_gen.model_dump(exclude_unset=True))
                        except Exception as e_mem_add_final_resp: logger.error(f"添加最终LLM响应到记忆失败: {e_mem_add_final_resp}")
                    else:
                        err_msg_final_resp_gen = final_parser_err_resp or "V1.0.0最终响应JSON校验失败。"
                        if final_validation_failures_resp: err_msg_final_resp_gen += " 失败点: " + json.dumps(final_validation_failures_resp[:2], ensure_ascii=False)
                        elif parsed_final_camelcase_resp_json and parsed_final_camelcase_resp_json.get("status") == "failure":
                             err_msg_final_resp_gen = parsed_final_camelcase_resp_json.get("errorDetails",{}).get("technicalMessage", err_msg_final_resp_gen)

                        logger.error(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] LLM未能生成有效V1.0-CamelCaseJSON最终回复: {err_msg_final_resp_gen}")
                        final_reply_for_user = f"抱歉,在总结操作结果时发生了一些问题。错误: {err_msg_final_resp_gen[:1000]}... "
                        final_llm_interaction_id_for_user = active_llm_interaction_id or (final_llm_camelcase_json_for_reply.get("llmInteractionId") if final_llm_camelcase_json_for_reply else f"error_resp_gen_{str(uuid4())[:6]}")
                        final_llm_camelcase_json_for_reply = None
                except Exception as e_llm_final_gen_call:
                    logger.critical(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] LLM最终响应调用或处理失败: {e_llm_final_gen_call}", exc_info=True)
                    final_reply_for_user = f"抱歉,系统在为您准备最终报告时遇到了严重的内部错误: {str(e_llm_final_gen_call)[:1000]}... "
                    final_llm_interaction_id_for_user = (final_llm_camelcase_json_for_reply.get("llmInteractionId") if final_llm_camelcase_json_for_reply else active_llm_interaction_id or f"critical_err_resp_gen_{str(uuid4())[:6]}")
                    final_llm_camelcase_json_for_reply = None
            
            elif final_llm_camelcase_json_for_reply and \
                 final_llm_camelcase_json_for_reply.get("status") == "success" and \
                 final_llm_camelcase_json_for_reply.get("decision",{}).get("isCallTools") is False:
                logger.info(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 使用规划阶段的直接回复V1.0-CamelCaseJSON作为最终输出。")
                final_llm_interaction_id_for_user = final_llm_camelcase_json_for_reply.get("llmInteractionId")

            elif not final_llm_camelcase_json_for_reply :
                 logger.error(f"[OrchestratorV1_1_3 - ReqID:{self.current_request_id}] 流程结束时,final_llm_camelcase_json_for_reply 为空,表明处理失败。将使用之前记录的错误信息 (final_reply_for_user)。")

            user_facing_thought_process_final_summary = "综合思考过程已在之前的日志中发送。"
            if final_llm_camelcase_json_for_reply and final_llm_camelcase_json_for_reply.get("status") == "success":
                user_facing_thought_process_final_summary = final_llm_camelcase_json_for_reply.get("thoughtProcess", user_facing_thought_process_final_summary)
                resp_user_obj_final = final_llm_camelcase_json_for_reply.get("decision", {}).get("responseToUser", {})
                final_reply_for_user = resp_user_obj_final.get("content", final_reply_for_user)
            
            await status_callback({"type": "general_status", "request_id": self.current_request_id, "stage": "finalization", "status": "completed" if (final_llm_camelcase_json_for_reply and final_llm_camelcase_json_for_reply.get("status") == "success") else "failed", "message": "请求处理流程已结束。"})
            await status_callback({
                "type": "final_response",
                "request_id": self.current_request_id,
                "llm_interaction_id": final_llm_interaction_id_for_user,
                "content": final_reply_for_user.strip() if final_reply_for_user else "抱歉,未能生成有效的回复。",
                "finaljson_if_success": final_llm_camelcase_json_for_reply
            })

            if not (final_llm_camelcase_json_for_reply and final_llm_camelcase_json_for_reply.get("status") == "success"):
                final_assistant_synthetic_error_message_camelcase_json = {
                    "requestId": self.current_request_id,
                    "llmInteractionId": final_llm_interaction_id_for_user or f"agent_synth_final_err_{str(uuid4())[:6]}",
                    "timestampUtc": datetime.now(timezone.utc).isoformat(),
                    "status": "failure",
                    "errorDetails": {"errorType": "AGENT_PROCESSING_FAILURE", "errorCode": "OVERALL_REQUEST_HANDLING_FAILED", "messageToUser": final_reply_for_user, "technicalMessage": "Agent failed to successfully complete the user request after all attempts.", "isDirectLlmFailure": False },
                    "executionPhase": "final_error_synthesis",
                    "thoughtProcess": user_facing_thought_process_final_summary or "Agent 最终处理失败,未能生成详细思考过程。",
                    "decision": {"isCallTools": False, "toolCallRequests": [], "responseToUser": {"contentType":"text/plain", "content": final_reply_for_user}}
                }
                try: self.memory_manager.add_to_short_term({"role": "assistant", "content": json.dumps(final_assistant_synthetic_error_message_camelcase_json, ensure_ascii=False)})
                except Exception as e_mem_add_synth_err: logger.error(f"添加Agent合成的最终错误助手消息到记忆失败: {e_mem_add_synth_err}")

        except Exception as e_process_top_level:
            request_id_for_fatal = self.current_request_id or f"fatal_err_no_req_id_{str(uuid4())[:6]}"
            logger.critical(f"[OrchestratorV1_1_3 - ReqID:{request_id_for_fatal}] 处理用户请求 '{user_request[:1000]}' 时发生顶层未捕获异常: {e_process_top_level}", exc_info=True)
            error_msg_for_user_fatal = f"抱歉,处理您的请求 ('{user_request[:30]}...') 时发生严重的、未预期的内部系统错误。请稍后再试或联系技术支持。"
            tb_str_for_thinking_log_fatal = traceback.format_exc().replace('\n', ' | ')
            thinking_log_content_fatal = f"请求处理流程中发生顶层致命错误: {e_process_top_level}。Traceback (部分): {tb_str_for_thinking_log_fatal[:1000]}..."
            fatal_llm_interaction_id = f"fatal_agent_err_{str(uuid4())[:6]}"
            await status_callback({"type": "thinking_log", "request_id": request_id_for_fatal, "llm_interaction_id": fatal_llm_interaction_id, "stage": "fatal_error_capture", "content": thinking_log_content_fatal})
            await status_callback({"type": "general_status", "request_id": request_id_for_fatal, "stage": "fatal_error_handler", "status": "error", "message": f"请求处理失败,发生致命内部错误: {str(e_process_top_level)[:1000]}", "details": {"error_type": type(e_process_top_level).__name__, "full_error_message": str(e_process_top_level)}})
            await status_callback({"type": "final_response", "request_id": request_id_for_fatal, "llm_interaction_id": fatal_llm_interaction_id, "content": error_msg_for_user_fatal, "finaljson_if_success": None})
        finally:
            request_end_time = time.monotonic()
            duration_total = request_end_time - request_start_time
            logger.info(f"\n{'='*25} CircuitAgent 请求处理完毕 (ReqID: {self.current_request_id or 'N/A'}, 总耗时: {duration_total:.3f} 秒) {'='*25}\n")
            self.current_request_id = None


    # --- Helper Methods for Prompts (V1.0.0 - 辅助方法,用于生成系统提示) ---
    def _get_tool_schemas_for_prompt(self) -> str:
        if not self.tools_registry: return "  (当前无可用工具)"
        tool_schemas_parts = []
        sorted_tool_names = sorted(self.tools_registry.keys())

        for tool_name in sorted_tool_names:
            schema = self.tools_registry[tool_name]
            desc = schema.get('description', '无描述。')
            params_schema = schema.get('parameters', {})
            props_schema = params_schema.get('properties', {})
            req_params = params_schema.get('required', [])

            param_desc_segments = []
            if props_schema:
                sorted_param_names = sorted(props_schema.keys())
                for param_name in sorted_param_names: 
                    param_details_dict = props_schema[param_name]
                    param_type = param_details_dict.get('type','any')
                    is_required_str = "必须 (required)" if param_name in req_params else "可选 (optional)"
                    param_description = param_details_dict.get('description','无参数描述')
                    enum_values = param_details_dict.get('enum')
                    enum_desc = f" 可选值: {enum_values}。" if enum_values and isinstance(enum_values, list) else ""
                    param_desc_segments.append(f"    - 参数名 `{param_name}`:\n      - 类型: `{param_type}`\n      - 是否必需: {is_required_str}\n      - 描述: {param_description}{enum_desc}")
            elif params_schema.get("type") == "object" and not props_schema :
                 param_desc_segments = ["    - 此工具不接受任何参数(参数对象 `toolArguments` 应为空对象 `{}`)。"]
            else:
                 param_desc_segments = ["    - (此工具的参数定义似乎不完整或无参数)"]

            tool_schemas_parts.append(f"  - 工具名称: `{tool_name}`\n    工具描述: {desc}\n  工具参数详情 (这些参数应放在 `toolArguments` 对象内部):\n{chr(10).join(param_desc_segments)}")
        return "\n\n".join(tool_schemas_parts)

    def _get_planning_prompt(self, tool_schemas_desc: str, memory_context: str,
                                is_replanning: bool = False, request_id: Optional[str] = None) -> str:
        current_timestamp_utc = datetime.now(timezone.utc).isoformat()
        llm_interaction_id_example_plan_prefix = f"plan_ex_llm_id_{str(uuid4())[:6]}"
        example_prev_tool_call_id = f"tc_ex_prev_fail_{str(uuid4())[:6]}"

        reasoning_model_instructions = (
            "\n【重要: Reasoning Model 输出规范 (V1.0.0)】\n"
            "1.  **思考过程**: 您的详细思考过程、分析、逐步推理和决策逻辑【必须】包含在 `<think>...</think>` 标签内,并放在您回复的最开始部分。\n"
            "2.  **JSON 输出**: 在 `</think>` 标签之后,您【必须】输出一个严格符合下面描述的V1.0-CamelCaseJSON格式的单个JSON对象。此JSON对象应被三个反引号和'json'标记包围 (即 ```json ... ```)。JSON中所有key【必须】使用camelCase (例如: `isCallTools`, `toolCallRequests`, `requestId`).\n"
            "3.  **`thoughtProcess` 字段 (in JSON)**: JSON对象内部的 `thoughtProcess` 字段现在是次要的。它可以是一个简短的总结或留空 ( `\"\"` ),因为您的主要思考过程已在 `<think>...</think>` 块中。Agent将优先使用 `<think>` 块中的内容作为思考日志。\n"
        )

        replanning_guidance = ""
        if is_replanning:
            replanning_guidance = (
                "\n【重要: 重规划指示 (V1.0.0 - Reasoning Model)】\n"
                "您当前正在进行重规划。这意味着您之前的规划或工具执行遇到了问题。请在您的 `<think>...</think>` 块中：\n"
                "1.  **仔细分析失败原因**: 详细检查对话历史中的 `role: tool` 消息 (`content` JSON内的 `status: \"failure\"`, `message`, `errorDetails`) 和 `role: assistant` 消息中可能的Agent解析/校验错误 (`errorDetails.failedValidationPoints`)。\n"
                "2.  **参考当前电路状态**: 【务必】仔细查阅 `memory_context` 中的【当前电路状态】。您的新计划【必须】基于当前实际存在的元件和连接。不要不必要地重新添加已存在的元件。\n"
                "3.  **处理抽象节点**: 若涉及连接到 'INPUT', 'OUTPUT', 'GND' 等未作为元件存在的抽象节点失败,优先规划使用 `add_component_tool` (如 `component_type: 'Terminal'`) 创建它们,然后再连接。\n"
                "4.  **制定修正计划**: 基于以上分析,制定一个【全新的、修正了先前问题的计划】。这应在您的 `<think>...</think>` 块中清晰阐述。\n"
                "然后,在 `</think>` 之后输出符合V1.0-CamelCaseJSON规范的JSON。如果这个【新JSON本身的顶层 `status` 字段必须设置为 `'success'`】(因为您成功地为【当前这次思考和规划】输出了一个结构完整且逻辑合理的V1.0-CamelCaseJSON JSON)。\n"
                "5.  **无法解决的情况**: 如果分析后认为无法完成用户核心请求,则在 `<think>...</think>` 中解释,并在 `</think>` 后的JSON中制定一个【直接回复用户并解释情况的计划】 (`status: 'success'`, `isCallTools: False`).\n"
                "6.  **真正意义上的规划失败**: 只有当您在【当前这次重规划尝试中】,由于自身的理解困难、无法形成任何有效的 `<think>...</think>` 块或后续的V1.0-CamelCaseJSON JSON结构时,才应将后续JSON的顶层 `status` 字段设为 `'failure'`。\n"
                "**核心原则**: 不要因为*过去*的工具执行失败,就将您*当前新制定*的计划的JSON标记为 `status: 'failure'`. `status` 反映的是您【当前这次生成JSON这个行为本身】的成功与否。\n"
            )

        json_schema_description_for_prompt = """
```json
{
  "requestId": "string_or_null_当前用户请求周期的ID_如果系统提示中提供了此值请原样返回_否则为null",
  "llmInteractionId": "string_必须是本次LLM响应的唯一ID_例如_plan_llm_id_后跟8位随机字符_如_plan_llm_id_a1b2c3d4",
  "timestampUtc": "string_当前UTC时间戳_ISO_8601格式_例如_2024-07-16T12:00:00.000Z",
  "status": "string_必须是 'success' 或 'failure'._表示本次JSON输出是否由LLM为当前阶段成功生成。",
  "errorDetails": { // 如果 status 是 'success',则此字段为 null
    "errorType": "string_enum_高级错误类别_例如_PLANNING_ERROR_LLM_OUTPUT_VALIDATION_ERROR_INTERNAL_LOGIC_ERROR",
    "errorCode": "string_特定错误代码_例如_JSON_MALFORMED_MISSING_REQUIRED_FIELD_TOOL_PARAMS_INVALID",
    "messageToUser": "string_用户友好的解释_如果此错误与用户操作直接相关或适合用户查看。否则为通用Agent错误消息。",
    "technicalMessage": "string_详细的技术错误消息_用于日志记录和调试_这是LLM认为其自身输出生成过程中出现的问题。",
    "isDirectLlmFailure": "boolean_如果LLM明确表示无法完成请求或为本次尝试生成有效JSON则为True。如果错误是由于Agent端对LLM输出的JSON进行校验失败(即使JSON本身语法有效)_或LLM在格式良好的JSON中报告逻辑失败_则为False。",
    "failedValidationPoints": [ // 可选_如果LLM根据Agent反馈修正其先前的输出_则列出Agent发现的校验问题
      {
        "jsonPath": "string_例如_decision.toolCallRequests[0].toolArguments.component_id",
        "issue_description": "string_例如_必需字段缺失_或_值必须是字符串但得到的是整数"
      }
    ]
  },
  "executionPhase": "string_对于此任务_必须是 'planning'",
  "thoughtProcess": "string_此字段现在是次要的_您的主要详细推理必须在初始的 `<think>...</think>` 块中_此JSON字段可以是简短总结或为空_Agent将优先使用 `<think>` 块内容。",
  "decision": {
    "isCallTools": "boolean_如果需要调用工具则为True_否则为False_也接受不区分大小写的字符串 'true'/'false'",
    "toolCallRequests": [ // 如果 isCallTools 为 False, 则为 null 或空列表
      {
        "toolCallId": "string_由您为本次特定工具调用生成的唯一ID_例如_tc_add_resistor_xyz123",
        "toolName": "string_要调用的工具名称_从可用工具列表中选择 (例如 add_component_tool)",
        "toolArguments": { 
            // 此对象的内容是工具特定的_此处的键 (例如 component_type, value)
            // 应与 '可用工具列表与参数规范' 部分提供的 snake_case 名称匹配。
            // 电路工具示例: "component_type": "电阻", "value": "1k"
            // 搜索工具示例: "query": "欧姆定律", "num_results": 2 
        },
        "uiHints": { // 可选
            "displayNameForTool": "string_optional_更用户友好的工具调用名称_例如_添加电阻R1",
            "estimatedDurationCategory": "string_enum_optional_short_medium_long_very_long",
            "showProgressGranularly": "boolean_optional_如果为True_UI可能会显示更细粒度的进度(如果工具支持)_默认为False"
        },
        "estimatedComplexityOrNotes": "string_optional_LLM对此调用的内部注释_依赖关系或置信度。"
      }
    ],
    "responseToUser": {
      "contentType": "string_例如_text/plain_或_application/markdown",
      "content": "string_如果isCallTools为False_这是您对用户的直接且完整的回复_它必须非空。如果isCallTools为True_这应该是一条有意义的过渡消息_反映计划的操作_例如_好的_我将添加元件X然后连接到Y_如果确实不需要过渡消息则可以为空字符串_但为了用户体验首选提供一条好的消息。",
      "suggestionsForNextSteps": [ // 可选
        {
          "suggestionId": "string_optional_此建议的唯一ID_例如_sugg_ask_about_led_color",
          "textForUser": "string_向用户显示的建议文本_例如_您想指定LED颜色吗",
          "actionType": "string_enum_optional_USER_INPUT_EXPECTED_or_PREDEFINED_AGENT_ACTION_or_UI_NAVIGATION",
          "actionPayload": "object_or_string_optional_如果类型是PREDEFINED_AGENT_ACTION_这可能是简化的请求对象或命令字符串_供Agent在用户选择后处理"
        }
      ],
      "requiresUserClarificationForCurrentRequest": "boolean_optional_如果当前请求需要用户进一步输入才能继续_并且content正在请求该澄清_则设置为True_默认为False"
    }
  },
  "diagnostics": { // 可选
      "llmConfidenceScoreForThisOutput": "float_optional_0.0_到_1.0_LLM对此JSON输出的正确性和完整性的自评估置信度",
      "alternativePlansConsideredCount": "integer_optional_如果LLM在确定此计划前考虑了多个计划",
      "parsingFeedbackFromPreviousAttemptId": "string_or_null_如果这是对先前格式错误的JSON的修正_则为该失败尝试的llmInteractionId"
  },
  "usageMetadata": null
}
```
"""
        direct_qa_example = (
            "\n【通用示例1: 直接回答用户问题 (无需工具) - V1.0.0 Reasoning Model Output】\n"
            "如果用户问: “你好,什么是电容？”\n"
            "您的输出应类似 (ID和时间戳会变化): \n"
            "<think>\n"
            "用户询问电容的定义。这是一个概念性问题,不需要调用任何电路设计工具,我可以根据我的知识库直接回答。我将提供一个关于电容基本作用、单位和常见类型的解释,并给出下一步建议。我的回答将是清晰和直接的。\n"
            "</think>\n"
            "```json\n"
            "{\n"
            "  \"requestId\": \"" + (request_id or "userReqExampleId123") + "\",\n"
            "  \"llmInteractionId\": \"" + llm_interaction_id_example_plan_prefix + "_directQaCap\",\n"
            "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
            "  \"status\": \"success\",\n"
            "  \"errorDetails\": null,\n"
            "  \"executionPhase\": \"planning\",\n"
            "  \"thoughtProcess\": \"用户询问电容定义,直接回答。(主要思考过程在 <think> 块中)\",\n"
            "  \"decision\": {\n"
            "    \"isCallTools\": false,\n"
            "    \"toolCallRequests\": [],\n"
            "    \"responseToUser\": {\n"
            "      \"contentType\": \"text/plain\",\n"
            "      \"content\": \"电容是一种能够储存电荷的电子元件,由两块导体板中间夹一层绝缘介质构成。它的主要特性是电容量,单位是法拉(F),常用单位有微法(μF)、纳法(nF)和皮法(pF). 电容在电路中常用于滤波、耦合、隔直流、储能等.\",\n"
            "      \"suggestionsForNextSteps\": [\n"
            "        {\"textForUser\": \"您想了解电容在具体电路中的应用吗？\", \"actionType\": \"USER_INPUT_EXPECTED\"},\n"
            "        {\"textForUser\": \"需要我帮您在当前电路中添加一个电容吗？\", \"actionType\": \"USER_INPUT_EXPECTED\", \"actionPayload\": \"请帮我添加一个10uF的电解电容\"}\n"
            "      ],\n"
            "      \"requiresUserClarificationForCurrentRequest\": false\n"
            "    }\n"
            "  },\n"
            "  \"diagnostics\": {\"llmConfidenceScoreForThisOutput\": 0.95},\n"
            "  \"usageMetadata\": null\n"
            "}\n"
            "```\n"
        )
        tool_call_example = (
            "\n【通用示例2: 需要调用工具时的输出V1.0-CamelCaseJSON Reasoning Model Output】\n"
            "如果用户说: “帮我加一个1k欧姆的电阻R1,再用DuckDuckGo搜索'什么是LED'并返回2条结果,然后把R1连到GND。”\n"
            "您的输出应类似 (ID和时间戳会变化,每个toolCallId必须唯一,由您生成): \n"
            "<think>\n"
            "用户需要执行三个操作: 1. 添加电阻R1 (1kΩ)。 2. 使用DuckDuckGo搜索'什么是LED'并明确要求返回2条结果。3. 添加GND (如果不存在)并连接R1和GND。我将按顺序规划这三个/四个工具调用。确保为每个工具调用生成唯一的toolCallId。并为用户提供一个过渡性的回复,表明我理解了请求并正在处理。电路状态目前为空,元件GND可能需要先添加。\n"
            "</think>\n"
            "```json\n"
            "{\n"
            "  \"requestId\": \"" + (request_id or "userReqExampleId456") + "\",\n"
            "  \"llmInteractionId\": \"" + llm_interaction_id_example_plan_prefix + "_multiToolSearchFix2\",\n"
            "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
            "  \"status\": \"success\",\n"
            "  \"errorDetails\": null,\n"
            "  \"executionPhase\": \"planning\",\n"
            "  \"thoughtProcess\": \"规划添加R1,搜索,连接GND。(主要思考过程在 <think> 块中)\",\n"
            "  \"decision\": {\n"
            "    \"isCallTools\": true,\n"
            "    \"toolCallRequests\": [\n"
            "      {\n"
            "        \"toolCallId\": \"tc_add_r1_" + str(uuid4())[:8] + "\",\n"
            "        \"toolName\": \"add_component_tool\",\n"
            "        \"toolArguments\": {\"component_type\": \"电阻\", \"component_id\": \"R1\", \"value\": \"1kΩ\"},\n"
            "        \"uiHints\": {\"displayNameForTool\": \"添加电阻 R1 (1kΩ)\"}\n"
            "      },\n"
            "      {\n"
            "        \"toolCallId\": \"tc_search_led_" + str(uuid4())[:8] + "\",\n"
            "        \"toolName\": \"duckduckgo_search_tool\",\n"
            "        \"toolArguments\": {\"query\": \"什么是LED\", \"num_results\": 2},\n"
            "        \"uiHints\": {\"displayNameForTool\": \"搜索LED定义(2条结果)\"}\n"
            "      },\n"
            "      {\n"
            "        \"toolCallId\": \"tc_add_gnd_" + str(uuid4())[:8] + "\",\n"
            "        \"toolName\": \"add_component_tool\",\n"
            "        \"toolArguments\": {\"component_type\": \"地\", \"component_id\": \"GND\"},\n"
            "        \"uiHints\": {\"displayNameForTool\": \"添加地线 GND (如果需要)\"}\n"
            "      },\n"
            "      {\n"
            "        \"toolCallId\": \"tc_conn_r1gnd_" + str(uuid4())[:8] + "\",\n"
            "        \"toolName\": \"connect_components_tool\",\n"
            "        \"toolArguments\": {\"comp1_id\": \"R1\", \"comp2_id\": \"GND\"},\n"
            "        \"uiHints\": {\"displayNameForTool\": \"连接 R1 与 GND\"}\n"
            "      }\n"
            "    ],\n"
            "    \"responseToUser\": {\n"
            "      \"contentType\": \"text/plain\",\n"
            "      \"content\": \"好的,我正在为您添加电阻R1 (1kΩ),搜索LED的定义(2条结果),并准备连接R1到GND。请稍候...\",\n"
            "      \"suggestionsForNextSteps\": []\n"
            "    }\n"
            "  },\n"
            "  \"diagnostics\": null,\n"
            "  \"usageMetadata\": null\n"
            "}\n"
            "```\n"
        )
        
        replan_example = ""
        if is_replanning:
            replan_example = (
                "\n【重规划示例 (V1.0.0 Reasoning Model Output): 工具失败后,成功重规划并调用新/修正的工具】\n"
                "假设历史记录中有如下用户请求和失败的工具调用: \n"
                "  User: \"连接 R10 和 C5\"\n"
                "  Assistant (Previous Plan JSON): ... (Planned connect_components_tool for R10, C5, llmInteractionId: " + example_prev_tool_call_id + "_plan) ...\n"
                "  Tool (connect_components_tool, toolCallId: " + example_prev_tool_call_id + "_tool, name: connect_components_tool) result (in history): { \"role\": \"tool\", ..., \"content\": \"{\\\"status\\\": \\\"failure\\\", \\\"message\\\": \\\"错误: 元件 'R10' 在电路中不存在. \\\", \\\"error\\\": { \\\"error_type\\\": \\\"CIRCUIT_OPERATION_ERROR\\\", \\\"error_code\\\": \\\"COMPONENT_NOT_FOUND_FOR_CONNECTION\\\", ... }}\" }\n"
                "  Current Circuit State (in memory_context): (R10 does not exist, C5 exists)\n"
                "您在【当前重规划】时,您的新V1.0-CamelCaseJSON 输出应类似: \n"
                "<think>\n"
                "重规划开始。分析历史: 用户想连接R10和C5。上一个计划 (llmInteractionId: " + example_prev_tool_call_id + "_plan) 中调用connect_components_tool (toolCallId: " + example_prev_tool_call_id + "_tool) 失败了,工具报告原因是元件 'R10' 在电路中不存在。当前电路状态也确认R10不在电路中，但C5存在。因此,我的新计划是首先添加R10 (用户未指定类型或值,我将默认为电阻,并提供一个常用值如1kΩ). 然后再调用connect_components_tool连接新创建的R10和已存在的C5。本次规划逻辑清晰，后续的JSON应标记为status: 'success'.\n"
                "</think>\n"
                "```json\n"
                "{\n"
                "  \"requestId\": \"" + (request_id or "userReqExampleId789Replan") + "\",\n"
                "  \"llmInteractionId\": \"" + llm_interaction_id_example_plan_prefix + "_replanAddConnectFix2\",\n"
                "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
                "  \"status\": \"success\",\n"
                "  \"errorDetails\": null,\n"
                "  \"executionPhase\": \"planning\",\n"
                "  \"thoughtProcess\": \"R10不存在,先添加再连接。(主要思考过程在 <think> 块中)\",\n"
                "  \"decision\": {\n"
                "    \"isCallTools\": true,\n"
                "    \"toolCallRequests\": [\n"
                "      {\n"
                "        \"toolCallId\": \"tc_replan_add_r10_" + str(uuid4())[:8] + "\",\n"
                "        \"toolName\": \"add_component_tool\",\n"
                "        \"toolArguments\": {\"component_type\": \"电阻\", \"component_id\": \"R10\", \"value\": \"1k\"},\n"
                "        \"uiHints\": {\"displayNameForTool\": \"(修正) 添加电阻 R10 (1kΩ)\"}\n"
                "      },\n"
                "      {\n"
                "        \"toolCallId\": \"tc_replan_connect_r10c5_" + str(uuid4())[:8] + "\",\n"
                "        \"toolName\": \"connect_components_tool\",\n"
                "        \"toolArguments\": {\"comp1_id\": \"R10\", \"comp2_id\": \"C5\"},\n"
                "        \"uiHints\": {\"displayNameForTool\": \"(修正) 连接 R10 与 C5\"}\n"
                "      }\n"
                "    ],\n"
                "    \"responseToUser\": {\n"
                "      \"contentType\": \"text/plain\",\n"
                "      \"content\": \"检测到元件R10之前不存在。我将先为您添加一个1kΩ的电阻R10,然后再将它与C5连接。\",\n"
                "      \"suggestionsForNextSteps\": [\n"
                "        {\"textForUser\": \"操作完成后显示电路状态.\"}\n"
                "      ],\n"
                "      \"requiresUserClarificationForCurrentRequest\": false\n"
                "    }\n"
                "  },\n"
                "  \"diagnostics\": {\"parsingFeedbackFromPreviousAttemptId\": \"" + example_prev_tool_call_id + "_plan\"},\n"
                "  \"usageMetadata\": null\n"
                "}\n"
                "```\n"
            )
        prompt_parts = [
            "您是一位初版电路设计编程助理 (Agent Version V1.0.0, 11 Tools)。您的任务是理解用户指令,并据此规划行动或直接回复。\n", # Version update
            reasoning_model_instructions,
            "\n【核心任务: 规划阶段 (V1.0.0)】\n"
            "请首先在 `<think>...</think>` 标签内深入分析用户的最新指令、完整的对话历史、当前的电路状态和记忆。然后,在 `</think>` 标签之后,生成一个符合V1.0-CamelCaseJSON规范的JSON对象作为您的行动计划或直接回复。JSON中所有key【必须】使用camelCase (例如: `isCallTools`, `toolCallRequests`, `requestId`).\n",
            replanning_guidance if is_replanning else "",
            "【V1.0.0 输出格式规范 (在</think>之后输出, 必须严格遵守)】:\n",
            json_schema_description_for_prompt,
            "\n【重要指令与检查清单 (V1.0.0 - Planning)】:\n"
            "1.  **`<think>` Block First**: 您的详细逐步推理**必须**在 `<think>...</think>` 标签内,并置于回复最开始。\n"
            "2.  **JSON After `</think>`**: V1.0.0 对象 (用 ```json ... ``` 包裹) **必须**紧跟 `</think>` 标签。此JSON中的所有键名必须是 camelCase (例如, `requestId`, `isCallTools`, `toolCallRequests`)。`toolArguments` 内部的键名 (例如, `component_type`) 应遵循下面工具 Schema 中提供的 snake_case 命名。\n"
            "3.  **JSON `thoughtProcess` Field**: 此JSON字段现在是次要的。它可以是简短总结或空字符串 `\"\"`。`<think>...</think>` 块中的内容是主要的思考过程。\n"
            "4.  **`decision.isCallTools`**: JSON中的此字段**必须**是布尔值 (`true` 或 `false`)。大小写不敏感的字符串 \"True\" 或 \"true\" 也可接受,Agent会将其解析为布尔值。\n"
            "5.  **其他 JSON 字段**: 严格遵循V1.0-CamelCaseJSON Schema 的JSON部分。\n"
            "6.  **电路状态感知**: 在规划涉及现有元件的工具调用前,请在 `memory_context` (当前电路状态) 中确认它们的存在。如果需要连接像 'INPUT' 这样的抽象节点而它们并非作为元件存在,请首先规划添加它们 (例如,作为 'Terminal')。\n\n",
            direct_qa_example,
            tool_call_example,
        ]
        if is_replanning:
            prompt_parts.append(replan_example)

        prompt_parts.extend([
            "\n【可用工具列表与参数规范 (V1.0.0 - 11 Tools)】:\n", # Version update
            tool_schemas_desc,
            "\n\n【当前上下文信息 (V1.0.0)】:\n"
            f"Current Request ID (如果可用,请在JSON的requestId字段中原样返回): {request_id or 'N/A_NOT_PROVIDED_IN_PROMPT_SET_TO_NULL'}\n"
            f"Current UTC Time (供您生成timestampUtc参考): {current_timestamp_utc}\n"
            f"当前电路与记忆摘要:\n{memory_context}\n\n"
            "【最后再次强调】: 您的输出【必须】以 `<think>...</think>` 块开始,后跟一个被 ```json ... ``` 包围的、严格符合上述V1.0-CamelCaseJSON规范 (所有key使用camelCase) 的单个JSON对象。JSON对象之外不应有任何其他文本。请务必仔细检查 `<think>` 块的使用以及JSON的语法和所有字段的类型及条件要求！"
        ])
        return "".join(prompt_parts)

    def _get_response_generation_prompt(self, memory_context: str, tool_schemas_desc: str, request_id: Optional[str] = None) -> str:
        current_timestamp_utc = datetime.now(timezone.utc).isoformat()
        llm_interaction_id_example_resp_prefix = f"resp_ex_llm_id_{str(uuid4())[:6]}"

        reasoning_model_instructions_resp_phase = (
            "\n【重要: Reasoning Model 输出规范 (V1.0.0 - Response Generation)】\n"
            "1.  **思考过程**: 您的详细思考过程 (如何分析工具结果或决定直接回复, 以及如何构思最终回复) 【必须】包含在 `<think>...</think>` 标签内,并放在您回复的最开始部分。\n"
            "2.  **JSON 输出**: 在 `</think>` 标签之后,您【必须】输出一个严格符合下面描述的V1.0-CamelCaseJSON格式的单个JSON对象。此JSON对象应被三个反引号和'json'标记包围 (即 ```json ... ```)。JSON中所有key【必须】使用camelCase.\n"
            "3.  **`thoughtProcess` 字段 (in JSON)**: JSON对象内部的 `thoughtProcess` 字段现在是次要的。它可以是一个简短的总结或留空 ( `\"\"` ),因为您的主要思考过程已在 `<think>...</think>` 块中。Agent将优先使用 `<think>` 块中的内容作为思考日志。\n"
        )
        
        json_schema_description_for_resp_phase = """
```json
{
  "requestId": "string_or_null_当前用户请求周期的ID_如果系统提示中提供了此值请原样返回_否则为null",
  "llmInteractionId": "string_必须是本次LLM响应的唯一ID_例如_resp_llm_id_后跟8位随机字符_如_resp_llm_id_e5f6g7h8",
  "timestampUtc": "string_当前UTC时间戳_ISO_8601格式_例如_2024-07-16T12:05:00.000Z",
  "status": "string_必须是 'success' 或 'failure'_表示您是否为本次尝试成功生成了此最终响应JSON_如果您现在无法构思出合适的摘要或回复_则设为failure",
  "errorDetails": {
    "errorType": "string_enum_例如_RESPONSE_GENERATION_ERROR_LLM_OUTPUT_VALIDATION_ERROR",
    "errorCode": "string_例如_JSON_MALFORMED_SUMMARY_LOGIC_ERROR",
    "messageToUser": "string_optional_用户友好的消息_如果适用",
    "technicalMessage": "string_本次响应生成尝试的详细技术错误消息。",
    "isDirectLlmFailure": "boolean_如果LLM明确表示无法完成请求或为本次尝试生成有效JSON则为True。如果错误是由于Agent端对LLM输出的JSON进行校验失败(即使JSON本身语法有效)_或LLM在格式良好的JSON中报告逻辑失败_则为False。",
    "failedValidationPoints": [ { "jsonPath": "...", "issue_description": "..." } ]
  },
  "executionPhase": "string_对于此任务_必须是 'response_generation'",
  "thoughtProcess": "string_此字段现在是次要的_您的主要详细推理必须在初始的 `<think>...</think>` 块中_此JSON字段可以是简短总结或为空_Agent将优先使用 `<think>` 块内容。",
  "decision": {
    "isCallTools": "boolean_在此响应生成阶段必须为false_也接受不区分大小写的字符串 'true'/'false'",
    "toolCallRequests": [],
    "responseToUser": {
      "contentType": "string_例如_text/plain_或_application/markdown",
      "content": "string_这是您对用户的最终且完整的回复_它必须非空。它应总结已采取的操作_报告结果_并根据工具输出(如果最初未调用工具_则根据您的直接知识)回应用户的原始请求。此内容是用户将看到的。",
      "suggestionsForNextSteps": [
        {
          "suggestionId": "string_optional_此建议的唯一ID_例如_sugg_ask_about_led_color",
          "textForUser": "string_向用户显示的建议文本_例如_您想指定LED颜色吗",
          "actionType": "string_enum_optional_USER_INPUT_EXPECTED_or_PREDEFINED_AGENT_ACTION_or_UI_NAVIGATION",
          "actionPayload": "object_or_string_optional_如果类型是PREDEFINED_AGENT_ACTION_这可能是简化的请求对象或命令字符串_供Agent在用户选择后处理"
        }
      ],
      "requiresUserClarificationForCurrentRequest": "boolean_optional_如果当前请求需要用户进一步输入才能继续_并且content正在请求该澄清_则设置为True_默认为False"
    }
  },
  "diagnostics": {
      "llmConfidenceScoreForThisOutput": "float_optional_0.0_到_1.0",
      "alternativePlansConsideredCount": "integer_optional",
      "parsingFeedbackFromPreviousAttemptId": "string_or_null"
  },
  "usageMetadata": null
}
```
"""
        response_gen_example = (
            "\n【示例 (V1.0.0 Reasoning Model Output): 总结工具结果并生成最终回复】\n"
            "假设对话历史中包含以下工具执行结果 (工具1成功, 工具2是搜索工具也成功):\n"
            "  Tool Message 1 (for toolCallId: tc_xyz_add_r1): { \"role\": \"tool\", ..., \"content\": \"{\\\"status\\\": \\\"success\\\", \\\"message\\\": \\\"已添加电阻R1\\\", ...}\" }\n"
            "  Tool Message 2 (for toolCallId: tc_abc_search_led): { \"role\": \"tool\", ..., \"content\": \"{\\\"status\\\": \\\"success\\\", \\\"message\\\": \\\"已完成对'LED'的DuckDuckGo搜索,找到2条相关信息。\\\", \\\"data\\\": {\\\"query\\\": \\\"LED\\\", \\\"num_results_returned\\\": 2, \\\"results_json_string\\\": \\\"[{\\\\\\\"title\\\\\\\":\\\\\\\"LED - Wikipedia\\\\\\\", ...}]\\\"}}\" }\n"
            "您的输出V1.0-CamelCaseJSON JSON应类似 (ID和时间戳会变化): \n"
            "<think>\n"
            "回顾工具执行结果: add_component_tool (toolCallId: tc_xyz_add_r1) 成功添加了电阻R1。duckduckgo_search_tool (toolCallId: tc_abc_search_led) 成功搜索了'LED'并返回了结果。我需要向用户清晰地报告这两个操作的成功,并简要提及搜索到的信息。最终的回复将整合这些信息,保持友好和乐于助人的语气。\n"
            "</think>\n"
            "```json\n"
            "{\n"
            "  \"requestId\": \"" + (request_id or "userReqExampleIdResp123") + "\",\n"
            "  \"llmInteractionId\": \"" + llm_interaction_id_example_resp_prefix + "_finalSummaryRSearchFix2\",\n" 
            "  \"timestampUtc\": \"" + current_timestamp_utc + "\",\n"
            "  \"status\": \"success\",\n"
            "  \"errorDetails\": null,\n"
            "  \"executionPhase\": \"response_generation\",\n"
            "  \"thoughtProcess\": \"总结R1添加成功,LED搜索成功。(主要思考过程在 <think> 块中)\",\n"
            "  \"decision\": {\n"
            "    \"isCallTools\": false, \n"
            "    \"toolCallRequests\": [], \n"
            "    \"responseToUser\": {\n"
            "      \"contentType\": \"text/plain\",\n"
            "      \"content\": \"您好,我已经成功为您添加了电阻R1。关于LED的DuckDuckGo搜索也已完成,我找到了2条相关信息,例如 'LED - Wikipedia'。您想了解更多搜索到的细节吗？\",\n"
            "      \"suggestionsForNextSteps\": [\n"
            "        {\"suggestionId\": \"sugg_show_search_details\", \"textForUser\": \"显示LED搜索结果的详细信息\", \"actionType\": \"USER_INPUT_EXPECTED\"},\n"
            "        {\"suggestionId\": \"sugg_view_circuit\", \"textForUser\": \"查看当前电路中已有的元件列表。\", \"actionType\": \"USER_INPUT_EXPECTED\", \"actionPayload\": \"当前电路什么样\"}\n"
            "      ],\n"
            "      \"requiresUserClarificationForCurrentRequest\": false \n"
            "    }\n"
            "  },\n"
            "  \"diagnostics\": {\"llmConfidenceScoreForThisOutput\": 0.98},\n"
            "  \"usageMetadata\": null\n"
            "}\n"
            "```\n"
        )
        return (
            "您是一位初版电路设计编程助理 (Agent Version V1.0.0, 11 Tools), 经验丰富,技术精湛,并且极其擅长清晰、准确、诚实地汇报工作结果。\n" # Version update
            f"{reasoning_model_instructions_resp_phase}\n"
            "【核心任务: 响应生成阶段 (V1.0.0)】\n"
            "您当前的任务是: 基于到目前为止的【完整对话历史】(包括用户最初的指令、您在规划阶段生成的V1.0-CamelCaseJSON计划、以及所有【已执行工具的结果详情】,这些工具结果是以 'role: tool', 'toolCallId: ...', 'name: ...', 'content: JSON_string_of_tool_output' 的格式存在于历史记录中的), 首先在 `<think>...</think>` 标签内进行思考和总结, 然后在 `</think>` 之后生成【最终的、面向用户的V1.0-CamelCaseJSON回复】。JSON中所有key【必须】使用camelCase.\n\n"
            "【V1.0.0 输出格式规范 (在</think>之后输出, 与规划阶段结构相同,但有特定值要求 - 再次强调)】:\n"
            f"{json_schema_description_for_resp_phase}\n"
            "【重要指令与检查清单 (V1.0.0 - 响应生成阶段特定要求)】:\n"
            "1.  **`<think>` Block First**: 您的详细工具结果分析和回复构思**必须**在 `<think>...</think>` 标签内。\n"
            "2.  **JSON After `</think>`**: V1.0.0 对象 (用 ```json ... ``` 包裹) **必须**紧跟 `</think>` 标签。此JSON中的所有键名必须是 camelCase。\n"
            "3.  **`executionPhase`**: 在此阶段,此值【必须】是 `\"response_generation\"`。\n"
            "4.  **`decision.isCallTools`**: 在此响应生成阶段,此值【必须】为 `false` (或可解析为`false`的字符串)。\n"
            "5.  **`decision.toolCallRequests`**: 在此响应生成阶段,此列表【必须】为 `[]` (空数组) 或 `null`。\n"
            "6.  **`decision.responseToUser.content`**: 这是您基于所有先前步骤生成的【最终、完整、友好】的文本回复。它【不能】为空字符串或仅包含空白。\n"
            "7.  **回顾工具结果**: 仔细检查对话历史中 `role: tool` 的消息。您的最终回复必须准确反映这些结果。\n\n"
            f"{response_gen_example}\n"
            "【上下文参考信息 (仅供你回顾 - V1.0.0)】:\n"
            f"Current Request ID (如果可用,请在JSON的requestId字段中原样返回): {request_id or 'N/A_NOT_PROVIDED_IN_PROMPT_SET_TO_NULL'}\n"
            f"Current UTC Time (供您生成timestampUtc参考): {current_timestamp_utc}\n"
            f"当前电路与记忆摘要:\n{memory_context}\n"
            f"我的可用工具列表 (共11个, 仅供你参考,此阶段不应再调用它们):\n{tool_schemas_desc}\n\n" # Version update
            "【最后再次强调】: 您的输出【必须】以 `<think>...</think>` 块开始,后跟一个被 ```json ... ``` 包围的、严格符合上述V1.0-CamelCaseJSON规范 (所有key使用camelCase) 的单个JSON对象。在这个阶段,您【绝对不能】再请求调用任何新工具。您的任务是总结并回复。"
        )

# --- Main entry point for testing (Optional) ---
async def main_test_flow(agent: CircuitAgent, user_query: str):
    logger.info(f"\n\n>>>>>>>>> 测试开始 (V1.0.0): 用户查询: '{user_query}' <<<<<<<<<<") # Version update

    async def mock_status_callback(status_update: Dict[str, Any]):
        if "finaljson_if_success" in status_update and status_update["finaljson_if_success"]:
            printable_update = status_update.copy()
            try:
                printable_update["finaljson_if_success"] = json.loads(json.dumps(status_update["finaljson_if_success"], indent=2, ensure_ascii=False))
            except:
                pass
            logger.info(f"[StatusCallback] {json.dumps(printable_update, indent=2, ensure_ascii=False, default=str)}")
        elif "plan" in status_update and isinstance(status_update["plan"], list):
            printable_update = status_update.copy()
            try:
                printable_update["plan"] = json.loads(json.dumps(status_update["plan"], indent=2, ensure_ascii=False))
            except:
                pass
            logger.info(f"[StatusCallback] {json.dumps(printable_update, indent=2, ensure_ascii=False, default=str)}")
        else:
            logger.info(f"[StatusCallback] {json.dumps(status_update, ensure_ascii=False, default=str)}")

    await agent.process_user_request(user_query, mock_status_callback)
    logger.info(f">>>>>>>>>> 测试结束 (V1.0.0): 用户查询: '{user_query}' <<<<<<<<<<\n") # Version update

if __name__ == "__main__":
    logger.info("========== CircuitAgent V1.0.0 (11 Tools) - 命令行测试模式 ==========") 
    
    zhipu_api_key = os.environ.get("ZHIPUAI_API_KEY")
    if not zhipu_api_key:
        logger.critical("严重错误: ZHIPUAI_API_KEY 环境变量未设置,且代码中也未提供。Agent 无法运行。")
        sys.exit("错误: ZHIPUAI_API_KEY 未设置。请在运行前设置此环境变量。")

    test_agent = None # 初始化为 None
    try:
        test_agent = CircuitAgent(
            api_key=zhipu_api_key,
            model_name="glm-z1-flash",
            verbose=True,
            max_short_term_items=20,
            planning_llm_retries=1, 
            max_tool_retries=0, 
            max_replanning_attempts=1 
        )
        logger.info("CircuitAgent V1.0.0 (11 Tools) 初始化成功,准备接收测试指令。")
    except Exception as e_init:
        logger.critical(f"Agent 初始化失败: {e_init}", exc_info=True)
        sys.exit(f"Agent 初始化失败: {e_init}")

    test_queries = [
        "你好,你是谁？",
        "当前电路是什么样的?",
        "帮我添加一个10k欧姆的电阻,命名为R100。",
        "使用 DuckDuckGo 搜索一下什么是基尔霍夫电流定律。",
        "用 DuckDuckGo 搜索 'Python async library' 并返回2条结果",
        "搜索知乎", 
        "请帮我把R100的电阻值更新为4.7k, 然后查一下R100的连接数量, 接着用DuckDuckGo搜索“运算放大器原理”, 最后再移除R100。",
        "清空整个电路。",
    ]

    async def run_all_tests_main(agent_instance: CircuitAgent): # 修改函数名以示区别
        for i, query in enumerate(test_queries):
            logger.info(f"\n--- 测试用例 {i+1}/{len(test_queries)} (V1.0.0) ---")
            await main_test_flow(agent_instance, query) # 传递 agent_instance
            logger.info(f"--- 测试用例 {i+1} (V1.0.0) 完成 ---\n")
            if i < len(test_queries) - 1:
                 await asyncio.sleep(2)

    # ------------------- 关键修复部分开始 -------------------
    async def cleanup_remaining_tasks(current_loop):
        """Helper coroutine to clean up remaining tasks."""
        active_tasks = [task for task in asyncio.all_tasks(current_loop) if not task.done()]
        if active_tasks:
            logger.info(f"等待 {len(active_tasks)} 个剩余异步任务完成...")
            try:
                # 等待所有当前活动的任务完成，设置一个超时以防万一
                await asyncio.wait_for(asyncio.gather(*active_tasks, return_exceptions=True), timeout=5.0)
                logger.info("所有剩余异步任务已处理。")
            except asyncio.TimeoutError:
                logger.warning("等待剩余异步任务超时。")
                # 对于超时的任务，尝试取消它们
                for task in active_tasks:
                    if not task.done():
                        task.cancel()
                        try:
                            await task # 等待取消完成
                        except asyncio.CancelledError:
                            logger.info(f"任务 {task.get_name()} 已取消。")
                        except Exception as e_cancel:
                            logger.error(f"取消任务 {task.get_name()} 时发生错误: {e_cancel}")
            except Exception as e_gather:
                logger.error(f"处理剩余异步任务时发生错误: {e_gather}", exc_info=True)
    # ------------------- 关键修复部分结束 -------------------

    main_loop_is_running_at_start = loop.is_running()
    try:
        if test_agent: # 确保 agent 实例已创建
            # 如果主循环没有运行 (例如，直接从脚本顶部获取的 loop)，则使用 run_until_complete
            if not main_loop_is_running_at_start:
                loop.run_until_complete(run_all_tests_main(test_agent))
            else:
                # 如果已经在运行的循环中 (不太可能直接运行脚本时发生，但为了健壮性)
                # 我们可以创建一个新任务并等待它，但这会复杂化。
                # 简单起见，假设直接运行脚本时，loop 是由我们控制的。
                # 为了安全，我们还是用 run_until_complete, 它能处理好新旧循环。
                asyncio.run(run_all_tests_main(test_agent)) # 或者 loop.run_until_complete
        else:
            logger.error("Agent 实例未能创建，无法运行测试。")

    except KeyboardInterrupt:
        logger.info("测试被用户中断。")
    except Exception as e_main_run:
        logger.critical(f"运行测试时发生未处理的异常: {e_main_run}", exc_info=True)
    finally:
        # 确保在 finally 块中我们使用的是仍然有效的 loop 引用
        # 并且只在它真的还在运行时尝试关闭它。
        # asyncio.run() 会自己管理循环的关闭。
        # 如果是手动管理的 loop，则需要这里的逻辑。
        
        current_loop_ref = None
        try:
            current_loop_ref = asyncio.get_running_loop()
        except RuntimeError: # No running loop
            current_loop_ref = loop # Fallback to the loop we initially got/created

        if current_loop_ref and not current_loop_ref.is_closed():
            # 使用 run_until_complete 来运行清理协程
            logger.info("开始执行异步清理任务...")
            current_loop_ref.run_until_complete(cleanup_remaining_tasks(current_loop_ref))
            logger.info("异步清理任务完成。")
            
            # 只有当这个循环不是由 asyncio.run() 管理时才手动关闭
            # 如果是手动通过 set_event_loop 和 run_until_complete (针对单个协程) 管理的
            if not main_loop_is_running_at_start and current_loop_ref is loop: # 确保是我们手动启动和停止的循环
                 if not current_loop_ref.is_closed(): # 再次检查，因为cleanup可能已经关闭了某些东西
                    current_loop_ref.close()
                    logger.info("事件循环已关闭。")
            elif current_loop_ref.is_running() and not current_loop_ref.is_closed(): # 如果是其他情况且仍在运行
                logger.warning("事件循环仍在运行但未明确关闭，这可能发生在嵌套的asyncio使用中。")


        logger.info("========== CircuitAgent V1.0.0 (11 Tools) - 命令行测试结束 ==========")
--- END: Otherfiles/CircuitManusCore.py ---

--- START: static/index.html ---
<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CircuitManus Pro - 光绘墨迹终端 (V1.1.0 - Lumina Script Multi-LLM)</title> <!-- 版本更新 -->

    <!-- Google Fonts Preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Google Fonts Stylesheets -->
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Roboto:wght@300;400;500;700&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap"
        rel="stylesheet">
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <!-- Animate.css for Animations -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">

    <!-- 主 CSS 文件入口 (style.css 会 @import 其他CSS模块) -->
    <link rel="stylesheet" href="static/css/style.css"> <!-- 确保这是模块化CSS的入口 -->

    <!-- Three.js 库 (如果需要，可以考虑本地化或通过npm管理) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body data-theme="light-crystal" data-animation-level="full">

    <!-- Dynamic Crystal Background (CSS driven) -->
    <div class="dynamic-crystal-background">
        <div class="background-grid-pattern"></div>
    </div>

    <!-- IDT Tech Component / Black Hole Effect Wrapper (CSS & JS driven) -->
    <div id="idtTechComponentWrapper" class="component-wrapper is-visible black-hole-container">
        <div class="bh-effect bh-outer-glow"></div>
        <div class="bh-effect bh-accretion-disk-outer"></div>
        <div class="bh-effect bh-accretion-disk-middle"></div>
        <div class="bh-effect bh-accretion-disk-inner"></div>
        <div class="bh-effect bh-core-shadow"></div>
        <div class="bh-effect bh-orbiting-star"></div>
        <!-- Canvas for Three.js will be appended here by three_visuals.js -->
    </div>

    <!-- Loader -->
    <div class="loader-container" id="loader">
        <div class="lumina-loader-core">
            <div class="lumina-loader-center-pulse"></div>
        </div>
        <div class="loader-logo-text">
            <span>CIRCUIT</span>MANUS<span class="loader-version-pro">PRO</span>
        </div>
        <p class="loading-text">同步光绘墨迹流 (V1.1.0 Lumina)...</p> <!-- 版本更新 -->
    </div>

    <!-- Main Application Container -->
    <div class="main-container" id="main-container">
        <!-- Header -->
        <header class="header lumina-panel" id="app-header">
            <div class="logo">
                <div class="logo-icon"><i class="fas fa-network-wired"></i></div>
                <!-- 版本更新 -->
                <h1>CircuitManus <span class="version-pro">Lumina <span class="version-number">v1.1.0</span></span></h1>
            </div>
            <div class="header-buttons">
                <button id="toggleIdtComponentBtn" class="header-btn icon-btn" title="切换核心投影 (黑洞)"><i
                        class="fas fa-atom"></i></button>
                <button id="theme-toggle" class="header-btn icon-btn" title="切换显示模式"><i
                        class="fas fa-palette"></i></button>
                <button id="clear-chat" class="header-btn icon-btn" title="清空当前墨迹"><i
                        class="fas fa-eraser"></i></button>
                <button id="toggle-process-log-visibility" class="header-btn icon-btn" title="切换处理日志侧栏"><i
                        class="fas fa-scroll"></i></button>
            </div>
        </header>

        <!-- App Body (Sidebar + Main Chat Area + Process Log Sidebar) -->
        <div class="app-body-container" id="appBodyContainer">
            <!-- Left Sidebar -->
            <aside class="sidebar lumina-panel left-sidebar" id="sidebar">
                <button id="left-sidebar-toggle" class="sidebar-toggle-btn icon-btn" title="展开/收起侧边栏">
                    <i class="fas fa-bars"></i>
                </button>
                <div class="sidebar-content-wrapper">
                    <div class="sidebar-main-actions">
                        <button class="sidebar-button lumina-button-sidebar active" data-mode="chat" title="灵感交流"><i
                                class="fas fa-comments"></i><span>灵感交流</span></button>
                        <button class="sidebar-button lumina-button-sidebar" data-mode="code" title="代码绘卷"><i
                                class="fas fa-code-branch"></i><span>代码绘卷</span></button>
                        <button class="sidebar-button lumina-button-sidebar" data-mode="circuit" title="电路拓印"><i
                                class="fas fa-sitemap"></i><span>电路拓印</span></button>
                        <button class="sidebar-button lumina-button-sidebar" data-mode="settings" title="参数调校"><i
                                class="fas fa-sliders-h"></i><span>参数调校</span></button>
                    </div>
                    <div class="session-manager" id="session-manager">
                        <div class="session-manager-header" id="session-manager-toggle">
                            <span><i class="fas fa-stream"></i> 会话流</span>
                            <i class="fas fa-caret-down toggle-icon"></i>
                        </div>
                        <div class="session-list-container" id="session-list-container">
                            <ul class="session-list" id="session-list">
                                <!-- Session items will be populated by JavaScript -->
                            </ul>
                        </div>
                    </div>
                </div>
                <button id="create-new-session" class="lumina-button lumina-button-primary lumina-button-fixed-bottom"
                    title="创建新光绘项目"><i class="fas fa-edit"></i><span>新建光绘</span></button>
            </aside>

            <!-- Main Chat Area -->
            <main class="chat-area" id="chat-area">
                <div class="chat-area-content lumina-panel main-chat-panel">
                    <div class="chat-header" id="chat-header">
                        <h2 id="current-session-name">默认光绘项目</h2>
                        <button id="edit-session-name-btn" class="icon-btn" title="重命名光绘项目"><i
                                class="fas fa-pencil-alt"></i></button>
                    </div>
                    <div class="chat-box" id="chat-box">
                        <!-- Chat messages will be populated by JavaScript -->
                    </div>
                    <div class="file-preview lumina-panel" id="file-preview">
                        <div class="file-preview-header">
                            <h3><i class="fas fa-folder-open"></i> 附件预览</h3>
                            <button id="close-preview" class="icon-btn" title="关闭预览"><i
                                    class="fas fa-times"></i></button>
                        </div>
                        <div class="file-preview-content" id="file-preview-content">
                            <!-- File preview items will be populated by JavaScript -->
                        </div>
                    </div>
                    <div class="input-area lumina-panel" id="input-area">
                        <button id="attach-button" class="input-action-btn icon-btn" title="添加附件"><i
                                class="fas fa-paperclip"></i></button>
                        <div class="input-wrapper">
                            <textarea id="user-input" placeholder="向Lumina核心发送指令 (Shift+Enter换行)..."
                                rows="1"></textarea>
                            <div class="input-actions-overlay">
                                <button id="mic-button" class="overlay-btn icon-btn" title="语音墨迹 (开发中)"><i
                                        class="fas fa-microphone-alt"></i></button>
                                <span id="char-counter" class="char-counter">0/8000</span>
                            </div>
                        </div>
                        <button id="send-button" class="send-button lumina-button lumina-button-primary" title="发送指令">
                            <svg viewBox="0 0 24 24" fill="currentColor" class="send-icon">
                                <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path>
                            </svg>
                            <i class="fas fa-spinner fa-spin send-loading-icon" style="display: none;"></i>
                        </button>
                        <input type="file" id="file-input" multiple style="display: none">
                    </div>
                </div>
            </main>

            <!-- Right Agent Process Log Sidebar -->
            <aside class="process-log-sidebar lumina-panel" id="agent-process-sidebar">
                <div class="process-log-header">
                    <span><i class="fas fa-route"></i> Agent 执行轨迹</span>
                    <button class="icon-btn" id="toggle-process-log-sidebar-collapse" title="折叠/展开轨迹日志">
                        <i class="fas fa-chevron-left"></i>
                    </button>
                    <button class="icon-btn" id="close-process-log-sidebar" title="关闭轨迹日志" style="display:none;">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="process-log-content" id="process-log-content-sidebar">
                    <!-- Log items will be populated by JavaScript -->
                </div>
            </aside>
        </div>
    </div>

    <!-- Toast Notification Container -->
    <div class="toast-container" id="toast-container">
        <!-- Toast messages will be populated by JavaScript -->
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settings-modal">
        <div class="modal-content animate__animated lumina-panel">
            <div class="modal-header">
                <h2><i class="fas fa-sliders-h"></i> 参数调校台</h2>
                <button id="close-settings" class="icon-btn" title="关闭配置"><i class="fas fa-times"></i></button>
            </div>
            <div class="modal-body">
                <div class="setting-group">
                    <h3><i class="fas fa-fill-drip"></i> 界面风格</h3>
                    <div class="setting-item">
                        <label for="theme-select">界面主题</label>
                        <select id="theme-select" class="lumina-select">
                            <option value="light-crystal">月白宣纸 (亮色)</option>
                            <option value="dark-crystal">墨黑星空 (暗色)</option>
                            <option value="auto-crystal">随境而变 (自动)</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label for="font-size">文本字号</label>
                        <div class="lumina-range-container">
                            <input type="range" id="font-size" min="12" max="20" value="16" step="1"
                                class="lumina-range">
                            <span id="font-size-value">16px</span>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label for="animation-level">动态效果等级</label>
                        <select id="animation-level" class="lumina-select">
                            <option value="full">流畅光绘</option>
                            <option value="basic">简约墨迹</option>
                            <option value="none">静止画卷</option>
                        </select>
                    </div>
                </div>

                <!-- 新增：LLM模型和语言偏好设置组 -->
                <div class="setting-group">
                    <h3><i class="fas fa-cogs"></i> AI核心配置</h3>
                    <div class="setting-item">
                        <label for="llm-model-select">选择语言模型</label>
                        <select id="llm-model-select" class="lumina-select">
                            <!-- 选项将由JS动态填充，这里是占位符 -->
                            <option value="zhipu-ai">智谱清言 (GLM)</option>
                            <option value="deepseek" disabled>DeepSeek 大模型 (暂不可用)</option> 
                        </select>
                    </div>
                    <div class="setting-item" id="chinese-deep-thinking-setting-item"> <!-- 包裹元素，方便JS控制显隐 -->
                        <label for="enable-chinese-deep-thinking-toggle">启用深度中文思考</label>
                        <div class="lumina-switch-container">
                            <label class="lumina-switch"><input type="checkbox" id="enable-chinese-deep-thinking-toggle"><span
                                    class="slider round"></span></label>
                        </div>
                    </div>
                </div>
                <!-- 结束新增 -->

                <div class="setting-group">
                    <h3><i class="fas fa-mouse-pointer"></i> 交互行为</h3>
                    <div class="setting-item">
                        <label for="auto-scroll">信息流自动滚动</label>
                        <div class="lumina-switch-container">
                            <label class="lumina-switch"><input type="checkbox" id="auto-scroll" checked><span
                                    class="slider round"></span></label>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label for="sound-enabled">声音反馈 (实验性)</label>
                        <div class="lumina-switch-container">
                            <label class="lumina-switch"><input type="checkbox" id="sound-enabled"><span
                                    class="slider round"></span></label>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label for="show-chat-bubbles-think">消息气泡内显示思考</label>
                        <div class="lumina-switch-container">
                            <label class="lumina-switch"><input type="checkbox" id="show-chat-bubbles-think"
                                    checked><span class="slider round"></span></label>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label for="show-log-bubbles-think">处理日志中显示思考</label>
                        <div class="lumina-switch-container">
                            <label class="lumina-switch"><input type="checkbox" id="show-log-bubbles-think"
                                    checked><span class="slider round"></span></label>
                        </div>
                    </div>
                </div>
                <div class="setting-group">
                    <h3><i class="fas fa-brain"></i> Agent 辅助</h3> <!-- 原 "Agent 核心" 改为 "Agent 辅助" 或其他 -->
                    <div class="setting-item">
                        <label for="auto-submit-quick-actions">快捷指令自动提交</label>
                        <div class="lumina-switch-container">
                            <label class="lumina-switch"><input type="checkbox" id="auto-submit-quick-actions"
                                    checked><span class="slider round"></span></label>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label for="component-visibility-toggle">3D核心投影默认可见</label>
                        <div class="lumina-switch-container">
                            <label class="lumina-switch"><input type="checkbox" id="component-visibility-toggle"
                                    checked><span class="slider round"></span></label>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="reset-settings" class="lumina-button"><i class="fas fa-undo-alt"></i>恢复默认</button>
                <button id="save-settings" class="lumina-button lumina-button-primary"><i class="fas fa-save"></i>
                    保存参数</button>
            </div>
        </div>
    </div>

    <!-- JavaScript Modules -->
    <script type="module" src="static/js/utils/dom_elements.js"></script>
    <script type="module" src="static/js/utils/helpers.js"></script>
    <script type="module" src="static/js/core/state.js"></script>
    <script type="module" src="static/js/core/ui_updater.js"></script>
    <script type="module" src="static/js/core/websocket_manager.js"></script>
    <script type="module" src="static/js/modules/theme_handler.js"></script>
    <script type="module" src="static/js/modules/layout_handler.js"></script>
    <script type="module" src="static/js/modules/session_handler.js"></script>
    <script type="module" src="static/js/modules/settings_handler.js"></script>
    <script type="module" src="static/js/modules/file_handler.js"></script>
    <script type="module" src="static/js/modules/three_visuals.js"></script>
    <script type="module" src="static/js/modules/copy_handler.js"></script>
    <script type="module" src="static/js/modules/quick_actions_handler.js"></script>
    <script type="module" src="static/js/core/event_listener_setup.js"></script>
    <script type="module" src="static/js/app.js"></script>

</body>
</html>

--- END: static/index.html ---

--- START: static/script.js ---
// 当整个 HTML 文档加载完成并解析完毕后执行回调函数
document.addEventListener('DOMContentLoaded', () => {
    // ======== DOM 元素获取 (集中管理，方便维护) ========
    // 定义一个 dom 对象，用于存储所有获取到的 DOM 元素，方便统一管理和后续引用。
    const dom = {
        // 动态背景相关
        dynamicBackground: document.querySelector('.dynamic-crystal-background'), // 获取类名为 'dynamic-crystal-background' 的元素，用作动态背景容器。类名保持，效果由CSS内部调整

        // 加载动画相关
        loader: document.getElementById('loader'), // 获取 ID 为 'loader' 的元素，用作加载动画的容器。
        loaderCore: document.querySelector('.lumina-loader-core'), // 获取类名为 'lumina-loader-core' 的元素，这是新的加载动画核心部分。
        mainContainer: document.getElementById('main-container'), // 获取 ID 为 'main-container' 的元素，这是应用的主内容区域容器。
        appBodyContainer: document.getElementById('appBodyContainer'), // 获取 ID 为 'appBodyContainer' 的元素，这是应用主体内容的容器，用于布局调整。

        // 聊天核心区域
        chatArea: document.getElementById('chat-area'), // 获取 ID 为 'chat-area' 的元素，包含聊天框和输入区域。
        chatBox: document.getElementById('chat-box'), // 获取 ID 为 'chat-box' 的元素，用于显示聊天消息。
        userInput: document.getElementById('user-input'), // 获取 ID 为 'user-input' 的元素，用户输入消息的文本框。
        sendButton: document.getElementById('send-button'), // 获取 ID 为 'send-button' 的元素，发送消息的按钮。ID保持，但其 class 会在HTML中更新
        sendIcon: document.querySelector('.send-icon'), // 获取类名为 'send-icon' 的元素，发送按钮上的默认图标。
        sendLoadingIcon: document.querySelector('.send-loading-icon'), // 获取类名为 'send-loading-icon' 的元素，发送按钮上表示加载中的图标。

        // 头部与主题
        appHeader: document.getElementById('app-header'), // 获取 ID 为 'app-header' 的元素，应用的头部区域。
        themeToggleButton: document.getElementById('theme-toggle'), // 获取 ID 为 'theme-toggle' 的元素，切换主题的按钮。
        themeToggleIcon: document.querySelector('#theme-toggle i'), // 获取 ID 为 'theme-toggle' 按钮内的 <i> 图标元素。选择器不变
        clearChatButton: document.getElementById('clear-chat'), // 获取 ID 为 'clear-chat' 的元素，清除当前聊天记录的按钮。
        leftSidebarToggle: document.getElementById('left-sidebar-toggle'), // 获取 ID 为 'left-sidebar-toggle' 的元素，切换左侧边栏显示/隐藏的按钮。
        toggleProcessLogVisibilityButton: document.getElementById('toggle-process-log-visibility'), // 获取 ID 为 'toggle-process-log-visibility' 的元素，用于切换右侧处理过程日志侧边栏的可见性。

        // 侧边栏与会话管理 (左侧边栏)
        sidebar: document.getElementById('sidebar'), // 获取 ID 为 'sidebar' 的元素，左侧边栏容器。
        sidebarButtons: document.querySelectorAll('.sidebar-button'), // 获取所有类名为 'sidebar-button' 的元素，用于模式切换等。class 会在HTML中更新
        sessionManager: document.getElementById('session-manager'), // 获取 ID 为 'session-manager' 的元素，会话管理器区域。
        sessionManagerToggle: document.getElementById('session-manager-toggle'), // 获取 ID 为 'session-manager-toggle' 的元素，展开/折叠会话列表的按钮。
        sessionListContainer: document.getElementById('session-list-container'), // 获取 ID 为 'session-list-container' 的元素，会话列表的容器。
        sessionList: document.getElementById('session-list'), // 获取 ID 为 'session-list' 的元素 (ul)，用于显示会话列表项。
        createNewSessionButton: document.getElementById('create-new-session'), // 获取 ID 为 'create-new-session' 的元素，创建新会话的按钮。ID保持，class 会更新
        currentSessionNameDisplay: document.getElementById('current-session-name'), // 获取 ID 为 'current-session-name' 的元素，显示当前会话名称。
        editSessionNameButton: document.getElementById('edit-session-name-btn'), // 获取 ID 为 'edit-session-name-btn' 的元素，编辑当前会话名称的按钮。ID保持，class 会更新

        // 输入区域与文件上传
        inputArea: document.getElementById('input-area'), // 获取 ID 为 'input-area' 的元素，整个输入区域的容器。
        attachButton: document.getElementById('attach-button'), // 获取 ID 为 'attach-button' 的元素，附加文件按钮。ID保持，class 会更新
        micButton: document.getElementById('mic-button'), // 获取 ID 为 'mic-button' 的元素，麦克风/语音输入按钮。ID保持，class 会更新
        charCounter: document.getElementById('char-counter'), // 获取 ID 为 'char-counter' 的元素，显示用户输入字符数。
        fileInput: document.getElementById('file-input'), // 获取 ID 为 'file-input' 的元素 (type="file")，用于选择文件。
        filePreviewArea: document.getElementById('file-preview'), // 获取 ID 为 'file-preview' 的元素，显示已选择文件预览的区域。
        filePreviewContent: document.getElementById('file-preview-content'), // 获取 ID 为 'file-preview-content' 的元素，文件预览项的具体容器。
        closeFilePreviewButton: document.getElementById('close-preview'), // 获取 ID 为 'close-preview' 的元素，关闭文件预览区域的按钮。ID保持，class 会更新

        // Toast 通知
        toastContainer: document.getElementById('toast-container'), // 获取 ID 为 'toast-container' 的元素，显示 Toast 通知的容器。

        // Agent 处理过程日志区域 (右侧悬浮侧栏)
        processLogSidebarContainer: document.getElementById('agent-process-sidebar'), // 获取 ID 为 'agent-process-sidebar' 的元素，右侧Agent处理过程日志侧边栏的容器。
        processLogSidebarHeader: document.querySelector('#agent-process-sidebar .process-log-header'), // 获取右侧日志侧边栏内的头部元素。
        processLogSidebarContent: document.getElementById('process-log-content-sidebar'), // 获取 ID 为 'process-log-content-sidebar' 的元素，用于显示日志条目。
        toggleProcessLogSidebarCollapseButton: document.getElementById('toggle-process-log-sidebar-collapse'), // 获取 ID 为 'toggle-process-log-sidebar-collapse' 的元素，折叠/展开右侧日志侧边栏的按钮。ID保持
        closeProcessLogSidebarButton: document.getElementById('close-process-log-sidebar'), // 获取 ID 为 'close-process-log-sidebar' 的元素，关闭右侧日志侧边栏的按钮。ID保持

        // 设置模态框相关
        settingsModal: document.getElementById('settings-modal'), // 获取 ID 为 'settings-modal' 的元素，设置模态框。
        openSettingsButton: document.querySelector('.sidebar-button[data-mode="settings"]'), // 获取侧边栏中用于打开设置的按钮。
        closeSettingsButton: document.getElementById('close-settings'), // 获取 ID 为 'close-settings' 的元素，关闭设置模态框的按钮。ID保持
        themeSelect: document.getElementById('theme-select'), // 获取 ID 为 'theme-select' 的元素 (select)，选择主题。class 会更新
        fontSizeInput: document.getElementById('font-size'), // 获取 ID 为 'font-size' 的元素 (input type="range")，调整字体大小。class 会更新
        fontSizeValue: document.getElementById('font-size-value'), // 获取 ID 为 'font-size-value' 的元素，显示当前字体大小值。
        animationLevelSelect: document.getElementById('animation-level'), // 获取 ID 为 'animation-level' 的元素 (select)，选择动画级别。class 会更新
        autoScrollToggle: document.getElementById('auto-scroll'), // 获取 ID 为 'auto-scroll' 的元素 (input type="checkbox")，切换自动滚动。class 会更新
        soundEnabledToggle: document.getElementById('sound-enabled'), // 获取 ID 为 'sound-enabled' 的元素 (input type="checkbox")，切换声音提示。class 会更新
        showChatBubblesThinkToggle: document.getElementById('show-chat-bubbles-think'), // 获取 ID 为 'show-chat-bubbles-think' 的元素 (checkbox)，切换是否在聊天气泡中显示思考过程。class 会更新
        showLogBubblesThinkToggle: document.getElementById('show-log-bubbles-think'), // 获取 ID 为 'show-log-bubbles-think' 的元素 (checkbox)，切换是否在日志条目中显示思考气泡。class 会更新
        autoSubmitQuickActionsToggle: document.getElementById('auto-submit-quick-actions'), // 获取 ID 为 'auto-submit-quick-actions' 的元素 (checkbox), 切换快捷操作是否自动提交。class 会更新
        componentVisibilityToggle: document.getElementById('component-visibility-toggle'), // 获取 ID 为 'component-visibility-toggle' 的元素 (checkbox), 用于切换3D组件的显示。class 会更新
        resetSettingsButton: document.getElementById('reset-settings'), // 获取 ID 为 'reset-settings' 的元素，重置所有设置的按钮。ID保持
        saveSettingsButton: document.getElementById('save-settings'), // 获取 ID 为 'save-settings' 的元素，保存设置的按钮。ID保持

        // 3D组件显示开关与包装器
        idtComponentToggleBtn: document.getElementById('toggleIdtComponentBtn'), // 获取 ID 为 'toggleIdtComponentBtn' 的元素，用于切换3D组件（黑洞特效）的按钮。ID保持
        idtComponentWrapper: document.getElementById('idtTechComponentWrapper') // 获取 ID 为 'idtTechComponentWrapper' 的元素，3D组件（黑洞特效）的容器。ID保持
    };

    // ======== 应用状态与配置 ========
    // 定义应用的前缀，用于 localStorage 存储，以区分旧版或其他应用设置。
    const APP_PREFIX = 'CircuitManusPro_LuminaScript_'; // 更新应用前缀以区分旧设置
    // 定义一个 state 对象，用于存储应用的运行时状态和用户配置。
    let state = {
        sessions: {}, // 存储所有会话数据，以会话ID为键。
        currentSessionId: null, // 当前活动的会话ID。
        currentTheme: 'auto-crystal', // 当前主题设置 ('auto-crystal', 'light-crystal', 'dark-crystal')。初始值保持，applyTheme会处理
        autoScroll: true, // 是否自动滚动聊天框到底部。
        soundEnabled: false, // 是否启用声音提示。
        showChatBubblesThink: true, // 是否在聊天气泡中显示Agent的思考过程。
        showLogBubblesThink: true, // 是否在日志条目中显示Agent的思考过程。
        animationLevel: 'full', // 动画效果级别 ('full', 'basic', 'none')。
        currentMode: 'chat', // 当前应用模式 (如 'chat', 'code', 'circuit')。
        uploadedFiles: [], // 当前已选择待上传的文件列表。
        isAgentTyping: false, // Agent是否正在输入（用于显示打字指示器）。
        isLoading: false, // 应用是否处于加载状态（例如，等待Agent回复）。
        isSidebarExpanded: window.innerWidth > 1024, // 左侧边栏是否展开，默认为展开如果屏幕宽度大于1024px。
        isSessionManagerCollapsed: false, // 会话管理器（在左侧边栏内）是否折叠。
        isProcessLogSidebarVisible: false, // 右侧Agent处理过程日志侧边栏是否可见。
        isProcessLogSidebarCollapsed: true, // 右侧Agent处理过程日志侧边栏是否折叠。
        maxInputChars: 8000, // 用户输入框的最大字符数限制。
        currentClientRequestId: null, // 当前发送给后端的请求ID，用于追踪响应。
        lastResponseThinking: null, // 最近一次Agent响应中包含的思考过程内容。
        autoSubmitQuickActions: true, // 点击快捷操作按钮后是否自动发送消息。
        isIdtComponentVisible: true, // 3D技术组件（如黑洞特效）是否可见。
        isDraggingComponent: false, // 3D组件是否正在被拖拽。
        componentDragStartX: 0, // 3D组件拖拽开始时的鼠标X坐标。
        componentDragStartY: 0, // 3D组件拖拽开始时的鼠标Y坐标。
        componentInitialTopPx: 0, // 3D组件拖拽开始时的初始顶部位置 (px)。
        componentInitialLeftPx: 0, // 3D组件拖拽开始时的初始左侧位置 (px)。
        threeJsScene: null, // Three.js 场景对象。
        threeJsRenderer: null, // Three.js 渲染器对象。
        threeJsCamera: null, // Three.js 相机对象。
        threeJsAnimationId: null, // Three.js 动画循环的ID (用于取消动画)。
        threeJsInitialized: false, // Three.js 特效是否已初始化。
        threeBlackHoleGroup: null, // Three.js 黑洞对象的组合。
        threeAccretionDiskOuter: null, // Three.js 吸积盘 (外层)。
        threeAccretionDiskMiddle: null, // Three.js 吸积盘 (中层)。
        threeAccretionDiskInner: null, // Three.js 吸积盘 (内层)。
        threeStarField: null // Three.js 星空背景。
    };

    // ======== WebSocket 相关 ========
    let websocket = null; // WebSocket 连接实例。
    const websocketUrl = `ws://${window.location.host}/ws/chat`; // WebSocket 服务器的URL。
    let wsReconnectAttempts = 0; // 当前 WebSocket 重连尝试次数。
    const MAX_WS_RECONNECT_ATTEMPTS = 3; // 最大 WebSocket 重连尝试次数。
    const WS_RECONNECT_INTERVAL = 3000; // WebSocket 重连间隔时间 (毫秒)。

    /**
     * 连接WebSocket服务器。
     * 包含重连逻辑和加载状态更新。
     * 此函数负责建立与后端WebSocket的连接，并在连接成功、失败或关闭时执行相应操作。
     */
    function connectWebSocket() {
        // 如果 WebSocket 已经连接或正在连接，则不执行任何操作
        if (websocket && (websocket.readyState === WebSocket.OPEN || websocket.readyState === WebSocket.CONNECTING)) {
            console.log("WebSocket: Connection established.", event); // 在控制台打印已连接或正在连接的信息
            return; // 退出函数
        }
        // 在控制台打印连接尝试信息
        console.log(`WebSocket: Attempting connection (Attempt ${wsReconnectAttempts + 1}) to ${websocketUrl}`);
        // 如果加载动画元素存在，并且是第一次尝试连接，并且没有显示致命错误
        if (dom.loader && wsReconnectAttempts === 0 && !dom.loader.classList.contains('loader-fatal-error')) {
            const loadingText = dom.loader.querySelector('.loading-text'); // 获取加载文本元素
            if (loadingText) loadingText.textContent = "同步光绘墨迹流 (V1.0.0 Lumina)..."; // 更新加载文本，版本号同步
        }

        websocket = new WebSocket(websocketUrl); // 创建新的 WebSocket 实例

        // WebSocket 连接成功打开时的回调函数
        websocket.onopen = (event) => {
            console.log("WebSocket: Connection established.", event); // 在控制台打印连接成功信息
            wsReconnectAttempts = 0; // 重置重连尝试次数
            showToast("光绘墨迹数据流 ACTIVE (V1.0.0 Lumina).", "success", 4000); // 显示连接成功的 Toast 通知，版本号同步
            // 发送初始化消息到 WebSocket 服务器
            sendWebSocketMessage({
                type: 'init', // 消息类型为 'init'
                session_id: state.currentSessionId // 包含当前会话 ID
            });
            // 如果加载动画元素存在且未显示致命错误，则隐藏加载动画
            if (dom.loader && !dom.loader.classList.contains('loader-fatal-error')) dom.loader.classList.add('hidden');
            // 如果主容器元素存在，则添加 'loaded' 类，表示内容已加载
            if (dom.mainContainer) dom.mainContainer.classList.add('loaded');
        };

        // WebSocket 收到消息时的回调函数
        websocket.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data); // 解析收到的 JSON 格式消息
                console.log("WS RX:", message); // 在控制台打印收到的消息
                handleWebSocketMessage(message); // 调用消息处理函数
            } catch (e) {
                console.error("WebSocket: Failed to parse message.", e, "Raw data:", event.data); // 在控制台打印解析失败的错误信息和原始数据
                showToast("收到损坏的数据包流 (JSON解析失败).", "error"); // 显示解析失败的 Toast 通知
            }
        };

        // WebSocket 发生错误时的回调函数
        websocket.onerror = (event) => {
            console.error("WebSocket: Error occurred.", event); // 在控制台打印错误信息
        };

        // WebSocket 连接关闭时的回调函数
        websocket.onclose = (event) => {
            console.log("WebSocket: Connection closed.", event); // 在控制台打印连接关闭信息
            hideTypingIndicator(); // 隐藏打字指示器
            setLoadingState(false); // 设置加载状态为 false
            websocket = null; // 将 WebSocket 实例置为 null

            // 获取关闭原因和代码
            const reason = event.reason ? `Reason: ${event.reason}` : (event.wasClean ? '连接正常关闭.' : '连接异常断开.');
            const codeMsg = `(Code: ${event.code})`;

            // 如果连接不是正常关闭且重连次数未达到上限
            if (!event.wasClean && wsReconnectAttempts < MAX_WS_RECONNECT_ATTEMPTS) {
                wsReconnectAttempts++; // 增加重连尝试次数
                showToast(`墨迹数据链接不稳定. 尝试重新校准 (${wsReconnectAttempts}/${MAX_WS_RECONNECT_ATTEMPTS})... ${codeMsg}`, "warning", WS_RECONNECT_INTERVAL + 500); // 显示重连尝试的 Toast 通知
                setTimeout(connectWebSocket, WS_RECONNECT_INTERVAL); // 延迟指定时间后尝试重连
            } else if (!event.wasClean) { // 如果连接不是正常关闭且已达到最大重连次数
                // 隐藏主容器
                if (dom.mainContainer) {
                    dom.mainContainer.style.display = 'none';
                }
                // 清空 Toast 通知容器
                if (dom.toastContainer) {
                    dom.toastContainer.innerHTML = '';
                }

                // 如果加载动画元素存在
                if (dom.loader) {
                    dom.loader.classList.add('loader-fatal-error'); // 添加致命错误类
                    dom.loader.classList.remove('hidden'); // 移除隐藏类，显示加载动画
                    dom.loader.innerHTML = ''; // 清空加载动画原有内容

                    // 创建致命错误状态下的加载核心元素
                    const fatalErrorCore = document.createElement('div');
                    fatalErrorCore.className = 'lumina-loader-core error-state'; // 设置类名
                    fatalErrorCore.innerHTML = `<div class="lumina-loader-center-pulse"></div>`; // 设置内部 HTML

                    // 创建致命错误状态下的 Logo 文本元素
                    const fatalErrorLogo = document.createElement('div');
                    fatalErrorLogo.className = 'loader-logo-text'; // 设置类名
                    fatalErrorLogo.innerHTML = `<span>CIRCUIT</span>MANUS<span class="loader-version-pro">PRO</span> - 链接故障`; // 设置内部 HTML

                    // 创建致命错误标题元素
                    const fatalErrorHeading = document.createElement('p');
                    fatalErrorHeading.className = 'loading-text'; // 设置类名
                    fatalErrorHeading.textContent = "通信链接已断开且无法恢复"; // 设置文本内容

                    // 创建致命错误详情文本元素
                    const fatalErrorDetails = document.createElement('p');
                    fatalErrorDetails.className = 'error-details-text'; // 设置类名
                    fatalErrorDetails.textContent = `与后端核心的连接已彻底中断 (${MAX_WS_RECONNECT_ATTEMPTS} 次校准尝试失败)。请检查您的网络连接或服务器状态。${codeMsg} ${reason}`; // 设置文本内容

                    // 创建刷新页面按钮
                    const refreshButton = document.createElement('button');
                    refreshButton.id = 'refresh-page-button'; // 设置 ID
                    refreshButton.className = 'lumina-button lumina-button-primary refresh-button'; // 设置类名
                    refreshButton.innerHTML = '<i class="fas fa-sync-alt"></i> 刷新页面'; // 设置内部 HTML (图标和文本)
                    refreshButton.onclick = () => window.location.reload(); // 点击时刷新页面

                    // 将创建的元素添加到加载动画容器中
                    dom.loader.appendChild(fatalErrorCore);
                    dom.loader.appendChild(fatalErrorLogo);
                    dom.loader.appendChild(fatalErrorHeading);
                    dom.loader.appendChild(fatalErrorDetails);
                    dom.loader.appendChild(refreshButton);
                }
            } else { // 如果连接是正常关闭的
                showToast(`通信链接已终止. ${codeMsg} ${reason}`, "info", 6000); // 显示连接终止的 Toast 通知
            }
        };
    }

    /**
     * 通过WebSocket发送消息到服务器。
     * @param {object} message - 要发送的消息对象。
     * 此函数负责将前端构造的消息对象序列化为JSON字符串，并通过已建立的WebSocket连接发送。
     * 如果连接未打开，则会尝试重新连接或提示用户。
     */
    function sendWebSocketMessage(message) {
        // 检查 WebSocket 是否存在并且连接状态为 OPEN
        if (websocket && websocket.readyState === WebSocket.OPEN) {
            const messageStr = JSON.stringify(message); // 将消息对象转换为 JSON 字符串
            console.log("WS TX:", message); // 在控制台记录发送的消息对象
            websocket.send(messageStr); // 通过 WebSocket 发送消息字符串
        } else {
            // 如果 WebSocket 连接未打开，则记录错误信息
            console.error("WebSocket: Connection not open. Cannot send message:", message);
            showToast("通信链接不活跃. 尝试重新建立链接...", "warning"); // 显示警告 Toast 通知
            // 检查 WebSocket 是否不存在，或连接状态为 CLOSED 或 CLOSING
            if (!websocket || websocket.readyState === WebSocket.CLOSED || websocket.readyState === WebSocket.CLOSING) {
                // 如果重连尝试次数未达到最大限制
                if (wsReconnectAttempts < MAX_WS_RECONNECT_ATTEMPTS) {
                    connectWebSocket(); // 尝试重新连接 WebSocket
                } else {
                    // 如果已达到最大重连尝试次数，显示错误 Toast 通知
                    showToast("无法发送: 达到最大重连尝试次数. 请刷新页面.", "error");
                }
            }
        }
    }

    /**
     * 处理从WebSocket接收到的消息。
     * 根据消息类型分发到不同的处理函数。
     * @param {object} message - 从服务器接收到的已解析的JSON消息。
     * 这是WebSocket消息处理的核心分发器。
     */
    function handleWebSocketMessage(message) {
        try {
            // 根据消息类型进行分发处理
            switch (message.type) {
                case 'init_success': // 初始化成功消息
                    try {
                        // 设置当前会话 ID
                        state.currentSessionId = message.session_id;
                        // 将最后会话 ID 存储到 localStorage
                        localStorage.setItem(APP_PREFIX + 'lastSessionId', state.currentSessionId);

                        // 根据 Agent 可用状态设置提示消息和类型
                        const agentStatusMessage = message.agent_available === false
                            ? 'Lumina AI核心 OFFLINE. 功能受限. (V1.0.0 Lumina)' // Agent 不可用时的消息，版本号同步
                            : 'Lumina核心 (V1.0.0 Lumina) 已同步到光绘网络!'; // Agent 可用时的消息，版本号同步
                        const agentStatusType = message.agent_available === false ? 'warning' : 'success'; // Agent 不可用时为警告，可用时为成功
                        // 显示 Toast 通知
                        showToast(agentStatusMessage, agentStatusType, message.agent_available ? 4500 : 8000);

                        // 如果当前会话 ID 在会话列表中不存在，则创建新会话
                        if (!state.sessions[state.currentSessionId]) {
                            const now = Date.now(); // 获取当前时间戳
                            // 创建新的会话对象
                            state.sessions[state.currentSessionId] = {
                                id: state.currentSessionId, // 会话 ID
                                name: `光绘墨迹项目 ${Object.keys(state.sessions).length + 1}`, // 会话名称，包含序号
                                messages: [], // 消息列表，初始为空
                                createdAt: now, // 创建时间
                                lastActivity: now, // 最后活动时间
                            };
                            saveSessions(); // 保存会话数据
                        }
                        initializeCurrentSessionUI(true); // 初始化当前会话的 UI，标记为初始加载
                    } catch (e) {
                        // 捕获处理 init_success 时的错误
                        console.error(`Error handling init_success:`, e, message);
                        showToast(`处理初始化成功消息时出错: ${e.message}`, 'error');
                    }
                    break;

                case 'init_error': // 初始化错误消息
                    try {
                        // 显示初始化失败的 Toast 通知
                        showToast(`AI核心同步失败: ${message.message}`, 'error', 10000);
                        // 如果加载动画存在且未显示致命错误，则隐藏加载动画
                        if (dom.loader && !dom.loader.classList.contains('loader-fatal-error')) dom.loader.classList.add('hidden');
                        // 如果主容器存在，则添加 'loaded' 类
                        if (dom.mainContainer) dom.mainContainer.classList.add('loaded');
                        // 如果 Agent 不可用
                        if (message.agent_available === false) {
                            // 在聊天框追加系统错误消息
                            appendMessage("CRITICAL SYSTEM ALERT: Lumina AI核心未能初始化. 子系统无响应. (V1.0.0 Lumina)", 'error-system', false, null, false, [], "System Error"); // 版本号同步
                        }
                        setLoadingState(false); // 设置加载状态为 false
                    } catch (e) {
                        // 捕获处理 init_error 时的错误
                        console.error(`Error handling init_error:`, e, message);
                        showToast(`处理初始化错误消息时出错: ${e.message}`, 'error');
                    }
                    break;

                case 'error': // 通用错误消息
                    try {
                        // 在控制台记录服务器报告的错误
                        console.error("Server-reported error:", message);
                        // 显示服务器异常的 Toast 通知
                        showToast(`服务器异常: ${message.message}`, 'error', 7000);
                        // 如果错误消息包含详细信息
                        if (message.details) {
                            // 在聊天框追加服务器错误消息
                            appendMessage(`SERVER ERROR (${message.message}): ${message.details}`, 'error-system', false, null, false, [], "Server Error");
                        }
                        setLoadingState(false); // 设置加载状态为 false
                    } catch (e) {
                        // 捕获处理服务器 'error' 消息时的错误
                        console.error(`Error handling server 'error' message:`, e, message);
                        showToast(`处理服务器错误报告时出错: ${e.message}`, 'error');
                    }
                    break;

                case 'general_status': handleGeneralStatus(message); break; // 处理通用状态消息
                case 'llm_communication_status': handleLlmCommStatus(message); break; // 处理 LLM 通信状态消息
                case 'thinking_log': handleThinkingLog(message); break; // 处理思考日志消息
                case 'plan_details': handlePlanDetails(message); break; // 处理计划详情消息
                case 'tool_status_update': handleToolStatusUpdate(message); break; // 处理工具状态更新消息
                case 'interim_response': handleInterimResponse(message); break; // 处理临时响应消息
                case 'final_response': // 处理最终响应消息
                    try {
                        handleFinalResponse(message); // 调用最终响应处理函数
                    } catch (e_final_resp) {
                        // 捕获处理 final_response 时的错误
                        console.error(`Error handling final_response:`, e_final_resp, message);
                        showToast(`处理最终响应时发生内部错误: ${e_final_resp.message}`, 'error');
                        hideTypingIndicator(); // 隐藏打字指示器
                        setLoadingState(false); // 设置加载状态为 false
                    }
                    break;

                default: // 未知消息类型
                    console.warn("收到未知数据包类型:", message.type, message); // 在控制台记录未知消息类型
                    showToast(`未知数据包类型: ${message.type}`, 'warning'); // 显示未知消息类型的 Toast 通知
            }
        } catch (e_outer_switch) {
            // 捕获 handleWebSocketMessage switch 逻辑中的严重错误
            console.error("Critical error in handleWebSocketMessage switch logic.", e_outer_switch, "Original message:", message);
            showToast("处理服务器消息时发生严重内部错误。", "error"); // 显示严重内部错误的 Toast 通知
            hideTypingIndicator(); // 隐藏打字指示器
            setLoadingState(false); // 设置加载状态为 false
        }
    }

    // ======== 辅助函数定义区 ========

    /**
     * 获取当前模式的显示名称。
     * @param {string} mode - 模式的内部标识符 (如 'chat', 'code')。
     * @returns {string} 对应模式的用户友好显示名称。
     */
    function getModeDisplayName(mode) {
        // 定义一个对象，存储模式标识符和对应的显示名称
        const names = { chat: '灵感交流', code: '代码绘卷', circuit: '电路拓印', settings: '参数调校' };
        // 返回对应模式的显示名称，如果找不到则返回 '未知领域'
        return names[mode] || '未知领域';
    }

    /**
     * 应用右侧固定日志侧边栏的布局。
     * 根据侧边栏的可见性和折叠状态，调整聊天区域的右边距和侧边栏的宽度。
     */
    function applyFixedLogSidebarLayout() {
        // 检查右侧日志侧边栏容器和聊天区域是否存在，如果不存在则直接返回
        if (!dom.processLogSidebarContainer || !dom.chatArea) return;
        // 从CSS变量获取日志侧边栏的固定宽度，并转换为数字，默认值为350
        const logSidebarFixedWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--process-log-sidebar-width').replace('px', '')) || 350;
        // 从CSS变量获取日志侧边栏折叠后的宽度，并转换为数字，默认值为55
        const logSidebarCollapsedWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--process-log-sidebar-width-collapsed').replace('px', '')) || 55;

        // 如果右侧日志侧边栏可见
        if (state.isProcessLogSidebarVisible) {
            // 如果右侧日志侧边栏已折叠
            if (state.isProcessLogSidebarCollapsed) {
                // 设置聊天区域的右边距为折叠后的侧边栏宽度加上原有的右内边距
                dom.chatArea.style.marginRight = `${logSidebarCollapsedWidth + parseInt(getComputedStyle(dom.chatArea).paddingRight || '0', 10)}px`;
                // 设置右侧日志侧边栏容器的宽度为折叠后的宽度
                dom.processLogSidebarContainer.style.width = `${logSidebarCollapsedWidth}px`;
                 // 隐藏关闭按钮，显示折叠按钮
                 dom.closeProcessLogSidebarButton.style.display = 'none';
                 dom.toggleProcessLogSidebarCollapseButton.style.display = 'flex'; // Ensure it's visible
            } else { // 如果右侧日志侧边栏未折叠
                // 设置聊天区域的右边距为固定宽度的侧边栏宽度加上原有的右内边距
                dom.chatArea.style.marginRight = `${logSidebarFixedWidth + parseInt(getComputedStyle(dom.chatArea).paddingRight || '0', 10)}px`;
                // 设置右侧日志侧边栏容器的宽度为固定宽度
                dom.processLogSidebarContainer.style.width = `${logSidebarFixedWidth}px`;
                 // 显示关闭按钮，确保折叠按钮也是可见的
                 dom.closeProcessLogSidebarButton.style.display = 'flex';
                 dom.toggleProcessLogSidebarCollapseButton.style.display = 'flex';
            }
        } else { // 如果右侧日志侧边栏不可见
            // 清除聊天区域的右边距设置，恢复默认
            dom.chatArea.style.marginRight = '';
            // 隐藏关闭按钮，确保折叠按钮可见 (虽然侧边栏不可见，但按钮仍然可能在UI中)
            dom.closeProcessLogSidebarButton.style.display = 'none';
            dom.toggleProcessLogSidebarCollapseButton.style.display = 'flex';
        }
    }

    /**
     * 更新右侧日志侧边栏的折叠/展开状态。
     * @param {boolean} collapse - 是否折叠侧边栏。
     * @param {boolean} [instant=false] - 是否立即更新，无动画。
     * 此函数会切换相关的CSS类，更新图标，并重新应用布局。
     */
    function updateProcessLogSidebarCollapseState(collapse, instant = false) {
        // 更新状态中的折叠标记
        state.isProcessLogSidebarCollapsed = collapse;
        // 如果右侧日志侧边栏容器存在
        if (dom.processLogSidebarContainer) {
            // 根据折叠状态切换 'collapsed' CSS 类
            dom.processLogSidebarContainer.classList.toggle('collapsed', state.isProcessLogSidebarCollapsed);
            // 获取折叠/展开按钮内的图标元素
            const iconElement = dom.toggleProcessLogSidebarCollapseButton.querySelector('i');
            // 如果图标元素存在，则根据折叠状态更新其类名 (切换箭头方向)
            if (iconElement) {
                iconElement.className = state.isProcessLogSidebarCollapsed ? 'fas fa-chevron-right' : 'fas fa-chevron-left';
            }
        }
        // 应用新的布局设置
        applyFixedLogSidebarLayout();
        // 将折叠状态保存到 localStorage
        localStorage.setItem(APP_PREFIX + 'isProcessLogSidebarCollapsed', state.isProcessLogSidebarCollapsed.toString());
    }

    /**
     * 隐藏右侧日志侧边栏。
     * 更新状态，移除相关CSS类，并重新应用布局。
     */
    function hideProcessLogSidebar() {
        // 如果右侧日志侧边栏容器不存在，则直接返回
        if (!dom.processLogSidebarContainer) return;
        // 更新状态，标记侧边栏为不可见
        state.isProcessLogSidebarVisible = false;
        // 移除 'visible' CSS 类，使其隐藏
        dom.processLogSidebarContainer.classList.remove('visible');
        // 如果应用主体内容容器存在
        if (dom.appBodyContainer) {
            // 移除表示日志侧边栏打开和折叠状态的 CSS 类
            dom.appBodyContainer.classList.remove('with-process-log-open', 'log-sidebar-collapsed');
        }
        // 应用布局更改
        applyFixedLogSidebarLayout();
        // 将可见性状态保存到 localStorage
        localStorage.setItem(APP_PREFIX + 'isProcessLogSidebarVisible', state.isProcessLogSidebarVisible.toString());
        // 在控制台记录日志侧边栏已隐藏
        console.log("右侧日志侧栏已隐藏。");
    }

    /**
     * 显示右侧日志侧边栏。
     * @param {boolean} [ensureExpanded=false] - 如果为true且侧边栏当前是折叠的，则强制展开它。
     * 更新状态，添加相关CSS类，并根据需要调整布局。
     */
    function showProcessLogSidebar(ensureExpanded = false) {
        // 如果右侧日志侧边栏容器不存在，则直接返回
        if (!dom.processLogSidebarContainer) return;
        // 更新状态，标记侧边栏为可见
        state.isProcessLogSidebarVisible = true;
        // 添加 'visible' CSS 类，使其显示
        dom.processLogSidebarContainer.classList.add('visible');

        // 如果应用主体内容容器存在
        if (dom.appBodyContainer) {
            // 添加表示日志侧边栏打开的 CSS 类
            dom.appBodyContainer.classList.add('with-process-log-open');
            // 根据侧边栏的折叠状态，切换 'log-sidebar-collapsed' CSS 类
            dom.appBodyContainer.classList.toggle('log-sidebar-collapsed', state.isProcessLogSidebarCollapsed);
        }

        // 如果需要确保展开，并且当前侧边栏是折叠的
        if (ensureExpanded && state.isProcessLogSidebarCollapsed) {
            toggleProcessLogSidebarCollapse(false); // 调用切换折叠状态的函数，传入 false 表示展开
        } else {
            // 否则，仅应用布局更改
            applyFixedLogSidebarLayout();
        }
        // 将可见性状态保存到 localStorage
        localStorage.setItem(APP_PREFIX + 'isProcessLogSidebarVisible', state.isProcessLogSidebarVisible.toString());
        // 在控制台记录日志侧边栏的显示状态
        console.log(`右侧日志侧栏已显示 (强制展开: ${ensureExpanded}, 当前折叠状态: ${state.isProcessLogSidebarCollapsed}).`);
    }

    /**
     * 切换右侧日志侧边栏的折叠/展开状态。
     * @param {boolean} [instant=false] - 是否立即切换，无动画。
     */
    function toggleProcessLogSidebarCollapse(instant = false) {
        // 如果右侧日志侧边栏容器或切换按钮不存在，则直接返回
        if (!dom.processLogSidebarContainer || !dom.toggleProcessLogSidebarCollapseButton) return;
        // 调用更新折叠状态的函数，传入当前折叠状态的相反值
        updateProcessLogSidebarCollapseState(!state.isProcessLogSidebarCollapsed, instant);
        // 在控制台记录新的折叠状态
        console.log(`右侧日志侧栏折叠状态切换为: ${state.isProcessLogSidebarCollapsed ? '已折叠' : '已展开'}`);
    }

    /**
     * 设置应用的加载状态。
     * @param {boolean} isLoading - 是否处于加载中。
     * 此函数会禁用/启用发送按钮和输入框，并切换发送按钮的图标。
     */
    function setLoadingState(isLoading) {
        // 更新应用状态中的 isLoading 标志
        state.isLoading = isLoading;
        // 如果发送按钮存在，则根据 isLoading 状态设置其 disabled 属性
        if (dom.sendButton) dom.sendButton.disabled = isLoading;
        // 如果用户输入框存在，则根据 isLoading 状态设置其 disabled 属性
        if (dom.userInput) dom.userInput.disabled = isLoading;
        // 如果发送图标存在，则根据 isLoading 状态设置其显示/隐藏
        if (dom.sendIcon) dom.sendIcon.style.display = isLoading ? 'none' : 'inline-block';
        // 如果发送加载中图标存在，则根据 isLoading 状态设置其显示/隐藏
        if (dom.sendLoadingIcon) dom.sendLoadingIcon.style.display = isLoading ? 'inline-block' : 'none';
        // 如果发送按钮存在，则根据 isLoading 状态更新其 title 属性 (鼠标悬停提示)
        if (dom.sendButton) dom.sendButton.title = isLoading ? "墨迹传输中..." : "发送指令";
        // 如果输入区域容器存在
        if (dom.inputArea) {
            // 根据 isLoading 状态切换 'processing' CSS 类
            dom.inputArea.classList.toggle('processing', isLoading);
        }
        // 如果发送按钮存在
        if (dom.sendButton) {
            // 根据 isLoading 状态切换 'processing-active' CSS 类
            dom.sendButton.classList.toggle('processing-active', isLoading);
        }
    }

    /**
     * 将右侧日志侧边栏滚动到底部。
     * @param {boolean} [instant=false] - 是否立即滚动，无平滑效果。
     */
    function scrollToProcessLogBottom(instant = false) {
        // 检查日志侧栏内容元素是否存在
        if (!dom.processLogSidebarContent) {
            // 如果不存在，则在控制台输出错误信息并返回
            console.error("日志侧栏内容元素 (processLogSidebarContent) 未找到，无法滚动。");
            return;
        }
        // 获取日志侧栏内容容器元素
        const container = dom.processLogSidebarContent;
        // 根据 instant 参数和动画级别设置滚动行为 ('auto' 或 'smooth')
        const behavior = instant || state.animationLevel === 'none' ? 'auto' : 'smooth';
        // 执行滚动操作，将容器滚动到其最底部
        container.scrollTo({ top: container.scrollHeight, behavior: behavior });
    }

    /**
     * 解析日志项的CSS类字符串，提取类型、阶段和状态。
     * @param {string} itemClassesStr - 包含多个CSS类的字符串。
     * @returns {object} 解析后的对象，包含 type, stage, status 属性。
     */
    function parseItemClasses(itemClassesStr) {
        // 如果类字符串存在，则按空格分割成数组；否则使用空数组
        const classes = itemClassesStr ? itemClassesStr.split(' ') : [];
        // 初始化解析结果对象
        const parsed = { type: null, stage: null, status: null };
        // 遍历所有类名
        classes.forEach(cls => {
            // 如果类名以 'type-' 开头，则提取类型
            if (cls.startsWith('type-')) parsed.type = cls.substring(5);
            // 如果类名以 'stage-' 开头，则提取阶段
            else if (cls.startsWith('stage-')) parsed.stage = cls.substring(6);
            // 如果类名以 'status-' 开头，则提取状态
            else if (cls.startsWith('status-')) parsed.status = cls.substring(7);
            // 如果类名以 'phase-' 开头，也作为阶段处理 (兼容旧命名)
            else if (cls.startsWith('phase-')) parsed.stage = cls.substring(6);
        });
        // 返回解析后的对象
        return parsed;
    }

    /**
     * 总结工具调用的参数对象，用于日志显示。
     * @param {object} argsObj - 工具参数对象。
     * @returns {string} 参数的简短字符串表示。
     */
    function summarizeArguments(argsObj) {
        // 检查参数对象是否有效，如果无效或为空，则返回 "(无参数)"
        if (!argsObj || typeof argsObj !== 'object' || Object.keys(argsObj).length === 0) {
            return "(无参数)";
        }
        try {
            // 使用 JSON.stringify 将参数对象转换为字符串
            // replacer 函数用于处理长字符串，截断超过40个字符的字符串
            // 最后限制总长度不超过200个字符
            return JSON.stringify(argsObj, (key, value) => {
                if (typeof value === 'string' && value.length > 40) {
                    return value.substring(0, 37) + "..."; // 截断长字符串并添加省略号
                }
                return value; // 其他值保持不变
            }).substring(0, 200); // 限制总长度
        } catch (e) {
            // 如果转换过程中发生错误，则在控制台打印警告并返回 "(参数总结出错)"
            console.warn("总结参数时发生错误:", e);
            return "(参数总结出错)";
        }
    }

    /**
     * 格式化日志项的详细信息对象为HTML字符串。
     * @param {object} details - 包含详细信息的对象。
     * @param {string|null} type - 日志项类型。
     * @param {string|null} stage - 日志项阶段。
     * @param {string|null} status - 日志项状态。
     * @returns {string|null} 格式化后的HTML字符串，如果无有效细节则返回null。
     */
    function formatLogDetails(details, type, stage, status) {
        // 检查 details 对象是否有效，如果无效或为空，则返回 null
        if (!details || typeof details !== 'object' || Object.keys(details).length === 0) {
            return null;
        }
        let html = ''; // 初始化 HTML 字符串
        // 定义一个递归函数来格式化对象
        const formatRecursive = (obj, currentType, currentStage, currentStatus, indentLevel = 0) => {
            let partHtml = ''; // 初始化部分 HTML 字符串
            // 遍历对象的每个属性
            for (const key in obj) {
                // 确保属性是对象自身的属性，而不是原型链上的
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    const value = obj[key]; // 获取属性值
                    // 格式化属性键名：将驼峰命名转换为空格分隔，替换下划线，并首字母大写
                    const displayKey = key
                        .replace(/([A-Z])/g, " $1") // 在大写字母前添加空格
                        .replace(/_/g, ' ')         // 将下划线替换为空格
                        .trim()                      // 去除首尾空格
                        .replace(/\b\w/g, char => char.toUpperCase()); // 将每个单词的首字母大写
                    // 根据缩进级别设置左内边距样式
                    const paddingLeftStyle = `padding-left: ${indentLevel * 10}px;`;

                    // 跳过特定类型的特定键，这些键可能冗余或已在其他地方处理
                    // 确保只跳过 tool_call_id 在特定的消息类型中
                    if ((type === 'plan_details' || type === 'tool_status_update') && key === 'tool_call_id') {
                         continue;
                    }

                    // 特殊处理 'uiHints' 键
                    if (key === 'uiHints' && typeof value === 'object' && value !== null) {
                        // 获取 displayNameForTool 和 estimatedDurationCategory，并进行HTML转义
                        const dn = String(value.displayNameForTool || 'N/A').replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        const ed = String(value.estimatedDurationCategory || 'N/A').replace(/</g, "&lt;").replace(/>/g, "&gt;");
                         // 检查 showProgressGranularly 是否存在并显示
                        const spg = value.showProgressGranularly !== undefined ? `, 细粒度进度: ${value.showProgressGranularly ? '是' : '否'}` : '';
                        // 构建 uiHints 的 HTML
                        partHtml += `<div class="log-detail-item" style="${paddingLeftStyle}"><strong class="log-detail-key">UI投影:</strong> <span class="log-detail-value">显示: ${dn}, 时长: ${ed}${spg}</span></div>`;
                    } else if (key === 'result_data_preview' && typeof value === 'string') { // 特殊处理 'result_data_preview' 键
                        // 获取预览内容并进行HTML转义
                        let previewContent = String(value).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        // 构建结果预览的 HTML，使用 <pre> and <code> 标签
                        partHtml += `<div class="log-detail-item" style="${paddingLeftStyle}"><strong class="log-detail-key">结果预览:</strong> <pre class="log-detail-raw-json"><code>${previewContent}</code></pre></div>`; // Use log-detail-raw-json for pre formatting
                    } else if ((type === 'plan_details' || type === 'tool_status_update') && (key === 'arguments' || key === 'toolArguments') && typeof value === 'object' && value !== null) { // 特殊处理参数对象
                        let argItems = []; // 初始化参数项数组
                        // 遍历参数对象的每个参数
                        for (const argKey in value) {
                            // 格式化参数键名
                            const formattedArgKey = argKey.replace(/_/g, ' ').replace(/\b\w/g, char => char.toUpperCase());
                            // 将参数键值对添加到数组，并对值进行HTML转义
                             const argValue = value[argKey];
                             let formattedArgValue;
                             if (typeof argValue === 'object' && argValue !== null) {
                                 try { formattedArgValue = JSON.stringify(argValue).replace(/</g, "&lt;").replace(/>/g, "&gt;"); }
                                 catch (e) { formattedArgValue = String(argValue).replace(/</g, "&lt;").replace(/>/g, "&gt;") + " (JSON error)"; }
                             } else {
                                 formattedArgValue = String(argValue).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                             }
                            argItems.push(`<em class="log-arg-key">${formattedArgKey}</em>: ${formattedArgValue}`);
                        }
                        // 构建参数的 HTML
                        partHtml += `<div class="log-detail-item" style="${paddingLeftStyle}"><strong class="log-detail-key">${displayKey}:</strong> <span class="log-detail-value">${argItems.join('; ')}</span></div>`;
                    } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) { // If the value is an object and not an array
                        // Build HTML for the object header
                        partHtml += `<div class="log-detail-item log-detail-object-header" style="${paddingLeftStyle}"><strong class="log-detail-key">${displayKey}:</strong></div>`;
                        // Recursively call formatRecursive to handle nested objects
                        partHtml += formatRecursive(value, currentType, currentStage, currentStatus, indentLevel + 1);
                    } else if (Array.isArray(value)) { // If the value is an array
                        // Format each element in the array
                        const arrayItems = value.map(item => {
                            if (typeof item === 'object' && item !== null) return JSON.stringify(item).replace(/</g, "&lt;").replace(/>/g, "&gt;"); // Object to JSON string and escape
                            return String(item).replace(/</g, "&lt;").replace(/>/g, "&gt;"); // Other types to string and escape
                        });
                        // Build HTML for the array
                        partHtml += `<div class="log-detail-item" style="${paddingLeftStyle}"><strong class="log-detail-key">${displayKey}:</strong> <span class="log-detail-value log-detail-array">[${arrayItems.join(', ')}]</span></div>`;
                    } else { // If the value is another basic type
                        // Escape HTML special characters in the value
                        const sanitizedValue = String(value).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        // Build HTML for the basic type key-value pair
                        partHtml += `<div class="log-detail-item" style="${paddingLeftStyle}"><strong class="log-detail-key">${displayKey}:</strong> <span class="log-detail-value">${sanitizedValue}</span></div>`;
                    }
                }
            }
            return partHtml; // Return the HTML for the current level
        };
        // Call the recursive function to start formatting
        html = formatRecursive(details, type, stage, status, 0);
        // If the HTML string is not empty, return it, otherwise return null
        return html || null;
    }

    /**
     * 向右侧日志侧边栏添加一个新的日志项。
     * 此函数处理不包含独立思考过程的日志条目。图标和主消息文本将并排显示。
     * @param {string} messageText - 日志消息文本 (将作为主文本)。
     * @param {string} iconClass - 用于日志项的FontAwesome图标类。
     * @param {string} [itemClasses=''] - 附加到日志项的CSS类字符串。
     * @param {object|null} [details=null] - 包含详细信息的对象，将格式化并显示在主文本下方。
     * @returns {HTMLElement|null} 创建的日志项DOM元素，如果失败则返回null。
     */
    function appendLogItem(messageText, iconClass, itemClasses = '', details = null) {
        // 检查日志侧边栏内容元素是否存在
        if (!dom.processLogSidebarContent) {
            console.error("日志侧栏内容元素 (processLogSidebarContent) 未找到。"); // 输出错误信息
            return null; // 返回 null
        }
        // 创建日志项的 div 元素
        const logItemDiv = document.createElement('div');
        // 设置基础类名和入场动画类名
        logItemDiv.className = 'log-item animate__animated animate__fadeInUp';
        // 设置动画持续时间
        logItemDiv.style.setProperty('--animate-duration', '0.3s');
        // 如果有附加的 CSS 类，则添加它们
        if (itemClasses) {
            logItemDiv.classList.add(...itemClasses.split(' ').filter(cls => cls)); // 分割字符串并过滤空类名后添加
        }

        // 创建图标元素 (作为日志项的第一个子元素 - CSS将使其与第二个子元素并排)
        const iconEl = document.createElement('i');
        iconEl.className = iconClass; // 设置图标的 FontAwesome 类
        logItemDiv.appendChild(iconEl);

        // 创建主要内容区域的包装器 (垂直 flex 容器)，包含主文本和详细信息 (作为日志项的第二个子元素)
        const contentAreaWrapper = document.createElement('div');
        contentAreaWrapper.classList.add('log-item-content-area'); // 添加 CSS 类

        // 创建消息文本元素 (作为内容区域包装器的第一个子元素)
        const messageEl = document.createElement('span');
        messageEl.className = 'log-item-message';
        messageEl.textContent = messageText; // 设置消息文本内容
        contentAreaWrapper.appendChild(messageEl); // 将消息文本添加到内容区域包装器

        // 如果存在详细信息且不为空对象
        if (details && Object.keys(details).length > 0) {
            // 创建详细信息区域的 div 元素 (作为内容区域包装器的第二个子元素)
            const detailsEl = document.createElement('div');
            detailsEl.className = 'log-item-details'; // 使用通用详细信息类
            // 解析日志项的类名以获取类型、阶段和状态，用于格式化详细信息
            const { type: logType, stage: logStage, status: logStatus } = parseItemClasses(logItemDiv.className);
            // 格式化详细信息对象为 HTML 字符串
            const formattedDetailsHtml = formatLogDetails(details, logType, logStage, logStatus);

            // 如果格式化后的 HTML 不为空
            if (formattedDetailsHtml) {
                detailsEl.innerHTML = formattedDetailsHtml; // 设置详细信息区域的 HTML 内容
            } else { // 如果格式化失败或无内容
                 // 添加一个表示“无详细信息”的默认消息，或者尝试显示原始 details 对象
                 detailsEl.innerHTML = `<span class="log-detail-item"><strong class="log-detail-key">详细信息:</strong> <span class="log-detail-value">(无或格式化失败)</span></span>`;
                try {
                    // Fallback: Attempt to represent the details object as JSON or string if formatting failed
                    let rawDetailsStr = typeof details === 'object' ? JSON.stringify(details, null, 2) : String(details);
                    detailsEl.innerHTML += `<pre class="log-detail-raw-json error"><code>${rawDetailsStr.replace(/</g, "&lt;").replace(/>/g, "&gt;")}<br>(原始数据)</code></pre>`;
                } catch (e_raw) {
                     // If even the fallback fails
                     detailsEl.innerHTML += `<span class="log-detail-item error"><strong class="log-detail-key">原始数据错误:</strong> <span class="log-detail-value">${e_raw.message}</span></span>`;
                }
            }
            contentAreaWrapper.appendChild(detailsEl); // 将详细信息区域添加到内容区域包装器
        }

        // 将内容区域包装器添加到日志项 div (在图标之后)
        logItemDiv.appendChild(contentAreaWrapper);


        // 将日志项 div 添加到日志侧边栏内容区域
        dom.processLogSidebarContent.appendChild(logItemDiv);
        // 滚动日志侧边栏到底部
        scrollToProcessLogBottom();
        // 返回创建的日志项 DOM 元素
        return logItemDiv;
    }

    /**
     * 向右侧日志侧边栏添加一个包含思考过程的日志项。
     * 此函数处理包含独立思考过程的日志条目。图标和主消息文本将并排显示，思考过程在下方独立区域。
     * @param {string} headerText - 日志项的头部消息文本 (将作为主文本)。
     * @param {string} headerIconClass - 用于头部的FontAwesome图标类。
     * @param {string} itemClasses - 附加到日志项的CSS类字符串。
     * @param {string} thinkContent - 思考过程的文本内容 (将显示在主文本下方)。
     * @param {string} [thinkBubbleLabel="详细思考投影"] - 思考气泡的标签文本。
     * @returns {HTMLElement|null} 创建的日志项DOM元素，如果失败则返回null。
     */
    function appendLogItemWithThink(headerText, headerIconClass, itemClasses, thinkContent, thinkBubbleLabel = "详细思考投影") {
        // 检查日志侧边栏内容元素是否存在
        if (!dom.processLogSidebarContent) {
            console.error("日志侧栏内容元素 (processLogSidebarContent) 未找到。"); // 输出错误信息
            return null; // 返回 null
        }
        // 创建日志项的 div 元素
        const logItemDiv = document.createElement('div');
        // 设置基础类名和入场动画类名
        logItemDiv.className = 'log-item animate__animated animate__fadeInUp';
        // 设置动画持续时间
        logItemDiv.style.setProperty('--animate-duration', '0.3s');
        // 如果有附加的 CSS 类，则添加它们
        if (itemClasses) logItemDiv.classList.add(...itemClasses.split(' '));

        // 创建图标元素 (作为日志项的第一个子元素 - CSS将使其与第二个子元素并排)
        const iconEl = document.createElement('i');
        iconEl.className = headerIconClass; // 设置图标的 FontAwesome 类
        logItemDiv.appendChild(iconEl);

        // 创建主要内容区域的包装器 (垂直 flex 容器)，包含主文本和思考内容 (作为日志项的第二个子元素)
        const contentAreaWrapper = document.createElement('div');
        contentAreaWrapper.classList.add('log-item-content-area'); // 添加 CSS 类

        // 创建主消息文本元素 (作为内容区域包装器的第一个子元素)
        const messageEl = document.createElement('span');
        messageEl.className = 'log-item-message';
        messageEl.textContent = headerText; // 设置主消息文本内容 (使用 headerText 作为主文本)
        contentAreaWrapper.appendChild(messageEl);


        // 如果存在思考内容
        if (thinkContent) {
            // 创建思考内容区域的 div 元素 (作为内容区域包装器的第二个子元素 - 将显示在主文本下方)
            const thinkDiv = document.createElement('div');
            thinkDiv.classList.add('log-think-content'); // 添加特定类名

            // 格式化思考内容：替换换行符为 <br>
            let formattedThink = String(thinkContent).replace(/\n/g, '<br>');
            // 定义用于匹配 JSON 代码块的正则表达式
            const jsonBlockRegex = /```json\s*([\s\S]*?)\s*```/gi; // Adjusted regex to handle potential surrounding whitespace
            // 替换思考内容中的 JSON 代码块为格式化后的 <pre><code> 块
            formattedThink = formattedThink.replace(jsonBlockRegex, (match, jsonContentStr) => {
                const trimmedJson = jsonContentStr.trim(); // Remove leading/trailing whitespace from JSON content
                try {
                    const parsedJson = JSON.parse(trimmedJson); // Parse the JSON
                    // Format the parsed JSON object into a string with indentation (2 spaces), and escape HTML special characters
                    const escapedJsonString = JSON.stringify(parsedJson, null, 2)
                        .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    // Return the formatted HTML using <pre> and <code> tags with the embedded-json class
                    return `<pre class="log-detail-raw-json"><code>${escapedJsonString}</code></pre>`;
                } catch (jsonErr) {
                    // If JSON parsing fails, log a warning to the console
                    console.warn("Log item with think: JSON parsing for pretty print failed within thought:", jsonErr);
                    // Escape HTML special characters from the original JSON content
                    const escapedOriginalJson = trimmedJson
                        .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    // Return HTML containing the original content and an error message, styled as an error embedded JSON block
                    return `<pre class="log-detail-raw-json error"><code>${escapedOriginalJson}<br>(无效JSON投影)</code></pre>`;
                }
            });
            // Set the HTML content of the thinking content area, including the label and formatted thinking text
            thinkDiv.innerHTML = `<strong><i class="fas fa-brain"></i> ${thinkBubbleLabel}:</strong><div class="think-bubble">${formattedThink}</div>`;
            // Append the thinking content area to the content area wrapper
            contentAreaWrapper.appendChild(thinkDiv);
        }

        // Append the content area wrapper to the log item div (after the icon)
        logItemDiv.appendChild(contentAreaWrapper);

        // Append the log item div to the process log sidebar content area
        dom.processLogSidebarContent.appendChild(logItemDiv);
        // Scroll the process log sidebar to the bottom
        scrollToProcessLogBottom();
        // Return the created log item DOM element
        return logItemDiv;
    }


    /**
     * 处理来自服务器的 'general_status' 类型消息。
     * @param {object} msg - 包含状态信息的服务器消息对象。
     * 此函数根据状态信息选择合适的图标和类，并调用 appendLogItem 添加到日志。
     */
    function handleGeneralStatus(msg) {
        // 从消息对象中解构出 stage, status, message (重命名为 msgText), 和 details
        const { stage, status, message: msgText, details } = msg;
        // 初始化日志图标类为信息图标和通用日志信息类
        let logIconClass = 'fas fa-info-circle log-info';
        // 构建日志项的 CSS 类字符串，包含类型、阶段和状态
        let logItemClasses = `type-general_status stage-${stage} status-${status}`;

        // 根据不同的状态 (status) 更新日志图标类
        if (status === 'started' || status === 'llm_retry_needed' || status === 'llm_error_retrying') logIconClass = 'fas fa-sync-alt fa-spin log-processing'; // 开始或重试中：旋转的同步图标
        else if (status === 'completed' || status === 'received' || status === 'completed_and_validated') logIconClass = 'fas fa-check-circle log-success'; // 完成或已接收：成功的勾选图标
        else if (status === 'error' || status === 'failed' || status === 'failed_after_llm_retries' || status === 'tool_failure_detected' || status === 'fatal_error_handler' || status === 'fatal_error_capture') { // 错误或失败：错误的感叹号三角图标
            logIconClass = 'fas fa-exclamation-triangle log-error';
        }
        else if (status === 'ignored') logIconClass = 'fas fa-eye-slash log-muted'; // 已忽略：静音的眼睛斜杠图标

        // 调用 appendLogItem 函数将日志项添加到日志侧边栏
        appendLogItem(msgText, logIconClass, logItemClasses, details);
        // 如果日志侧边栏当前不可见，则显示它（不强制展开）
        if (!state.isProcessLogSidebarVisible) showProcessLogSidebar(false);
    }

    /**
     * 处理来自服务器的 'llm_communication_status' 类型消息。
     * @param {object} msg - 包含LLM通信状态的服务器消息对象。
     * 此函数根据LLM通信状态选择图标和类，并添加到日志。
     */
    function handleLlmCommStatus(msg) {
        // 从消息对象中解构出 llm_phase, status, message (重命名为 msgText), 和 details
        const { llm_phase, status, message: msgText, details } = msg;
        // 初始化日志图标类为大脑图标和处理中样式
        let logIconClass = 'fas fa-brain log-processing';
        // 构建日志项的 CSS 类字符串，包含类型、LLM阶段和状态
        let logItemClasses = `type-llm_communication_status phase-${llm_phase} status-${status}`;

        // 根据不同的状态 (status) 更新日志图标类
        if (status === 'started') logIconClass = 'fas fa-brain fa-beat-fade log-processing'; // 开始：跳动的大脑图标
        else if (status === 'completed') logIconClass = 'fas fa-check log-success'; // 完成：成功的勾选图标
        else if (status === 'error') logIconClass = 'fas fa-bolt log-error'; // 错误：闪电图标 (表示错误)

        // 调用 appendLogItem 函数将日志项添加到日志侧边栏
        appendLogItem(msgText, logIconClass, logItemClasses, details);
        // 如果日志侧边栏当前不可见，则显示它（不强制展开）
        if (!state.isProcessLogSidebarVisible) showProcessLogSidebar(false);
    }

    /**
     * 处理来自服务器的 'thinking_log' 类型消息。
     * @param {object} msg - 包含思考日志内容的服务器消息对象。
     * 如果设置允许，则以带思考气泡的方式添加到日志，否则添加简略日志。
     */
    function handleThinkingLog(msg) {
        // 从消息对象中解构出 stage, content, 和 llm_interaction_id
        const { stage, content, llm_interaction_id } = msg;
        // 如果消息中包含 content，则更新状态中的 lastResponseThinking
        if (content) {
            state.lastResponseThinking = content;
        }

        // 检查用户设置是否允许在日志中显示思考气泡
        if (state.showLogBubblesThink) {
            // 格式化思考标签文本，将下划线替换为空格并转为大写
            const thinkLabel = `AI思维墨迹 (${stage.replace(/_/g, ' ').toUpperCase()})`;
            // 调用 appendLogItemWithThink 函数添加带思考气泡的日志项
            appendLogItemWithThink(thinkLabel, 'fas fa-lightbulb log-think', `type-thinking_log stage-${stage} llm-id-${llm_interaction_id}`, content, "详细思考投影:");
        } else {
            // 如果不允许显示思考气泡，则添加简略的日志项
            // 日志内容为 "思维墨迹收到 (阶段, LLM_ID: ID) - 内容前80字符..."
            appendLogItem(`思维墨迹收到 (${stage}, LLM_ID: ${llm_interaction_id}) - ${content.substring(0, 80)}...`, 'fas fa-comment-dots log-muted', `type-thinking_log stage-${stage} muted`);
        }
        // 如果日志侧边栏当前不可见，则显示它（不强制展开）
        if (!state.isProcessLogSidebarVisible) showProcessLogSidebar(false);
    }

    /**
     * 处理来自服务器的 'plan_details' 类型消息，展示Agent的行动计划。
     * @param {object} msg - 包含行动计划详情的服务器消息对象。
     * 此函数会遍历计划中的每个工具调用，并将其添加到日志中。
     */
    function handlePlanDetails(msg) {
        // 从消息对象中解构出 plan (行动计划数组)
        const { plan } = msg;
        // 清空应用状态中待处理的工具调用记录
        state.pendingToolCalls = {};
        // 遍历计划中的每一个工具调用 (toolCall)
        if (Array.isArray(plan)) { // Ensure plan is an array before iterating
             plan.forEach(toolCall => {
                 // 从 toolCall 对象中解构出相关属性
                 const { toolCallId, toolName, toolArguments, uiHints = {}, order } = toolCall;
                 // Check if essential properties exist
                 if (!toolCallId || !toolName) {
                      console.warn("Plan details missing essential fields (toolCallId or toolName), skipping:", toolCall);
                      appendLogItem(
                          `收到无效计划项 (缺少ID或名称).`,
                          'fas fa-exclamation-circle log-warning',
                          'type-plan_details status-invalid',
                          toolCall
                      );
                      return; // Skip this invalid item
                 }
                 // 将当前工具调用信息记录到待处理列表中
                 state.pendingToolCalls[toolCallId] = {
                     name: toolName, // 工具名称
                     args_summary: summarizeArguments(toolArguments), // 参数的简短总结
                     ui_hints: uiHints, // UI 提示信息
                     order: order // 执行顺序
                 };
                 // Get the display name for the tool, prioritizing displayNameForTool from uiHints, otherwise generating from toolName
                 const displayName = uiHints.displayNameForTool || toolName.replace(/_tool$/, "").replace(/_/g, " ").replace(/\b\w/g, l => l.toUpperCase());
                 // Construct the log message text
                 const logMessageText = `执行节点 #${order}: ${displayName} (ID: ${toolCallId}) - 状态: QUEUED`;
                 // Call the appendLogItem function to add the planned tool call to the log sidebar
                 // Details include arguments and UI hints for display
                 appendLogItem(
                     logMessageText, // Log message text (主文本)
                     'fas fa-tasks log-info', // Log icon (任务列表 icon)
                     `type-plan_details tool-${toolName} status-pending`, // Log item CSS classes
                     { arguments: toolArguments, tool_call_id: toolCallId, ui_hints: uiHints } // Detailed information for display below the main text
                 );
             });
        } else {
            console.warn("Received plan_details message with non-array plan property:", plan);
             appendLogItem(
                `收到无效计划详情 (Plan不是数组).`,
                'fas fa-exclamation-circle log-error',
                'type-plan_details status-invalid',
                { raw_plan_data: plan } // Include raw data in details
            );
        }
        // Show and ensure the log sidebar is expanded so the user can see the plan details
        showProcessLogSidebar(true);
    }

    /**
     * 处理来自服务器的 'tool_status_update' 类型消息，更新工具执行状态。
     * @param {object} msg - 包含工具执行状态更新的服务器消息对象。
     * 此函数会查找现有的日志项并更新它，或者添加一个新的日志项来反映工具状态。
     */
    function handleToolStatusUpdate(msg) {
        // 从消息对象中解构出工具调用ID、工具名称、状态、消息文本和详细信息
        const { tool_call_id, tool_name, status, message: msgText, details } = msg;
         // Validate essential fields
        if (!tool_call_id || !tool_name || status === undefined || msgText === undefined) {
             console.warn("Received invalid tool_status_update message (missing essential fields):", msg);
              appendLogItem(
                 `收到无效工具状态更新 (缺少ID,名称,状态或消息).`,
                 'fas fa-exclamation-circle log-error',
                 'type-tool_status_update status-invalid',
                 msg // Include the full invalid message in details
             );
            return;
        }
        // Initialize log icon class and generic info class
        let logIconClass = 'fas fa-cog log-info';
        // Set specific status CSS class
        let itemStatusClass = `status-${status}`;

        // Update log icon class based on different tool execution statuses
        if (status === 'running') logIconClass = 'fas fa-cogs fa-spin log-processing'; // Running: Spinning cogs icon
        else if (status === 'retrying') logIconClass = 'fas fa-history fa-spin log-processing'; // Retrying: Spinning history icon
        else if (status === 'succeeded') logIconClass = 'fas fa-check-double log-success'; // Succeeded: Double checkmark icon
        else if (status === 'failed') logIconClass = 'fas fa-times-circle log-error'; // Failed: Error cross icon
        else if (status === 'aborted_due_to_previous_failure') { // Aborted due to previous failure
            logIconClass = 'fas fa-ban log-warning'; // Aborted: Ban icon (warning)
            itemStatusClass = 'status-aborted'; // Explicitly set status class to 'aborted'
        }

        // Get tool information from the pending tool calls list
        const pendingToolInfo = state.pendingToolCalls[tool_call_id];
        // Get the display name for the tool, prioritizing displayNameForTool from pending info's uiHints, otherwise generating from tool_name
        const displayName = pendingToolInfo?.ui_hints?.displayNameForTool || tool_name.replace(/_tool$/, "").replace(/_/g, " ").replace(/\b\w/g, l => l.toUpperCase());
        // Construct the full log message text (this will be the main text next to the icon)
        let fullLogMessage = `工具模块: ${displayName} (ID: ${tool_call_id}) - ${status.replace(/_/g, ' ').toUpperCase()}: ${msgText}`;

        // Attempt to find an existing log item for this tool call in the sidebar content area
        // Added data-tool-call-id attribute in appendLogItem to make lookup reliable
        let existingLogItem = dom.processLogSidebarContent.querySelector(`.log-item[data-tool-call-id="${tool_call_id}"]`);

        // If found an existing log item for this tool call
        if (existingLogItem) {
            // Update the existing log item's classes, icon, message, and details
            existingLogItem.className = `log-item animate__animated type-tool_status_update tool-${tool_name} ${itemStatusClass}`; // Update classes
            existingLogItem.style.setProperty('--animate-duration', '0.5s'); // Keep animation duration

            const iconEl = existingLogItem.querySelector('i:first-child');
            if (iconEl) iconEl.className = logIconClass; // Update icon class

            const messageEl = existingLogItem.querySelector('.log-item-message');
            if (messageEl) messageEl.textContent = fullLogMessage; // Update message text

            // Find or create the details element within the content area wrapper
            const contentAreaWrapper = existingLogItem.querySelector('.log-item-content-area');
            if (contentAreaWrapper) {
                 let detailsEl = contentAreaWrapper.querySelector('.log-item-details') || contentAreaWrapper.querySelector('.log-think-content'); // Could be either class for details

                 if (details && Object.keys(details).length > 0) { // If there are new details
                     if (!detailsEl) { // If original item didn't have details, create a new one
                          detailsEl = document.createElement('div');
                          detailsEl.className = 'log-item-details'; // Assume it's a standard details block
                          contentAreaWrapper.appendChild(detailsEl);
                     }
                      // Ensure the correct class is applied for standard details
                     detailsEl.classList.remove('log-think-content'); // Remove if it was a think block previously
                     detailsEl.classList.add('log-item-details'); // Add standard details class

                     const { type, stage, status: parsedStatus } = parseItemClasses(existingLogItem.className);
                     const formattedDetailsHtml = formatLogDetails(details, type, stage, parsedStatus);
                     detailsEl.innerHTML = formattedDetailsHtml || '';
                      if (!formattedDetailsHtml) { // If formatting failed, provide fallback
                          detailsEl.innerHTML = `<span class="log-detail-item"><strong class="log-detail-key">详细信息:</strong> <span class="log-detail-value">(无或格式化失败)</span></span>`;
                          try {
                              let rawDetailsStr = typeof details === 'object' ? JSON.stringify(details, null, 2) : String(details);
                              detailsEl.innerHTML += `<pre class="log-detail-raw-json error"><code>${rawDetailsStr.replace(/</g, "&lt;").replace(/>/g, "&gt;")}<br>(原始数据)</code></pre>`;
                          } catch (e_raw) { /* Ignore further errors */ }
                      }
                 } else if (detailsEl) { // If there are no new details, but an element for details existed, remove it
                     detailsEl.remove(); // Remove the details element entirely
                 }
            } else {
                 console.error("Tool status update: Cannot find content area wrapper for details update.");
            }


             // Add animation feedback
            existingLogItem.classList.remove('animate__flash', 'animate__headShake', 'animate__pulse');
            if (status === 'failed') existingLogItem.classList.add('animate__headShake'); // Shake on failure
            else if (status === 'succeeded') existingLogItem.classList.add('animate__pulse'); // Pulse on success
            else existingLogItem.classList.add('animate__flash'); // Flash on other updates

        } else { // If no existing log item found, create a new one
             // Create a new log item for this tool status update
             const logItemDiv = appendLogItem(fullLogMessage, logIconClass, `type-tool_status_update tool-${tool_name} ${itemStatusClass}`, details);
            // Add the toolCallId as a data attribute for future lookups
             if (logItemDiv) logItemDiv.dataset.toolCallId = tool_call_id;

            // Add animation feedback to the newly created item
            if (logItemDiv) {
                 logItemDiv.classList.remove('animate__fadeInUp'); // Remove initial fade-in
                 logItemDiv.classList.add('animate__animated'); // Ensure animated class is present for potential future animations
                 if (status === 'failed') logItemDiv.classList.add('animate__headShake');
                 else if (status === 'succeeded') logItemDiv.classList.add('animate__pulse');
                 else logItemDiv.classList.add('animate__flash');
                logItemDiv.style.setProperty('--animate-duration', '0.5s');
            }
        }

        // If the process log sidebar is currently not visible, show it (without forcing expansion)
        if (!state.isProcessLogSidebarVisible) showProcessLogSidebar(false);

        // If tool execution status is success, failed, or aborted
        if (status === 'succeeded' || status === 'failed' || status === 'aborted_due_to_previous_failure') {
            // Remove this tool call from the pending list
            if (state.pendingToolCalls[tool_call_id]) {
                delete state.pendingToolCalls[tool_call_id];
            }
        }
    }

    /**
     * 处理来自服务器的 'interim_response' 类型消息，通常是Agent在执行工具前的过渡性回复。
     * @param {object} msg - 包含过渡性回复内容的服务器消息对象。
     */
    function handleInterimResponse(msg) {
        // 从消息对象中解构出 content (回复内容) 和 llm_interaction_id
        const { content, llm_interaction_id } = msg;
        // Call the appendLogItem function to add the interim response to the log sidebar
        // The main text will be a preview of the intention message
        appendLogItem(
            // Log message text, showing the first 180 characters of the content, with ellipsis if longer
            `AI意图墨迹: "${content.substring(0, 180)}${content.length > 180 ? '...' : ''}"`,
            'fas fa-feather-alt log-info', // Log icon (feather pen icon, indicating intention)
            'type-agent_intention', // Log item CSS classes
            // Detailed information, including LLM interaction ID and the full content
            { llm_interaction_id: llm_interaction_id, full_content: content }
        );
        // If the process log sidebar is currently not visible, show it (without forcing expansion)
        if (!state.isProcessLogSidebarVisible) showProcessLogSidebar(false);
    }

    /**
     * 处理来自服务器的 'final_response' 类型消息，这是Agent对用户请求的最终答复。
     * @param {object} msg - 包含最终答复内容的服务器消息对象。
     * 此函数会解析最终响应，将其添加到聊天区域，并更新会话状态。
     */
    function handleFinalResponse(msg) {
        // Hide the typing indicator
        hideTypingIndicator();
        // Set the application's loading state to false (not loading)
        setLoadingState(false);
        // Clear the current client request ID, indicating this request is complete
        state.currentClientRequestId = null;
        // Clear the list of pending tool calls
        state.pendingToolCalls = {};

        // Destructure content (main response content) and llm_interaction_id from the message object
        const { content, llm_interaction_id } = msg;
        // Get the camelCase JSON object for the specific version (v1.3.2) from the message, if successful
        const finalCamelCaseJson = msg.final_v1_3_2_camelcase_json_if_success; // Ensure version number syncs with backend

        // Initialize thinking content and actual response content for the chat bubble
        let thinkingForBubble = null;
        let actualContentForBubble = content; // Default to raw content

        // Check if finalCamelCaseJson exists, is an object, and its status is 'success'
        if (finalCamelCaseJson && typeof finalCamelCaseJson === 'object' && finalCamelCaseJson.status === 'success') {
            // If the JSON contains thoughtProcess, use it as thinking content
            if (finalCamelCaseJson.thoughtProcess) {
                thinkingForBubble = finalCamelCaseJson.thoughtProcess;
            }
            // Check if the JSON structure conforms to the expected decision and user response content
            if (finalCamelCaseJson.decision && typeof finalCamelCaseJson.decision === 'object' &&
                finalCamelCaseJson.decision.responseToUser && typeof finalCamelCaseJson.decision.responseToUser === 'object' &&
                finalCamelCaseJson.decision.responseToUser.content !== undefined // Check if content exists even if it's null/empty
            ) {
                 // Use the content from the JSON, defaulting to an empty string if it's null or undefined
                actualContentForBubble = finalCamelCaseJson.decision.responseToUser.content || "";


                // Get suggestions for next steps
                const suggestions = finalCamelCaseJson.decision.responseToUser.suggestionsForNextSteps;
                // If suggestions exist, are an array, and have a length greater than 0
                if (suggestions && Array.isArray(suggestions) && suggestions.length > 0) {
                    // Build the HTML string for suggestions
                    let suggestionsText = "\n\n<div class=\"final-response-suggestions\"><strong>下一步行动投影:</strong><ul>";
                    suggestions.forEach(sugg => {
                        if (sugg.textForUser) { // Ensure suggestion text exists
                            // Create a list item and a quick action button for each suggestion
                            // Escape quotes in data-message attribute
                            const escapedMessage = String(sugg.textForUser).replace(/"/g, '&quot;');
                             // Escape HTML special characters in the displayed text
                            const escapedTextForUser = String(sugg.textForUser).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                            suggestionsText += `<li><a href="#" class="quick-action-btn lumina-button" data-message="${escapedMessage}"><i class="fas fa-arrow-right"></i> ${escapedTextForUser}</a></li>`;
                        }
                    });
                    suggestionsText += "</ul></div>";
                    // Append the suggestions HTML to the actual response content
                    actualContentForBubble += suggestionsText;
                    // Append the response with suggestions to the chat box, marked as HTML content
                    appendMessage(actualContentForBubble, 'agent', true, thinkingForBubble, false, [], null);
                } else {
                    // If no suggestions, just append the response content to the chat box
                     // If actualContentForBubble is empty from JSON and there are no suggestions, provide a default message
                    if (!actualContentForBubble.trim()) {
                         actualContentForBubble = "(Agent返回的回复内容为空)"; // Fallback message
                         console.warn("Final response JSON has empty content and no suggestions. Using fallback message.");
                    }
                    appendMessage(actualContentForBubble, 'agent', false, thinkingForBubble, false, [], null); // Use false for isHTML if no suggestions added HTML
                }
            } else {
                // If the JSON structure is not as expected, use the raw content as a fallback, and log a warning
                console.warn("Final response JSON structure missing decision.responseToUser.content or nested objects are invalid. Using fallback content.", finalCamelCaseJson);
                 // Use the raw content as the final message, add an error type for potential styling
                appendMessage(content || "(Agent返回的原始内容为空)", 'agent', false, thinkingForBubble, false, [], "ContentMissingIn_V1_PCP_JSON_Or_Structure_Invalid");
                actualContentForBubble = content || "(Agent返回的原始内容为空)"; // Update for session history
            }
        } else {
            // If no valid finalCamelCaseJson or its status is not success
            // Use the previously cached thinking process
            thinkingForBubble = state.lastResponseThinking;
            // Determine the reason for fallback
            const reasonForFallback = finalCamelCaseJson
                ? `JSON status is not 'success' (is '${finalCamelCaseJson.status}') or JSON is not an object (is '${typeof finalCamelCaseJson}').`
                : "final_v1_3_2_camelcase_json_if_success is missing.";
            // Log a warning indicating fallback and cached thinking
            console.warn(`Final response: ${reasonForFallback} Using fallback content and cached thinking. Raw message content: "${content}"`, finalCamelCaseJson);
            // Append the raw content as the final message, add an error type including the reason for fallback
            appendMessage(content || "(Agent返回的原始内容为空)", 'agent', false, thinkingForBubble, false, [], `ErrorResponseOrNo_V1_PCP_JSON_Reason:_${reasonForFallback.replace(/\s/g, '_').substring(0, 50)}`);
            actualContentForBubble = content || "(Agent返回的原始内容为空)"; // Update for session history
        }

        // Add the final Agent response to the current session's message history
        addMessageToCurrentSession({
            content: actualContentForBubble, // Actual response content (potentially including suggestions HTML)
            sender: 'agent', // Sender is agent
            timestamp: Date.now(), // Current timestamp
            isHTML: (actualContentForBubble.includes('<div class="final-response-suggestions">')), // Mark as HTML if suggestions were added
            rawResponseV1_3_2_CamelCase: finalCamelCaseJson, // Raw camelCase JSON response (ensure version sync)
            thinking: thinkingForBubble, // Thinking process
        });
        // Clear the cached thinking process as it has been used for the current response
        state.lastResponseThinking = null;

        // Update the current session's last activity timestamp
        if (state.sessions[state.currentSessionId]) {
            state.sessions[state.currentSessionId].lastActivity = Date.now();
        }
        // Save all session data to localStorage
        saveSessions();
        // Re-render the session list to reflect the change in activity time
        renderSessionList();

        // Get LLM interaction ID for logging
        const llmIdForLog = (finalCamelCaseJson && finalCamelCaseJson.llmInteractionId) ? finalCamelCaseJson.llmInteractionId : (llm_interaction_id || 'N/A_Final');
        // Add a log item to the process log sidebar indicating the final response has been rendered
        appendLogItem(`AI最终回复已渲染 (LLM_ID: ${llmIdForLog})`, 'fas fa-flag-checkered log-success', 'type-final_response',
            // Detailed information: if finalCamelCaseJson exists, include content summary and raw response; otherwise include error details
            finalCamelCaseJson ? { summary: (actualContentForBubble.includes('<div class="final-response-suggestions">') ? actualContentForBubble.substring(0, 120).split('<br>')[0] : actualContentForBubble.substring(0, 120)) + "...", raw_response_v1_3_2: finalCamelCaseJson } : { error_details: "响应生成指示失败或缺少有效JSON.", fallback_content_preview: (content || "(空)").substring(0,120) + "..."}
        );
        // Based on the current state of the process log sidebar, decide whether to force expansion or maintain state
        if (!state.isProcessLogSidebarVisible) showProcessLogSidebar(false); // If not visible, show but don't force expand
        else if (state.isProcessLogSidebarCollapsed) showProcessLogSidebar(false); // If already collapsed, maintain collapsed state
        else showProcessLogSidebar(true); // If already expanded, maintain expanded state (or force expand to ensure new log is seen)
    }


    // ======== 初始化应用 ========
    /**
     * 初始化整个前端应用。
     * 包括加载设置、主题、字体、会话，设置事件监听器，连接WebSocket等。
     */
    function initializeApp() {
        // 在控制台输出初始化信息，包含版本号
        console.log("CircuitManus Pro - 光绘墨迹终端 (V1.0.0 Lumina) 初始化..."); // 版本号同步

        // 加载用户设置 (如主题、字体大小等)
        loadSettings();
        // 应用当前主题
        applyCurrentTheme();
        // 应用保存的字体大小，如果未保存则使用默认 '16'
        applyFontSize(localStorage.getItem(APP_PREFIX + 'fontSize') || '16');
        // 应用动画级别
        applyAnimationLevel(state.animationLevel);
        // 加载会话数据
        loadSessions();
        // 设置所有DOM元素的事件监听器
        setupEventListeners();
        // 调整用户输入文本框的初始高度
        adjustTextareaHeight();
        // 更新字符计数器的显示
        updateCharCounter();
        // 根据保存的状态更新左侧边栏的展开/收起状态 (true 表示立即更新，无动画)
        updateSidebarState(state.isSidebarExpanded, true);
        // 根据保存的状态更新会话管理器的折叠/展开状态 (true 表示立即更新)
        updateSessionManagerState(state.isSessionManagerCollapsed, true);
        // 应用右侧固定日志侧边栏的布局
        applyFixedLogSidebarLayout();
        // 根据保存的状态更新右侧日志侧边栏的折叠状态 (true 表示立即更新)
        updateProcessLogSidebarCollapseState(state.isProcessLogSidebarCollapsed, true);
        // 根据保存的状态决定是否显示右侧日志侧边栏
        if (state.isProcessLogSidebarVisible) {
            showProcessLogSidebar(false); // 显示，但不强制展开
        } else {
            hideProcessLogSidebar(); // 隐藏
        }
        // 根据保存的状态切换3D黑洞特效的可见性
        toggleThreeBlackHoleVisibility(state.isIdtComponentVisible);
        // 设置3D组件切换按钮的 title 属性
        dom.idtComponentToggleBtn.setAttribute('title', state.isIdtComponentVisible ? '停用核心投影' : '激活核心投影');
        // 获取并设置3D组件切换按钮的图标
        const idtIcon = dom.idtComponentToggleBtn.querySelector('i');
        if (idtIcon) idtIcon.className = state.isIdtComponentVisible ? 'fas fa-eye-slash' : 'fas fa-atom';

        // 连接 WebSocket 服务器
        connectWebSocket();
        // 初始化当前会话的UI (true 表示是初始加载或连接)
        initializeCurrentSessionUI(true);
        // 为聊天框中的快捷操作按钮附加事件监听器
        attachQuickActionButtonListeners(dom.chatBox);
        // Update the CSS variable for input area height
        updateInputAreaHeightVar();

        // Log that the system is ready
        console.log("光绘墨迹终端 系统就绪. 等待数据流.");
    }

    // ======== 事件监听器设置 ========
    /**
     * 设置应用中所有主要的DOM事件监听器。
     */
    function setupEventListeners() {
        // 为发送按钮添加点击事件监听器，调用 handleSendMessage 函数
        dom.sendButton.addEventListener('click', handleSendMessage);
        // 为用户输入框添加键盘按下事件监听器，调用 handleUserInputKeypress 函数
        dom.userInput.addEventListener('keypress', handleUserInputKeypress);
        // 为用户输入框添加输入事件监听器
        dom.userInput.addEventListener('input', () => {
            adjustTextareaHeight(); // 调整文本框高度
            updateCharCounter(); // 更新字符计数器
            updateInputAreaHeightVar(); // 更新输入区域高度的CSS变量
        });

        // 为主题切换按钮添加点击事件监听器
        dom.themeToggleButton.addEventListener('click', () => {
            const themes = ['auto-crystal', 'light-crystal', 'dark-crystal']; // 定义可用主题数组
            const currentIndex = themes.indexOf(state.currentTheme); // 获取当前主题在数组中的索引
            const nextTheme = themes[(currentIndex + 1) % themes.length]; // 计算下一个主题 (循环切换)
            applyTheme(nextTheme); // 应用下一个主题
            showToast(`显示模式已切换至: ${getThemeDisplayName(state.currentTheme)}`, 'info'); // 显示主题切换的 Toast 通知
        });

        // 为清除聊天按钮添加点击事件监听器，调用 handleClearCurrentChat 函数
        dom.clearChatButton.addEventListener('click', handleClearCurrentChat);
        // 如果左侧边栏切换按钮存在
        if (dom.leftSidebarToggle) {
            // 为其添加点击事件监听器，调用 updateSidebarState 函数切换侧边栏状态
            dom.leftSidebarToggle.addEventListener('click', () => updateSidebarState(!state.isSidebarExpanded));
        }

        // 为切换右侧日志侧边栏可见性按钮添加点击事件监听器
        dom.toggleProcessLogVisibilityButton.addEventListener('click', () => {
            if (state.isProcessLogSidebarVisible) hideProcessLogSidebar(); // 如果可见则隐藏
            else showProcessLogSidebar(false); // 如果隐藏则显示 (不强制展开)
        });

        // 遍历所有侧边栏按钮 (模式切换按钮等)
        dom.sidebarButtons.forEach(button => {
            // 为每个按钮添加点击事件监听器
            button.addEventListener('click', () => {
                const mode = button.dataset.mode; // 获取按钮的 data-mode 属性值
                if (mode === 'settings') openSettingsModal(); // 如果模式是 'settings'，则打开设置模态框
                else handleModeChange(mode); // 否则，调用 handleModeChange 函数切换应用模式
            });
        });

        // 为会话管理器切换按钮添加点击事件监听器，调用 updateSessionManagerState 函数切换会话列表的折叠/展开状态
        dom.sessionManagerToggle.addEventListener('click', () => updateSessionManagerState(!state.isSessionManagerCollapsed));
        // 为创建新会话按钮添加点击事件监听器，调用 createNewSession 函数
        dom.createNewSessionButton.addEventListener('click', () => createNewSession());
        // 为编辑会话名称按钮添加点击事件监听器，调用 handleEditSessionName 函数
        dom.editSessionNameButton.addEventListener('click', handleEditSessionName);

        // 为附加文件按钮添加点击事件监听器，触发文件输入框的点击事件
        dom.attachButton.addEventListener('click', () => dom.fileInput.click());
        // 为文件输入框添加 change 事件监听器，调用 handleFileSelection 函数处理文件选择
        dom.fileInput.addEventListener('change', handleFileSelection);
        // 为关闭文件预览按钮添加点击事件监听器，调用 closeFilePreview 函数
        dom.closeFilePreviewButton.addEventListener('click', closeFilePreview);
        // 为麦克风按钮添加点击事件监听器，显示一个提示信息 (当前功能可能未完全实现)
        dom.micButton.addEventListener('click', () => showToast('语音墨迹: 校准中...', 'info'));

        // 如果关闭设置按钮存在，为其添加点击事件监听器，调用 closeSettingsModal 函数 (true 表示恢复更改)
        if (dom.closeSettingsButton) dom.closeSettingsButton.addEventListener('click', () => closeSettingsModal(true));
        // 如果保存设置按钮存在，为其添加点击事件监听器
        if (dom.saveSettingsButton) dom.saveSettingsButton.addEventListener('click', () => {
            collectAndSaveSettings(); // 收集并保存设置
            closeSettingsModal(false); // 关闭设置模态框 (false 表示不恢复更改)
            showToast('系统参数已同步!', 'success'); // 显示保存成功的 Toast 通知
        });
        // 如果重置设置按钮存在，为其添加点击事件监听器，调用 resetToDefaultSettings 函数
        if (dom.resetSettingsButton) dom.resetSettingsButton.addEventListener('click', resetToDefaultSettings);

        // 如果字体大小输入框 (range slider) 存在
        if (dom.fontSizeInput) {
            // 为其添加 input 事件监听器
            dom.fontSizeInput.addEventListener('input', () => {
                const newSize = dom.fontSizeInput.value; // 获取新的字体大小值
                // 如果字体大小值显示元素存在，则更新其文本内容
                if (dom.fontSizeValue) dom.fontSizeValue.textContent = `${newSize}px`;
                // 设置 CSS 变量 '--base-font-size' 以实时应用字体大小
                document.documentElement.style.setProperty('--base-font-size', `${newSize}px`);
            });
        }
        // 如果动画级别选择框存在，为其添加 change 事件监听器，调用 applyAnimationLevel 函数应用新级别
        if (dom.animationLevelSelect) dom.animationLevelSelect.addEventListener('change', (e) => applyAnimationLevel(e.target.value));
        // 如果自动滚动切换开关存在，为其添加 change 事件监听器，更新 state.autoScroll 的值
        if (dom.autoScrollToggle) dom.autoScrollToggle.addEventListener('change', (e) => { state.autoScroll = e.target.checked; });
        // 如果启用声音切换开关存在，为其添加 change 事件监听器，更新 state.soundEnabled 的值
        if (dom.soundEnabledToggle) dom.soundEnabledToggle.addEventListener('change', (e) => { state.soundEnabled = e.target.checked; });
        // 如果显示聊天气泡思考切换开关存在，为其添加 change 事件监听器，更新 state.showChatBubblesThink 的值
        if (dom.showChatBubblesThinkToggle) dom.showChatBubblesThinkToggle.addEventListener('change', (e) => { state.showChatBubblesThink = e.target.checked; });
        // 如果显示日志气泡思考切换开关存在，为其添加 change 事件监听器，更新 state.showLogBubblesThink 的值
        if (dom.showLogBubblesThinkToggle) dom.showLogBubblesThinkToggle.addEventListener('change', (e) => { state.showLogBubblesThink = e.target.checked; });
        // 如果自动提交快捷操作切换开关存在，为其添加 change 事件监听器，更新 state.autoSubmitQuickActions 的值
        if (dom.autoSubmitQuickActionsToggle) dom.autoSubmitQuickActionsToggle.addEventListener('change', (e) => { state.autoSubmitQuickActions = e.target.checked; });

        // 如果3D组件可见性切换开关存在
        if (dom.componentVisibilityToggle) dom.componentVisibilityToggle.addEventListener('change', (e) => {
            state.isIdtComponentVisible = e.target.checked; // 更新状态
            toggleThreeBlackHoleVisibility(state.isIdtComponentVisible); // 切换3D组件的可见性
            // Update the title and icon of the 3D component toggle button
            dom.idtComponentToggleBtn.setAttribute('title', state.isIdtComponentVisible ? '停用核心投影' : '激活核心投影');
            const idtIcon = dom.idtComponentToggleBtn.querySelector('i');
            if (idtIcon) idtIcon.className = state.isIdtComponentVisible ? 'fas fa-eye-slash' : 'fas fa-atom';
            // If the visibility toggle switch in settings exists, sync its state
            if (dom.componentVisibilityToggle) dom.componentVisibilityToggle.checked = state.isIdtComponentVisible;
            // Save the visibility state to localStorage
            localStorage.setItem(APP_PREFIX + 'isIdtComponentVisible', state.isIdtComponentVisible.toString());
        });

        // If the settings modal exists, add a click event listener to it (to close the modal when clicking outside its content)
        if (dom.settingsModal) dom.settingsModal.addEventListener('click', (e) => {
            if (e.target === dom.settingsModal) closeSettingsModal(true); // If the clicked target is the modal itself (background), close it
        });

        // Listen for system color scheme changes (for 'auto-crystal' theme)
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
            if (state.currentTheme === 'auto-crystal') applyCurrentTheme(); // If the current theme is auto, reapply the theme
        });

        // If the process log sidebar collapse/expand button exists, add a click event listener
        if (dom.toggleProcessLogSidebarCollapseButton) dom.toggleProcessLogSidebarCollapseButton.addEventListener('click', () => toggleProcessLogSidebarCollapse());
        // If the process log sidebar close button exists, add a click event listener
        if (dom.closeProcessLogSidebarButton) dom.closeProcessLogSidebarButton.addEventListener('click', () => hideProcessLogSidebar());

        // If the 3D component toggle button and its wrapper both exist
        if (dom.idtComponentToggleBtn && dom.idtComponentWrapper) {
            // Add a click event listener to the toggle button
            dom.idtComponentToggleBtn.addEventListener('click', () => {
                // Toggle the visibility state of the 3D component (based on whether it currently has the 'is-visible' class)
                state.isIdtComponentVisible = !dom.idtComponentWrapper.classList.contains('is-visible');
                toggleThreeBlackHoleVisibility(state.isIdtComponentVisible); // Apply the new visibility
                // Update the title and icon of the button
                dom.idtComponentToggleBtn.setAttribute('title', state.isIdtComponentVisible ? '停用核心投影' : '激活核心投影');
                const idtIcon = dom.idtComponentToggleBtn.querySelector('i');
                if (idtIcon) idtIcon.className = state.isIdtComponentVisible ? 'fas fa-eye-slash' : 'fas fa-atom';
                // If the visibility toggle switch in settings exists, sync its state
                if (dom.componentVisibilityToggle) dom.componentVisibilityToggle.checked = state.isIdtComponentVisible;
                // Save the visibility state to localStorage
                localStorage.setItem(APP_PREFIX + 'isIdtComponentVisible', state.isIdtComponentVisible.toString());
            });
        }

        // If the 3D component wrapper exists, add a mousedown event listener to it (for dragging)
        if (dom.idtComponentWrapper) {
            dom.idtComponentWrapper.addEventListener('mousedown', handleComponentMouseDown);
        }
        // Add a resize event listener to the window
        window.addEventListener('resize', () => {
            updateInputAreaHeightVar(); // Update the CSS variable for input area height
            applyFixedLogSidebarLayout(); // Apply the layout for the right process log sidebar
            // If Three.js is initialized and camera, renderer, and wrapper exist (for responsive canvas resizing)
            if (state.threeJsInitialized && state.threeJsCamera && state.threeJsRenderer && dom.idtComponentWrapper) {
                const Rcontainer = dom.idtComponentWrapper; // Get the 3D component container
                state.threeJsCamera.aspect = Rcontainer.clientWidth / Rcontainer.clientHeight; // Update camera aspect ratio
                state.threeJsCamera.updateProjectionMatrix(); // Update camera projection matrix
                state.threeJsRenderer.setSize(Rcontainer.clientWidth, Rcontainer.clientHeight); // Update renderer size
            }
        });

        // Add mouseover event listener to the chat box for showing the copy button
        dom.chatBox.addEventListener('mouseover', handleChatBoxMouseOver);
        // Add mouseout event listener to the chat box for hiding the copy button
        dom.chatBox.addEventListener('mouseout', handleChatBoxMouseOut);
    }

    /**
     * Initializes the Three.js black hole effect.
     * @param {HTMLElement} container - The DOM element to which the Three.js Canvas will be mounted.
     * This function is responsible for creating the Three.js scene, camera, renderer, lighting, and 3D objects.
     */
    function initThreeBlackHole(container) {
        // If Three.js is already initialized
        if (state.threeJsInitialized) {
            // And there is no current animation ID, but the component should be visible
            if (!state.threeJsAnimationId && state.isIdtComponentVisible) {
                animateThreeBlackHole(); // Restart the animation
            }
            return; // Return without re-initializing
        }
        // If the container element is not found
        if (!container) {
            console.error("Three.js: Container element not found for black hole."); // Log error message
            return; // Exit function
        }
        // If the THREE object is not defined (Three.js library is not loaded)
        if (typeof THREE === 'undefined') {
            console.error("Three.js library is not loaded."); // Log error message
            showToast("错误: 3D核心组件库未能加载。", "error", 5000); // Show error Toast
            return; // Exit function
        }

        // Create a Three.js scene
        state.threeJsScene = new THREE.Scene();
        // Create a perspective camera (field of view, aspect ratio, near clipping plane, far clipping plane)
        state.threeJsCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 2000);
        // Set the camera's position (move back along the Z axis to make objects visible)
        state.threeJsCamera.position.z = 60;
        // Create a WebGL renderer, enabling anti-aliasing and transparent background
        state.threeJsRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        // Set the renderer size to match the container's width and height
        state.threeJsRenderer.setSize(container.clientWidth, container.clientHeight);
        // Set the device pixel ratio for sharper rendering
        state.threeJsRenderer.setPixelRatio(window.devicePixelRatio);
        // Clear any existing canvas elements from previous initializations
        container.querySelectorAll('canvas').forEach(canvas => canvas.remove());
        // Append the renderer's DOM element (canvas) to the container
        container.appendChild(state.threeJsRenderer.domElement);

        // Create an ambient light (color, intensity)
        const ambientLight = new THREE.AmbientLight(0xaaaaaa, 0.5);
        state.threeJsScene.add(ambientLight); // Add ambient light to the scene
        // Create a point light (color, intensity, distance)
        const pointLight = new THREE.PointLight(0xffffff, 1, 500);
        pointLight.position.set(0, 20, 30); // Set the point light's position
        state.threeJsScene.add(pointLight); // Add point light to the scene

        // Create a group to hold the black hole and accretion disks, for easier manipulation
        state.threeBlackHoleGroup = new THREE.Group();
        const sphereRadius = 12; // Define the radius of the black hole sphere (event horizon)
        // Create sphere geometry (radius, width segments, height segments)
        const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 48, 48);
        // Create standard mesh material (color, roughness, metalness)
        const sphereMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000, roughness: 0.8, metalness: 0.1
        });
        // Create the event horizon mesh object
        const eventHorizon = new THREE.Mesh(sphereGeometry, sphereMaterial);
        state.threeBlackHoleGroup.add(eventHorizon); // Add the event horizon to the group

        // Define colors, opacity, radii, tube radii, and rotation speeds for the accretion disks
        const diskColors = [0xff6600, 0xff9933, 0xffcc66]; // Orange/Yellow shades
        const diskOpacities = [0.6, 0.7, 0.8]; // Opacity
        const diskRadii = [sphereRadius + 7, sphereRadius + 14, sphereRadius + 21]; // Torus radii
        const diskTubeRadii = [2.5, 3.5, 4.5]; // Torus tube radii
        const diskRotationSpeeds = [0.01, -0.008, 0.012]; // Rotation speeds (positive/negative indicates direction)

        // Create three accretion disks (outer, middle, inner)
        // Store references in state for animation
        state.threeAccretionDiskOuter = new THREE.Mesh(); // Initialize with dummy objects
        state.threeAccretionDiskMiddle = new THREE.Mesh();
        state.threeAccretionDiskInner = new THREE.Mesh();

        [state.threeAccretionDiskOuter, state.threeAccretionDiskMiddle, state.threeAccretionDiskInner] = diskRadii.map((radius, i) => {
            // Create Phong mesh material (suitable for highlights)
            const diskMaterial = new THREE.MeshPhongMaterial({
                color: diskColors[i], // Color
                emissive: new THREE.Color(diskColors[i]).multiplyScalar(0.5), // Emissive color (makes it look brighter)
                specular: 0x333333, // Specular color
                shininess: 20, // Shininess
                side: THREE.DoubleSide, // Render both sides
                transparent: true, // Enable transparency
                opacity: diskOpacities[i], // Opacity
                blending: THREE.AdditiveBlending // Blending mode (Additive, makes overlapping parts brighter)
            });
            // Create torus geometry (radius, tube radius, radial segments, tubular segments)
            const disk = new THREE.Mesh(new THREE.TorusGeometry(radius, diskTubeRadii[i], 16, 60), diskMaterial);
            disk.rotation.x = Math.PI / 1.8; // Adjust the tilt angle of the accretion disks (X-axis rotation)
            disk.userData.rotationSpeed = diskRotationSpeeds[i]; // Store rotation speed in userData
            state.threeBlackHoleGroup.add(disk); // Add the disk to the group
            return disk; // Return the created disk object
        });


        // Create star field background
        const starGeometry = new THREE.BufferGeometry(); // Create buffer geometry
        // Create points material (color, size, transparent, opacity, size attenuation, blending mode)
        const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff, size: 0.25, transparent: true, opacity: 0.7,
            sizeAttenuation: true, blending: THREE.AdditiveBlending
        });
        const starVertices = []; // Array to store star vertex coordinates
        // Generate random coordinates for 3000 stars
        for (let i = 0; i < 3000; i++) {
            const x = THREE.MathUtils.randFloatSpread(500); // X coordinate in [-250, 250] range
            const y = THREE.MathUtils.randFloatSpread(500); // Y coordinate in [-250, 250] range
            const z = THREE.MathUtils.randFloatSpread(500); // Z coordinate in [-250, 250] range
            starVertices.push(x, y, z); // Add coordinates to the array
        }
        // Set the 'position' attribute of the geometry (vertex coordinates)
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        // Create the star points object
        state.threeStarField = new THREE.Points(starGeometry, starMaterial);
        state.threeJsScene.add(state.threeStarField); // Add the star field to the scene

        // Add the entire black hole group (containing event horizon and accretion disks) to the scene
        state.threeJsScene.add(state.threeBlackHoleGroup);
        // Mark Three.js as initialized
        state.threeJsInitialized = true;
        // Start the animation loop
        animateThreeBlackHole();
        // Log successful initialization
        console.log("Three.js black hole initialized successfully.");
    }

    /**
     * Three.js黑洞动画循环。
     * 此函数使用 requestAnimationFrame 来持续渲染和更新3D场景中的对象动画。
     */
    function animateThreeBlackHole() {
        // If Three.js is not initialized or component is not visible, stop animation
        if (!state.threeJsInitialized || !state.isIdtComponentVisible) {
            // If animation ID exists, cancel the animation frame request
            if (state.threeJsAnimationId) cancelAnimationFrame(state.threeJsAnimationId);
            state.threeJsAnimationId = null; // Set animation ID to null
            return; // Exit function
        }
        // Request the next animation frame and store the returned ID for potential cancellation
        state.threeJsAnimationId = requestAnimationFrame(animateThreeBlackHole);

        // If the black hole group exists, make it rotate slowly
        if (state.threeBlackHoleGroup) {
            state.threeBlackHoleGroup.rotation.y += 0.0015; // Rotate around Y axis
            state.threeBlackHoleGroup.rotation.x += 0.0007; // Rotate around X axis (slight wobble)
        }
        // If the outer accretion disk exists, rotate it around Z axis based on its stored speed
        if (state.threeAccretionDiskOuter) state.threeAccretionDiskOuter.rotation.z += state.threeAccretionDiskOuter.userData.rotationSpeed;
        // If the middle accretion disk exists, rotate it around Z axis based on its stored speed
        if (state.threeAccretionDiskMiddle) state.threeAccretionDiskMiddle.rotation.z += state.threeAccretionDiskMiddle.userData.rotationSpeed;
        // If the inner accretion disk exists, rotate it around Z axis based on its stored speed
        if (state.threeAccretionDiskInner) state.threeAccretionDiskInner.rotation.z += state.threeAccretionDiskInner.userData.rotationSpeed;
        // If the star field background exists, make it rotate slowly
        if (state.threeStarField) {
            state.threeStarField.rotation.x += 0.0001; // Rotate around X axis
            state.threeStarField.rotation.y += 0.00015; // Rotate around Y axis
        }
        // If renderer, scene, and camera exist, perform the rendering operation
        if (state.threeJsRenderer && state.threeJsScene && state.threeJsCamera) {
            state.threeJsRenderer.render(state.threeJsScene, state.threeJsCamera);
        }
    }

    /**
     * 控制Three.js场景的显隐和动画启停。
     * @param {boolean} isVisible - 是否显示3D组件。
     */
    function toggleThreeBlackHoleVisibility(isVisible) {
        // If the 3D component wrapper element does not exist, return
        if (!dom.idtComponentWrapper) return;
        // Toggle the 'is-visible' CSS class on the wrapper element based on the isVisible parameter
        dom.idtComponentWrapper.classList.toggle('is-visible', isVisible);
        // Update the isIdtComponentVisible flag in the state
        state.isIdtComponentVisible = isVisible;
        // If the component should be visible
        if (isVisible) {
            // If Three.js is not yet initialized
            if (!state.threeJsInitialized) {
                initThreeBlackHole(dom.idtComponentWrapper); // Initialize the Three.js effect
            } else if (!state.threeJsAnimationId) { // If already initialized but animation is not running
                animateThreeBlackHole(); // Start the animation
            }
        } else { // If the component should be hidden
            // If the animation ID exists (i.e., animation is running)
            if (state.threeJsAnimationId) {
                cancelAnimationFrame(state.threeJsAnimationId); // Cancel the animation frame request, stop the animation
                state.threeJsAnimationId = null; // Set animation ID to null
            }
        }
        // Save the component's visibility state to localStorage
        localStorage.setItem(APP_PREFIX + 'isIdtComponentVisible', isVisible.toString());
    }

    /**
     * 处理鼠标悬停在聊天框消息气泡上以显示复制按钮的事件。
     * @param {MouseEvent} event - 鼠标事件对象。
     */
    function handleChatBoxMouseOver(event) {
        // Find the target element of the mouseover event or its nearest '.message-agent .message-bubble' parent element
        const targetMessageBubble = event.target.closest('.message-agent .message-bubble');
        // If a target message bubble is found (i.e., mouse is hovering over an Agent message bubble)
        if (targetMessageBubble) {
            // Try to get an existing copy button within the bubble
            let copyButton = targetMessageBubble.querySelector('.copy-llm-response-btn');
            // If the copy button does not exist
            if (!copyButton) {
                // Create a new copy button element
                copyButton = document.createElement('button');
                copyButton.className = 'copy-llm-response-btn icon-btn'; // Set the button's class name
                copyButton.innerHTML = '<i class="fas fa-copy"></i>'; // Set the button's icon
                copyButton.title = '复制回复内容'; // Set the button's tooltip
                // Add a click event listener to the copy button, calling handleCopyLlmResponse
                copyButton.addEventListener('click', handleCopyLlmResponse);
                // Append the copy button to the message bubble
                targetMessageBubble.appendChild(copyButton);
            }
            // Set the opacity and visibility of the copy button to make it visible
            copyButton.style.opacity = '1';
            copyButton.style.visibility = 'visible';
        }
    }

    /**
     * 处理鼠标移出聊天框消息气泡以隐藏复制按钮的事件。
     * @param {MouseEvent} event - 鼠标事件对象。
     */
    function handleChatBoxMouseOut(event) {
        // Find the target element of the mouseout event or its nearest '.message-agent .message-bubble' parent element
        const targetMessageBubble = event.target.closest('.message-agent .message-bubble');
        // If a target message bubble is found
        if (targetMessageBubble) {
            // Get the copy button within the bubble
            const copyButton = targetMessageBubble.querySelector('.copy-llm-response-btn');
            // Check if the copy button exists, and the related target (element mouse is moving to) is not the bubble itself or the button itself or a child of the button
            // This prevents the button from being hidden incorrectly when moving from the bubble to the button
            if (copyButton && !targetMessageBubble.contains(event.relatedTarget) && event.relatedTarget !== copyButton && !copyButton.contains(event.relatedTarget)) {
                // Set the opacity and visibility of the copy button to hide it
                copyButton.style.opacity = '0';
                copyButton.style.visibility = 'hidden';
            }
        } else {
            // If the mouse moved out of the entire chat box (targetMessageBubble is null), hide copy buttons in all Agent message bubbles
            dom.chatBox.querySelectorAll('.message-agent .message-bubble .copy-llm-response-btn').forEach(btn => {
                btn.style.opacity = '0';
                btn.style.visibility = 'hidden';
            });
        }
    }

    /**
     * 处理点击LLM回复消息气泡中的复制按钮的事件。
     * @param {MouseEvent} event - 点击事件对象。
     * 此函数将消息内容复制到用户剪贴板。
     */
    function handleCopyLlmResponse(event) {
        // Prevent event propagation to higher elements (e.g., the message bubble's parent)
        event.stopPropagation();
        // Get the clicked button element
        const button = event.currentTarget;
        // Find the nearest message bubble element containing the button
        const messageBubble = button.closest('.message-bubble');
        // Find the element containing the text content within the message bubble
        const textContentDiv = messageBubble.querySelector('.message-text-content');

        // If the text content element is found
        if (textContentDiv) {
            // Extract plain text from the HTML content, first replacing <br> tags with newline characters \n
            let textToCopy = textContentDiv.innerHTML.replace(/<br\s*\/?>/gi, '\n');
            // Create a temporary div element for further cleaning of HTML tags to get pure text
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = textToCopy; // Put the text containing newlines (potentially still with other HTML) into the temporary div
            textToCopy = tempDiv.textContent || tempDiv.innerText || ""; // Get the pure text content

            // Remove the "下一步行动投影:" section and its content from the text if it exists
            const suggestionIndex = textToCopy.indexOf("下一步行动投影:");
            if (suggestionIndex !== -1) {
                textToCopy = textToCopy.substring(0, suggestionIndex).trim(); // Truncate and remove trailing whitespace
            }

            // Use the browser's Clipboard API to copy the processed plain text to the clipboard
            navigator.clipboard.writeText(textToCopy.trim())
                .then(() => {
                    // Callback on successful copy
                    showToast('回复已复制到剪贴板!', 'success', 2000); // Show success Toast notification
                    button.innerHTML = '<i class="fas fa-check"></i>'; // Change button icon to checkmark
                    // Restore button icon to copy icon after 1.5 seconds
                    setTimeout(() => { button.innerHTML = '<i class="fas fa-copy"></i>'; }, 1500);
                })
                .catch(err => {
                    // Callback on copy failure
                    console.error('无法复制文本: ', err); // Log error to console
                    showToast('复制失败!', 'error'); // Show failure Toast notification
                });
        }
    }

    /**
     * 处理3D组件容器的鼠标按下事件，用于开始拖动。
     * @param {MouseEvent} e - 鼠标按下事件对象。
     */
    function handleComponentMouseDown(e) {
        // If the 3D component is not visible, or if the clicked button is not the left mouse button (button !== 0), do not start dragging
        if (!dom.idtComponentWrapper.classList.contains('is-visible') || e.button !== 0) { return; }
        // Set dragging state to true
        state.isDraggingComponent = true;
        // Change the mouse cursor style for the 3D component container to 'grabbing'
        dom.idtComponentWrapper.style.cursor = 'grabbing';
        // Disable page text selection to prevent selecting text while dragging
        document.body.style.userSelect = 'none';
        // Get the computed styles of the document root element
        const styles = getComputedStyle(document.documentElement);
        // Get the current top and left offset percentages stored in CSS variables, default to 0 if not found
        const currentTopPercent = parseFloat(styles.getPropertyValue('--idt-offset-top-percentage').replace('%', '')) || 0;
        const currentLeftPercent = parseFloat(styles.getPropertyValue('--idt-offset-left-percentage').replace('%', '')) || 0;
        // Calculate the initial top position (in pixels) at the start of dragging
        // Prioritize any existing inline pixel value, otherwise calculate from percentage and window height
        state.componentInitialTopPx = (dom.idtComponentWrapper.style.top && dom.idtComponentWrapper.style.top.endsWith('px'))
            ? parseFloat(dom.idtComponentWrapper.style.top) // Use the inline px value if present
            : (currentTopPercent / 100) * window.innerHeight; // Otherwise calculate from percentage
        // Calculate the initial left position (in pixels) at the start of dragging
        // Logic is the same as above
        state.componentInitialLeftPx = (dom.idtComponentWrapper.style.left && dom.idtComponentWrapper.style.left.endsWith('px'))
            ? parseFloat(dom.idtComponentWrapper.style.left)
            : (currentLeftPercent / 100) * window.innerWidth;
        // Record the mouse's X coordinate at the moment of pressing
        state.componentDragStartX = e.clientX;
        // Record the mouse's Y coordinate at the moment of pressing
        state.componentDragStartY = e.clientY;
        // Add a mousemove event listener to the document
        document.addEventListener('mousemove', handleComponentMouseMove);
        // Add a mouseup event listener to the document
        document.addEventListener('mouseup', handleComponentMouseUp);
        // Add a mouseleave event listener to the document (handles case where mouse leaves browser window while dragging)
        document.addEventListener('mouseleave', handleComponentMouseUp);
        // Prevent the default mouse down behavior (e.g., image dragging)
        e.preventDefault();
    }
    /**
     * Handles the mousemove event during 3D component dragging.
     * @param {MouseEvent} e - The mousemove event object.
     */
    function handleComponentMouseMove(e) {
        // If not currently dragging, do nothing
        if (!state.isDraggingComponent) return;
        // Calculate the distance the mouse moved in the X direction
        const deltaX = e.clientX - state.componentDragStartX;
        // Calculate the distance the mouse moved in the Y direction
        const deltaY = e.clientY - state.componentDragStartY;
        // Calculate the new top position (in pixels)
        let newTopPx = state.componentInitialTopPx + deltaY;
        // Calculate the new left position (in pixels)
        let newLeftPx = state.componentInitialLeftPx + deltaX;
        // Get the bounding box information of the 3D component container (primarily for width and height)
        const componentRect = dom.idtComponentWrapper.getBoundingClientRect();
        // Get the viewport width and height
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        // Clamp the new top position within the viewport (from 0 to viewport height - component height)
        newTopPx = Math.max(0, Math.min(newTopPx, viewportHeight - componentRect.height));
        // Clamp the new left position within the viewport (from 0 to viewport width - component width)
        newLeftPx = Math.max(0, Math.min(newLeftPx, viewportWidth - componentRect.width));
        // Apply the new top position (via inline style)
        dom.idtComponentWrapper.style.top = `${newTopPx}px`;
        // Apply the new left position (via inline style)
        dom.idtComponentWrapper.style.left = `${newLeftPx}px`;
    }
    /**
     * Handles the mouseup event when dragging of the 3D component ends.
     */
    function handleComponentMouseUp() {
        // If not currently dragging, do nothing
        if (!state.isDraggingComponent) return;
        // Set dragging state to false
        state.isDraggingComponent = false;
        // Restore the mouse cursor style for the 3D component container to 'grab'
        dom.idtComponentWrapper.style.cursor = 'grab';
        // Restore page text selection ability
        document.body.style.userSelect = '';
        // Remove the mousemove event listener from the document
        document.removeEventListener('mousemove', handleComponentMouseMove);
        // Remove the mouseup event listener from the document
        document.removeEventListener('mouseup', handleComponentMouseUp);
        // Remove the mouseleave event listener from the document
        document.removeEventListener('mouseleave', handleComponentMouseUp);
        // Convert the final pixel position to percentage and store it
        // Get the final top position (in pixels), default to 0 if not present in inline style
        const finalTopPx = parseFloat(dom.idtComponentWrapper.style.top) || 0;
        // Get the final left position (in pixels), default to 0 if not present in inline style
        const finalLeftPx = parseFloat(dom.idtComponentWrapper.style.left) || 0;
        // Get the viewport width and height
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        // Calculate the component width as a percentage of the viewport width
        const componentWidthPercent = (dom.idtComponentWrapper.offsetWidth / viewportWidth) * 100;
        // Calculate the component height as a percentage of the viewport height
        const componentHeightPercent = (dom.idtComponentWrapper.offsetHeight / viewportHeight) * 100;
        // Calculate the new top position percentage
        let newTopPercent = (finalTopPx / viewportHeight) * 100;
        // Calculate the new left position percentage
        let newLeftPercent = (finalLeftPx / viewportWidth) * 100;
        // Re-clamp the percentages within a reasonable range to prevent the component from partially moving out of the viewport
        newTopPercent = Math.max(0, Math.min(newTopPercent, 100 - componentHeightPercent));
        newLeftPercent = Math.max(0, Math.min(newLeftPercent, 100 - componentWidthPercent));
        // Update CSS variables to store the new percentage position
        document.documentElement.style.setProperty('--idt-offset-top-percentage', `${newTopPercent.toFixed(2)}%`);
        document.documentElement.style.setProperty('--idt-offset-left-percentage', `${newLeftPercent.toFixed(2)}%`);
        // Clear the inline top and left styles, allowing CSS variables to take effect and avoiding using old px values on the next drag
        dom.idtComponentWrapper.style.top = '';
        dom.idtComponentWrapper.style.left = '';
        // Save the new percentage position to localStorage for persistence
        localStorage.setItem(APP_PREFIX + 'idtComponentTopPercent', `${newTopPercent.toFixed(2)}%`);
        localStorage.setItem(APP_PREFIX + 'idtComponentLeftPercent', `${newLeftPercent.toFixed(2)}%`);
    }

    /**
     * 更新用户输入框下方的字符计数器。
     */
    function updateCharCounter() {
        // 获取用户输入框当前内容的长度
        const currentLength = dom.userInput.value.length;
        // 更新字符计数器元素的文本内容，格式为 "当前长度/最大长度"
        dom.charCounter.textContent = `${currentLength}/${state.maxInputChars}`;
        // 移除字符计数器上可能存在的 'warn' 和 'error' CSS 类
        dom.charCounter.classList.remove('warn', 'error');
        // 如果当前长度超过最大限制
        if (currentLength > state.maxInputChars) {
            // 添加 'error' CSS 类，通常会显示为红色
            dom.charCounter.classList.add('error');
        } else if (currentLength > state.maxInputChars * 0.9) { // 如果当前长度超过最大限制的90%
            // 添加 'warn' CSS 类，通常会显示为黄色或橙色
            dom.charCounter.classList.add('warn');
        }
    }

    /**
     * 生成唯一的会话ID。
     * @returns {string} 生成的会话ID。
     * 格式为 "session_lumina_" + 当前时间戳(36进制) + "_" + 随机字符串(36进制，10位)
     */
    function generateSessionId() {
        return `session_lumina_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 12)}`;
    }
    /**
     * 生成唯一的客户端请求ID。
     * @returns {string} 生成的请求ID。
     * 格式为 "creq_lumina_proc_" + 当前时间戳(36进制) + "_" + 随机字符串(36进制，8位)
     */
    function generateClientRequestId() {
        return `creq_lumina_proc_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 10)}`;
    }

    /**
     * 初始化当前会话的用户界面。
     * 如果存在上次会话ID且有效，则加载该会话；否则加载最近活动的会话或创建新会话。
     * @param {boolean} [isInitialLoadOrConnect=false] - 是否是应用初始加载或WebSocket重连。
     */
    function initializeCurrentSessionUI(isInitialLoadOrConnect = false) {
        // 从 localStorage 获取上次使用的会话 ID
        const lastSessionId = localStorage.getItem(APP_PREFIX + 'lastSessionId');
        // 优先使用当前 state 中的 currentSessionId (可能由 WebSocket 的 init_success 消息设置)
        let targetSessionId = state.currentSessionId;
        // 如果 state 中没有 currentSessionId
        if (!targetSessionId) {
            // 尝试从 localStorage 恢复，并检查该会话是否存在于当前加载的会话数据中
            if (lastSessionId && state.sessions[lastSessionId]) {
                targetSessionId = lastSessionId; // 使用 localStorage 中的会话 ID
            } else if (Object.keys(state.sessions).length > 0) { // 如果 localStorage 中的无效，则尝试使用最近活动的会话
                // 将所有会话按最后活动时间降序排列
                const sortedSessions = Object.values(state.sessions).sort((a, b) => b.lastActivity - a.lastActivity);
                targetSessionId = sortedSessions[0].id; // 选择最近活动的会话
            }
        }
        // 如果经过以上步骤仍然没有找到有效的会话 ID，或者找到的 ID 在当前会话数据中不存在
        if (!targetSessionId || !state.sessions[targetSessionId]) {
            // 创建一个新的会话，isInitialCreation = true 表示这是初始化时创建，避免不必要的立即UI切换
            targetSessionId = createNewSession(true);
        }
        // 切换到目标会话，并传递 isInitialLoadOrConnect 标志
        switchSession(targetSessionId, isInitialLoadOrConnect);
    }

    /**
     * 创建一个新的会话。
     * @param {boolean} [isInitialCreation=false] - 是否是在应用初始化时创建（避免不必要的UI切换）。
     * @returns {string} 新创建的会话ID。
     */
    function createNewSession(isInitialCreation = false) {
        // 生成一个新的唯一会话 ID
        const newId = generateSessionId();
        // 获取当前时间戳
        const now = Date.now();
        // 计算新会话的序号 (基于当前已有的会话数量)
        const sessionCount = Object.keys(state.sessions).length + 1;
        // 在 state.sessions 中创建新的会话对象
        state.sessions[newId] = {
            id: newId, // 会话 ID
            name: `光绘墨迹项目 ${sessionCount}`, // 默认会话名称，包含序号
            messages: [], // 消息列表，初始为空
            createdAt: now, // 创建时间
            lastActivity: now, // 最后活动时间
        };
        saveSessions(); // 将更新后的会话数据保存到 localStorage
        // 如果不是在应用初始化时创建 (即用户主动创建)
        if (!isInitialCreation) {
            // 立即切换到这个新创建的会话
            switchSession(newId, false); // false 表示不是初始加载
            showToast('新光绘墨迹项目已创建!', 'success'); // 显示创建成功的 Toast 通知
            // 如果左侧边栏未展开，则展开它
            if (!state.isSidebarExpanded) updateSidebarState(true);
            // 如果会话管理器是折叠的，则展开它
            if (state.isSessionManagerCollapsed) updateSessionManagerState(false);
        }
        // 返回新创建的会话 ID
        return newId;
    }

    /**
     * 切换到指定的会话。
     * @param {string} sessionId - 要切换到的会话ID。
     * @param {boolean} [isInitialLoadOrConnect=false] - 是否是应用初始加载或WebSocket重连。
     * 此函数负责更新UI以显示选定会话的内容。
     */
    function switchSession(sessionId, isInitialLoadOrConnect = false) {
        // 安全检查：如果目标会话 ID 在 state.sessions 中不存在
        if (!state.sessions[sessionId]) {
            console.error(`尝试切换到不存在的会话: ${sessionId}. 创建一个 fallback 会话.`); // 打印错误信息
            // 创建一个新的会话作为后备 (isInitialCreation = true 避免递归调用 switchSession)
            const fallbackId = createNewSession(true);
            state.currentSessionId = fallbackId; // 更新当前会话 ID 为后备会话的 ID
        } else {
            // 如果目标会话存在，则更新当前会话 ID
            state.currentSessionId = sessionId;
        }

        // 如果不是初始加载/连接，并且 WebSocket 已连接并处于打开状态
        if (!isInitialLoadOrConnect && websocket && websocket.readyState === WebSocket.OPEN) {
            // 向后端发送 'init' 消息，通知后端当前会话已更改
            sendWebSocketMessage({ type: 'init', session_id: state.currentSessionId });
        }

        // 将当前会话 ID 保存到 localStorage，作为“最后活动会话”
        localStorage.setItem(APP_PREFIX + 'lastSessionId', state.currentSessionId);
        // 如果当前会话对象存在于 state.sessions 中
        if (state.sessions[state.currentSessionId]) {
            // Update the last activity timestamp for this session to the current time
            state.sessions[state.currentSessionId].lastActivity = Date.now();
        }
        // Save all session data to localStorage
        saveSessions();

        // Update UI elements to reflect the current session:
        // Set the text content of the current session name display area, default to "初始化墨迹..." if session does not exist
        dom.currentSessionNameDisplay.textContent = state.sessions[state.currentSessionId]?.name || "初始化墨迹...";
        // Clear the existing content of the chat box
        dom.chatBox.innerHTML = '';

        // Render messages or welcome message for the current session:
        // If the message list of the current session is empty
        if (state.sessions[state.currentSessionId]?.messages.length === 0) {
            appendWelcomeMessage(); // Display the welcome message
        } else {
            // If there are messages, iterate through them and append to the chat box
            state.sessions[state.currentSessionId]?.messages.forEach(msg => {
                // Use the message object's properties when appending
                appendMessage(msg.content, msg.sender, msg.isHTML, msg.thinking, true, msg.attachments, msg.errorType); // true indicates switching session, loading history
            });
        }
        scrollToBottom(true); // Scroll the chat box to the bottom (true for instant scroll)
        renderSessionList(); // Re-render the session list (to update the active session's style etc.)
        dom.userInput.focus(); // Set focus to the input box

        // Clear and handle the right process log sidebar
        if (dom.processLogSidebarContent) dom.processLogSidebarContent.innerHTML = ''; // Clear log content
        // Depending on its current visibility state, decide whether to show or hide it
        if (state.isProcessLogSidebarVisible) {
            showProcessLogSidebar(false); // If visible, re-show (do not force expand)
        } else {
            hideProcessLogSidebar(); // If not visible, keep hidden
        }

        // Log the switched session information to the console
        console.log(`切换到光绘墨迹项目: ${state.sessions[state.currentSessionId]?.name} (ID: ${state.currentSessionId})`);
        // Update the placeholder text of the user input box, including current mode and current project name
        const currentSessionNameForPlaceholder = state.sessions[state.currentSessionId]?.name || '当前项目';
        dom.userInput.placeholder = `向Lumina核心发送指令 (${getModeDisplayName(state.currentMode)}模式，当前项目: ${currentSessionNameForPlaceholder})...`;
    }

    /**
     * 删除指定的会话。
     * @param {string} sessionId - 要删除的会话ID。
     * @param {Event} [event] - 可选的点击事件对象，用于阻止事件冒泡。
     */
    function deleteSession(sessionId, event) {
        // If an event object is provided (typically a click event), prevent event propagation
        // This prevents triggering the parent element's click event (which switches sessions) when clicking the delete button
        if (event) event.stopPropagation();
        // If the session ID to be deleted does not exist in state.sessions, return without doing anything
        if (!state.sessions[sessionId]) return;
        // Get the name of the session to be deleted for the confirmation prompt
        const sessionName = state.sessions[sessionId].name;
        // Show a confirmation dialog asking the user if they are sure they want to delete the current session's chat history
        if (!confirm(`归档光绘墨迹项目 "${sessionName}" (ID: ${sessionId})? 此操作不可逆转.`)) {
            return; // If the user cancels, return
        }
        // Find and get the corresponding session list item element from the DOM
        const listItem = dom.sessionList.querySelector(`li[data-session-id="${sessionId}"]`);
        // If the list item element is found
        if (listItem) {
            // If animations are enabled (state.animationLevel is not 'none')
            if (state.animationLevel !== 'none') {
                // Add Animate.css exit animation class
                listItem.classList.add('animate__animated', 'animate__zoomOutLeft');
                // Set the animation duration
                listItem.style.setProperty('--animate-duration', '0.4s');
                // Listen for the animation end event, remove the list item element after the animation finishes (once: true means the event triggers only once)
                listItem.addEventListener('animationend', () => listItem.remove(), { once: true });
            } else {
                // If animations are not enabled, remove the list item element directly
                listItem.remove();
            }
        }
        // Delete the session data from the state.sessions object
        delete state.sessions[sessionId];
        // Check if the deleted session was the currently active session
        if (state.currentSessionId === sessionId) {
            // If it was the current session, need to switch to another session or create a new one
            // Get the remaining sessions, sorted by last activity timestamp in descending order
            const remainingSessions = Object.values(state.sessions).sort((a, b) => b.lastActivity - a.lastActivity);
            // If there are other sessions remaining
            if (remainingSessions.length > 0) {
                // Switch to the most recently active session
                switchSession(remainingSessions[0].id, false);
            } else {
                // If there are no other sessions remaining, create a new fallback session
                const newFallbackId = createNewSession(true); // true indicates not to immediately switch UI
                switchSession(newFallbackId, false); // Then switch to this new session
            }
        } else {
            // If the deleted session was not the current session, just save the updated session data and re-render the session list
            saveSessions();
            renderSessionList();
        }
        // Show a Toast notification informing the user that the session has been archived (deleted)
        showToast(`光绘墨迹项目 "${sessionName}" 已归档.`, 'info');
        // If all sessions have been deleted, ensure the session list displays the empty state (done by re-rendering)
        if (Object.keys(state.sessions).length === 0 && dom.sessionList) renderSessionList();
    }

    /**
     * 处理编辑当前会话名称的逻辑。
     * 弹出提示框让用户输入新名称，并更新状态和UI。
     */
    function handleEditSessionName() {
        // Get the current active session object
        const currentSession = state.sessions[state.currentSessionId];
        // If there is no current active session, do nothing
        if (!currentSession) return;
        // Use the prompt dialog to ask the user to enter a new session name, with the current name as default value
        const newName = prompt(`重命名光绘墨迹项目 "${currentSession.name}":`, currentSession.name);
        // If the user entered a new name (newName is not null), and the new name after trimming whitespace is not empty, and it is different from the original name
        if (newName && newName.trim() !== "" && newName.trim() !== currentSession.name) {
            // Update the current session's name, limiting the length to 70 characters
            currentSession.name = newName.trim().substring(0, 70);
            // Update the current session's last activity timestamp
            currentSession.lastActivity = Date.now();
            // Update the UI element displaying the current session name
            dom.currentSessionNameDisplay.textContent = currentSession.name;
            // Save all session data (because the name has changed)
            saveSessions();
            // Re-render the session list to reflect the name change
            renderSessionList();
            // Show a Toast notification informing the user that the name has been updated
            showToast("光绘墨迹项目名称已更新.", "success");
            // Update the placeholder text of the user input box to reflect the new session name
            const currentSessionNameForPlaceholder = state.sessions[state.currentSessionId]?.name || '当前项目';
            dom.userInput.placeholder = `向Lumina核心发送指令 (${getModeDisplayName(state.currentMode)}模式，当前项目: ${currentSessionNameForPlaceholder})...`;
        }
    }

    /**
     * Renders the session list to the UI.
     * Dynamically creates list items based on the data in `state.sessions`.
     */
    function renderSessionList() {
        // If the session list container element (ul) does not exist, do nothing
        if (!dom.sessionList) return;
        // Clear the existing content of the session list container
        dom.sessionList.innerHTML = '';
        // Get all session data and sort it by last activity timestamp in descending order
        const sortedSessions = Object.values(state.sessions)
            .sort((a, b) => b.lastActivity - a.lastActivity);

        // If the sorted session list has a length of 0 (i.e., no sessions)
        if (sortedSessions.length === 0) {
            // Create a list item representing "no sessions"
            const emptyItem = document.createElement('li');
            emptyItem.classList.add('session-list-empty'); // Add specific CSS class
            // Set its content, including an icon and text
            emptyItem.innerHTML = '<i class="fas fa-folder-open"></i> 无光绘项目';
            dom.sessionList.appendChild(emptyItem); // Add this item to the session list container
            return; // End function execution
        }

        // Iterate through each session data in the sorted list
        sortedSessions.forEach(session => {
            // Create a list item (li) element for each session
            const listItem = document.createElement('li');
            listItem.classList.add('session-list-item'); // Add base CSS class
            // If the current session being iterated is the active session, add the 'active-session' CSS class for highlighting
            if (session.id === state.currentSessionId) {
                listItem.classList.add('active-session');
            }
            // Store the session ID in the data-session-id attribute of the list item for easy access later
            listItem.dataset.sessionId = session.id;

            // Format the session's last activity time and creation time
            const lastActivityDate = new Date(session.lastActivity);
            const createdDate = new Date(session.createdAt);
            // Format the last activity timestamp into a user-friendly relative time string (e.g., "just now", "5 min ago")
            const timeSinceLastActivity = formatTimeSince(session.lastActivity);

            // Set the title attribute (tooltip) of the list item, showing detailed last modified time and creation time
            listItem.title = `最后修改: ${timeSinceLastActivity} (${lastActivityDate.toLocaleString()})\n创建于: ${createdDate.toLocaleDateString()}`;

            // Create a div to wrap the session name and time information for layout purposes
            const contentWrapper = document.createElement('div');
            contentWrapper.classList.add('session-item-content');

            // Create a span to display the session name
            const nameSpan = document.createElement('span');
            nameSpan.classList.add('session-name');
            nameSpan.textContent = session.name; // Set the session name

            // Create a span to display the relative activity time
            const timeSpan = document.createElement('span');
            timeSpan.classList.add('session-time');
            timeSpan.textContent = timeSinceLastActivity; // Set the time text

            // Append the name and time spans to the content wrapper
            contentWrapper.appendChild(nameSpan);
            contentWrapper.appendChild(timeSpan);

            // Create a delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.classList.add('session-delete-btn', 'icon-btn'); // Add CSS classes
            deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>'; // Set the button icon
            deleteBtn.title = "归档此光绘项目"; // Set the tooltip
            // Add a click event listener to the delete button, calling the deleteSession function, passing the session ID and event object
            deleteBtn.addEventListener('click', (e) => deleteSession(session.id, e));

            // Append the content wrapper and delete button to the list item
            listItem.appendChild(contentWrapper);
            listItem.appendChild(deleteBtn);

            // Add a click event listener to the entire list item
            listItem.addEventListener('click', () => {
                // If the clicked session is not the currently active session, switch to it
                if (state.currentSessionId !== session.id) switchSession(session.id, false);
            });
            // Append the created list item to the session list container (ul)
            dom.sessionList.appendChild(listItem);
        });
    }

    /**
     * Formats a timestamp into a user-friendly relative time string.
     * @param {number} dateTimestamp - The timestamp.
     * @returns {string} The formatted time string (e.g., "just now", "5 min ago", "yesterday", "10/26/2023").
     */
    function formatTimeSince(dateTimestamp) {
        const now = new Date(); // Get current time
        // Calculate the number of seconds passed since the given timestamp
        const secondsPast = (now.getTime() - dateTimestamp) / 1000;

        // Return different time formats based on the number of seconds passed
        if (secondsPast < 60) return '刚刚'; // Within 1 minute
        if (secondsPast < 3600) return `${Math.round(secondsPast / 60)}分前`; // Within 1 hour, show minutes
        if (secondsPast <= 86400) return `${Math.round(secondsPast / 3600)}时前`; // Within 24 hours, show hours

        // Calculate the number of days passed
        const daysPast = Math.round(secondsPast / 86400);
        if (daysPast === 1) return '昨天'; // 1 day ago
        if (daysPast < 7) return `${daysPast}天前`; // Within 7 days, show days

        // If more than 7 days ago
        const date = new Date(dateTimestamp); // Convert timestamp to Date object
        // If it's the same year, show month and day (e.g., "Oct 26")
        if (now.getFullYear() === date.getFullYear()) {
            return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        }
        // If it's a different year, show year, month, day (e.g., "23/Oct/26")
        return date.toLocaleDateString(undefined, { year: '2-digit', month: 'short', day: 'numeric' });
    }

    /**
     * Saves all current session data to localStorage.
     */
    function saveSessions() {
        try {
            // Convert the state.sessions object to a JSON string and store it in localStorage
            // Use APP_PREFIX as the key name to avoid conflicts with other applications or older versions
            localStorage.setItem(APP_PREFIX + 'sessions', JSON.stringify(state.sessions));
        } catch (e) {
            // If an error occurs during storage (e.g., localStorage is full)
            console.error("Error saving session data (墨迹归档不稳定):", e); // Log the error to the console
            showToast("未能持久化会话数据. 归档异常.", "error"); // Show a Toast notification informing the user
        }
    }

    /**
     * Loads session data from localStorage.
     */
    function loadSessions() {
        // Get the stored session data string from localStorage
        const storedSessions = localStorage.getItem(APP_PREFIX + 'sessions');
        // Initialize state.sessions to an empty object in case loading fails or there is no data
        state.sessions = {};
        // If session data exists in localStorage
        if (storedSessions) {
            try {
                // Parse the JSON string into an object
                const parsedSessions = JSON.parse(storedSessions);
                // Iterate through each key (session ID) of the parsed sessions object
                Object.keys(parsedSessions).forEach(id => {
                    const s = parsedSessions[id]; // Get the individual session object
                    // Validate the basic structure of the session object
                    if (s && typeof s.id === 'string' && typeof s.name === 'string' && Array.isArray(s.messages)) {
                        // If the structure is valid, add it to state.sessions
                        state.sessions[id] = {
                            id: s.id, // Session ID
                            name: s.name || "已归档项目", // Session name, use fallback name if empty
                            // Map and validate each message object in the messages array
                            messages: s.messages.map(m => ({
                                content: m.content || "", // Message content, empty string if null/undefined
                                sender: m.sender || "system", // Sender, defaults to "system" if null/undefined
                                timestamp: m.timestamp || Date.now(), // Timestamp, defaults to current time if null/undefined
                                isHTML: m.isHTML || false, // Is HTML content, defaults to false if null/undefined
                                attachments: m.attachments || [], // List of attachments, empty array if null/undefined
                                thinking: m.thinking || null, // Thinking process, null if null/undefined
                                rawResponseV1_3_2_CamelCase: m.rawResponseV1_3_2_CamelCase, // Raw camelCase JSON response (ensure version sync)
                                errorType: m.errorType, // Error type (may be undefined)
                            })),
                            createdAt: s.createdAt || Date.now(), // Creation timestamp, defaults to current time if null/undefined
                            lastActivity: s.lastActivity || Date.now(), // Last activity timestamp, defaults to current time if null/undefined
                        };
                    } else {
                        // If the session object structure is corrupted, log a warning
                        console.warn("发现损坏的光绘墨迹归档数据, 已跳过:", id, s);
                    }
                });
            } catch (e) {
                // If an error occurs while parsing the JSON string
                console.error("加载或解析会话数据失败 (归档损坏):", e); // Log the error to the console
                state.sessions = {}; // Reset state.sessions to an empty object
                localStorage.removeItem(APP_PREFIX + 'sessions'); // Remove the corrupted data from localStorage
                showToast("加载归档数据失败. 数据可能已损坏.", "error"); // Show a Toast notification
            }
        }
    }

    /**
     * Updates the expanded/collapsed state of the left sidebar.
     * @param {boolean} expand - Whether to expand or collapse.
     * @param {boolean} [instant=false] - Whether to update instantly without animation.
     */
    function updateSidebarState(expand, instant = false) {
        // Update the sidebar expanded state in the state
        state.isSidebarExpanded = expand;
        // Toggle the 'expanded' CSS class on the sidebar DOM element based on the expanded state
        dom.sidebar.classList.toggle('expanded', state.isSidebarExpanded);
        // If the left sidebar toggle button exists
        if (dom.leftSidebarToggle) {
            // Update its 'aria-expanded' attribute for accessibility
            dom.leftSidebarToggle.setAttribute('aria-expanded', state.isSidebarExpanded.toString());
            // Get the icon element within the toggle button
            const toggleIcon = dom.leftSidebarToggle.querySelector('i');
            // If the icon exists, update its CSS class based on the expanded state (toggle icon style like 'x' and 'bars')
            if (toggleIcon) {
                toggleIcon.className = state.isSidebarExpanded ? 'fas fa-times' : 'fas fa-bars';
            }
        }
        // Logic: If the sidebar is collapsed (isSidebarExpanded is false)
        // And the session manager is currently expanded (!state.isSessionManagerCollapsed is true)
        if (!state.isSidebarExpanded && !state.isSessionManagerCollapsed) {
            // Automatically collapse the session manager
            updateSessionManagerState(true, instant); // true means collapse, instant indicates whether to update immediately
        }
    }

    /**
     * Updates the collapsed/expanded state of the session manager.
     * @param {boolean} collapse - Whether to collapse or expand.
     * @param {boolean} [instant=false] - Whether to update instantly without animation.
     */
    function updateSessionManagerState(collapse, instant = false) {
        // Update the session manager collapsed state in the state
        state.isSessionManagerCollapsed = collapse;
        // Toggle the 'collapsed' CSS class on the session manager DOM element based on the collapsed state
        dom.sessionManager.classList.toggle('collapsed', state.isSessionManagerCollapsed);
        // Update the 'aria-expanded' attribute of the session manager toggle button (note: aria-expanded indicates if it is "expanded", so the value is opposite to collapse)
        dom.sessionManagerToggle.setAttribute('aria-expanded', (!state.isSessionManagerCollapsed).toString());
        // Get the icon element within the toggle button (usually a small arrow)
        const sessionToggleIcon = dom.sessionManagerToggle.querySelector('.toggle-icon');
        // If the icon exists, update its CSS class based on the collapsed state (toggle arrow direction)
        if (sessionToggleIcon) {
            sessionToggleIcon.className = state.isSessionManagerCollapsed ? 'fas fa-caret-right' : 'fas fa-caret-down';
        }
    }

    /**
     * Handles sending a message.
     * Constructs the message object, adds it to the current session, updates the UI, and sends it via WebSocket to the backend.
     */
    async function handleSendMessage() {
        // If the application is currently in a loading state (e.g., waiting for a reply from the previous request)
        if (state.isLoading) {
            showToast("Lumina核心正在处理上一指令. 请稍候...", "warning"); // Show a warning message
            return; // Prevent sending a new message
        }
        // Get the text content from the user input box and remove leading/trailing whitespace
        const messageText = dom.userInput.value.trim();
        // Copy the list of currently selected files to upload (using spread operator to create a shallow copy)
        const filesToSend = [...state.uploadedFiles];
        // If the message text is empty and no files have been selected
        if (messageText === '' && filesToSend.length === 0) {
            showToast("需要指令. 请输入指令或附加数据模块.", "warning"); // Show a warning message
            return; // Prevent sending an empty message
        }
        // If the number of characters in the user input exceeds the maximum limit
        if (dom.userInput.value.length > state.maxInputChars) {
            showToast(`指令缓冲区溢出. 最大 ${state.maxInputChars} 字符.`, "error"); // Show an error message
            return; // Prevent sending an over-limit message
        }
        // If the WebSocket is not connected or the connection state is not OPEN
        if (!websocket || websocket.readyState !== WebSocket.OPEN) {
            showToast("光绘链接离线. 尝试重新同步...", "warning"); // Show a warning message
            connectWebSocket(); // Attempt to reconnect the WebSocket
            return; // Prevent sending the message
        }
        // Set the application to a loading state (disables input etc.)
        setLoadingState(true);
        // Generate a new client request ID to track the response for this message
        state.currentClientRequestId = generateClientRequestId();
        // Clear any cached thinking process from the last response
        state.lastResponseThinking = null;

        // Construct the user message object for storage and display
        const currentUserMessage = {
            content: messageText, // Message text
            sender: 'user', // Sender is user
            timestamp: Date.now(), // Current timestamp
            isHTML: false, // Content is not HTML
            attachments: filesToSend.map(f => ({ name: f.name, size: f.size, type: f.type })) // Attachment information (name, size, type)
        };
        // Add this user message to the current session's message history (state and localStorage)
        addMessageToCurrentSession(currentUserMessage);
        // Append this user message to the chat interface for display
        appendMessage(messageText, 'user', false, null, false, currentUserMessage.attachments);

        // Auto-naming logic: If the current session object exists, the session name starts with "光绘墨迹项目 " (default name),
        // and this is the user's first message in this session (count of user messages is 1 after adding this one)
        const currentSession = state.sessions[state.currentSessionId];
        if (currentSession && currentSession.name.startsWith("光绘墨迹项目 ") && currentSession.messages.filter(m => m.sender === 'user').length === 1) {
            // Use the first 40 characters of the message text as the auto-generated name (default to "新墨迹" if empty)
            const autoName = messageText.substring(0, 40).trim() || "新墨迹";
            // Update the session name, add "..." if the message was longer than 40 characters
            currentSession.name = autoName + (messageText.length > 40 ? "..." : "");
            // Update the UI element displaying the session name
            dom.currentSessionNameDisplay.textContent = currentSession.name;
            // Re-render the session list to reflect the name change
            renderSessionList();
        }

        // Clear the input area:
        dom.userInput.value = ''; // Clear the user input box
        adjustTextareaHeight(); // Adjust the input box height
        updateCharCounter(); // Update the character counter
        closeFilePreview(); // Close the file preview area
        state.uploadedFiles = []; // Clear the list of selected files

        // Prepare and display the right process log sidebar:
        if (dom.processLogSidebarContent) dom.processLogSidebarContent.innerHTML = ''; // Clear log content
        showProcessLogSidebar(true); // Show and ensure the log sidebar is expanded

        // Construct the message content to send to the backend:
        let backendMessageContent = messageText; // Start with the user's input text
        // If there are attachments
        if (filesToSend.length > 0) {
            // Append file information to the message text, informing the backend about the attached files
            backendMessageContent += `\n[用户已附加数据模块: ${filesToSend.map(f => f.name).join(', ')}. 请基于这些模块名称处理指令.]`;
        }

        // Send the message to the backend via WebSocket
        sendWebSocketMessage({
            type: 'message', // Message type
            session_id: state.currentSessionId, // Current session ID
            request_id: state.currentClientRequestId, // Client request ID
            content: backendMessageContent, // Message content including file information
            mode: state.currentMode // Current application mode
        });
    }
    /**
     * Adds a message object to the current session's `messages` array and saves the sessions.
     * @param {object} messageObject - The message object to add.
     */
    function addMessageToCurrentSession(messageObject) {
        // Check if the current session exists in state.sessions
        if (state.sessions[state.currentSessionId]) {
            // If the message sender is not 'agent' (i.e., it's a user message or system message)
            // Delete fields specific to Agent responses to avoid unnecessarily storing them in non-Agent messages
            if (messageObject.sender !== 'agent') {
                delete messageObject.rawResponseV1_3_2_CamelCase; // Delete raw JSON response field
                delete messageObject.thinking; // Delete thinking process field
            }
            // If the message object does not have an errorType property (or it's null/undefined)
            // Delete the property from the object for data cleanliness
            if (messageObject.errorType === undefined || messageObject.errorType === null) {
                delete messageObject.errorType;
            }
            // Push the message object to the end of the current session's messages array
            state.sessions[state.currentSessionId].messages.push(messageObject);
            // Save all session data to localStorage to persist the changes
            saveSessions();
        } else {
            // If attempting to add a message to a non-existent session, log an error
            console.error("尝试向不存在的会话添加消息:", state.currentSessionId);
        }
    }
    /**
     * Handles the keypress event in the user input box.
     * If Enter is pressed (and Shift is not held), sends the message.
     * @param {KeyboardEvent} event - The keypress event object.
     */
    function handleUserInputKeypress(event) {
        // Check if the pressed key is 'Enter' and the Shift key is NOT simultaneously pressed
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault(); // Prevent the default behavior (e.g., inserting a newline in the textarea)
            handleSendMessage(); // Call the function to send the message
        }
    }

    /**
     * Appends a new message to the chat box.
     * @param {string} content - The message content.
     * @param {string} sender - The sender ('user', 'agent', 'system-info', 'error-system').
     * @param {boolean} [isHTML=false] - Is the content HTML?
     * @param {string|null} [thinkContent=null] - The agent's thinking process text (if applicable).
     * @param {boolean} [isSwitchingSession=false] - Is this being called while switching sessions (loading history)?
     * @param {Array} [attachments=[]] - List of attachments for the message.
     * @param {string|null} [errorType=null] - The error type of the message (if applicable).
     */
    function appendMessage(content, sender, isHTML = false, thinkContent = null, isSwitchingSession = false, attachments = [], errorType = null) {
        // Create the top-level div element for the message
        const messageDiv = document.createElement('div');
        // Determine the CSS class for the message based on the sender (e.g., 'message-user', 'message-agent')
        const messageSenderClass = `message-${sender}`;
        messageDiv.classList.add('message', messageSenderClass); // Add the generic 'message' class and the specific sender class
        // If an error type exists, add a CSS class based on the error type for potential specific styling
        if (errorType) {
            const errorClassSuffix = errorType.toLowerCase().replace(/\s+/g, '-'); // Convert error type to CSS class name (lowercase, spaces to hyphens)
            messageDiv.classList.add(`message-error-type-${errorClassSuffix}`);
        }
        // If it's a system info or system error message
        if (sender === 'system-info' || sender === 'error-system') {
            messageDiv.classList.add('system-message'); // Add the 'system-message' class
            if (sender === 'error-system') messageDiv.classList.add('error-message'); // If it's a system error, add the 'error-message' class as well
        }
        // Apply entry animation (if not loading history while switching sessions, and animation level is not 'none')
        if (!isSwitchingSession && state.animationLevel !== 'none') {
            // Choose different Animate.css classes based on the animation level
            const animationClass = state.animationLevel === 'full' ? 'animate__fadeInUp' : (state.animationLevel === 'basic' ? 'animate__fadeIn' : '');
            if (animationClass) { // If an animation class was chosen
                messageDiv.classList.add('animate__animated', animationClass); // Add animation classes
                // Set the animation duration
                messageDiv.style.setProperty('--animate-duration', state.animationLevel === 'full' ? '0.45s' : '0.35s');
            }
        }
        // Create the avatar div element
        const avatarDiv = document.createElement('div');
        avatarDiv.classList.add('message-avatar'); // Add the 'message-avatar' class
        // Choose different FontAwesome icons for the avatar based on the sender
        let avatarIcon = 'fas fa-question-circle'; // Default icon
        if (sender === 'user') avatarIcon = 'fas fa-user-pen'; // User icon
        else if (sender === 'agent') avatarIcon = 'fas fa-lightbulb'; // Agent icon
        else if (sender === 'system-info') avatarIcon = 'fas fa-info-circle'; // System info icon
        else if (sender === 'error-system') avatarIcon = 'fas fa-exclamation-triangle'; // System error icon
        avatarDiv.innerHTML = `<i class="${avatarIcon}"></i>`; // Set the HTML content for the avatar icon

        // Determine the order of avatar and message bubble based on the sender (Agent-like messages have avatar first, user messages have avatar last)
        if (sender === 'agent' || sender === 'system-info' || sender === 'error-system') {
            messageDiv.appendChild(avatarDiv); // Append the avatar to the beginning of the message div
        }

        // Create the message bubble div element
        const messageBubbleDiv = document.createElement('div');
        messageBubbleDiv.classList.add('message-bubble'); // Add the 'message-bubble' class
        // Create the message content wrapper div element (to contain thinking process and main content)
        const messageContentWrapper = document.createElement('div');
        messageContentWrapper.classList.add('message-content-wrapper');

        // If it's an Agent message, and there is thinking content (thinkContent), AND the user setting allows showing thinking process in chat bubbles
        if (sender === 'agent' && thinkContent && state.showChatBubblesThink) {
            // Create the div element to display the thinking process prefix and content
            const thinkPrefixDiv = document.createElement('div');
            thinkPrefixDiv.classList.add('message-thought-prefix'); // Add specific class name
            // Format the thinking content: replace newline characters with <br>
            let formattedThink = String(thinkContent).replace(/\n/g, '<br>');
            // Define a regular expression to match JSON code blocks (case-insensitive, dotall for newlines)
            const jsonBlockRegex = /```json\s*([\s\S]*?)\s*```/gi;
            // Replace JSON code blocks within the thinking content with formatted <pre><code> blocks
            formattedThink = formattedThink.replace(jsonBlockRegex, (match, jsonContentStr) => {
                const trimmedJson = jsonContentStr.trim(); // Trim leading/trailing whitespace from JSON content
                try {
                    const parsedJson = JSON.parse(trimmedJson); // Parse the JSON
                    // Format the parsed JSON object into a string with indentation (2 spaces), and escape HTML special characters
                    const escapedJsonString = JSON.stringify(parsedJson, null, 2)
                        .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    // Return the formatted HTML using <pre> and <code> tags with the embedded-json class
                    return `<pre class="embedded-json"><code>${escapedJsonString}</code></pre>`;
                } catch (e) {
                    // If JSON parsing fails, log a warning to the console
                    console.warn("Chat bubble: JSON parsing for pretty print failed within thought:", e);
                    // Escape HTML special characters from the original JSON content
                    const escapedOriginalJson = trimmedJson.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    // Return HTML containing the original content and an error message, styled as an error embedded JSON block
                    return `<pre class="embedded-json error"><code>${escapedOriginalJson}<br>(无效JSON投影)</code></pre>`;
                }
            });
            // Set the HTML content of the thinking process prefix div, including the label and formatted thinking text
            thinkPrefixDiv.innerHTML = `<strong><i class="fas fa-brain"></i> AI思维墨迹:</strong><div class="think-bubble-content">${formattedThink}</div>`;
            // Append the thinking process prefix div to the message content wrapper
            messageContentWrapper.appendChild(thinkPrefixDiv);
        }

        // Create the div element to display the main message text content
        const textContentDiv = document.createElement('div');
        textContentDiv.classList.add('message-text-content'); // Add specific class name
        // If the content is HTML (isHTML is true)
        if (isHTML) {
            textContentDiv.innerHTML = content; // Directly insert the HTML content
        } else { // If the content is plain text
            // Define a regular expression to match URLs
            const urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
            // Process the plain text: escape HTML special characters, replace newlines with <br>, and convert URLs to clickable links
            const linkedContent = String(content)
                .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") // Escape &, <, >
                .replace(/"/g, "&quot;").replace(/'/g, "&#39;") // Escape ", '
                .replace(/\n/g, '<br>') // Replace newline characters with <br> tags
                .replace(urlRegex, (url) => `<a href="${url}" target="_blank" rel="noopener noreferrer" class="external-link"><i class="fas fa-external-link-alt"></i> ${url}</a>`); // Convert URLs to links
            textContentDiv.innerHTML = linkedContent; // Set the processed text content
        }
        // Append the main text content div to the message content wrapper
        messageContentWrapper.appendChild(textContentDiv);

        // If the message includes attachments (attachments array is not empty)
        if (attachments && attachments.length > 0) {
            // Create the div element to display the attachment summary
            const attachmentsDiv = document.createElement('div');
            attachmentsDiv.classList.add('message-attachments-summary'); // Add specific class name
            // Set the initial HTML content for the attachment summary, including an icon and attachment count
            attachmentsDiv.innerHTML = `<i class="fas fa-paperclip"></i> 数据模块已附加 (${attachments.length}): `;
            // Iterate through each attachment
            attachments.forEach(file => {
                // Create a span element to act as a "chip" or "tag" for the filename
                const fileChip = document.createElement('span');
                fileChip.classList.add('filename-chip'); // Add specific class name
                fileChip.textContent = file.name; // Set the chip text to the filename
                // Set the title attribute (tooltip) of the chip, showing detailed file information (name, size, type)
                fileChip.title = `${file.name} (${(file.size / 1024).toFixed(1)}KB, 类型: ${file.type || '未知'})`;
                // Append the filename chip to the attachment summary div
                attachmentsDiv.appendChild(fileChip);
            });
            // Append the attachment summary div to the message content wrapper
            messageContentWrapper.appendChild(attachmentsDiv);
        }
        // Append the content wrapper to the message bubble
        messageBubbleDiv.appendChild(messageContentWrapper);
        // Append the message bubble to the message div (after the avatar for Agent-like messages)
        messageDiv.appendChild(messageBubbleDiv);

        // If it's a user message
        if (sender === 'user') {
            messageDiv.appendChild(avatarDiv); // Append the avatar to the end of the message div
        }

        // Append the entire message div (including avatar and bubble) to the chat box (dom.chatBox)
        dom.chatBox.appendChild(messageDiv);
        // Attach event listeners for any quick action buttons within the newly appended message
        attachQuickActionButtonListeners(messageDiv);
        // If it's not loading history while switching sessions (i.e., it's a newly sent or received message)
        if (!isSwitchingSession) { scrollToBottom(); } // Scroll the chat box to the bottom
    }

    /**
     * Appends the initial welcome message to the chat box.
     * Only called if the chat box is empty.
     */
    function appendWelcomeMessage() {
        // Get the last child element in the chat box (i.e., the last message)
        const lastMessage = dom.chatBox.lastElementChild;
        // If the last message exists and it is already the initial welcome message (checked by class name), do not add it again
        if (lastMessage && lastMessage.classList.contains('system-message-initial')) { return; }

        // Define the HTML content string for the welcome message
        const welcomeHTML = `
            <div class="message-content">
                <div class="welcome-header">
                    <!-- Robot icon with animation -->
                    <i class="fas fa-dna robot-icon animate__animated animate__pulse animate__infinite" style="--animate-duration: 3.5s;"></i>
                    <!-- App title and version -->
                    <h2>CircuitManus <span class="version-pro">Lumina <span class="version-number">v1.0.0</span></span></h2> <!-- Version sync -->
                </div>
                <!-- Subtitle -->
                <p class="welcome-subtitle">您的光绘墨迹交互界面，赋能创意与构想。Lumina核心已激活，请挥洒您的灵感。</p>
                <!-- Capabilities display -->
                <div class="capabilities">
                    <div class="capability"><i class="fas fa-lightbulb"></i><span>灵感激发</span></div>
                    <div class="capability"><i class="fas fa-drafting-compass"></i><span>草图勾勒</span></div>
                    <div class="capability"><i class="fas fa-palette"></i><span>色彩构想</span></div>
                    <div class="capability"><i class="fas fa-code"></i><span>代码生成</span></div>
                    <div class="capability"><i class="fas fa-microchip"></i><span>电路设计</span></div>
                    <div class="capability"><i class="fas fa-project-diagram"></i><span>流程规划</span></div>
                    <div class="capability"><i class="fas fa-feather-alt"></i><span>文本创作</span></div>
                    <div class="capability"><i class="fas fa-search"></i><span>信息检索</span></div>
                </div>
                 <!-- Quick actions area -->
                 <div class="quick-actions">
                    <p>开始您的创作或选择预设指令:</p>
                    <ul>
                        <!-- Various quick action buttons -->
                        <li><a href="#" class="quick-action-btn lumina-button" data-message="设计一个简约的LOGO"><i class="fas fa-signature"></i> 设计LOGO</a></li>
                        <li><a href="#" class="quick-action-btn lumina-button" data-message="写一首关于星空的短诗"><i class="fas fa-moon"></i> 星空诗篇</a></li>
                        <li><a href="#" class="quick-action-btn lumina-button" data-message="帮我规划一个旅行日程"><i class="fas fa-map-signs"></i> 旅行规划</a></li>
                        <li><a href="#" class="quick-action-btn lumina-button" data-message="描述当前的电路状态"><i class="fas fa-eye"></i> 查看电路</a></li>
                        <li><a href="#" class="quick-action-btn lumina-button" data-message="清空所有元件和连接"><i class="fas fa-eraser"></i> 清空画布</a></li>
                        <li><a href="#" class="quick-action-btn lumina-button" data-message="解释什么是人工智能"><i class="fas fa-brain"></i> AI释义</a></li>
                        <li><a href="#" class="quick-action-btn lumina-button" data-message="新建一个光绘项目"><i class="fas fa-plus-square"></i> 新建项目</a></li>
                        <li><a href="#" class="quick-action-btn lumina-button" data-message="切换到代码绘卷模式"><i class="fas fa-laptop-code"></i> 代码模式</a></li>
                    </ul>
                 </div>
            </div>
        `;
        // Create the top-level div element for the welcome message
        const welcomeDiv = document.createElement('div');
        // Choose the entry animation class based on the animation level
        const animClass = state.animationLevel !== 'none' ? (state.animationLevel === 'full' ? 'animate__fadeInUp' : 'animate__fadeIn') : '';
        // Set the CSS classes for the welcome message div, including base classes, system message class, initial message class, panel class, and animation class
        welcomeDiv.className = `message system-message system-message-initial lumina-panel ${animClass ? 'animate__animated ' + animClass : ''}`;
        // If an animation class was applied, set the animation duration
        if (animClass) welcomeDiv.style.setProperty('--animate-duration', '0.65s');
        // Set the HTML content of the welcome message div
        welcomeDiv.innerHTML = welcomeHTML;
        // Append the welcome message div to the chat box
        dom.chatBox.appendChild(welcomeDiv);
        // Attach event listeners for quick action buttons within the welcome message
        attachQuickActionButtonListeners(welcomeDiv);
    }

    /**
     * Scrolls the chat box to the bottom.
     * @param {boolean} [instant=false] - Whether to scroll instantly without smooth effect.
     */
    function scrollToBottom(instant = false) {
        // Only execute if state.autoScroll (automatic scrolling) is true
        if (state.autoScroll) {
            // Determine the scroll behavior ('auto' for instant scroll, 'smooth' for smooth scroll) based on the instant parameter and the application's animation level
            const behavior = instant || state.animationLevel === 'none' ? 'auto' : 'smooth';
            // Call the scrollTo method on the chat box (dom.chatBox), scrolling it to the very bottom of its content
            dom.chatBox.scrollTo({ top: dom.chatBox.scrollHeight, behavior: behavior });
        }
    }

    /**
     * Displays the typing indicator for the Agent.
     */
    function showTypingIndicator() {
        // If the Agent is already in typing state (state.isAgentTyping is true), do not add the indicator again
        if (state.isAgentTyping) return;
        // Set the Agent to typing state
        state.isAgentTyping = true;
        // Create the top-level div element for the typing indicator
        const typingDiv = document.createElement('div');
        typingDiv.id = 'typing-indicator'; // Set an ID for easy lookup and removal later
        // Choose the entry animation class based on the animation level
        const animationClass = state.animationLevel !== 'none' ? 'animate__fadeInUp' : '';
        // Add base CSS classes ('message', 'message-agent', 'typing-indicator')
        typingDiv.classList.add('message', 'message-agent', 'typing-indicator');
        // If an animation class was chosen
        if (animationClass) {
            typingDiv.classList.add('animate__animated', animationClass); // Add animation class
            typingDiv.style.setProperty('--animate-duration', '0.4s'); // Set animation duration
        }
        // Create the avatar div element
        const avatarDiv = document.createElement('div');
        avatarDiv.classList.add('message-avatar'); // Add the 'message-avatar' class
        // Set the Agent avatar icon (lightbulb, with pulsing effect)
        avatarDiv.innerHTML = '<i class="fas fa-lightbulb fa-beat"></i>';
        // Create the message bubble div element
        const bubbleDiv = document.createElement('div');
        bubbleDiv.classList.add('message-bubble'); // Add the 'message-bubble' class
        // Create the message content wrapper div element
        const contentWrapper = document.createElement('div');
        contentWrapper.classList.add('message-content-wrapper');
        // Create the div element to display the text content
        const textContent = document.createElement('div');
        textContent.classList.add('message-text-content');
        // Create the HTML for three dynamic dots (...)
        let dotsHTML = Array(3).fill('<span class="typing-dot"></span>').join('');
        // Set the text content of the typing indicator, including "Lumina核心构思中" and the dynamic dots
        textContent.innerHTML = `Lumina核心构思中<span class="typing-dots">${dotsHTML}</span>`;
        // Assemble elements: text content -> content wrapper -> bubble
        contentWrapper.appendChild(textContent);
        bubbleDiv.appendChild(contentWrapper);
        // Assemble the message: avatar -> bubble -> typing indicator top-level div
        typingDiv.appendChild(avatarDiv);
        typingDiv.appendChild(bubbleDiv);
        // Append the typing indicator to the chat box
        dom.chatBox.appendChild(typingDiv);
        // Scroll the chat box to the bottom to ensure the typing indicator is visible
        scrollToBottom();
    }
    /**
     * Hides the typing indicator for the Agent.
     */
    function hideTypingIndicator() {
        // If the Agent is not currently in typing state (state.isAgentTyping is false), do nothing
        if (!state.isAgentTyping) return;
        // Set the Agent to not typing state
        state.isAgentTyping = false;
        // Find the typing indicator element by its ID
        const typingElement = document.getElementById('typing-indicator');
        // If the typing indicator element is found
        if (typingElement) {
            // If animations are enabled (state.animationLevel is not 'none')
            if (state.animationLevel !== 'none') {
                // Choose the exit animation class based on the animation level
                const animationOutClass = state.animationLevel === 'full' ? 'animate__fadeOutDown' : 'animate__fadeOut';
                // Remove any potential entry animation classes
                typingElement.classList.remove('animate__fadeInUp', 'animate__fadeIn');
                // Add the Animate.css exit animation class
                typingElement.classList.add('animate__animated', animationOutClass);
                // Set the duration of the exit animation
                typingElement.style.setProperty('--animate-duration', '0.3s');
                // Listen for the animation end event, remove the element after the animation finishes (once: true means the event triggers only once)
                typingElement.addEventListener('animationend', () => typingElement.remove(), { once: true });
            } else {
                // If animations are not enabled, remove the typing indicator element directly
                typingElement.remove();
            }
        }
    }
    /**
     * Adjusts the height of the user input textarea based on its content.
     */
    function adjustTextareaHeight() {
        // First, set the textarea's height to 'auto' so that scrollHeight reflects the actual content height needed
        dom.userInput.style.height = 'auto';
        // Get the actual scroll height of the textarea's content
        let scrollHeight = dom.userInput.scrollHeight;
        // Get the max height limit for the textarea from CSS, default to 200px if not defined
        const maxHeight = parseInt(getComputedStyle(dom.userInput).maxHeight, 10) || 200;
        // Get the min height limit for the textarea from CSS, default to 52px (ensure a default value)
        const minHeight = parseInt(getComputedStyle(dom.userInput).minHeight, 10) || 52;

        // Define extra space to simulate vertical padding for single-line text, improving visual appearance
        const singleLinePadding = 5;
        // Check if it's a single line of text (by checking for newline characters) AND the actual content height is less than the minimum height plus the simulated vertical padding
         // This condition aims to avoid adding extra height unnecessarily when the minHeight is already sufficient for single-line text plus its actual CSS padding
        if (dom.userInput.value.split('\n').length <= 1 && scrollHeight < minHeight + singleLinePadding * 2) {
            // If this is the case, add the simulated padding to the scrollHeight
            scrollHeight += singleLinePadding;
        }


        // If the calculated content height exceeds the maximum height limit
        if (scrollHeight > maxHeight) {
            // Set the textarea's height to the maximum height
            dom.userInput.style.height = maxHeight + 'px';
            // Show the vertical scrollbar
            dom.userInput.style.overflowY = 'auto';
        } else { // If the content height is within the limits
            // Set the textarea's height to the greater of scrollHeight and minHeight (ensuring it's not less than the minimum height)
            dom.userInput.style.height = Math.max(scrollHeight, minHeight) + 'px';
            // Hide the vertical scrollbar
            dom.userInput.style.overflowY = 'hidden';
        }
    }

    /**
     * Handles clearing the current chat history.
     */
    function handleClearCurrentChat() {
        // If there is no current active session ID, or the session does not exist in state.sessions, do nothing
        if (!state.currentSessionId || !state.sessions[state.currentSessionId]) return;
        // Show a confirmation dialog asking the user if they are sure they want to clear the current session's chat history
        // The prompt message includes the name of the current session
        if (!confirm(`清空当前光绘墨迹项目 "${state.sessions[state.currentSessionId].name}"? 这将清除所有消息记录.`)) {
            return; // If the user cancels, return
        }
        // Clear the message array of the current session
        state.sessions[state.currentSessionId].messages = [];
        // Update the last activity timestamp for the current session to the current time
        state.sessions[state.currentSessionId].lastActivity = Date.now();
        // Save all session data (because messages have been cleared)
        saveSessions();
        // Clear the UI display of the chat box
        dom.chatBox.innerHTML = '';
        // Display the welcome message in the empty chat box
        appendWelcomeMessage();
        // Clear and hide the right process log sidebar
        if (dom.processLogSidebarContent) dom.processLogSidebarContent.innerHTML = ''; // Clear log content
        // Depending on its current visibility state, decide whether to show or hide it
        if (state.isProcessLogSidebarVisible) {
            showProcessLogSidebar(false); // If visible, show (do not force expand)
        } else {
            hideProcessLogSidebar(); // If not visible, hide
        }
        // Show a Toast notification informing the user that the current session has been cleared
        showToast('当前光绘墨迹项目已清空!', 'info');
        // Re-render the session list (might affect the display order based on "last activity time")
        renderSessionList();
    }

    /**
     * Handles switching between application modes (e.g., chat, code, circuit).
     * @param {string} newMode - The new mode to switch to.
     */
    function handleModeChange(newMode) {
        // If the new mode to switch to is the same as the current mode, do nothing
        if (state.currentMode === newMode) return;

        // Update the active state of the sidebar buttons:
        // Iterate through all sidebar buttons (dom.sidebarButtons)
        dom.sidebarButtons.forEach(button =>
            // Toggle the 'active' CSS class: add 'active' class if the button's data-mode attribute value matches newMode, otherwise remove it
            button.classList.toggle('active', button.dataset.mode === newMode)
        );
        // Update the current mode in the state
        state.currentMode = newMode;
        // Log that the mode has been switched
        console.log(`模式已切换至: ${newMode}`);
        // Show a Toast notification informing the user that they have switched to the new mode (using getModeDisplayName to get the display name of the mode)
        showToast(`已切换至 ${getModeDisplayName(newMode)} 领域`, 'info');

        // Update the placeholder text of the user input box to reflect the new mode and current session name
        const sessionNameForPlaceholder = state.sessions[state.currentSessionId]?.name || '当前项目';
        dom.userInput.placeholder = `向Lumina核心发送指令 (${getModeDisplayName(state.currentMode)}模式，当前项目: ${sessionNameForPlaceholder})...`;
    }

    /**
     * Handles the file selection event.
     * Validates the number and size of files and adds valid files to the upload list and preview area.
     * @param {Event} event - The change event object from the file input.
     */
    function handleFileSelection(event) {
        // Get the selected files from the event object's target.files and convert them to a real array
        const files = Array.from(event.target.files);
        // If no files were selected, do nothing
        if (files.length === 0) return;
        // Define limits for file upload: maximum 5 files, maximum 2MB per file
        const MAX_FILES = 5;
        const MAX_SIZE_MB = 2;
        // Iterate through each selected file
        files.forEach(file => {
            // Check if the number of currently selected files to upload has reached the limit
            if (state.uploadedFiles.length >= MAX_FILES) {
                // If the limit is reached, show a warning Toast notification and stop processing subsequent files
                showToast(`每次传输最多允许 ${MAX_FILES} 个数据卷轴.`, 'warning');
                return; // Note: this return statement only skips the current iteration of the forEach loop, it does not exit the entire function
            }
            // Check if the size of the current file exceeds the limit (MAX_SIZE_MB converted to bytes)
            if (file.size > MAX_SIZE_MB * 1024 * 1024) {
                // If the size limit is exceeded, show a warning Toast notification and skip this file
                showToast(`数据卷轴 "${file.name}" 大小超过 ${MAX_SIZE_MB}MB 限制.`, 'warning');
                return; // Skip processing of the current file
            }
            // Check if a file with the same name and size has already been added (simple deduplication logic)
            if (!state.uploadedFiles.find(f => f.name === file.name && f.size === file.size)) {
                // If the file has not been added before, add it to the state.uploadedFiles array
                state.uploadedFiles.push(file);
                // Add the file to the UI's file preview area
                addFileToPreview(file);
            } else {
                // If the file has already been added, show an info Toast notification
                showToast(`数据卷轴 "${file.name}" 已在队列中.`, 'info');
            }
        });
        // If the upload file list is not empty (i.e., at least one file was selected and passed validation)
        if (state.uploadedFiles.length > 0) {
            // Show the file preview area (by adding the 'active' CSS class)
            dom.filePreviewArea.classList.add('active');
        }
        // Clear the value of the file input, so the user can select the same file again next time (otherwise the change event might not trigger)
        dom.fileInput.value = '';
    }
    /**
     * Adds a selected file to the UI's file preview area.
     * @param {File} file - The file object to add to the preview.
     */
    function addFileToPreview(file) {
        // Create a new div element as a file preview item
        const fileItem = document.createElement('div');
        fileItem.classList.add('file-item'); // Add base CSS class
        // If animations are enabled (state.animationLevel is not 'none')
        if (state.animationLevel !== 'none') {
            // Add Animate.css entry animation class (bounce in)
            fileItem.classList.add('animate__animated', 'animate__bounceIn');
            // Set the animation duration
            fileItem.style.setProperty('--animate-duration', '0.4s');
        }
        // Store the filename and file size in data-* attributes of the element for easy lookup and removal later
        fileItem.dataset.fileName = file.name;
        fileItem.dataset.fileSize = file.size;
        // Get the corresponding FontAwesome icon class based on the file type and name
        const iconClass = getFileIconClass(file.type, file.name);
        // Set the HTML content of the file preview item, including icon, filename, and remove button
        // The title attribute of the filename span displays detailed file information (name, size, type)
        fileItem.innerHTML = `
            <i class="fas ${iconClass} file-icon"></i>
            <span class="file-name" title="${file.name} (${(file.size / 1024).toFixed(1)}KB, 类型: ${file.type || '未知'})">${file.name}</span>
            <button class="file-remove icon-btn" title="移除数据卷轴"><i class="fas fa-times-circle"></i></button>`;
        // Add a click event listener to the remove button within the preview item
        fileItem.querySelector('.file-remove').addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent event propagation to the parent element (the file item itself)
            // Call the removeFileFromPreview function, passing the filename and size to remove this file
            removeFileFromPreview(file.name, file.size);
        });
        // Append the created file preview item to the file preview content area (dom.filePreviewContent)
        dom.filePreviewContent.appendChild(fileItem);
    }
    /**
     * Gets the corresponding FontAwesome icon class based on the file type and name.
     * @param {string} fileType - The MIME type of the file.
     * @param {string} fileName - The name of the file.
     * @returns {string} The FontAwesome icon class name.
     */
    function getFileIconClass(fileType, fileName) {
        // Determine common file types based on MIME type
        if (fileType.startsWith('image/')) return 'fa-file-image'; // Image files
        if (fileType.startsWith('audio/')) return 'fa-file-audio'; // Audio files
        if (fileType.startsWith('video/')) return 'fa-file-video'; // Video files
        if (fileType === 'application/pdf') return 'fa-file-pdf'; // PDF files
        // Determine compressed files based on MIME type or file extension
        if (fileType === 'application/zip' || fileName.endsWith('.zip') || fileName.endsWith('.rar') || fileName.endsWith('.7z')) return 'fa-file-archive';

        // Get the file extension (converted to lowercase)
        const ext = fileName.slice(fileName.lastIndexOf(".")).toLowerCase();
        // Define arrays of common code and text file extensions
        const codeExtensions = ['.js', '.ts', '.py', '.java', '.c', '.cpp', '.h', '.hpp', '.cs', '.html', '.css', '.json', '.xml', '.yaml', '.yml', '.sh', '.bat', '.v', '.sv', '.vhd', '.md', '.txt', '.log', '.sch', '.brd', '.cir', '.net', '.vhd'];
        // If the file extension is in the array, or the MIME type includes 'text', consider it a code/text file
        if (codeExtensions.includes(ext) || fileType.includes('text')) return 'fa-file-code';
        // Office document type determination
        if (['.doc', '.docx'].includes(ext)) return 'fa-file-word'; // Word documents
        if (['.xls', '.xlsx', '.csv'].includes(ext)) return 'fa-file-excel'; // Excel or CSV files
        if (['.ppt', '.pptx'].includes(ext)) return 'fa-file-powerpoint'; // PowerPoint files
        // CAD file type determination (example)
        if (['.dwg', '.dxf'].includes(ext)) return 'fa-drafting-compass'; // CAD files (using drafting compass icon)
        // If none of the above conditions are met, return the default file icon
        return 'fa-file-alt';
    }
    /**
     * Removes the specified file from the upload list and UI preview.
     * @param {string} fileName - The name of the file to remove.
     * @param {number} fileSize - The size of the file to remove (used to distinguish files with the same name).
     */
    function removeFileFromPreview(fileName, fileSize) {
        // Filter out files from the state.uploadedFiles array that match the given filename and size
        // Use filter to create a new array that does not include the file to be removed
        state.uploadedFiles = state.uploadedFiles.filter(f => !(f.name === fileName && f.size === fileSize));
        // Find the corresponding file preview item element from the DOM
        // Use CSS.escape(fileName) to correctly handle potential special CSS selector characters in the filename
        const fileItemElement = dom.filePreviewContent.querySelector(`.file-item[data-file-name="${CSS.escape(fileName)}"][data-file-size="${fileSize}"]`);

        // If the corresponding DOM element is found
        if (fileItemElement) {
            // If animations are enabled (state.animationLevel is not 'none')
            if (state.animationLevel !== 'none') {
                // Remove any potential entry animation classes (bounceIn)
                fileItemElement.classList.remove('animate__bounceIn');
                // Add Animate.css exit animation class (bounce out)
                fileItemElement.classList.add('animate__animated', 'animate__bounceOut');
                // Listen for the animation end event
                fileItemElement.addEventListener('animationend', () => {
                    // After the animation finishes, check again if the Toast is still in the DOM (in case it was removed by other means during the animation)
                    if (fileItemElement.parentElement) {
                         fileItemElement.remove(); // Remove the DOM element
                         // If the upload file list is empty after removal, close (hide) the file preview area
                         if (state.uploadedFiles.length === 0) closeFilePreview();
                    }
                }, { once: true }); // once: true means the event triggers only once
            } else {
                // If animations are not enabled, remove the DOM element directly
                fileItemElement.remove();
                // If the upload file list is empty after removal, close the file preview area
                if (state.uploadedFiles.length === 0) closeFilePreview();
            }
        }
    }
    /**
     * Closes the file preview area.
     * It is hidden by removing the 'active' CSS class.
     */
    function closeFilePreview() { dom.filePreviewArea.classList.remove('active'); }

    /**
     * Applies the currently selected theme (light, dark, or auto).
     * This function primarily switches the theme by setting the `data-theme` attribute on the `body` element and related active classes.
     * It's a simple wrapper around `applyTheme` used to apply the current theme in state when the specific theme name isn't known but the current state needs to be applied.
     */
    function applyCurrentTheme() { applyTheme(state.currentTheme, true); } // true indicates initial load

    /**
     * Applies the specified theme.
     * @param {string} themeName - The name of the theme to apply ('light-crystal', 'dark-crystal', 'auto-crystal').
     * @param {boolean} [initialLoad=false] - Whether this is the initial load.
     */
    function applyTheme(themeName, initialLoad = false) {
        // Get the body element
        const body = document.body;
        // Remove any previously added theme active classes ('light-crystal-active', 'dark-crystal-active')
        body.classList.remove('light-crystal-active', 'dark-crystal-active');
        // Get the icon element within the theme toggle button
        const themeIcon = dom.themeToggleButton.querySelector('i');
        // Check and handle based on the themeName
        if (themeName === 'auto-crystal') { // If in auto mode
            // Check if the system prefers dark mode
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                body.classList.add('dark-crystal-active'); // System prefers dark, apply dark theme active class
            } else {
                body.classList.add('light-crystal-active'); // System prefers light or is unknown, apply light theme active class
            }
            // If the theme icon exists, set its class name to magic wand icon (indicating auto)
            if (themeIcon) themeIcon.className = 'fas fa-magic';
        } else if (themeName === 'dark-crystal') { // If in dark mode
            body.classList.add('dark-crystal-active'); // Apply dark theme active class
            // If the theme icon exists, set its class name to sun icon (indicating toggle to light)
            if (themeIcon) themeIcon.className = 'fas fa-sun';
        } else { // Default to light mode (light-crystal)
            body.classList.add('light-crystal-active'); // Apply light theme active class
            // If the theme icon exists, set its class name to moon icon (indicating toggle to dark)
            if (themeIcon) themeIcon.className = 'fas fa-moon';
        }
        // Set the 'data-theme' attribute on the body element with the theme name
        // This attribute is primarily used for CSS variable switching, e.g.: :root[data-theme="dark-crystal"] { --primary-color: ...; }
        body.dataset.theme = themeName;
        // Update the current theme name in the state
        state.currentTheme = themeName;
        // If the theme select dropdown in the settings modal exists, sync its value
        if (dom.themeSelect) dom.themeSelect.value = themeName;
        // If it's not initial load (i.e., user manually switched theme)
        if (!initialLoad) saveSettings(); // Save settings to localStorage
        // Log the applied theme information to the console
        console.log(`显示模式已设定为: ${themeName} (实际生效类: ${body.className.match(/(light|dark)-crystal-active/)?.[0] || '无特定激活类'})`);
    }

    /**
     * Gets the user-friendly display name for a theme.
     * @param {string} theme - The internal identifier of the theme.
     * @returns {string} The display name of the theme.
     */
    function getThemeDisplayName(theme) {
        // Define an object storing theme identifiers and their corresponding user-friendly display names
        const names = {
            'light-crystal': '月白宣纸 (Light)', // Light theme
            'dark-crystal': '墨黑星空 (Dark)',   // Dark theme
            'auto-crystal': '随境而变 (Auto)'    // Auto theme
        };
        // Return the display name for the corresponding theme, default to '未知意境' if not found
        return names[theme] || '未知意境';
    }
    /**
     * Applies the specified font size.
     * @param {string|number} size - The font size value (typically in pixels).
     */
    function applyFontSize(size) {
        // Convert the size parameter to an integer
        const newSize = parseInt(size, 10);
        // Validate if the font size is within a reasonable range (12px to 20px)
        // If it's not a number, or less than 12, or greater than 20
        if (isNaN(newSize) || newSize < 12 || newSize > 20) {
            // Revert to default font size (16px)
            document.documentElement.style.setProperty('--base-font-size', '16px');
            // If the font size input (range slider) in the settings modal exists, set its value to '16'
            if (dom.fontSizeInput) dom.fontSizeInput.value = '16';
            // If the font size value display element exists, set its text content to '16px'
            if (dom.fontSizeValue) dom.fontSizeValue.textContent = '16px';
            return; // End function execution
        }
        // If the font size is valid, set the CSS variable '--base-font-size'
        document.documentElement.style.setProperty('--base-font-size', `${newSize}px`);
        // Update the UI controls in the settings modal (if they exist):
        // Set the value of the font size input (range slider)
        if (dom.fontSizeInput) dom.fontSizeInput.value = newSize;
        // Set the text content of the font size value display element
        if (dom.fontSizeValue) dom.fontSizeValue.textContent = `${newSize.toFixed(0)}px`;
    }
    /**
     * Applies the specified animation level.
     * @param {string} level - The animation level ('full', 'basic', 'none').
     */
    function applyAnimationLevel(level) {
        // Set the 'data-animation-level' attribute on the body element with the specified level
        // CSS can use this attribute to control different levels of animation effects, e.g.:
        // body[data-animation-level="none"] .animate__animated { animation: none !important; }
        document.body.dataset.animationLevel = level;
        // Update the current animation level in the state
        state.animationLevel = level;
        // Update the value of the animation level select dropdown in the settings modal (if it exists and is different from the current level)
        if (dom.animationLevelSelect && dom.animationLevelSelect.value !== level) {
            dom.animationLevelSelect.value = level;
        }
        // Log the applied animation level
        console.log(`动态效果等级已设定为: ${level}`);
    }

    /**
     * Opens the settings modal and loads the current settings into the UI controls.
     */
    function openSettingsModal() {
        // Load the current settings from the application state into the various UI controls in the modal:
        // Set the value of the theme select dropdown
        if (dom.themeSelect) dom.themeSelect.value = state.currentTheme;
        // Get the currently effective font size (read from CSS variable to ensure accuracy)
        const currentFontSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-font-size').replace('px', '')) || 16;
        // Set the value of the font size input (range slider)
        if (dom.fontSizeInput) dom.fontSizeInput.value = currentFontSize;
        // Set the text content of the font size value display element
        if (dom.fontSizeValue) dom.fontSizeValue.textContent = `${currentFontSize.toFixed(0)}px`;
        // Set the value of the animation level select dropdown
        if (dom.animationLevelSelect) dom.animationLevelSelect.value = state.animationLevel;
        // Set the checked state of the auto-scroll toggle (checkbox)
        if (dom.autoScrollToggle) dom.autoScrollToggle.checked = state.autoScroll;
        // Set the checked state of the sound enabled toggle
        if (dom.soundEnabledToggle) dom.soundEnabledToggle.checked = state.soundEnabled;
        // Set the checked state of the "show thinking process in chat bubbles" toggle
        if (dom.showChatBubblesThinkToggle) dom.showChatBubblesThinkToggle.checked = state.showChatBubblesThink;
        // Set the checked state of the "show thinking bubble in log entries" toggle
        if (dom.showLogBubblesThinkToggle) dom.showLogBubblesThinkToggle.checked = state.showLogBubblesThink;
        // Set the checked state of the "auto-submit quick actions" toggle
        if (dom.autoSubmitQuickActionsToggle) dom.autoSubmitQuickActionsToggle.checked = state.autoSubmitQuickActions;
        // Set the checked state of the "3D component visibility" toggle
        if (dom.componentVisibilityToggle) dom.componentVisibilityToggle.checked = state.isIdtComponentVisible;

        // Set the display style of the settings modal to 'flex' to make it visible (modals are typically flex layout for centering)
        dom.settingsModal.style.display = 'flex';
        // Get the content area element of the modal
        const modalContent = dom.settingsModal.querySelector('.modal-content');
        // Remove any potential exit animation classes to prevent interference with entry animation
        modalContent.classList.remove('animate__fadeOutDown', 'animate__zoomOut', 'animate__fadeOut');
        // Apply entry animation (if animation level is not 'none')
        // Choose different Animate.css entry animation classes based on the animation level
        const animIn = state.animationLevel !== 'none' ? (state.animationLevel === 'full' ? 'animate__zoomIn' : 'animate__fadeIn') : '';
        if (animIn) { // If an animation class was chosen
            modalContent.classList.add('animate__animated', animIn); // Add animation classes
            modalContent.style.setProperty('--animate-duration', '0.45s'); // Set animation duration
        }
    }
    /**
     * Closes the settings modal.
     * @param {boolean} [revertChanges=true] - If true, revert unsaved setting changes before closing.
     */
    function closeSettingsModal(revertChanges = true) {
        // If revertChanges is true (typically when clicking the "Close" button or outside the modal)
        if (revertChanges) {
            // Reload and apply settings from localStorage to revert to the saved state
            applyTheme(localStorage.getItem(APP_PREFIX + 'theme') || 'auto-crystal', true); // true indicates initial load, avoids saving again
            applyFontSize(localStorage.getItem(APP_PREFIX + 'fontSize') || '16');
            applyAnimationLevel(localStorage.getItem(APP_PREFIX + 'animationLevel') || 'full');
            state.autoScroll = (localStorage.getItem(APP_PREFIX + 'autoScroll') || 'true') === 'true';
            state.soundEnabled = (localStorage.getItem(APP_PREFIX + 'soundEnabled') || 'false') === 'true';
            state.showChatBubblesThink = (localStorage.getItem(APP_PREFIX + 'showChatBubblesThink') || 'true') === 'true';
            state.showLogBubblesThink = (localStorage.getItem(APP_PREFIX + 'showLogBubblesThink') || 'true') === 'true';
            state.autoSubmitQuickActions = (localStorage.getItem(APP_PREFIX + 'autoSubmitQuickActions') || 'true') === 'true';
            state.isIdtComponentVisible = (localStorage.getItem(APP_PREFIX + 'isIdtComponentVisible') || 'true') === 'true';

            // Update the UI controls in the settings modal to reflect the reverted setting values
            if (dom.autoScrollToggle) dom.autoScrollToggle.checked = state.autoScroll;
            if (dom.soundEnabledToggle) dom.soundEnabledToggle.checked = state.soundEnabled;
            if (dom.showChatBubblesThinkToggle) dom.showChatBubblesThinkToggle.checked = state.showChatBubblesThink;
            if (dom.showLogBubblesThinkToggle) dom.showLogBubblesThinkToggle.checked = state.showLogBubblesThink;
            if (dom.autoSubmitQuickActionsToggle) dom.autoSubmitQuickActionsToggle.checked = state.autoSubmitQuickActions;
            if (dom.componentVisibilityToggle) dom.componentVisibilityToggle.checked = state.isIdtComponentVisible;
            // Apply the reverted 3D component visibility state
            toggleThreeBlackHoleVisibility(state.isIdtComponentVisible);
            // Update the icon of the 3D component toggle button
            const idtIcon = dom.idtComponentToggleBtn.querySelector('i');
            if (idtIcon) idtIcon.className = state.isIdtComponentVisible ? 'fas fa-eye-slash' : 'fas fa-atom';
        }

        // Get the content area element of the modal
        const modalContent = dom.settingsModal.querySelector('.modal-content');
        // Remove any potential entry animation classes
        modalContent.classList.remove('animate__zoomIn', 'animate__fadeIn');
        // Choose the exit animation class based on the animation level
        const animOut = state.animationLevel !== 'none' ? (state.animationLevel === 'full' ? 'animate__zoomOut' : 'animate__fadeOut') : '';

        // Define the handler function for animation end
        const animationEndHandler = () => {
            // Set the display style of the settings modal to 'none' to hide it
            dom.settingsModal.style.display = 'none';
            // If an exit animation class was applied, remove them after the animation ends so entry animation plays correctly next time
            if (animOut) modalContent.classList.remove('animate__animated', animOut);
        };

        // If animations are enabled (state.animationLevel is not 'none') and an exit animation class was chosen
        if (state.animationLevel !== 'none' && animOut) {
            modalContent.classList.add('animate__animated', animOut); // Add the exit animation class
            modalContent.style.setProperty('--animate-duration', '0.35s'); // Set the animation duration
            // Listen for the animation end event, call animationEndHandler after the animation finishes (once: true means only triggers once)
            modalContent.addEventListener('animationend', animationEndHandler, { once: true });
        } else {
            // If animations are not enabled, or no exit animation class was chosen, call animationEndHandler directly to hide the modal
            animationEndHandler();
        }
    }
    /**
     * Collects the current settings from the settings modal UI controls, applies and saves them.
     */
    function collectAndSaveSettings() {
        // Get the selected theme value from the theme select dropdown
        state.currentTheme = dom.themeSelect.value;
        applyTheme(state.currentTheme); // Apply the selected theme

        // Get the value from the font size input (range slider) and apply it
        applyFontSize(dom.fontSizeInput.value);

        // Get the value from the animation level select dropdown and apply it
        applyAnimationLevel(dom.animationLevelSelect.value);

        // Update boolean settings in state, getting the checked state from the corresponding toggle switches (checkboxes)
        state.autoScroll = dom.autoScrollToggle.checked;
        state.soundEnabled = dom.soundEnabledToggle.checked;
        state.showChatBubblesThink = dom.showChatBubblesThinkToggle.checked;
        state.showLogBubblesThink = dom.showLogBubblesThinkToggle.checked;
        state.autoSubmitQuickActions = dom.autoSubmitQuickActionsToggle.checked;
        state.isIdtComponentVisible = dom.componentVisibilityToggle.checked;
        // Apply the 3D component visibility setting
        toggleThreeBlackHoleVisibility(state.isIdtComponentVisible);

        // Call the saveSettings function to save all updated settings to localStorage
        saveSettings();
    }
    /**
     * Saves all persistent application settings to localStorage.
     */
    function saveSettings() {
        // Save theme setting
        localStorage.setItem(APP_PREFIX + 'theme', state.currentTheme);
        // Save font size (get the actually effective value from the CSS variable, and remove 'px' suffix)
        localStorage.setItem(APP_PREFIX + 'fontSize', document.documentElement.style.getPropertyValue('--base-font-size').replace('px', ''));
        // Save animation level setting
        localStorage.setItem(APP_PREFIX + 'animationLevel', state.animationLevel);
        // Save auto-scroll setting (convert to string 'true' or 'false')
        localStorage.setItem(APP_PREFIX + 'autoScroll', state.autoScroll.toString());
        // Save sound enabled setting
        localStorage.setItem(APP_PREFIX + 'soundEnabled', state.soundEnabled.toString());
        // Save "show thinking process in chat bubbles" setting
        localStorage.setItem(APP_PREFIX + 'showChatBubblesThink', state.showChatBubblesThink.toString());
        // Save "show thinking bubble in log entries" setting
        localStorage.setItem(APP_PREFIX + 'showLogBubblesThink', state.showLogBubblesThink.toString());
        // Save sidebar expanded state
        localStorage.setItem(APP_PREFIX + 'sidebarExpanded', state.isSidebarExpanded.toString());
        // Save session manager collapsed state
        localStorage.setItem(APP_PREFIX + 'sessionManagerCollapsed', state.isSessionManagerCollapsed.toString());
        // Save process log sidebar visibility state
        localStorage.setItem(APP_PREFIX + 'isProcessLogSidebarVisible', state.isProcessLogSidebarVisible.toString());
        // Save process log sidebar collapsed state
        localStorage.setItem(APP_PREFIX + 'isProcessLogSidebarCollapsed', state.isProcessLogSidebarCollapsed.toString());
        // Save "auto-submit quick actions" setting
        localStorage.setItem(APP_PREFIX + 'autoSubmitQuickActions', state.autoSubmitQuickActions.toString());
        // Save current application mode
        localStorage.setItem(APP_PREFIX + 'currentMode', state.currentMode);
        // Save 3D component visibility state
        localStorage.setItem(APP_PREFIX + 'isIdtComponentVisible', state.isIdtComponentVisible.toString());
        // Save 3D component position percentages
        localStorage.setItem(APP_PREFIX + 'idtComponentTopPercent', document.documentElement.style.getPropertyValue('--idt-offset-top-percentage'));
        localStorage.setItem(APP_PREFIX + 'idtComponentLeftPercent', document.documentElement.style.getPropertyValue('--idt-offset-left-percentage'));
        // Log that settings have been saved
        console.log("系统参数数据已保存到归档.");
    }
    /**
     * Loads application settings from localStorage and updates the application state.
     */
    function loadSettings() {
        // Load and apply the saved position of the 3D component (top and left offset percentages)
        const savedTopPercent = localStorage.getItem(APP_PREFIX + 'idtComponentTopPercent');
        const savedLeftPercent = localStorage.getItem(APP_PREFIX + 'idtComponentLeftPercent');
        // If the saved top offset percentage exists in localStorage, apply it to the CSS variable
        if (savedTopPercent !== null) document.documentElement.style.setProperty('--idt-offset-top-percentage', savedTopPercent);
        // If the saved left offset percentage exists in localStorage, apply it to the CSS variable
        if (savedLeftPercent !== null) document.documentElement.style.setProperty('--idt-offset-left-percentage', savedLeftPercent);

        // Load other application settings, use default values if no corresponding item exists in localStorage:
        // Theme setting, defaults to 'auto-crystal'
        state.currentTheme = localStorage.getItem(APP_PREFIX + 'theme') || 'auto-crystal';
        // Animation level, defaults to 'full'
        state.animationLevel = localStorage.getItem(APP_PREFIX + 'animationLevel') || 'full';
        // Auto-scroll, defaults to 'true' (note: localStorage stores strings, need to convert to boolean)
        state.autoScroll = (localStorage.getItem(APP_PREFIX + 'autoScroll') || 'true') === 'true';
        // Sound enabled, defaults to 'false'
        state.soundEnabled = (localStorage.getItem(APP_PREFIX + 'soundEnabled') || 'false') === 'true';
        // Show thinking process in chat bubbles, defaults to 'true'
        state.showChatBubblesThink = (localStorage.getItem(APP_PREFIX + 'showChatBubblesThink') || 'true') === 'true';
        // Show thinking bubble in log entries, defaults to 'true'
        state.showLogBubblesThink = (localStorage.getItem(APP_PREFIX + 'showLogBubblesThink') || 'true') === 'true';
        // Sidebar expanded state, defaults to determined by window width (expanded if > 1024px)
        state.isSidebarExpanded = (localStorage.getItem(APP_PREFIX + 'sidebarExpanded') || (window.innerWidth > 1024).toString()) === 'true';
        // Session manager collapsed state, defaults to 'false' (not collapsed)
        state.isSessionManagerCollapsed = (localStorage.getItem(APP_PREFIX + 'sessionManagerCollapsed') || 'false') === 'true';
        // Process log sidebar visibility state, defaults to 'false' (not visible)
        state.isProcessLogSidebarVisible = (localStorage.getItem(APP_PREFIX + 'isProcessLogSidebarVisible') || 'false') === 'true';
        // Process log sidebar collapsed state, defaults to 'true' (collapsed)
        state.isProcessLogSidebarCollapsed = (localStorage.getItem(APP_PREFIX + 'isProcessLogSidebarCollapsed') || 'true') === 'true';
        // Auto-submit quick actions, defaults to 'true'
        state.autoSubmitQuickActions = (localStorage.getItem(APP_PREFIX + 'autoSubmitQuickActions') || 'true') === 'true';
        // Current application mode, defaults to 'chat'
        state.currentMode = localStorage.getItem(APP_PREFIX + 'currentMode') || 'chat';
        // 3D component visibility state, defaults to 'true' (visible)
        state.isIdtComponentVisible = (localStorage.getItem(APP_PREFIX + 'isIdtComponentVisible') || 'true') === 'true';

        // Update the state of UI elements to reflect the loaded settings:
        // Update the active state of the sidebar buttons to match the loaded currentMode
        dom.sidebarButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.mode === state.currentMode));
        // Update the placeholder text of the user input box
        // Note: Session data (state.sessions) might not be fully loaded at this point, so currentSessionId might be null
        // Therefore, the session name part might temporarily show as "当前项目"
        const sessionNameForPlaceholder = state.sessions[state.currentSessionId]?.name || '当前项目';
        dom.userInput.placeholder = `向Lumina核心发送指令 (${getModeDisplayName(state.currentMode)}模式，当前项目: ${sessionNameForPlaceholder})...`;
    }
    /**
     * Resets all settings to their default values, applies and saves these default values.
     */
    function resetToDefaultSettings() {
        // Define an object containing all resettable settings and their default values
        const defaults = {
            theme: 'auto-crystal', // Default theme
            fontSize: '16', // Default font size (px)
            animationLevel: 'full', // Default animation level
            autoScroll: true, // Default auto-scroll
            soundEnabled: false, // Default sound disabled
            showChatBubblesThink: true, // Default show thinking process in chat bubbles
            showLogBubblesThink: true, // Default show thinking bubble in log entries
            sidebarExpanded: window.innerWidth > 1024, // Default sidebar expanded state (based on window width)
            sessionManagerCollapsed: false, // Default session manager not collapsed
            isProcessLogSidebarVisible: false, // Default process log sidebar not visible
            isProcessLogSidebarCollapsed: true, // Default process log sidebar collapsed
            autoSubmitQuickActions: true, // Default auto-submit quick actions
            currentMode: 'chat', // Default application mode
            isIdtComponentVisible: true, // Default 3D component visible
            idtComponentTopPercent: '2.5%', // Default 3D component top offset percentage
            idtComponentLeftPercent: '1.8%', // Default 3D component left offset percentage
        };
        // Apply default settings to application state and UI:
        applyTheme(defaults.theme); // Apply default theme
        applyFontSize(defaults.fontSize); // Apply default font size
        applyAnimationLevel(defaults.animationLevel); // Apply default animation level
        // Update various boolean and string settings in state
        state.autoScroll = defaults.autoScroll;
        state.soundEnabled = defaults.soundEnabled;
        state.showChatBubblesThink = defaults.showChatBubblesThink;
        state.showLogBubblesThink = defaults.showLogBubblesThink;
        state.autoSubmitQuickActions = defaults.autoSubmitQuickActions;
        state.currentMode = defaults.currentMode;
        state.isIdtComponentVisible = defaults.isIdtComponentVisible;
        toggleThreeBlackHoleVisibility(state.isIdtComponentVisible); // Apply default 3D component visibility

        // Update UI state to reflect default values:
        updateSidebarState(defaults.sidebarExpanded, true); // Update sidebar state (true for instant update)
        updateSessionManagerState(defaults.sessionManagerCollapsed, true); // Update session manager state (true for instant update)
        // Update process log sidebar state
        state.isProcessLogSidebarVisible = defaults.isProcessLogSidebarVisible;
        state.isProcessLogSidebarCollapsed = defaults.isProcessLogSidebarCollapsed;
        applyFixedLogSidebarLayout(); // Apply layout
        updateProcessLogSidebarCollapseState(state.isProcessLogSidebarCollapsed, true); // Update collapsed state (true for instant update)
        // Show or hide the log sidebar based on default visibility
        if (state.isProcessLogSidebarVisible) showProcessLogSidebar(false); else hideProcessLogSidebar();
        // Update the title and icon of the 3D component toggle button
        dom.idtComponentToggleBtn.setAttribute('title', state.isIdtComponentVisible ? '停用核心投影' : '激活核心投影');
        const idtIcon = dom.idtComponentToggleBtn.querySelector('i');
        if (idtIcon) idtIcon.className = state.isIdtComponentVisible ? 'fas fa-eye-slash' : 'fas fa-atom';
        // Reset 3D component position (via CSS variables)
        document.documentElement.style.setProperty('--idt-offset-top-percentage', defaults.idtComponentTopPercent);
        document.documentElement.style.setProperty('--idt-offset-left-percentage', defaults.idtComponentLeftPercent);

        // Update UI control values in the settings modal to reflect the restored default settings:
        if (dom.themeSelect) dom.themeSelect.value = defaults.theme;
        if (dom.fontSizeInput) dom.fontSizeInput.value = defaults.fontSize;
        if (dom.fontSizeValue) dom.fontSizeValue.textContent = `${defaults.fontSize}px`;
        if (dom.animationLevelSelect) dom.animationLevelSelect.value = defaults.animationLevel;
        if (dom.autoScrollToggle) dom.autoScrollToggle.checked = defaults.autoScroll;
        if (dom.soundEnabledToggle) dom.soundEnabledToggle.checked = defaults.soundEnabled;
        if (dom.showChatBubblesThinkToggle) dom.showChatBubblesThinkToggle.checked = defaults.showChatBubblesThink;
        if (dom.showLogBubblesThinkToggle) dom.showLogBubblesThinkToggle.checked = defaults.showLogBubblesThink;
        if (dom.autoSubmitQuickActionsToggle) dom.autoSubmitQuickActionsToggle.checked = defaults.autoSubmitQuickActions;
        if (dom.componentVisibilityToggle) dom.componentVisibilityToggle.checked = defaults.isIdtComponentVisible;

        // Update active state of sidebar buttons and placeholder text of user input box to reflect default mode
        dom.sidebarButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.mode === defaults.currentMode));
        const sessionNameForPlaceholder = state.sessions[state.currentSessionId]?.name || '当前项目';
        dom.userInput.placeholder = `向Lumina核心发送指令 (${getModeDisplayName(state.currentMode)}模式，当前项目: ${sessionNameForPlaceholder})...`;

        // Save the restored default settings to localStorage
        saveSettings();
        // Show a Toast notification informing the user that settings have been restored to default
        showToast('系统参数已恢复为默认光绘配置!', 'success');
    }

    /**
     * Displays a Toast notification.
     * @param {string} message - The notification message text.
     * @param {string} [type='info'] - The notification type ('info', 'success', 'warning', 'error').
     * @param {number} [duration=3500] - The duration (in milliseconds) the notification should be displayed, 0 for no auto-dismiss.
     */
    function showToast(message, type = 'info', duration = 3500) {
        // If the Toast container element does not exist, log an error and return
        if (!dom.toastContainer) {
            console.error("Toast container element not found."); return;
        }
        // Create a new div element as a Toast notification
        const toast = document.createElement('div');
        // Add base CSS classes ('toast', 'lumina-panel') and specific type class (e.g., 'toast-info')
        toast.classList.add('toast', 'lumina-panel', `toast-${type}`);

        // Choose entry and exit animation classes (Animate.css) based on the animation level
        const animIn = state.animationLevel !== 'none' ? (state.animationLevel === 'full' ? 'animate__fadeInRight' : 'animate__fadeIn') : '';
        const animOut = state.animationLevel !== 'none' ? (state.animationLevel === 'full' ? 'animate__fadeOutRight' : 'animate__fadeOut') : '';

        // If animations are enabled and an entry animation class was chosen
        if (state.animationLevel !== 'none' && animIn) {
            toast.classList.add('animate__animated', animIn); // Add animation classes
            toast.style.setProperty('--animate-duration', '0.45s'); // Set animation duration
        }

        // Define an object storing notification types and their corresponding FontAwesome icon classes
        const icons = { 'info': 'fa-info-circle', 'success': 'fa-check-circle', 'warning': 'fa-exclamation-triangle', 'error': 'fa-times-circle' };
        // Get the icon class matching the current notification type, default to 'fa-info-circle' if not found
        const iconClass = icons[type] || 'fa-info-circle';

        // Create a span element to display the notification message text
        const messageSpan = document.createElement('span');
        messageSpan.className = 'toast-message'; // Add CSS class
        messageSpan.textContent = message; // Set text content

        // Set the HTML content of the Toast notification, including the icon
        toast.innerHTML = `<i class="fas ${iconClass} toast-icon"></i>`;
        // Append the message text span to the Toast notification
        toast.appendChild(messageSpan);
        // Create a close button
        const closeButton = document.createElement('button');
        closeButton.className = 'toast-close icon-btn'; // Add CSS classes (using generic icon button styles)
        closeButton.innerHTML = '<i class="fas fa-times"></i>'; // Set the button icon (X)
        closeButton.setAttribute('title', '关闭通知'); // Set the tooltip
        // Add a click event listener to the close button, calling the removeToast function
        // Note: pass the animOut parameter to ensure the correct exit animation is used even when manually closed
        closeButton.addEventListener('click', () => removeToast(toast, animOut, true)); // true indicates manual close
        // Append the close button to the Toast notification
        toast.appendChild(closeButton);

        // Append the created Toast notification to the Toast container
        dom.toastContainer.appendChild(toast);

        // If auto-dismiss duration is set (duration > 0)
        if (duration > 0) {
            // Use setTimeout to set a timer to remove the Toast notification after the specified duration
            const timeoutId = setTimeout(() => {
                removeToast(toast, animOut, false); // false indicates non-manual close
            }, duration);
            // Store the timeout ID in the Toast element's data-timeout-id attribute
            // This allows clearing the timer when manually closing, avoiding unnecessary removal operations
            toast.dataset.timeoutId = timeoutId.toString();
        }
    }

    /**
     * Removes a Toast notification.
     * @param {HTMLElement} toast - The Toast DOM element to remove.
     * @param {string} animOut - The animation class name to use for fading out.
     * @param {boolean} [isManualClose=false] - Whether the close was triggered manually by the user.
     */
    function removeToast(toast, animOut, isManualClose = false) {
        // Ensure the Toast element is still present in the DOM (i.e., has a parent element)
        if (toast.parentElement) {
            // If it's a manual close and the Toast element has an auto-close timeoutId stored
            if (isManualClose && toast.dataset.timeoutId) {
                // Clear that timeout to prevent it from attempting to remove the Toast after manual close
                clearTimeout(parseInt(toast.dataset.timeoutId, 10));
            }

            // Handle animation and removal logic:
            // If animations are enabled, an exit animation class was chosen, and the Toast element currently has the 'animate__animated' class
            if (state.animationLevel !== 'none' && animOut && toast.classList.contains('animate__animated')) {
                // Remove any potential entry animation classes (just in case)
                toast.classList.remove('animate__fadeInRight', 'animate__fadeIn');
                // Add the exit animation class
                toast.classList.add(animOut);
                toast.style.setProperty('--animate-duration', '0.3s'); // Set the duration of the exit animation
                // Listen for the animation end event
                toast.addEventListener('animationend', () => {
                    // After the animation finishes, check again if the Toast is still in the DOM (in case it was removed by other means during the animation)
                    if (toast.parentElement) {
                        toast.remove(); // Remove the Toast element from the DOM
                    }
                }, { once: true }); // once: true means the event triggers only once
            } else {
                // If animations are not enabled, or the animation class doesn't apply, remove the Toast element directly from the DOM
                toast.remove();
            }
        }
    }

    /**
     * Attaches click event listeners to all quick action buttons (.quick-action-btn) within the specified container.
     * @param {HTMLElement} container - The parent container element containing the quick action buttons.
     */
    function attachQuickActionButtonListeners(container) {
        // Find all elements with the 'quick-action-btn' CSS class within the container
        container.querySelectorAll('.quick-action-btn').forEach(button => {
            // First, remove any existing identical event listener (handleQuickActionButtonClick) on this button
            // This prevents duplicate listeners if this function is called multiple times
            button.removeEventListener('click', handleQuickActionButtonClick);
            // Then, add a new click event listener to the button, specifying handleQuickActionButtonClick as the callback function
            button.addEventListener('click', handleQuickActionButtonClick);
        });
    }
    /**
     * Handles the click event of a quick action button.
     * Fills the user input box with the text from the button's data-message attribute and sends the message automatically based on settings.
     * @param {MouseEvent} e - The click event object.
     */
    function handleQuickActionButtonClick(e) {
        // Prevent the default behavior of the link (<a> tag) (e.g., page navigation or scrolling to an anchor)
        e.preventDefault();
        // Get the clicked button (or its nearest parent element with the 'quick-action-btn' class, to handle clicking the icon)
        // Then get the message text to send from its 'data-message' attribute
        const messageToSend = e.target.closest('.quick-action-btn').dataset.message;
        // If message text was successfully retrieved
        if (messageToSend) {
            dom.userInput.value = messageToSend; // Fill the user input box with the message text
            adjustTextareaHeight(); // Adjust the input box height to fit the new content
            updateCharCounter(); // Update the character counter
            dom.userInput.focus(); // Set focus to the input box, making it easy for the user to continue editing or send directly
            // If the "auto-submit quick actions" setting is enabled in the application settings (state.autoSubmitQuickActions is true)
            if (state.autoSubmitQuickActions) {
                handleSendMessage(); // Call the function to send the message automatically
            }
        }
    }
    /**
     * Updates the CSS variable `--input-area-height` to reflect the actual height of the current input area.
     * This might be useful for absolutely positioned elements that depend on this height (like the bottom positioning of the right process log sidebar).
     */
    function updateInputAreaHeightVar() {
        // If the input area DOM element exists
        if (dom.inputArea) {
            // Get the actual height of the input area (offsetHeight includes padding and border)
            const heightPx = dom.inputArea.offsetHeight;
            // Set a CSS variable named '--input-area-height' on the document's root element (documentElement)
            // Its value is the actual height of the input area (in pixels)
            document.documentElement.style.setProperty('--input-area-height', `${heightPx}px`);
            // If the right process log sidebar container exists AND is currently visible
            if (dom.processLogSidebarContainer && state.isProcessLogSidebarVisible) {
                // Note: The CSS already uses var(--input-area-height) for positioning,
                // so there's no need to directly modify its bottom style here via JavaScript.
                // dom.processLogSidebarContainer.style.bottom = `calc(${heightPx}px + var(--spacing-unit) * 2)`;
            }
        }
    }


    // Initialize the application
    // Call the initializeApp function to begin the entire frontend application initialization process.
    initializeApp();

}); // End of DOMContentLoaded (Executes the callback function after the entire HTML document has been loaded and parsed)

--- END: static/script.js ---

--- START: static/style.css ---
/* ==========================================================================
   [ START OF FILE style.css ]
   CircuitManus Pro - Lumina Script / 光绘墨迹 主题
   版本: 1.1.7_LogLayoutFix_BlackHoleRevise
   描述: 优化Agent执行轨迹侧栏布局 (图标与主文本同排, 详情在下方),
         重构3D组件视觉效果为更逼真黑洞模拟 (CSS分层吸积盘 + 环绕恒星模拟)。
   ========================================================================== */

/* ==========================================================================
   [ 1. CSS Reset and Base Styles ]
   全局样式重置和基础HTML/Body元素的默认样式定义。
   ========================================================================== */

/* 应用于所有元素，包括伪元素，以确保盒模型计算一致 */
*,
*::before,
*::after {
  box-sizing: border-box;
  /* 将盒模型设置为border-box，padding和border不计入元素宽高 */
  margin: 0;
  /* 移除元素的默认外边距 */
  padding: 0;
  /* 移除元素的默认内边距 */
}

/* 定义根元素的样式 */
html {
  font-size: var(--base-font-size);
  /* 根字体大小使用CSS变量，方便全局缩放主题UI元素 */
  scroll-behavior: smooth;
  /* 启用平滑滚动效果，用于页面内部锚点跳转等 */
}

/* 定义Body元素的默认样式，影响整个页面 */
body {
  font-family: var(--font-family-body);
  /* 应用主体文本字体 */
  line-height: var(--line-height-base);
  /* 应用基础行高，提高文本可读性 */
  background-color: var(--current-bg);
  /* 应用当前背景色，根据主题动态切换 */
  color: var(--current-text-primary);
  /* 应用当前主要文本颜色，根据主题动态切换 */
  margin: 0;
  padding: 0;
  overflow: hidden;
  /* 防止在Body元素上生成主滚动条，页面的滚动由内部特定容器控制 */
  /* 添加背景色和文本颜色的过渡效果，使主题切换平滑 */
  transition: background-color var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
    color var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
  -webkit-font-smoothing: antialiased;
  /* 优化字体在Webkit浏览器上的渲染平滑度 */
  -moz-osx-font-smoothing: grayscale;
  /* 优化字体在macOS Firefox上的渲染平滑度 */
  letter-spacing: 0.2px;
  /* 微调字符间距，提升整体文本观感 */
}

/* ==========================================================================
   [ 2. Lumina Theme Variables ]
   定义Lumima Script主题相关的CSS变量，包括颜色、字体、尺寸、过渡时长等。
   这些变量根据 body[data-theme] 在 [3. Theme Application Logic] 中被应用。
   ========================================================================== */
:root {
  /* Lumina Script - 浅色模式 (月白宣纸 / Moon White Rice Paper) 变量定义 */
  --lumina-bg-light: #F9F8F6;
  /* 极浅米色背景，模拟宣纸质感 */
  --lumina-panel-bg-light: rgba(251, 250, 248, 0.9);
  /* 半透明面板背景，稍深于主背景，增加层次 */
  --lumina-panel-border-light: rgba(120, 115, 110, 0.25);
  /* 面板边框颜色，淡墨色，半透明 */
  --lumina-text-primary-light: #4A4642;
  /* 主要文本颜色，深墨色 */
  --lumina-text-secondary-light: #88827C;
  /* 辅助文本颜色，较浅的墨色 */
  --lumina-accent-ink-light: #A0522D;
  /* 印章红/赭石色，用于重要的强调元素（如主按钮、部分图标） */
  --lumina-accent-light-light: #5E8BC9;
  /* 天青蓝，用于光绘线条、能量感元素、主要交互（如链接、悬停效果） */
  --lumina-glow-light: rgba(94, 139, 201, 0.35);
  /* 天青蓝辉光颜色，用于光晕效果 */
  /* 浅色模式下的背景纹理 (SVG Data URI模拟墨点或纸张纤维) */
  --lumina-ink-texture-light: url("data:image/svg+xml,%3Csvg width='80' height='80' viewBox='0 0 80 80' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseTextureLight'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='1' stitchTiles='stitch'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 .2 0 0 0 0 .19 0 0 0 0 .18 0 0 0 .015 0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseTextureLight)' opacity='0.3'/%3E%3C/svg%3E");

  /* Lumina Script - 深色模式 (墨黑星空 / Ink Black Starry Sky) 变量定义 */
  --lumina-bg-dark: #16181D;
  /* 深邃墨黑背景，模拟夜空或深沉的墨迹 */
  --lumina-panel-bg-dark: rgba(22, 24, 29, 0.88);
  /* 半透明面板背景，稍浅于主背景，增加层次 */
  --lumina-panel-border-dark: rgba(180, 195, 230, 0.3);
  /* 面板边框颜色，淡银色，半透明 */
  --lumina-text-primary-dark: #E0D8CE;
  /* 主要文本颜色，暖白色，模拟星光或淡墨迹 */
  --lumina-text-secondary-dark: #A09A90;
  /* 辅助文本颜色，较浅的暖灰色 */
  --lumina-accent-ink-dark: #E6C37F;
  /* 璨金色，用于重要的强调元素（如主按钮、部分图标），模拟金箔或亮色印章 */
  --lumina-accent-light-dark: #7AB8F5;
  /* 星河蓝，用于光绘线条、能量感元素、主要交互（如链接、悬停效果），模拟星辰或蓝光 */
  --lumina-glow-dark: rgba(122, 184, 245, 0.4);
  /* 星河蓝辉光颜色，用于光晕效果 */
  /* 深色模式下的背景纹理 (SVG Data URI模拟星尘或墨迹扩散) */
  --lumina-ink-texture-dark: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseTextureDark'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='2' stitchTiles='stitch'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 .9 0 0 0 0 .85 0 0 0 0 .8 0 0 0 .02 0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseTextureDark)' opacity='0.4'/%3E%3C/svg%3E");

  /* 字体定义 */
  --font-family-title: "Orbitron", "Noto Sans SC", system-ui, -apple-system, sans-serif;
  /* 标题和重要元素的字体，科技感或艺术感 */
  --font-family-body: "Roboto", "Noto Sans SC", system-ui, -apple-system, sans-serif;
  /* 主体文本字体，易读性高 */

  /* 尺寸与间距基础单位 */
  --base-font-size: 16px;
  /* 基础字体大小，所有rem或em基于此计算 */
  --line-height-base: 1.75;
  /* 基础行高 */
  --spacing-unit: 8px;
  /* 基础间距单位，用于构建整个布局和元素间距 */

  /* 圆角定义 */
  --border-radius-soft: 12px;
  /* 较大的柔和圆角，主要用于面板、气泡等大块区域 */
  --border-radius-slight: 6px;
  /* 较小的微略圆角，用于按钮、输入框等交互元素和内部组件 */

  /* 过渡与动画时长及缓动函数 */
  --transition-duration-ink-subtle: 0.45s;
  /* 墨迹般微妙过渡时长，用于颜色、透明度、简单位置变化 */
  --transition-duration-ink-flow: 0.65s;
  /* 墨迹般流动过渡时长，用于更明显或复杂的过渡，如加载动画 */
  --transition-duration-light-pulse: 0.35s;
  /* 光晕/脉冲过渡时长，用于按钮、图标等快速交互反馈 */
  --transition-timing-function-lumina: cubic-bezier(0.35, 0, 0.25, 1);
  /* Lumina主题专用缓动函数，提供独特动画曲线 */

  /* Z-轴层级定义，管理元素堆叠顺序 */
  --z-index-loader: 1000;
  /* 加载遮罩层最高 */
  --z-index-modal: 900;
  /* 模态框次高 */
  --z-index-toast: 950;
  /* Toast通知略高于模态框，防止被遮挡 */
  --z-index-sidebar: 100;
  /* 侧边栏在基础内容之上 */
  --z-index-header: 150;
  /* 头部在侧边栏之上 */
  --z-index-component-wrapper: 50;
  /* 3D黑洞组件在基础内容之下，但高于背景 */
  --z-index-process-log: 60;
  /* 日志侧边栏在3D组件之上，防止遮挡交互 */
  --z-index-file-preview: 55;
  /* 文件预览区在3D组件之上，但低于日志侧边栏 */

  /* 组件特定尺寸定义 */
  --idt-offset-top-percentage: 2.5%;
  /* 3D组件顶部相对于视口高度的偏移百分比 */
  --idt-offset-left-percentage: 1.8%;
  /* 3D组件左侧相对于视口宽度的偏移百分比 */
  --idt-component-width: 280px;
  /* 3D组件的固定宽度 */
  --idt-component-height: 280px;
  /* 3D组件的固定高度 */
  --header-height: 70px;
  /* 头部的高度 */
  --process-log-sidebar-width: 350px;
  /* 日志侧边栏展开状态的宽度 */
  --process-log-sidebar-width-collapsed: 55px;
  /* 日志侧边栏折叠状态的宽度 */
  --input-area-height: 75px;
  /* 输入区域的初始/最小高度 */

  /* 光绘线条粗细定义，用于边框或分隔线 */
  --lumina-line-weight-thin: 1px;
  /* 细线 */
  --lumina-line-weight-medium: 1.5px;
  /* 中等粗细 */
  --lumina-line-weight-bold: 2.5px;
  /* 粗线，用于强调 */

  /* 错误与成功状态颜色 */
  --lumina-error-color: #D9534F;
  /* 标准错误红色 */
  --lumina-error-glow: rgba(217, 83, 79, 0.4);
  /* 错误状态的辉光颜色 */
  --lumina-success-color: #5CB85C;
  /* 标准成功绿色 */
  --lumina-success-glow: rgba(92, 184, 92, 0.4);
  /* 成功状态的辉光颜色 */
}

/* ==========================================================================
   [ 3. Theme Application Logic ]
   根据 body[data-theme] 属性和 prefers-color-scheme 媒体查询，将 Lumina
   变量映射到通用的 --current-* 变量，实现主题切换和自动适应。
   ========================================================================== */

/* 当body元素的data-theme属性为'light-crystal'（强制浅色）或
   data-theme为'auto-crystal'且系统偏好亮色时（通过JS添加的类），
   应用浅色主题变量。 */
body[data-theme='light-crystal'],
body[data-theme="auto-crystal"].light-crystal-active {
  /* 应用浅色主题背景色 */
  --current-bg: var(--lumina-bg-light);
  /* 应用浅色主题面板背景色 */
  --current-panel-bg: var(--lumina-panel-bg-light);
  /* 应用浅色主题面板边框颜色 */
  --current-panel-border: var(--lumina-panel-border-light);
  /* 应用浅色主题主要文本颜色 */
  --current-text-primary: var(--lumina-text-primary-light);
  /* 应用浅色主题辅助文本颜色 */
  --current-text-secondary: var(--lumina-text-secondary-light);
  /* 应用浅色主题墨迹/印章强调色 */
  --current-accent-ink: var(--lumina-accent-ink-light);
  /* 应用浅色主题光/能量强调色 */
  --current-accent-light: var(--lumina-accent-light-light);
  /* 应用浅色主题辉光颜色 */
  --current-glow: rgba(var(--lumina-accent-light-rgb), 0.35); /* 确保使用 RGB 变量 */
  /* 应用浅色主题背景纹理 */
  --current-ink-texture: var(--lumina-ink-texture-light);

  /* 用于RGBA计算的RGB值，方便在CSS中动态调整透明度 */
  --current-accent-light-rgb: 94, 139, 201;
  --current-accent-ink-rgb: 160, 82, 45;
  --current-panel-bg-rgb: 251, 250, 248;
  --current-bg-rgb: 249, 248, 246;
  --current-text-primary-rgb: 74, 70, 66;
  --current-text-secondary-rgb: 136, 130, 124;
  --current-error-color-rgb: 217, 83, 79;
  --current-success-color-rgb: 92, 184, 92;
}

/* 当body元素的data-theme属性为'dark-crystal'（强制暗色）或
   data-theme为'auto-crystal'且系统偏好暗色时（通过JS添加的类），
   应用暗色主题变量。 */
body[data-theme='dark-crystal'],
body[data-theme="auto-crystal"].dark-crystal-active {
  /* 应用深色主题背景色 */
  --current-bg: var(--lumina-bg-dark);
  /* 应用深色主题面板背景色 */
  --current-panel-bg: rgba(22, 24, 29, 0.88);
  /* 半透明面板背景，稍浅于主背景，增加层次 */
  --lumina-panel-border-dark: rgba(180, 195, 230, 0.3);
  /* 面板边框颜色，淡银色，半透明 */
  --current-panel-border: var(--lumina-panel-border-dark);
  /* 应用深色主题主要文本颜色 */
  --current-text-primary: var(--lumina-text-primary-dark);
  /* 应用深色主题辅助文本颜色 */
  --current-text-secondary: var(--lumina-text-secondary-dark);
  /* 应用深色主题墨迹/印章强调色 */
  --lumina-accent-ink-dark: #E6C37F;
  /* 璨金色，用于重要的强调元素（如主按钮、部分图标），模拟金箔或亮色印章 */
  --current-accent-ink: var(--lumina-accent-ink-dark);
  /* 应用深色主题光/能量强调色 */
  --lumina-accent-light-dark: #7AB8F5;
  /* 星河蓝，用于光绘线条、能量感元素、主要交互（如链接、悬停效果），模拟星辰或蓝光 */
  --current-accent-light: var(--lumina-accent-light-dark);
  /* 应用深色主题辉光颜色 */
  --current-glow: rgba(var(--lumina-accent-light-rgb), 0.4); /* 确保使用 RGB 变量 */
  /* 应用深色主题背景纹理 */
  --current-ink-texture: var(--lumina-ink-texture-dark);

  /* 用于RGBA计算的RGB值，方便在CSS中动态调整透明度 */
  --current-accent-light-rgb: 122, 184, 245;
  --current-accent-ink-rgb: 230, 195, 127;
  --current-panel-bg-rgb: 22, 24, 29;
  --current-bg-rgb: 22, 24, 29;
  --current-text-primary-rgb: 224, 216, 206;
  --current-text-secondary-rgb: 160, 154, 144;
  --current-error-color-rgb: 217, 83, 79;
  --current-success-color-rgb: 92, 184, 92;
}

/* 确保错误和成功颜色的 RGB 变量存在于 :root */
:root {
    --lumina-error-color-rgb: 217, 83, 79;
    --lumina-success-color-rgb: 92, 184, 92;
}


/* ==========================================================================
   [ 4. Typography ]
   字体、标题、链接、图标等基础排版样式。
   ========================================================================== */

/* 所有标题 (h1-h6) 的共同样式 */
h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: var(--font-family-title);
  /* 应用标题字体 */
  color: var(--current-text-primary);
  /* 应用主要文本颜色 */
  font-weight: 500;
  /* 字体粗细 */
  letter-spacing: 0.8px;
  /* 增加字符间距 */
  /* 添加微妙的文字阴影，模拟辉光和深度 */
  text-shadow: 0 0 10px rgba(var(--current-accent-light-rgb), 0.15),
    0 0 1px rgba(var(--current-text-primary-rgb), 0.2);
}

/* 链接的基础样式 */
a {
  color: var(--current-accent-light);
  /* 链接颜色使用光强调色 */
  text-decoration: none;
  /* 移除下划线 */
  /* 添加颜色和滤镜的过渡效果 */
  transition: color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
    filter var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
  font-weight: 500;
  /* 字体加粗 */
}

/* 链接悬停或聚焦时的样式 */
a:hover,
a:focus {
  /* 悬停颜色混合了强调色和主要文本色 */
  color: color-mix(in srgb, var(--current-accent-light) 80%, var(--current-text-primary));
  text-decoration: none;
  /* 保持无下划线 */
  filter: brightness(1.15);
  /* 增加亮度 */
  outline: none;
  /* 移除默认聚焦轮廓 */
}

/* 链接获得键盘焦点的可视化指示器 */
a:focus-visible {
  outline: 2px dashed var(--current-accent-ink);
  /* 使用墨迹强调色绘制虚线轮廓 */
  outline-offset: 2px;
  /* 轮廓向外偏移 */
}

/* Font Awesome 图标基础样式 */
i.fas,
i.far,
i.fal,
i.fad,
i.fab {
  text-shadow: 0 0 6px rgba(var(--current-accent-light-rgb), 0.25);
  /* 给图标添加微妙的光晕阴影 */
  /* 添加颜色、阴影、变形的过渡效果 */
  transition: color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
    text-shadow var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
    transform var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
  display: inline-block;
  /* 使图标可以应用变形 */
  vertical-align: middle;
  /* 垂直对齐 */
}

/* ==========================================================================
   [ 5. Buttons and Interactive Elements ]
   通用按钮、图标按钮和Lumina风格按钮家族的样式定义。
   ========================================================================== */

/* 按钮基础样式重置 */
button {
  font-family: inherit;
  /* 继承父级字体 */
  cursor: pointer;
  /* 鼠标悬停时显示手型光标 */
  border: none;
  /* 移除边框 */
  background: none;
  /* 移除背景 */
  padding: 0;
  /* 移除内边距 */
  color: inherit;
  /* 继承父级文本颜色 */
}

/* 通用图标按钮样式 */
.icon-btn {
  color: var(--current-text-secondary);
  /* 默认颜色使用辅助文本色 */
  padding: calc(var(--spacing-unit) * 0.85);
  /* 内边距 */
  font-size: calc(var(--base-font-size) * 1.25);
  /* 图标大小 */
  line-height: 1;
  /* 行高 */
  border-radius: 50%;
  /* 圆形 */
  width: calc(var(--base-font-size) * 2.5);
  /* 宽度 */
  height: calc(var(--base-font-size) * 2.5);
  /* 高度 */
  display: inline-flex;
  /* 使用Flexbox布局使其内容（图标）居中 */
  align-items: center;
  /* 垂直居中 */
  justify-content: center;
  /* 水平居中 */
  flex-shrink: 0; /* 防止在flex容器中被压缩 */
}

/* 图标按钮悬停或聚焦时的样式 */
.icon-btn:hover,
.icon-btn:focus {
  color: var(--current-accent-light);
  /* 悬停时颜色变为光强调色 */
  background-color: rgba(var(--current-accent-light-rgb), 0.1);
  /* 添加半透明背景 */
  transform: scale(1.1);
  /* 略微放大 */
  box-shadow: 0 0 12px rgba(var(--current-accent-light-rgb), 0.2);
  /* 添加辉光阴影 */
}

/* 图标按钮获得键盘焦点的可视化指示器 */
.icon-btn:focus-visible {
  outline: 2px dashed var(--current-accent-ink);
  /* 使用墨迹强调色绘制虚线轮廓 */
  outline-offset: 2px;
  /* 轮廓向外偏移 */
}

/* 确保图标按钮内的图标不受通用图标阴影影响 */
.icon-btn i {
  text-shadow: none;
}

/* Lumina 风格按钮基础样式 */
.lumina-button {
  display: inline-flex;
  /* 使用Flexbox布局使其内容（图标+文本）居中或对齐 */
  align-items: center;
  /* 垂直居中 */
  justify-content: center;
  /* 水平居中 */
  padding: calc(var(--spacing-unit) * 1.1) calc(var(--spacing-unit) * 2.2);
  /* 内边距 */
  font-family: var(--font-family-title);
  /* 应用标题字体 */
  font-size: calc(var(--base-font-size) * 0.92);
  /* 字体大小 */
  font-weight: 500;
  /* 字体粗细 */
  border-radius: var(--border-radius-slight);
  /* 应用小圆角 */
  cursor: pointer;
  /* 鼠标悬停显示手型光标 */
  text-decoration: none;
  /* 移除下划线 */
  letter-spacing: 1px;
  /* 增加字符间距 */
  position: relative;
  /* 开启定位上下文，用于伪元素光效 */
  overflow: hidden;
  /* 隐藏溢出的伪元素 */
  /* 添加所有可变属性的过渡效果 */
  transition: all var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
  border: var(--lumina-line-weight-thin) solid var(--current-accent-light);
  /* 细边框，颜色使用光强调色 */
  color: var(--current-accent-light);
  /* 文本颜色使用光强调色 */
  background-color: transparent;
  /* 背景透明 */
  box-shadow: inset 0 0 0 0 rgba(var(--current-accent-light-rgb), 0.15);
  /* 默认无内阴影，用于悬停效果 */
}

/* Lumina 按钮内图标样式 */
.lumina-button i {
  margin-right: calc(var(--spacing-unit) * 0.8);
  /* 图标与文本之间的间距 */
  font-size: calc(var(--base-font-size) * 1.05);
  /* 图标大小 */
  line-height: 1;
  /* 行高 */
}

/* Lumina 按钮的光效伪元素 */
.lumina-button::before {
  content: '';
  /* 生成伪元素 */
  position: absolute;
  /* 绝对定位 */
  top: 50%;
  left: 50%;
  /* 定位到按钮中心 */
  width: 0;
  height: 0;
  /* 初始宽高为0 */
  background-color: rgba(var(--current-accent-light-rgb), 0.2);
  /* 背景颜色，半透明光强调色 */
  border-radius: 50%;
  /* 圆形 */
  transform: translate(-50%, -50%);
  /* 通过位移精确居中 */
  opacity: 0;
  /* 初始透明度为0 */
  /* 添加宽高和透明度的过渡 */
  transition: width var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
    height var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
    opacity var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
}

/* Lumina 按钮悬停或聚焦时的样式 */
.lumina-button:hover,
.lumina-button:focus {
  color: var(--current-text-primary);
  /* 文本颜色变为主要文本色 */
  border-color: var(--current-accent-light);
  /* 边框颜色不变 */
  /* 添加外部辉光和内部柔和阴影 */
  box-shadow: 0 0 15px rgba(var(--current-accent-light-rgb), 0.3),
    inset 0 0 10px rgba(var(--current-accent-light-rgb), 0.1);
  transform: translateY(-2px);
  /* 向上轻微抬升效果 */
}

/* 深色模式下 Lumina 按钮悬停/聚焦时，文本颜色特殊处理，变为背景色以获得更强的对比 */
body[data-theme='dark-crystal'] .lumina-button:hover,
body[data-theme="auto-crystal"].dark-crystal-active .lumina-button:hover,
body[data-theme='dark-crystal'] .lumina-button:focus,
body[data-theme="auto-crystal"].dark-crystal-active .lumina-button:focus {
  color: var(--current-bg);
  /* 文本颜色变为当前背景色 */
}

/* Lumina 按钮悬停时，光效伪元素的变化 */
.lumina-button:hover::before {
  width: 250%;
  height: 250%;
  /* 宽高放大，覆盖整个按钮 */
  opacity: 1;
  /* 透明度变为1 */
}

/* Lumina 按钮点击按下时的样式 */
.lumina-button:active {
  transform: translateY(0px) scale(0.98);
  /* 回到原位并轻微缩小 */
  box-shadow: inset 0 2px 5px rgba(var(--current-text-primary-rgb), 0.15);
  /* 添加内凹阴影效果 */
}

/* Lumina 按钮禁用状态的样式 */
.lumina-button:disabled,
.lumina-button.disabled {
  border-color: var(--current-text-secondary);
  /* 边框颜色变为辅助文本色 */
  color: var(--current-text-secondary);
  /* 文本颜色变为辅助文本色 */
  opacity: 0.5;
  /* 降低透明度 */
  cursor: not-allowed;
  /* 鼠标悬停显示禁用光标 */
  transform: none;
  /* 移除变形效果 */
  box-shadow: none;
  /* 移除阴影 */
  background-color: transparent;
  /* 背景保持透明 */
}

/* Lumina 按钮禁用状态下隐藏光效伪元素 */
.lumina-button:disabled::before,
.lumina-button.disabled::before {
  display: none;
}

/* Lumina 主按钮 (印章/点睛效果) */
.lumina-button-primary {
  border-color: var(--current-accent-ink);
  /* 边框颜色使用墨迹强调色 */
  color: var(--current-accent-ink);
  /* 文本颜色使用墨迹强调色 */
  font-weight: 700;
  /* 字体加粗 */
  box-shadow: 0 1px 3px rgba(var(--current-accent-ink-rgb), 0.2);
  /* 添加微妙的外部阴影 */
}

/* Lumina 主按钮的光效伪元素颜色 */
.lumina-button-primary::before {
  background-color: rgba(var(--current-accent-ink-rgb), 0.2);
  /* 光效颜色使用墨迹强调色 */
}

/* Lumina 主按钮悬停或聚焦时的样式 */
.lumina-button-primary:hover,
.lumina-button-primary:focus {
  color: var(--current-text-primary);
  /* 文本颜色变为主要文本色 */
  border-color: var(--current-accent-ink);
  /* 边框颜色不变 */
  /* 添加更强的外部辉光和内部柔和阴影 */
  box-shadow: 0 0 18px rgba(var(--current-accent-ink-rgb), 0.35),
    inset 0 0 12px rgba(var(--current-accent-ink-rgb), 0.1);
  /* 主按钮悬停时不改变Y轴位置 */
  transform: none;
}

/* 深色模式下主按钮悬停/聚焦时，文本颜色特殊处理，变为背景色 */
body[data-theme='dark-crystal'] .lumina-button-primary:hover,
body[data-theme="auto-crystal"].dark-crystal-active .lumina-button-primary:hover,
body[data-theme='dark-crystal'] .lumina-button-primary:focus,
body[data-theme="auto-crystal"].dark-crystal-active .lumina-button-primary:focus {
  color: var(--current-bg);
  /* 文本颜色变为当前背景色 */
}


/* Lumina 侧边栏按钮样式 */
.lumina-button-sidebar {
  justify-content: flex-start;
  /* 内容左对齐 */
  text-transform: none;
  /* 不改变文本大小写 */
  font-size: var(--base-font-size);
  /* 字体大小 */
  font-weight: 400;
  /* 字体粗细 */
  border: none;
  /* 无边框 */
  color: var(--current-text-secondary);
  /* 默认颜色使用辅助文本色 */
  padding: calc(var(--spacing-unit) * 1.2) calc(var(--spacing-unit) * 1.8);
  /* 内边距 */
  width: 100%;
  /* 宽度占满父容器 */
  border-radius: var(--border-radius-slight);
  /* 应用小圆角 */
  /* 添加多种属性的过渡效果 */
  transition: background-color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
    color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
    transform var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
    box-shadow var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
}

/* Lumina 侧边栏按钮内图标样式 */
.lumina-button-sidebar i {
  margin-right: calc(var(--spacing-unit) * 1.5);
  /* 图标与文本间距 */
  width: 22px;
  /* 固定图标区域宽度，确保文本对齐 */
  text-align: center;
  /* 图标在固定区域内居中 */
  color: var(--current-accent-light);
  /* 图标颜色使用光强调色 */
  transition: transform var(--transition-duration-light-pulse) ease;
  /* 图标变形过渡 */
}

/* 侧边栏按钮悬停或聚焦时的样式 */
.lumina-button-sidebar:hover,
.lumina-button-sidebar:focus {
  background-color: rgba(var(--current-accent-light-rgb), 0.08);
  /* 添加半透明背景 */
  color: var(--current-text-primary);
  /* 文本颜色变为主要文本色 */
  transform: translateX(4px);
  /* 向右轻微位移 */
  box-shadow: -4px 0 0 0 var(--current-accent-light) inset;
  /* 添加左侧光带效果 */
}

/* 侧边栏按钮悬停或聚焦时，图标的变形效果 */
.lumina-button-sidebar:hover i,
.lumina-button-sidebar:focus i {
  transform: scale(1.15);
  /* 图标轻微放大 */
}

/* 侧边栏按钮活动状态的样式 */
.lumina-button-sidebar.active {
  background-color: rgba(var(--current-accent-light-rgb), 0.15);
  /* 添加更明显的半透明背景 */
  color: var(--current-text-primary);
  /* 文本颜色为主要文本色 */
  font-weight: 500;
  /* 字体加粗 */
  /* 添加更宽的左侧光带和柔和外部阴影 */
  box-shadow: -5px 0 0 0 var(--current-accent-light) inset,
    0 0 10px rgba(var(--current-accent-light-rgb), 0.1);
}

/* 侧边栏按钮活动状态时，图标的样式 */
.lumina-button-sidebar.active i {
  color: var(--current-accent-light);
  /* 图标颜色保持光强调色 */
  transform: scale(1.1);
  /* 图标轻微放大 */
}

/* ==========================================================================
   [ 6. Layout and Structure ]
   定义主要的布局容器和它们的排列方式。
   ========================================================================== */

/* 应用主容器，包裹整个应用界面 */
.main-container {
  opacity: 0;
  transform: translateY(15px);
  /* 初始状态透明并向下偏移，用于加载动画 */
  /* 添加透明度和位移的过渡 */
  transition: opacity var(--transition-duration-ink-flow) var(--transition-timing-function-lumina),
    transform var(--transition-duration-ink-flow) var(--transition-timing-function-lumina);
  display: flex;
  /* 使用Flexbox布局 */
  flex-direction: column;
  /* 子元素垂直排列 */
  height: 100vh;
  width: 100vw;
  /* 占满整个视口 */
}

/* 主容器加载完成状态，显示并回到原位 */
.main-container.loaded {
  opacity: 1;
  transform: translateY(0);
}

/* App主体容器，包含左侧边栏和右侧聊天区域 */
.app-body-container {
  display: flex;
  /* 使用Flexbox布局 */
  flex-grow: 1;
  /* 填充剩余垂直空间 */
  overflow: hidden;
  /* 隐藏溢出内容 */
  position: relative;
  /* 开启定位上下文 */
  padding: var(--spacing-unit);
  /* 外部内边距 */
  gap: var(--spacing-unit);
  /* 子元素（侧边栏和聊天区域）之间的间距 */
}

/* 当日志侧边栏打开时，调整聊天区域的右边距，为其腾出空间 */
.app-body-container.with-process-log-open .chat-area {
  margin-right: calc(var(--process-log-sidebar-width) + var(--spacing-unit));
  /* 右边距 = 侧边栏宽度 + 间距 */
  transition: margin-right var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
  /* 添加边距过渡 */
}

/* 当日志侧边栏折叠时，调整聊天区域的右边距，为其腾出折叠后的空间 */
.app-body-container.with-process-log-open.log-sidebar-collapsed .chat-area {
  margin-right: calc(var(--process-log-sidebar-width-collapsed) + var(--spacing-unit));
  /* 右边距 = 折叠侧边栏宽度 + 间距 */
}

/* 聊天区域容器，包含聊天头部、消息列表和输入区 */
.chat-area {
  flex-grow: 1;
  /* 填充剩余水平空间 */
  display: flex;
  /* 使用Flexbox布局 */
  flex-direction: column;
  /* 聊天区域内部是列布局 */
  overflow: hidden;
  /* 隐藏溢出内容 */
  transition: margin-right var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
  /* 添加右边距过渡，与侧边栏展开/折叠联动 */
}

/* 右侧日志侧边栏的布局和基础样式 */
.process-log-sidebar.lumina-panel {
  position: fixed;
  /* 固定定位 */
  top: calc(var(--header-height) + var(--spacing-unit));
  /* 位于头部下方，留出间距 */
  right: var(--spacing-unit);
  /* 右侧对齐，留出间距 */
  bottom: calc(var(--input-area-height) + var(--spacing-unit) * 2);
  /* 位于输入区上方，留出间距 */
  width: var(--process-log-sidebar-width);
  /* 默认宽度（展开状态） */
  z-index: var(--z-index-process-log);
  /* 堆叠顺序 */
  display: flex;
  /* 使用Flexbox布局 */
  flex-direction: column;
  /* 内部元素垂直排列 */
  overflow: hidden;
  /* 隐藏溢出内容 */
  transform: translateX(calc(100% + var(--spacing-unit) * 2));
  /* 初始状态向右移出屏幕 */
  opacity: 0;
  /* 初始状态透明 */
  /* 添加变形、透明度和宽度的过渡 */
  transition: transform var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
    opacity var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
    width var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
}

/* 日志侧边栏可见状态，回到屏幕内并显示 */
.process-log-sidebar.lumina-panel.visible {
  transform: translateX(0);
  opacity: 1;
}

/* 日志侧边栏折叠状态，宽度变窄 */
.process-log-sidebar.lumina-panel.collapsed {
  width: var(--process-log-sidebar-width-collapsed);
  /* 变为折叠宽度 */
}

/* 日志侧边栏折叠时，隐藏日志内容区域和头部的文本（只保留图标） */
.process-log-sidebar.lumina-panel.collapsed .process-log-content,
.process-log-sidebar.lumina-panel.collapsed .process-log-header span {
  display: none;
}

/* 日志侧边栏折叠时，头部内容水平居中 */
.process-log-sidebar.lumina-panel.collapsed .process-log-header {
  justify-content: center;
}

/* 折叠按钮箭头动画：折叠时左箭头旋转 */
.process-log-sidebar.lumina-panel.collapsed #toggle-process-log-sidebar-collapse i.fa-chevron-left {
  transform: rotate(180deg);
}

/* 折叠按钮箭头动画：折叠时右箭头恢复 */
.process-log-sidebar.lumina-panel.collapsed #toggle-process-log-sidebar-collapse i.fa-chevron-right {
  transform: rotate(0deg);
}

/* 折叠按钮箭头动画：未折叠时左箭头恢复 */
.process-log-sidebar.lumina-panel:not(.collapsed) #toggle-process-log-sidebar-collapse i.fa-chevron-left {
  transform: rotate(0deg);
}

/* 折叠按钮箭头动画：未折叠时右箭头旋转 */
.process-log-sidebar.lumina-panel:not(.collapsed) #toggle-process-log-sidebar-collapse i.fa-chevron-right {
  transform: rotate(180deg);
}


/* ==========================================================================
   [ 7. Panel Base Styles ]
   定义所有 Lumina 风格面板的基础视觉样式，包括背景、边框、阴影等。
   ========================================================================== */

/* 所有具有 .lumina-panel 类的元素的通用样式 */
.lumina-panel {
  background-color: var(--current-panel-bg);
  /* 应用当前面板背景色 */
  border: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  /* 应用细边框和当前面板边框颜色 */
  border-radius: var(--border-radius-soft);
  /* 应用柔和圆角 */
  /* 添加微妙的外部阴影 */
  box-shadow: 0 5px 25px rgba(var(--current-text-primary-rgb), 0.05),
    0 1px 3px rgba(var(--current-text-primary-rgb), 0.03);
  backdrop-filter: blur(18px) saturate(120%);
  /* 毛玻璃效果，模糊背景并增加饱和度 */
  -webkit-backdrop-filter: blur(18px) saturate(120%);
  /* Webkit内核浏览器兼容 */
  /* 添加背景、边框、阴影的过渡 */
  transition: background-color var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
    border-color var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
    box-shadow var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
  position: relative;
  /* 开启定位上下文，用于伪元素 */
  background-image: var(--current-ink-texture);
  /* 应用当前主题的背景纹理 */
  background-blend-mode: overlay;
  /* 背景纹理与背景色叠加模式 */
}

/* 面板内发光边框效果伪元素 */
.lumina-panel::before {
  content: "";
  /* 生成伪元素 */
  position: absolute;
  /* 绝对定位 */
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  /* 使伪元素覆盖整个面板 */
  border-radius: inherit;
  /* 继承父元素的圆角 */
  /* 添加内阴影，模拟内发光效果和柔和边框 */
  box-shadow: inset 0 0 12px rgba(var(--current-accent-light-rgb), 0.12),
    inset 0 0 1px 1px rgba(var(--current-panel-bg-rgb), 0.7);
  pointer-events: none;
  /* 使伪元素不影响鼠标事件 */
  z-index: 0;
  /* 位于面板内容下方 */
  opacity: 0.8;
  /* 降低透明度 */
}


/* ==========================================================================
   [ 8. Header ]
   应用 Lumina 面板基础样式到头部，并定义头部特有布局和元素样式。
   ========================================================================== */

/* 头部应用 Lumina 面板样式，并进行特定调整 */
.header.lumina-panel {
  border-radius: 0 0 var(--border-radius-soft) var(--border-radius-soft);
  /* 底部圆角，顶部直角 */
  border-width: 0 0 var(--lumina-line-weight-thin) 0;
  /* 只保留底部边框 */
  border-bottom-color: var(--current-panel-border);
  /* 底部边框颜色 */
  padding: 0 calc(var(--spacing-unit) * 2.5);
  /* 左右内边距 */
  z-index: var(--z-index-header);
  /* 堆叠顺序 */
  display: flex;
  /* 使用Flexbox布局 */
  justify-content: space-between;
  /* 子元素分散对齐 */
  align-items: center;
  /* 子元素垂直居中 */
  flex-shrink: 0;
  /* 防止头部被压缩 */
  height: var(--header-height);
  /* 固定高度 */
  position: relative;
  /* 开启定位上下文，用于面板伪元素 */
}

/* Logo区域容器 */
.header.lumina-panel .logo {
  display: flex;
  /* 使用Flexbox布局 */
  align-items: center;
  /* 垂直居中 */
}

/* Logo图标样式 */
.header.lumina-panel .logo .logo-icon i {
  color: var(--current-accent-light);
  /* 图标颜色使用光强调色 */
  font-size: calc(var(--base-font-size) * 1.9);
  /* 图标大小 */
  margin-right: calc(var(--spacing-unit) * 1.2);
  /* 图标与标题间距 */
  text-shadow: 0 0 8px var(--current-glow);
  /* 图标添加辉光阴影 */
}

/* Logo标题样式 */
.header.lumina-panel .logo h1 {
  font-size: calc(var(--base-font-size) * 1.6);
  /* 标题字体大小 */
  color: var(--current-text-primary);
  /* 标题颜色使用主要文本色 */
  font-weight: 700;
  /* 字体加粗 */
  margin: 0;
  /* 移除默认外边距 */
  text-shadow: none;
  /* 移除通用标题阴影 */
}

/* Logo标题中的'Pro'版本标识样式 */
.header.lumina-panel .logo h1 .version-pro {
  font-size: 0.65em;
  /* 相对于父元素字体大小 */
  color: var(--current-accent-ink);
  /* 颜色使用墨迹强调色 */
  margin-left: var(--spacing-unit);
  /* 与主标题间距 */
  font-weight: 500;
  /* 字体粗细 */
}

/* Logo标题中版本号的样式 */
.header.lumina-panel .logo h1 .version-pro .version-number {
  font-size: 0.9em;
  /* 相对于父元素（'Pro'）字体大小 */
  opacity: 0.85;
  /* 降低透明度 */
}

/* 头部右侧按钮容器 */
.header.lumina-panel .header-buttons {
  display: flex;
  /* 使用Flexbox布局 */
  gap: calc(var(--spacing-unit) * 0.75);
  /* 按钮之间的间距 */
}

/* 头部图标按钮样式（应用通用icon-btn并调整大小） */
.header.lumina-panel .header-buttons .header-btn.icon-btn {
  width: calc(var(--header-height) * 0.6);
  height: calc(var(--header-height) * 0.6);
  /* 根据头部高度调整按钮大小 */
  font-size: calc(var(--base-font-size) * 1.15);
  /* 图标大小 */
}

/* 头部图标按钮中隐藏文本（仅显示图标） */
.header.lumina-panel .header-buttons .header-btn.icon-btn span {
  display: none;
}

/* ==========================================================================
   [ 9. Sidebar (Left) ]
   应用 Lumina 面板基础样式到左侧边栏，并定义侧边栏特有布局和元素样式。
   ========================================================================== */

/* 左侧边栏应用 Lumina 面板样式 */
.sidebar.lumina-panel.left-sidebar {
  border-radius: var(--border-radius-soft);
  /* 应用柔和圆角 */
  width: 280px;
  /* 默认宽度（展开状态） */
  flex-shrink: 0;
  /* 防止侧边栏被压缩 */
  display: flex;
  /* 使用Flexbox布局 */
  flex-direction: column;
  /* 内部元素垂直排列 */
  padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 1.5);
  /* 默认内边距 */
  /* 添加宽度和内边距的过渡 */
  transition: width var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
    padding var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
  overflow: hidden;
  /* 隐藏溢出内容 */
  z-index: var(--z-index-sidebar);
  /* 堆叠顺序 */
  position: relative;
  /* 开启定位上下文，用于固定底部的按钮 */
  padding-bottom: calc(var(--spacing-unit) * 8);
  /* 底部留出足够的空间给固定在底部的按钮 */
}

/* 侧边栏收起状态下的样式 */
.sidebar.lumina-panel.left-sidebar:not(.expanded) {
  width: calc(var(--header-height) - var(--spacing-unit));
  /* 收起后宽度变窄，约等于头部高度减去一些间距 */
  padding: calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 0.75);
  /* 收起后调整内边距 */
}

/* 侧边栏收起状态下，隐藏文本元素（只保留图标） */
.sidebar.lumina-panel.left-sidebar:not(.expanded) .sidebar-button span,
.sidebar.lumina-panel.left-sidebar:not(.expanded) .session-manager-header span,
.sidebar.lumina-panel.left-sidebar:not(.expanded) #create-new-session span,
.sidebar.lumina-panel.left-sidebar:not(.expanded) .session-list {
  display: none;
}

/* 侧边栏收起状态下，侧边栏按钮图标移除右边距（图标居中显示） */
.sidebar.lumina-panel.left-sidebar:not(.expanded) .sidebar-button i {
  margin-right: 0;
}

/* 侧边栏开关按钮样式 */
.sidebar-toggle-btn {
  margin-bottom: calc(var(--spacing-unit) * 2);
  /* 底部间距 */
  align-self: flex-start;
  /* 在Flex容器中靠左对齐 */
}

/* 侧边栏收起状态下，开关按钮居中对齐 */
.sidebar.left-sidebar:not(.expanded) .sidebar-toggle-btn {
  align-self: center;
  /* 在Flex容器中居中对齐 */
}

/* 侧边栏内容包装器，用于实现内容区域的内部滚动 */
.sidebar.lumina-panel.left-sidebar .sidebar-content-wrapper {
  display: flex;
  /* 使用Flexbox布局 */
  flex-direction: column;
  /* 子元素垂直排列 */
  gap: calc(var(--spacing-unit) * 2.5);
  /* 子元素之间的间距 */
  flex-grow: 1;
  /* 填充剩余垂直空间 */
  overflow-y: auto;
  /* 垂直方向允许滚动 */
  overflow-x: hidden;
  /* 水平方向隐藏溢出 */
  padding-right: calc(var(--spacing-unit) * 0.5);
  /* 为自定义滚动条留出空间 */
  margin-right: calc(var(--spacing-unit) * -0.5);
  /* 负外边距抵消内边距，使内容区域宽度不变 */
}

/* 侧边栏主操作按钮组容器 */
.sidebar.lumina-panel.left-sidebar .sidebar-main-actions {
  display: flex;
  /* 使用Flexbox布局 */
  flex-direction: column;
  /* 子元素垂直排列 */
  gap: calc(var(--spacing-unit) * 0.75);
  /* 按钮之间的间距 */
}

/* 会话管理器容器 */
/* 此处规则集原为空，已移除。特定样式直接应用于其子元素。 */

/* 会话管理器头部及折叠开关样式 */
.sidebar.lumina-panel.left-sidebar .session-manager .session-manager-header {
  color: var(--current-text-primary);
  /* 文本颜色使用主要文本色 */
  display: flex;
  /* 使用Flexbox布局 */
  justify-content: space-between;
  /* 子元素分散对齐 */
  align-items: center;
  /* 垂直居中 */
  padding: calc(var(--spacing-unit) * 1.2) 0;
  /* 上下内边距，左右无内边距 */
  cursor: pointer;
  /* 鼠标悬停显示手型光标 */
  font-family: var(--font-family-title);
  /* 应用标题字体 */
  font-size: calc(var(--base-font-size) * 1.05);
  /* 字体大小 */
  border-bottom: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  /* 底部细边框 */
  margin-bottom: var(--spacing-unit);
  /* 底部外边距 */
  transition: color var(--transition-duration-light-pulse) ease;
  /* 添加颜色过渡 */
}

/* 会话管理器头部悬停时的颜色变化 */
.sidebar.lumina-panel.left-sidebar .session-manager .session-manager-header:hover {
  color: var(--current-accent-light);
  /* 悬停时颜色变为光强调色 */
}

/* 会话管理器头部标题前的图标样式 */
.sidebar.lumina-panel.left-sidebar .session-manager .session-manager-header span i {
  margin-right: var(--spacing-unit);
  /* 图标与文本间距 */
  color: var(--current-accent-ink);
  /* 图标颜色使用墨迹强调色 */
}

/* 会话管理器头部折叠/展开开关图标样式 */
.sidebar.lumina-panel.left-sidebar .session-manager .session-manager-header .toggle-icon {
  transition: transform var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
  /* 添加变形过渡 */
  color: var(--current-text-secondary);
  /* 图标颜色使用辅助文本色 */
}

/* 箭头旋转动画：会话管理器折叠时，向下箭头旋转 */
.sidebar.lumina-panel.left-sidebar .session-manager.collapsed .session-manager-header .toggle-icon.fa-caret-down {
  transform: rotate(-90deg);
}

/* 箭头旋转动画：会话管理器未折叠时，向右箭头恢复 */
.sidebar.lumina-panel.left-sidebar .session-manager:not(.collapsed) .session-manager-header .toggle-icon.fa-caret-right {
  transform: rotate(0deg);
}

/* 会话列表容器 (控制滚动和折叠动画) */
.sidebar.lumina-panel.left-sidebar .session-list-container {
  max-height: 280px;
  /* 默认最大高度，用于未折叠状态下的滚动 */
  overflow-y: auto;
  /* 垂直方向允许滚动 */
  /* 添加最大高度、内边距和透明度的过渡，用于折叠/展开动画 */
  transition: max-height var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
    padding var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
    opacity var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
  padding-bottom: var(--spacing-unit);
  /* 底部内边距 */
}

/* 会话列表容器折叠状态（通过JS控制max-height为0实现隐藏动画） */
.sidebar.lumina-panel.left-sidebar .session-manager.collapsed .session-list-container {
  max-height: 0;
  /* 折叠时高度为0 */
  padding-bottom: 0;
  /* 移除底部内边距 */
  opacity: 0;
  /* 透明度变为0 */
}


/* 会话列表无序列表样式 */
.sidebar.lumina-panel.left-sidebar .session-list {
  list-style: none;
  /* 移除列表默认标记 */
  padding: 0;
  /* 移除默认内边距 */
}

/* 会话列表项样式 */
.sidebar.lumina-panel.left-sidebar .session-list-item {
  color: var(--current-text-secondary);
  /* 默认颜色使用辅助文本色 */
  padding: calc(var(--spacing-unit) * 1) calc(var(--spacing-unit) * 1.2);
  /* 内边距 */
  border-radius: var(--border-radius-slight);
  /* 应用小圆角 */
  margin-bottom: calc(var(--spacing-unit) * 0.6);
  /* 底部外边距 */
  cursor: pointer;
  /* 鼠标悬停显示手型光标 */
  /* 添加背景、颜色、阴影的过渡 */
  transition: background-color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
    color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
    box-shadow var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
  font-size: calc(var(--base-font-size) * 0.88);
  /* 字体大小 */
  display: flex;
  /* 使用Flexbox布局 */
  justify-content: space-between;
  /* 内容与删除按钮分散对齐 */
  align-items: center;
  /* 垂直居中 */
  position: relative;
  /* 开启定位上下文，用于伪元素 */
}

/* 会话列表项左侧光带/墨痕效果 (伪元素) */
.sidebar.lumina-panel.left-sidebar .session-list-item::before {
  content: '';
  /* 生成伪元素 */
  position: absolute;
  /* 绝对定位 */
  left: 0;
  /* 位于最左侧 */
  top: 15%;
  bottom: 15%;
  /* 上下留白 */
  width: 3px;
  /* 宽度 */
  background-color: var(--current-accent-ink);
  /* 默认颜色使用墨迹强调色 */
  border-radius: 0 2px 2px 0;
  /* 右侧圆角 */
  opacity: 0;
  /* 初始透明度为0 */
  transform: scaleX(0);
  /* 初始水平缩放为0 */
  transform-origin: left;
  /* 变形原点在左侧 */
  transition: opacity var(--transition-duration-light-pulse) ease, transform var(--transition-duration-light-pulse) ease;
  /* 添加透明度和变形过渡 */
}

/* 会话列表项悬停时的样式 */
.sidebar.lumina-panel.left-sidebar .session-list-item:hover {
  background-color: rgba(var(--current-panel-bg-rgb), 0.6);
  /* 添加半透明背景 */
  color: var(--current-text-primary);
  /* 文本颜色变为主要文本色 */
  box-shadow: 0 2px 8px rgba(var(--current-text-primary-rgb), 0.05);
  /* 添加柔和阴影 */
}

/* 会话列表项悬停时，左侧光带伪元素的变化 */
.sidebar.lumina-panel.left-sidebar .session-list-item:hover::before {
  opacity: 0.7;
  /* 透明度增加 */
  transform: scaleX(1);
  /* 水平缩放恢复，显示光带 */
}

/* 活动会话列表项的样式 */
.sidebar.lumina-panel.left-sidebar .session-list-item.active-session {
  background-color: rgba(var(--current-accent-light-rgb), 0.1);
  /* 添加半透明光强调色背景 */
  color: var(--current-text-primary);
  /* 文本颜色为主要文本色 */
  font-weight: 500;
  /* 字体加粗 */
}

/* 活动会话列表项的左侧光带伪元素样式 */
.sidebar.lumina-panel.left-sidebar .session-list-item.active-session::before {
  background-color: var(--current-accent-light);
  /* 颜色变为光强调色 */
  opacity: 1;
  /* 完全不透明 */
  transform: scaleX(1);
  /* 显示光带 */
  box-shadow: 0 0 5px var(--current-glow);
  /* 添加辉光效果 */
}

/* 会话列表项内容包装器，包含会话名称和时间戳 */
.sidebar.lumina-panel.left-sidebar .session-list-item .session-item-content {
  display: flex;
  /* 使用Flexbox布局 */
  flex-direction: column;
  /* 子元素垂直排列 */
  flex-grow: 1;
  /* 填充剩余水平空间 */
  overflow: hidden;
  /* 隐藏溢出内容 */
  margin-right: var(--spacing-unit);
  /* 与右侧删除按钮保持间距 */
}

/* 会话名称样式 */
.sidebar.lumina-panel.left-sidebar .session-list-item .session-name {
  white-space: nowrap;
  /* 防止换行 */
  overflow: hidden;
  /* 隐藏溢出文本 */
  text-overflow: ellipsis;
  /* 溢出文本显示省略号 */
  font-weight: 500;
  /* 字体粗细 */
}

/* 会话时间戳样式 */
.sidebar.lumina-panel.left-sidebar .session-list-item .session-time {
  font-size: 0.82em;
  /* 相对于父元素字体大小 */
  opacity: 0.75;
  /* 降低透明度 */
}

/* 会话删除按钮样式 */
.sidebar.lumina-panel.left-sidebar .session-list-item .session-delete-btn {
  color: var(--lumina-error-color);
  /* 颜色使用错误状态色 */
  opacity: 0.6;
  /* 降低透明度 */
  width: auto;
  height: auto;
  /* 宽高自适应 */
  font-size: calc(var(--base-font-size) * 0.95);
  /* 字体大小 */
  padding: calc(var(--spacing-unit) * 0.5);
  /* 内边距 */
}

/* 会话删除按钮悬停或聚焦时的样式 */
.sidebar.lumina-panel.left-sidebar .session-list-item .session-delete-btn:hover,
.sidebar.lumina-panel.left-sidebar .session-list-item .session-delete-btn:focus {
  opacity: 1;
  /* 完全不透明 */
  background-color: rgba(var(--lumina-error-color-rgb), 0.1);
  /* 添加半透明背景 */
  color: var(--lumina-error-color);
  /* 颜色保持错误状态色 */
}

/* 空列表项（如“暂无会话”）的样式 */
.sidebar.lumina-panel.left-sidebar .session-list-item.session-list-empty {
  text-align: center;
  /* 文本居中 */
  opacity: 0.6;
  /* 降低透明度 */
  cursor: default;
  /* 鼠标悬停显示默认光标 */
  font-style: italic;
  /* 斜体 */
}

/* 空列表项图标的样式 */
.sidebar.lumina-panel.left-sidebar .session-list-item.session-list-empty i {
  margin-right: var(--spacing-unit);
  /* 图标与文本间距 */
}

/* 空列表项悬停时，移除背景效果 */
.sidebar.lumina-panel.left-sidebar .session-list-item.session-list-empty:hover {
  background-color: transparent;
}

/* 空列表项不显示左侧光带伪元素 */
.sidebar.lumina-panel.left-sidebar .session-list-item.session-list-empty::before {
  display: none;
}

/* 新建会话按钮 (固定在左侧边栏底部) */
#create-new-session.lumina-button-primary.lumina-button-fixed-bottom {
  position: absolute;
  /* 绝对定位 */
  bottom: calc(var(--spacing-unit) * 2);
  /* 距离底部距离 */
  left: calc(var(--spacing-unit) * 1.5);
  right: calc(var(--spacing-unit) * 1.5);
  /* 左右距离与侧边栏内边距对齐 */
  width: auto;
  /* 宽度自适应 */
  max-width: calc(100% - var(--spacing-unit) * 3);
  /* 最大宽度为父容器宽度减去左右内边距 */
  z-index: 10;
  /* 确保按钮在侧边栏内容之上 */
  /* 添加更强的阴影，模拟印章突出效果 */
  box-shadow: 0 3px 10px rgba(var(--current-accent-ink-rgb), 0.25),
    0 0 8px rgba(var(--current-accent-ink-rgb), 0.15);
  padding-top: calc(var(--spacing-unit) * 1.25);
  padding-bottom: calc(var(--spacing-unit) * 1.25);
  /* 调整上下内边距 */
  margin-top: 0;
  /* 移除可能的默认顶部外边距 */
}

/* 根据浅色主题微调新建会话按钮的背景和文本颜色，使其更像印章 */
body[data-theme="light-crystal"] #create-new-session.lumina-button-primary.lumina-button-fixed-bottom,
body[data-theme="auto-crystal"].light-crystal-active #create-new-session.lumina-button-primary.lumina-button-fixed-bottom {
  background-color: var(--current-accent-ink);
  /* 背景色使用墨迹强调色 */
  color: var(--lumina-bg-light);
  /* 文本颜色使用浅色主题背景色 */
  border-color: var(--current-accent-ink);
  /* 边框颜色使用墨迹强调色 */
}

/* 根据深色主题微调新建会话按钮的背景和文本颜色，使其更像金印 */
body[data-theme="dark-crystal"] #create-new-session.lumina-button-primary.lumina-button-fixed-bottom,
body[data-theme="auto-crystal"].dark-crystal-active #create-new-session.lumina-button-primary.lumina-button-fixed-bottom {
  background-color: var(--current-accent-ink);
  /* 背景色使用墨迹强调色 */
  color: var(--lumina-bg-dark);
  /* 文本颜色使用深色主题背景色 */
  border-color: var(--current-accent-ink);
  /* 边框颜色使用墨迹强调色 */
}

/* 新建会话按钮悬停/聚焦状态的样式 */
#create-new-session.lumina-button-primary.lumina-button-fixed-bottom:hover,
#create-new-session.lumina-button-primary.lumina-button-fixed-bottom:focus {
  filter: brightness(1.1);
  /* 增加亮度 */
  transform: translateY(-1px) scale(1.02);
  /* 向上轻微抬升并放大 */
  box-shadow: 0 4px 12px rgba(var(--current-accent-ink-rgb), 0.35),
    0 0 15px rgba(var(--current-accent-ink-rgb), 0.25);
  /* 增强阴影和辉光效果 */
}

/* 侧边栏收起状态下，固定按钮的样式调整 */
.sidebar.lumina-panel.left-sidebar:not(.expanded) #create-new-session.lumina-button-fixed-bottom {
  width: calc(100% - var(--spacing-unit) * 1.5);
  /* 宽度调整 */
  left: calc(var(--spacing-unit) * 0.75);
  right: calc(var(--spacing-unit) * 0.75);
  /* 左右位置调整 */
  bottom: calc(var(--spacing-unit) * 1.5);
  /* 底部位置调整 */
  padding: calc(var(--spacing-unit) * 1);
  /* 调整内边距 */
}

/* 侧边栏收起状态下，固定按钮中的文本隐藏 */
.sidebar.lumina-panel.left-sidebar:not(.expanded) #create-new-session.lumina-button-fixed-bottom span {
  display: none;
}

/* 侧边栏收起状态下，固定按钮中的图标移除右边距 */
.sidebar.lumina-panel.left-sidebar:not(.expanded) #create-new-session.lumina-button-fixed-bottom i {
  margin-right: 0;
}

/* ==========================================================================
   [ 10. Chat Area ]
   应用 Lumina 面板基础样式到聊天区域内容面板，并定义聊天区域特有布局和元素样式。
   ========================================================================== */

/* 聊天区域主要内容面板，应用 Lumina 面板样式 */
.chat-area-content.lumina-panel.main-chat-panel {
  flex-grow: 1;
  /* 填充剩余垂直空间 */
  display: flex;
  /* 使用Flexbox布局 */
  flex-direction: column;
  /* 内部元素垂直排列 */
  overflow: hidden;
  /* 隐藏溢出内容 */
  position: relative;
  /* 开启定位上下文，用于文件预览区 */
}

/* 聊天头部，显示当前会话名称 */
.chat-area-content.lumina-panel.main-chat-panel .chat-header {
  display: flex;
  /* 使用Flexbox布局 */
  justify-content: space-between;
  /* 标题与编辑按钮分散对齐 */
  align-items: center;
  /* 垂直居中 */
  padding: var(--spacing-unit) calc(var(--spacing-unit) * 2.5);
  /* 内边距 */
  border-bottom: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  /* 底部细边框 */
  flex-shrink: 0;
  /* 防止头部被压缩 */
  height: calc(var(--header-height) * 0.8);
  /* 高度略小于主头部 */
}

/* 聊天头部会话名称标题样式 */
.chat-area-content.lumina-panel.main-chat-panel .chat-header h2 {
  font-size: calc(var(--base-font-size) * 1.15);
  /* 字体大小 */
  margin: 0;
  /* 移除默认外边距 */
  font-weight: 500;
  /* 字体粗细 */
  color: var(--current-text-primary);
  /* 颜色使用主要文本色 */
  flex-grow: 1;
  /* 填充剩余空间 */
  white-space: nowrap;
  /* 防止换行 */
  overflow: hidden;
  /* 隐藏溢出文本 */
  text-overflow: ellipsis;
  /* 溢出文本显示省略号 */
  text-shadow: none;
  /* 移除通用标题阴影 */
}

/* 聊天头部编辑按钮（应用通用icon-btn样式） */
/* 此规则集原为空，已移除。特定样式由 .icon-btn 提供。 */

/* 聊天消息框容器，用于显示所有消息 */
.chat-box {
  flex-grow: 1;
  /* 填充剩余垂直空间 */
  padding: calc(var(--spacing-unit) * 2.5);
  /* 内边距 */
  overflow-y: auto;
  /* 垂直方向允许滚动 */
  display: flex;
  /* 使用Flexbox布局 */
  flex-direction: column;
  /* 子元素（消息）垂直排列 */
  gap: calc(var(--spacing-unit) * 2.5);
  /* 消息之间的间距 */
  position: relative;
  /* 开启定位上下文 */
}

/* ==========================================================================
   [ 11. Message Elements ]
   定义聊天消息（用户、Agent、系统消息）及其内部元素的样式和布局。
   ========================================================================== */

/* 消息整体容器布局，默认Agent消息样式 */
.chat-box .message {
  display: flex;
  /* 使用Flexbox布局 */
  align-items: flex-start;
  /* 头像和气泡顶部对齐 */
  max-width: 90%;
  /* 最大宽度限制，防止消息过长 */
}

/* 用户消息布局 (头像在右，气泡在右) */
.chat-box .message.message-user {
  align-self: flex-end;
  /* 在Flex容器中靠右对齐 */
  flex-direction: row-reverse;
  /* 反转主轴方向，使头像在右侧 */
}

/* Agent消息布局 (头像在左，气泡在左) */
.chat-box .message.message-agent {
  align-self: flex-start;
  /* 在Flex容器中靠左对齐 */
  /* 默认flex-direction为row，已满足布局需求 */
}

/* 系统消息布局 (无头像，居中显示) */
.chat-box .message.system-message {
  align-self: center;
  /* 在Flex容器中水平居中 */
  max-width: 85%;
  /* 最大宽度略小于普通消息 */
  width: fit-content;
  /* 宽度自适应内容 */
  font-size: calc(var(--base-font-size) * 0.88);
  /* 字体大小 */
  text-align: center;
  /* 文本居中 */
  color: var(--current-text-secondary);
  /* 颜色使用辅助文本色 */
  opacity: 0.8;
  /* 降低透明度 */
  display: block;
  /* 使用块级显示，不参与Flexbox布局 */
}

/* 欢迎消息布局 (拉伸并居中)，同时应用面板样式 */
.chat-box .message.system-message-initial.lumina-panel {
  align-self: stretch;
  /* 在Flex容器中拉伸填充 */
  width: auto;
  /* 宽度自适应 */
  max-width: 95%;
  /* 最大宽度 */
  margin: var(--spacing-unit) auto;
  /* 上下间距，左右自动外边距实现水平居中 */
  text-align: left;
  /* 文本左对齐 */
  opacity: 1;
  /* 完全不透明 */
}

/* 消息气泡的样式 */
.chat-box .message .message-bubble {
  background-color: var(--current-panel-bg);
  /* 背景色使用当前面板背景色 */
  border-radius: var(--border-radius-soft);
  /* 应用柔和圆角 */
  padding: calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 2);
  /* 内边距 */
  /* 添加微妙的阴影 */
  box-shadow: 0 3px 10px rgba(var(--current-text-primary-rgb), 0.04),
    0 1px 2px rgba(var(--current-text-primary-rgb), 0.02);
  border: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  /* 应用细边框 */
  max-width: 100%;
  /* 最大宽度为父容器的100% */
  word-break: break-word;
  /* 强制长单词或URL换行 */
  position: relative;
  /* 开启定位上下文，用于复制按钮 */
  background-blend-mode: multiply;
  /* 背景混合模式 */
  /* 添加变形和阴影过渡 */
  transition: transform var(--transition-duration-light-pulse) ease,
    box-shadow var(--transition-duration-light-pulse) ease;
  flex-grow: 0;
  /* 不拉伸 */
  flex-shrink: 1;
  /* 允许缩小 */
}

/* 消息气泡悬停状态的样式 */
.chat-box .message:hover .message-bubble {
  transform: translateY(-1px);
  /* 向上轻微抬升效果 */
  box-shadow: 0 5px 15px rgba(var(--current-text-primary-rgb), 0.06),
    0 2px 5px rgba(var(--current-text-primary-rgb), 0.03);
  /* 悬停时阴影增强 */
}

/* 用户消息气泡的样式 */
.chat-box .message.message-user .message-bubble {
  background-color: rgba(var(--current-accent-light-rgb), 0.12);
  /* 背景色使用半透明光强调色 */
  border-color: rgba(var(--current-accent-light-rgb), 0.3);
  /* 边框颜色使用半透明光强调色 */
  color: var(--current-text-primary);
  /* 文本颜色使用主要文本色 */
}

/* 用户消息气泡内的链接颜色 */
.chat-box .message.message-user .message-bubble a {
  color: var(--current-accent-light);
  /* 链接颜色使用光强调色 */
}

/* Agent 消息气泡的样式 */
/* 此规则集原为空，已移除。默认样式已应用于 .message-bubble。 */

/* 系统消息气泡的样式 */
.chat-box .message.system-message .message-bubble {
  background-color: transparent;
  /* 背景透明 */
  border: var(--lumina-line-weight-thin) dashed rgba(var(--current-panel-border-rgb), 0.6);
  /* 使用虚线边框 */
  box-shadow: none;
  /* 移除阴影 */
  padding: calc(var(--spacing-unit) * 1.2);
  /* 调整内边距 */
}

/* 错误系统消息气泡的样式 */
.chat-box .message.system-message.error-message .message-bubble {
  border-color: var(--lumina-error-color);
  /* 边框颜色使用错误状态色 */
  color: var(--lumina-error-color);
  /* 文本颜色使用错误状态色 */
}


/* 消息头像的样式 */
.chat-box .message .message-avatar {
  width: 38px;
  height: 38px;
  /* 固定宽高 */
  border-radius: 50%;
  /* 圆形 */
  background-color: var(--current-panel-border);
  /* 背景色使用面板边框颜色 */
  display: flex;
  /* 使用Flexbox布局使其内容（图标）居中 */
  align-items: center;
  justify-content: center;
  /* 水平垂直居中 */
  flex-shrink: 0;
  /* 防止头像被压缩 */
  /* 调整 margin，确保头像和气泡在同一行 */
  margin-right: calc(var(--spacing-unit) * 1.25);
  /* Agent头像在左，右边距与气泡产生间距 */
  box-shadow: 0 1px 3px rgba(var(--current-text-primary-rgb), 0.08);
  /* 添加柔和阴影 */
  transition: transform var(--transition-duration-light-pulse) ease;
  /* 添加变形过渡 */
}

/* 消息头像悬停状态的样式 */
.chat-box .message:hover .message-avatar {
  transform: scale(1.05);
  /* 轻微放大效果 */
}

/* 消息头像内的图标样式 */
.chat-box .message .message-avatar i {
  font-size: calc(var(--base-font-size) * 1.2);
  /* 图标大小 */
  color: var(--current-text-secondary);
  /* 图标颜色使用辅助文本色 */
}

/* 用户消息头像 (在气泡右侧) 的样式 */
.chat-box .message.message-user .message-avatar {
  margin-right: 0;
  /* 移除右边距 */
  margin-left: calc(var(--spacing-unit) * 1.25);
  /* 左边距与气泡产生间距 */
  background-color: var(--current-accent-light);
  /* 背景色使用光强调色 */
}

/* 用户消息头像内的图标颜色 */
.chat-box .message.message-user .message-avatar i {
  color: var(--current-bg);
  /* 图标颜色使用当前背景色（与光强调色背景形成对比） */
}

/* Agent消息头像 (在气泡左侧) 的样式 */
.chat-box .message.message-agent .message-avatar {
  background-color: var(--current-accent-ink);
  /* 背景色使用墨迹强调色 */
}

/* Agent消息头像内的图标颜色 */
.chat-box .message.message-agent .message-avatar i {
  color: var(--current-bg);
  /* 图标颜色使用当前背景色（与墨迹强调色背景形成对比） */
}

/* 系统消息没有头像，隐藏头像元素 */
.chat-box .message.system-message .message-avatar {
  display: none;
}


/* 消息内容包装器 (包含思考过程和文本内容) */
.chat-box .message .message-content-wrapper {
  /* 此处规则集原为空，保留作容器用途。 */

  display: flex;
  /* 使用Flexbox布局 */
  flex-direction: column;
  /* 子元素垂直排列 */
  gap: calc(var(--spacing-unit) * 1.5);

}

/* 思考过程前缀（Thinking Process）的样式 */
.chat-box .message .message-thought-prefix {
  margin-bottom: calc(var(--spacing-unit) * 1.5);
  /* 底部外边距 */
  padding: calc(var(--spacing-unit) * 1.2);
  /* 内边距 */
  background-color: rgba(var(--current-panel-bg-rgb), 0.4);
  /* 半透明背景色 */
  border-radius: var(--border-radius-slight);
  /* 应用小圆角 */
  border: var(--lumina-line-weight-thin) dashed rgba(var(--current-panel-border-rgb), 0.7);
  /* 使用虚线边框 */
  font-size: 0.88em;
  /* 字体大小 */
  color: var(--current-text-secondary);
  /* 文本颜色使用辅助文本色 */
}

/* 思考过程前缀中的标题（如“Thinking Process:”）样式 */
.chat-box .message .message-thought-prefix strong {
  display: block;
  /* 块级显示 */
  margin-bottom: calc(var(--spacing-unit) * 0.75);
  /* 底部外边距 */
  font-family: var(--font-family-title);
  /* 应用标题字体 */
  color: var(--current-accent-ink);
  /* 颜色使用墨迹强调色 */
  font-weight: 500;
  /* 字体粗细 */
}

/* 思考过程前缀标题内的图标样式 */
.chat-box .message .message-thought-prefix strong i {
  margin-right: var(--spacing-unit);
  /* 图标与文本间距 */
}

/* 思考过程内容的容器，用于控制滚动 */
.chat-box .message .message-thought-prefix .think-bubble-content {
  line-height: 1.5;
  /* 行高 */
  max-height: 200px;
  /* 最大高度，超出则滚动 */
  overflow-y: auto;
  /* 垂直方向允许滚动 */
  padding-right: var(--spacing-unit);
  /* 为可能出现的滚动条留出空间 */
}

/* 思考内容中嵌入的 JSON 美化样式 */
.chat-box .message .message-thought-prefix .think-bubble-content pre.embedded-json {
  background-color: rgba(var(--current-bg-rgb), 0.3);
  /* 半透明背景色 */
  padding: calc(var(--spacing-unit) * 1);
  /* 内边距 */
  border-radius: var(--border-radius-slight);
  /* 应用小圆角 */
  margin-top: var(--spacing-unit);
  /* 顶部外边距 */
  font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
  /* 等宽字体 */
  font-size: 0.92em;
  /* 字体大小 */
  color: var(--current-text-secondary);
  /* 颜色使用辅助文本色 */
  border: 1px solid rgba(var(--current-panel-border-rgb), 0.3);
  /* 细边框 */
  white-space: pre-wrap; /* 允许换行 */
  word-break: break-all; /* 强制长单词或 URL 换行 */
}

/* 思考内容中嵌入的错误状态 JSON 样式 */
.chat-box .message .message-thought-prefix .think-bubble-content pre.embedded-json.error {
  color: var(--lumina-error-color);
  /* 颜色使用错误状态色 */
  border-color: var(--lumina-error-color);
  /* 边框颜色使用错误状态色 */
}

/* 消息主要文本内容的样式 */
.chat-box .message .message-text-content {
  line-height: 1.65;
  /* 行高 */
}

/* 消息文本内容中外部链接图标的样式 */
.chat-box .message .message-text-content a.external-link i {
  font-size: 0.82em;
  /* 图标大小 */
  margin-right: 4px;
  /* 图标与文本间距 */
  opacity: 0.75;
  /* 降低透明度 */
}

/* 附件摘要区域的样式 */
.chat-box .message .message-attachments-summary {
  margin-top: calc(var(--spacing-unit) * 1.2);
  /* 顶部外边距 */
  font-size: 0.82em;
  /* 字体大小 */
  opacity: 0.85;
  /* 降低透明度 */
  color: var(--current-text-secondary);
  /* 颜色使用辅助文本色 */
}

/* 附件摘要区域图标的样式 */
.chat-box .message .message-attachments-summary i {
  margin-right: calc(var(--spacing-unit) * 0.6);
  /* 图标与文本间距 */
}

/* 附件摘要中的文件名“芯片”样式 */
.chat-box .message .message-attachments-summary .filename-chip {
  display: inline-block;
  /* 内联块级显示 */
  background-color: rgba(var(--current-panel-border-rgb), 0.5);
  /* 半透明背景色 */
  color: var(--current-text-secondary);
  /* 文本颜色使用辅助文本色 */
  padding: 3px calc(var(--spacing-unit) * 0.75);
  /* 内边距 */
  border-radius: 12px;
  /* 应用较大圆角，形成芯片形状 */
  font-size: 0.92em;
  /* 字体大小 */
}

/* 欢迎消息的特定样式 (继承自 .system-message-initial.lumina-panel) */
.chat-box .message.system-message-initial.lumina-panel {
  padding: calc(var(--spacing-unit) * 2.5) calc(var(--spacing-unit) * 3);
  /* 调整内边距 */
  border-width: var(--lumina-line-weight-medium);
  /* 边框使用中等粗细 */
}

/* 欢迎消息头部的样式 */
.chat-box .message.system-message-initial.lumina-panel .welcome-header {
  display: flex;
  /* 使用Flexbox布局 */
  align-items: center;
  /* 垂直居中 */
  margin-bottom: calc(var(--spacing-unit) * 1.5);
  /* 底部外边距 */
}

/* 欢迎消息头部机器人图标样式 */
.chat-box .message.system-message-initial.lumina-panel .welcome-header .robot-icon {
  color: var(--current-accent-light);
  /* 颜色使用光强调色 */
  font-size: calc(var(--base-font-size) * 2.8);
  /* 图标大小 */
  margin-right: calc(var(--spacing-unit) * 1.5);
  /* 图标与标题间距 */
  text-shadow: 0 0 12px var(--current-glow);
  /* 添加辉光阴影 */
}

/* 欢迎消息头部标题样式 */
.chat-box .message.system-message-initial.lumina-panel .welcome-header h2 {
  font-size: calc(var(--base-font-size) * 1.9);
  /* 字体大小 */
  margin-bottom: 0;
  /* 移除默认底部外边距 */
  font-weight: 700;
  /* 字体加粗 */
}

/* 欢迎消息头部标题中的'Pro'版本标识样式 */
.chat-box .message.system-message-initial.lumina-panel .welcome-header h2 .version-pro {
  font-size: 0.6em;
  /* 相对于父元素字体大小 */
  color: var(--current-accent-ink);
  /* 颜色使用墨迹强调色 */
}

/* 欢迎消息头部标题中版本号的样式 */
.chat-box .message.system-message-initial.lumina-panel .welcome-header h2 .version-number {
  opacity: 0.8;
  /* 降低透明度 */
}

/* 欢迎消息能力列表容器样式 */
.chat-box .message.system-message-initial.lumina-panel .capabilities {
  display: flex;
  /* 使用Flexbox布局 */
  flex-wrap: wrap;
  /* 允许换行 */
  gap: calc(var(--spacing-unit) * 1.2);
  /* 项目之间的间距 */
  margin-bottom: calc(var(--spacing-unit) * 2.5);
  /* 底部外边距 */
}

/* 欢迎消息能力“芯片”样式 */
.chat-box .message.system-message-initial.lumina-panel .capabilities .capability {
  background-color: rgba(var(--current-accent-light-rgb), 0.06);
  /* 半透明背景色 */
  border: var(--lumina-line-weight-thin) solid rgba(var(--current-accent-light-rgb), 0.2);
  /* 细边框 */
  padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 1.2);
  /* 内边距 */
  border-radius: 18px;
  /* 应用较大圆角，形成芯片形状 */
  font-size: 0.88em;
  /* 字体大小 */
  display: inline-flex;
  /* 内联Flexbox布局 */
  align-items: center;
  /* 垂直居中 */
  color: var(--current-text-secondary);
  /* 文本颜色使用辅助文本色 */
  transition: all var(--transition-duration-light-pulse) ease;
  /* 添加所有属性的过渡 */
}

/* 欢迎消息能力“芯片”悬停时的样式 */
.chat-box .message.system-message-initial.lumina-panel .capabilities .capability:hover {
  background-color: rgba(var(--current-accent-light-rgb), 0.12);
  /* 背景色加深 */
  color: var(--current-text-primary);
  /* 文本颜色变为主要文本色 */
  transform: translateY(-1px);
  /* 向上轻微抬升 */
  box-shadow: 0 2px 5px rgba(var(--current-accent-light-rgb), 0.1);
  /* 添加柔和阴影 */
}

/* 欢迎消息能力“芯片”内的图标样式 */
.chat-box .message.system-message-initial.lumina-panel .capabilities .capability i {
  color: var(--current-accent-light);
  /* 图标颜色使用光强调色 */
  margin-right: calc(var(--spacing-unit) * 0.75);
  /* 图标与文本间距 */
}

/* 欢迎消息中的快捷操作区标题样式 */
.chat-box .message.system-message-initial.lumina-panel .quick-actions p {
  font-weight: 500;
  /* 字体加粗 */
  margin-bottom: calc(var(--spacing-unit) * 1.2);
  /* 底部外边距 */
  color: var(--current-text-primary);
  /* 文本颜色使用主要文本色 */
}

/* 欢迎消息中的快捷操作列表容器样式 */
.chat-box .message.system-message-initial.lumina-panel .quick-actions ul {
  list-style: none;
  /* 移除列表默认标记 */
  padding: 0;
  /* 移除默认内边距 */
  display: flex;
  /* 使用Flexbox布局 */
  flex-wrap: wrap;
  /* 允许换行 */
  gap: calc(var(--spacing-unit) * 1);
  /* 项目之间的间距 */
}

/* 欢迎消息中的快捷操作按钮样式 (应用通用lumina-button并调整大小) */
.chat-box .message.system-message-initial.lumina-panel .quick-actions ul li a.quick-action-btn.lumina-button {
  padding: calc(var(--spacing-unit) * 0.8) calc(var(--spacing-unit) * 1.5);
  /* 调整内边距 */
  font-size: calc(var(--base-font-size) * 0.85);
  /* 调整字体大小 */
}

/* 打字指示器（Typing Indicator）的容器样式 */
.chat-box .typing-indicator {
  display: flex;
  /* 使用Flexbox布局 */
  align-items: flex-start;
  /* 内容顶部对齐 */
}

/* 打字指示器消息气泡的样式 */
.chat-box .typing-indicator .message-bubble {
  background-color: var(--current-panel-bg);
  /* 背景色使用当前面板背景色 */
  padding: calc(var(--spacing-unit) * 1.2) calc(var(--spacing-unit) * 1.8);
  /* 调整内边距 */
}

/* 打字指示器中的点容器样式 */
.chat-box .typing-indicator .message-bubble .typing-dots {
  display: inline-flex;
  /* 内联Flexbox布局 */
  align-items: center;
  /* 垂直居中 */
}

/* 打字指示器中的点样式 */
.chat-box .typing-indicator .message-bubble .typing-dots .typing-dot {
  background-color: var(--current-accent-ink);
  /* 背景色使用墨迹强调色 */
  width: 7px;
  height: 7px;
  /* 固定宽高 */
  border-radius: 50%;
  /* 圆形 */
  margin: 0 3px;
  /* 水平间距 */
  animation: luminaTypingDotBounce 1.3s infinite ease-in-out;
  /* 应用跳动动画 */
}

/* 打字指示器第二个点的动画延迟 */
.chat-box .typing-indicator .message-bubble .typing-dots .typing-dot:nth-child(2) {
  animation-delay: 0.22s;
}

/* 打字指示器第三个点的动画延迟 */
.chat-box .typing-indicator .message-bubble .typing-dots .typing-dot:nth-child(3) {
  animation-delay: 0.44s;
}

/* 复制按钮样式 */
.message-bubble .copy-llm-response-btn {
  position: absolute;
  /* 绝对定位 */
  top: calc(var(--spacing-unit) * 1);
  right: calc(var(--spacing-unit) * 1);
  /* 定位在气泡右上角 */
  opacity: 0;
  visibility: hidden;
  /* 初始状态隐藏 */
  /* 添加透明度和可见性过渡 */
  transition: opacity var(--transition-duration-light-pulse) ease-in-out,
    visibility 0s var(--transition-duration-light-pulse) ease-in-out,
    background-color var(--transition-duration-light-pulse) ease-in-out;
  z-index: 10;
  /* 确保在气泡内容之上 */
  cursor: pointer;
  /* 鼠标悬停显示手型光标 */
}

/* 消息气泡悬停时显示复制按钮 */
.message-bubble:hover .copy-llm-response-btn {
  opacity: 1;
  visibility: visible;
  /* 悬停时显示 */
  transition-delay: 0s, 0s;
  /* 过渡延迟设为0，立即显示 */
}

/* 复制按钮悬停状态的样式 */
.message-bubble .copy-llm-response-btn:hover {
  background-color: rgba(var(--current-text-primary-rgb), 0.1);
  /* 添加半透明背景 */
  color: var(--current-text-primary);
  /* 文本颜色变为主要文本色 */
}

/* 确保复制按钮内的图标不影响鼠标事件 */
.message-bubble .copy-llm-response-btn i {
  pointer-events: none;
}


/* ==========================================================================
   [ 12. Input Area ]
   定义用户输入区域的样式和布局。
   ========================================================================== */

/* 用户输入区域容器，应用 Lumina 面板样式 */
.input-area.lumina-panel {
  border-radius: var(--border-radius-soft);
  /* 应用柔和圆角 */
  padding: calc(var(--spacing-unit) * 1.5);
  /* 内边距 */
  display: flex;
  /* 使用Flexbox布局 */
  align-items: flex-end;
  /* 子元素底部对齐 */
  flex-shrink: 0;
  /* 防止输入区域被压缩 */
  z-index: 5;
  /* 堆叠顺序 */
  border-top-width: var(--lumina-line-weight-thin);
  /* 顶部边框宽度 */
  position: relative;
  /* 开启定位上下文，用于文件预览区 */
}

/* 输入区域左侧操作按钮 (附件、语音等) 样式 */
.input-area.lumina-panel .input-action-btn {
  margin-right: calc(var(--spacing-unit) * 1);
  /* 右侧外边距 */
  align-self: flex-end;
  /* 在Flex容器中底部对齐 */
  margin-bottom: calc(var(--spacing-unit) * 0.35);
  /* 底部微调，使其与输入框底部对齐 */
}

/* 输入区域输入框和内部覆盖元素的包装器 */
.input-area.lumina-panel .input-wrapper {
  flex-grow: 1;
  /* 填充剩余水平空间 */
  position: relative;
  /* 开启定位上下文 */
  display: flex;
  /* 使用Flexbox布局 */
  flex-direction: column;
  /* 内部元素垂直排列 */
}

/* 发送按钮样式 (应用 Lumina 主按钮样式并调整) */
.input-area.lumina-panel .send-button.lumina-button-primary {
  width: 56px;
  height: 56px;
  /* 固定宽高 */
  align-self: flex-end;
  /* 在Flex容器中底部对齐 */
  margin-left: var(--spacing-unit);
  /* 左侧外边距 */
  border-radius: 50%;
  /* 圆形 */
  padding: 0;
  /* 移除内边距 */
}

/* 发送按钮内的SVG图标样式 */
.input-area.lumina-panel .send-button.lumina-button-primary .send-icon {
  width: 26px;
  height: 26px;
  /* 图标宽高 */
  fill: var(--current-bg);
  /* 填充颜色使用当前背景色（与按钮墨迹强调色背景形成对比） */
}

/* 发送按钮内的加载图标样式 */
.input-area.lumina-panel .send-button.lumina-button-primary .send-loading-icon {
  font-size: 22px;
  /* 图标大小 */
  color: var(--current-bg);
  /* 颜色使用当前背景色 */
}

/* 发送中状态下按钮应用的动画 */
.input-area.lumina-panel .send-button.lumina-button-primary.processing-active {
  animation: luminaSendButtonProcessing 1.8s infinite ease-in-out;
  /* 应用处理中动画 */
}

/* 用户输入框 (input, textarea, select) 的通用样式 */
input,
textarea,
select {
  font-family: var(--font-family-body);
  /* 应用主体文本字体 */
  background-color: rgba(var(--current-bg-rgb), 0.5);
  /* 半透明背景色 */
  border: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  /* 细边框 */
  color: var(--current-text-primary);
  /* 文本颜色使用主要文本色 */
  padding: calc(var(--spacing-unit) * 1.35) calc(var(--spacing-unit) * 1.5);
  /* 内边距 */
  border-radius: var(--border-radius-slight);
  /* 应用小圆角 */
  /* 添加边框颜色和阴影过渡 */
  transition: border-color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
    box-shadow var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
  width: 100%;
  /* 宽度占满父容器 */
}

/* 输入框聚焦状态的样式 */
input:focus,
textarea:focus,
select:focus {
  outline: none;
  /* 移除默认聚焦轮廓 */
  border-color: var(--current-accent-light);
  /* 边框颜色变为光强调色 */
  /* 添加辉光阴影 */
  box-shadow: 0 0 0 var(--lumina-line-weight-bold) rgba(var(--current-accent-light-rgb), 0.3),
    0 0 8px rgba(var(--current-accent-light-rgb), 0.2);
}

/* 用户文本输入框 (textarea) 的特定样式 */
textarea#user-input {
  border-width: var(--lumina-line-weight-medium);
  /* 使用中等粗细边框 */
  background-color: transparent;
  /* 默认背景透明 */
  min-height: 56px;
  /* 最小高度，与发送按钮高度对齐 */
  max-height: 180px;
  /* 最大高度，防止输入框过高 */
  padding-right: calc(var(--spacing-unit) * 9);
  /* 右侧内边距，为覆盖的按钮和计数器留出空间 */
  line-height: 1.6;
  /* 行高 */
  font-size: var(--base-font-size);
  /* 字体大小 */
  resize: none;
  /* 禁止手动调整大小 */
}

/* 用户文本输入框聚焦时的背景色 */
textarea#user-input:focus {
  background-color: rgba(var(--current-panel-bg-rgb), 0.3);
  /* 聚焦时背景变为半透明面板背景色 */
}

/* 输入框内覆盖的按钮和计数器区域 */
.input-area.lumina-panel .input-actions-overlay {
  position: absolute;
  /* 绝对定位 */
  right: calc(var(--spacing-unit) * 1.25);
  bottom: calc(var(--spacing-unit) * 1);
  /* 定位在输入框的右下角 */
  display: flex;
  /* 使用Flexbox布局 */
  align-items: center;
  /* 垂直居中 */
  gap: calc(var(--spacing-unit) * 0.75);
  /* 子元素之间的间距 */
}

/* 输入框内覆盖的操作按钮 (麦克风等) 样式 */
.input-area.lumina-panel .input-actions-overlay .overlay-btn {
  padding: calc(var(--spacing-unit) * 0.6);
  /* 内边距 */
  font-size: calc(var(--base-font-size) * 1.05);
  /* 图标大小 */
  color: var(--current-text-secondary);
  /* 默认颜色使用辅助文本色 */
  opacity: 0.65;
  /* 降低透明度 */
  background-color: transparent;
  /* 背景透明 */
  border-radius: var(--border-radius-slight);
  /* 应用小圆角 */
}

/* 输入框内覆盖的操作按钮悬停时的样式 */
.input-area.lumina-panel .input-actions-overlay .overlay-btn:hover {
  opacity: 1;
  /* 完全不透明 */
  color: var(--current-accent-light);
  /* 颜色变为光强调色 */
  background-color: rgba(var(--current-accent-light-rgb), 0.08);
  /* 添加半透明背景 */
}

/* 字符计数器样式 */
.input-area.lumina-panel .input-actions-overlay .char-counter {
  font-size: 0.78em;
  /* 字体大小 */
  color: var(--current-text-secondary);
  /* 默认颜色使用辅助文本色 */
  opacity: 0.55;
  /* 降低透明度 */
  margin-right: var(--spacing-unit);
  /* 右侧外边距 */
}

/* 字符计数器警告状态样式 */
.input-area.lumina-panel .input-actions-overlay .char-counter.warn {
  color: var(--current-accent-ink);
  /* 颜色使用墨迹强调色 */
  opacity: 0.8;
  /* 提高透明度 */
}

/* 字符计数器错误状态样式 */
.input-area.lumina-panel .input-actions-overlay .char-counter.error {
  color: var(--lumina-error-color);
  /* 颜色使用错误状态色 */
  opacity: 1;
  /* 完全不透明 */
  font-weight: 500;
  /* 字体加粗 */
}


/* ==========================================================================
   [ 13. File Preview ]
   文件预览区域样式。
   ========================================================================== */

/* 文件预览区域容器，应用 Lumina 面板样式 */
.file-preview.lumina-panel {
  position: absolute;
  /* 绝对定位，相对于父元素 .chat-area-content */
  bottom: calc(100% + var(--spacing-unit) * 1.25);
  /* 位于父元素底部上方，留出间距 */
  left: 0;
  right: 0;
  /* 左右拉伸填满父容器宽度 */
  max-height: 160px;
  /* 最大高度 */
  display: none;
  /* 初始状态隐藏 */
  flex-direction: column;
  /* 内部元素垂直排列 */
  z-index: var(--z-index-file-preview);
  /* 堆叠顺序 */
  overflow: hidden;
  /* 隐藏溢出内容 */
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
  /* 底部直角 */
  border-bottom-width: 0;
  /* 移除底部边框 */
}

/* 文件预览区域可见状态 */
.file-preview.lumina-panel.active {
  display: flex;
  /* 可见时使用Flexbox布局显示 */
}

/* 文件预览头部样式 */
.file-preview.lumina-panel .file-preview-header {
  display: flex;
  /* 使用Flexbox布局 */
  justify-content: space-between;
  /* 标题与关闭按钮分散对齐 */
  align-items: center;
  /* 垂直居中 */
  padding: calc(var(--spacing-unit) * 1) calc(var(--spacing-unit) * 1.5);
  /* 内边距 */
  border-bottom: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  /* 底部细边框 */
  flex-shrink: 0;
  /* 防止头部被压缩 */
}

/* 文件预览头部标题样式 */
.file-preview.lumina-panel .file-preview-header h3 {
  font-size: 0.95em;
  /* 字体大小 */
  margin: 0;
  /* 移除默认外边距 */
  font-family: var(--font-family-title);
  /* 应用标题字体 */
  color: var(--current-text-primary);
  /* 颜色使用主要文本色 */
  font-weight: 500;
  /* 字体粗细 */
}

/* 文件预览头部标题内的图标样式 */
.file-preview.lumina-panel .file-preview-header h3 i {
  color: var(--current-accent-light);
  /* 颜色使用光强调色 */
  margin-right: var(--spacing-unit);
  /* 图标与文本间距 */
}

/* 文件预览头部关闭按钮（应用通用icon-btn样式） */
/* 此规则集原为空，已移除。特定样式由 .icon-btn 提供。 */


/* 文件预览内容区域（文件列表）样式 */
.file-preview.lumina-panel .file-preview-content {
  flex-grow: 1;
  /* 填充剩余垂直空间 */
  overflow-y: auto;
  /* 垂直方向允许滚动 */
  padding: calc(var(--spacing-unit) * 1.25);
  /* 内边距 */
  display: flex;
  /* 使用Flexbox布局 */
  flex-wrap: wrap;
  /* 允许换行 */
  gap: calc(var(--spacing-unit) * 1);
  /* 文件项之间的间距 */
}

/* 单个文件项的样式 */
.file-preview.lumina-panel .file-item {
  background-color: rgba(var(--current-bg-rgb), 0.5);
  /* 半透明背景色 */
  border: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  /* 细边框 */
  border-radius: 18px;
  /* 应用较大圆角，形成芯片形状 */
  padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 1.2);
  /* 内边距 */
  display: inline-flex;
  /* 内联Flexbox布局 */
  align-items: center;
  /* 垂直居中 */
  font-size: 0.85em;
  /* 字体大小 */
  color: var(--current-text-secondary);
  /* 文本颜色使用辅助文本色 */
  transition: all var(--transition-duration-light-pulse) ease;
  /* 添加所有属性的过渡 */
}

/* 文件项悬停状态的样式 */
.file-preview.lumina-panel .file-item:hover {
  border-color: var(--current-accent-light);
  /* 边框颜色变为光强调色 */
  color: var(--current-text-primary);
  /* 文本颜色变为主要文本色 */
  box-shadow: 0 1px 4px rgba(var(--current-accent-light-rgb), 0.1);
  /* 添加柔和阴影 */
}

/* 文件项图标的样式 */
.file-preview.lumina-panel .file-item .file-icon {
  color: var(--current-accent-light);
  /* 颜色使用光强调色 */
  margin-right: calc(var(--spacing-unit) * 0.75);
  /* 图标与文本间距 */
  font-size: 1.1em;
  /* 图标大小 */
}

/* 文件名称文本样式 */
.file-preview.lumina-panel .file-item .file-name {
  max-width: 160px;
  /* 最大宽度限制 */
  white-space: nowrap;
  /* 防止换行 */
  overflow: hidden;
  /* 隐藏溢出文本 */
  text-overflow: ellipsis;
  /* 溢出文本显示省略号 */
}

/* 移除文件按钮样式 */
.file-preview.lumina-panel .file-item .file-remove {
  font-size: 1em;
  /* 字体大小 */
  color: var(--lumina-error-color);
  /* 颜色使用错误状态色 */
  margin-left: calc(var(--spacing-unit) * 0.8);
  /* 左侧外边距 */
  opacity: 0.7;
  /* 降低透明度 */
  padding: 2px;
  /* 内边距，增加点击区域 */
}

/* 移除文件按钮悬停或聚焦时的样式 */
.file-preview.lumina-panel .file-item .file-remove:hover,
.file-preview.lumina-panel .file-item .file-remove:focus {
  opacity: 1;
  /* 完全不透明 */
  background-color: rgba(var(--lumina-error-color-rgb), 0.1);
  /* 添加半透明背景 */
}


/* ==========================================================================
   [ 14. Modal (Settings) ]
   设置模态框的整体结构和基础样式。
   ========================================================================== */

/* 模态框背景遮罩层 */
.modal {
  position: fixed;
  /* 固定定位，覆盖整个视口 */
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  /* 占满整个视口 */
  background-color: rgba(var(--lumina-bg-dark, 22, 24, 29), 0.65);
  /* 半透明深色背景 */
  backdrop-filter: blur(10px) brightness(0.8);
  /* 毛玻璃效果，模糊背景并降低亮度 */
  -webkit-backdrop-filter: blur(10px) brightness(0.8);
  /* Webkit内核浏览器兼容 */
  display: none;
  /* 初始状态隐藏 */
  align-items: center;
  /* 垂直居中 */
  justify-content: center;
  /* 水平居中 */
  z-index: var(--z-index-modal);
  /* 堆叠顺序 */
}

/* 模态框内容容器，应用 Lumina 面板样式 */
.modal .modal-content.lumina-panel {
  max-width: 680px;
  /* 最大宽度 */
  width: 92%;
  /* 默认宽度 */
  max-height: 85vh;
  /* 最大高度，防止内容过多溢出视口 */
  display: flex;
  /* 使用Flexbox布局 */
  flex-direction: column;
  /* 内部元素垂直排列 */
  overflow: hidden;
  /* 隐藏溢出内容 */
  /* 添加阴影和边框效果 */
  box-shadow: 0 10px 40px rgba(var(--current-text-primary-rgb), 0.1),
    0 0 0 1px rgba(var(--current-panel-border-rgb), 0.5);
}

/* 模态框头部样式 */
.modal .modal-content.lumina-panel .modal-header {
  display: flex;
  /* 使用Flexbox布局 */
  justify-content: space-between;
  /* 标题与关闭按钮分散对齐 */
  align-items: center;
  /* 垂直居中 */
  padding: calc(var(--spacing-unit) * 1.8) calc(var(--spacing-unit) * 2.5);
  /* 内边距 */
  border-bottom: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  /* 底部细边框 */
  flex-shrink: 0;
  /* 防止头部被压缩 */
}

/* 模态框头部标题样式 */
.modal .modal-content.lumina-panel .modal-header h2 {
  font-size: calc(var(--base-font-size) * 1.35);
  /* 字体大小 */
  margin: 0;
  /* 移除默认外边距 */
  font-weight: 500;
  /* 字体粗细 */
  color: var(--current-text-primary);
  /* 颜色使用主要文本色 */
}

/* 模态框头部标题内的图标样式 */
.modal .modal-content.lumina-panel .modal-header h2 i {
  color: var(--current-accent-light);
  /* 颜色使用光强调色 */
  margin-right: calc(var(--spacing-unit) * 1.2);
  /* 图标与文本间距 */
}

/* 模态框头部关闭按钮（应用通用icon-btn样式） */
/* 此规则集原为空，已移除。特定样式由 .icon-btn 提供。 */


/* 模态框主体内容区域样式 */
.modal .modal-content.lumina-panel .modal-body {
  padding: calc(var(--spacing-unit) * 2.5);
  /* 内边距 */
  overflow-y: auto;
  /* 垂直方向允许滚动 */
  flex-grow: 1;
  /* 填充剩余垂直空间 */
}

/* 设置分组容器样式 */
.modal .modal-content.lumina-panel .modal-body .setting-group {
  margin-bottom: calc(var(--spacing-unit) * 3);
  /* 底部外边距 */
}

/* 最后一个设置分组移除底部外边距 */
.modal .modal-content.lumina-panel .modal-body .setting-group:last-child {
  margin-bottom: 0;
}

/* 设置分组标题样式 */
.modal .modal-content.lumina-panel .modal-body .setting-group h3 {
  font-size: calc(var(--base-font-size) * 1.1);
  /* 字体大小 */
  border-bottom: var(--lumina-line-weight-thin) solid rgba(var(--current-panel-border-rgb), 0.7);
  /* 底部细边框 */
  padding-bottom: calc(var(--spacing-unit) * 1.2);
  /* 底部内边距 */
  margin-bottom: calc(var(--spacing-unit) * 1.8);
  /* 底部外边距 */
  color: var(--current-text-primary);
  /* 颜色使用主要文本色 */
  font-weight: 500;
  /* 字体粗细 */
}

/* 设置分组标题内的图标样式 */
.modal .modal-content.lumina-panel .modal-body .setting-group h3 i {
  color: var(--current-accent-ink);
  /* 颜色使用墨迹强调色 */
  margin-right: var(--spacing-unit);
  /* 图标与文本间距 */
}

/* 单个设置项容器样式 */
.modal .modal-content.lumina-panel .modal-body .setting-item {
  display: flex;
  /* 使用Flexbox布局 */
  justify-content: space-between;
  /* 标签与控件分散对齐 */
  align-items: center;
  /* 垂直居中 */
  margin-bottom: calc(var(--spacing-unit) * 1.8);
  /* 底部外边距 */
  font-size: calc(var(--base-font-size) * 0.92);
  /* 字体大小 */
  color: var(--current-text-secondary);
  /* 默认颜色使用辅助文本色 */
}

/* 单个设置项中标签 (label) 的样式 */
.modal .modal-content.lumina-panel .modal-body .setting-item label:first-child {
  flex-basis: 55%;
  /* 占据约55%的宽度 */
  margin-right: var(--spacing-unit);
  /* 右侧外边距 */
  color: var(--current-text-primary);
  /* 颜色使用主要文本色 */
}


/* ==========================================================================
   [ 15. Settings Modal Controls ]
   设置模态框内表单控件（下拉框、范围滑块、开关）的样式。
   ========================================================================== */

/* 设置项中的控件通用容器样式 */
.modal .modal-content.lumina-panel .modal-body .setting-item .lumina-select,
.modal .modal-content.lumina-panel .modal-body .setting-item .lumina-range-container,
.modal .modal-content.lumina-panel .modal-body .setting-item .lumina-switch-container {
  flex-grow: 1;
  /* 填充剩余水平空间 */
  max-width: 240px;
  /* 最大宽度限制 */
  border: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  /* 细边框 */
  border-radius: var(--border-radius-slight);
  /* 应用小圆角 */
  padding: calc(var(--spacing-unit) * 0.9);
  /* 内边距 */
  background-color: rgba(var(--current-bg-rgb), 0.4);
  /* 半透明背景色 */
}

/* 开关控件容器的特殊样式 (覆盖通用控件容器样式) */
.modal .modal-content.lumina-panel .modal-body .setting-item .lumina-switch-container {
  border: none;
  /* 无边框 */
  padding: 0;
  /* 无内边距 */
  background-color: transparent;
  /* 背景透明 */
  display: flex;
  /* 使用Flexbox布局 */
  justify-content: flex-end;
  /* 子元素靠右对齐 */
}

/* 范围滑块容器样式 */
.modal .modal-content.lumina-panel .modal-body .setting-item .lumina-range-container {
  display: flex;
  /* 使用Flexbox布局 */
  align-items: center;
  /* 垂直居中 */
  padding-right: 0;
  /* 右侧内边距为0，因为值显示元素单独处理 */
}

/* 范围滑块 (input type=range) 样式 */
.modal .modal-content.lumina-panel .modal-body .setting-item input[type=range] {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  /* 移除原生样式 */
  width: 100%;
  height: 6px;
  /* 滑轨高度 */
  background: rgba(var(--current-panel-border-rgb), 0.5);
  /* 滑轨背景色 */
  border-radius: 3px;
  /* 滑轨圆角 */
  outline: none;
  /* 移除轮廓 */
  border: none;
  /* 移除边框 */
}

/* 范围滑块 thumb (滑块) 在 Webkit 内核浏览器中的样式 */
.lumina-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  /* 移除原生样式 */
  width: 18px;
  height: 18px;
  /* 滑块宽高 */
  background: var(--current-accent-light);
  /* 背景色使用光强调色 */
  border-radius: 50%;
  /* 圆形 */
  cursor: pointer;
  /* 鼠标悬停显示手型光标 */
  box-shadow: 0 0 8px rgba(var(--current-accent-light-rgb), 0.4);
  /* 添加辉光阴影 */
  border: 2px solid var(--current-panel-bg);
  /* 添加白色（面板背景色）边框 */
  transition: transform var(--transition-duration-light-pulse) ease;
  /* 添加变形过渡 */
  margin-top: -6px; /* 调整位置使滑块居中于滑轨 */
}

/* 范围滑块 thumb (滑块) 在 Webkit 内核浏览器中悬停时的样式 */
.lumina-range::-webkit-slider-thumb:hover {
  transform: scale(1.1);
  /* 略微放大 */
}

/* 范围滑块 thumb (滑块) 在 Firefox 浏览器中的样式 */
.lumina-range::-moz-range-thumb {
  width: 18px;
  height: 18px;
  /* 滑块宽高 */
  background: var(--current-accent-light);
  /* 背景色使用光强调色 */
  border-radius: 50%;
  /* 圆形 */
  cursor: pointer;
  /* 鼠标悬停显示手型光标 */
  border: none;
  /* 移除默认边框 */
  box-shadow: 0 0 8px rgba(var(--current-accent-light-rgb), 0.4);
  /* 添加辉光阴影 */
  border: 2px solid var(--current-panel-bg);
  /* 添加白色（面板背景色）边框 */
}

/* 范围滑块 thumb (滑块) 在 Firefox 浏览器中悬停时的样式 */
.lumina-range::-moz-range-thumb:hover {
  transform: scale(1.1);
  /* 略微放大 */
}


/* 开关容器样式 */
.lumina-switch {
  position: relative;
  /* 开启定位上下文 */
  display: inline-block;
  /* 内联块级显示 */
  width: 48px;
  height: 24px;
  /* 开关整体宽高 */
}

/* 隐藏原生的 checkbox 输入框 */
.lumina-switch input {
  display: none;
}

/* 开关滑轨 (slider) 样式 */
.lumina-switch .slider {
  position: absolute;
  /* 绝对定位 */
  cursor: pointer;
  /* 鼠标悬停显示手型光标 */
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  /* 覆盖整个父容器 */
  background-color: rgba(var(--current-panel-border-rgb), 0.6);
  /* 默认背景色使用半透明面板边框颜色 */
  transition: background-color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
  /* 添加背景色过渡 */
}

/* 圆形滑轨样式 */
.lumina-switch .slider.round {
  border-radius: 24px;
  /* 圆角使其呈药丸形状 */
}

/* 圆形滑轨的滑块也应用圆形 */
.lumina-switch .slider.round:before {
  border-radius: 50%;
}

/* 开关滑块 (thumb) 伪元素样式 */
.lumina-switch .slider:before {
  content: "";
  /* 生成伪元素 */
  position: absolute;
  /* 绝对定位 */
  height: 18px;
  width: 18px;
  /* 滑块宽高 */
  left: 3px;
  bottom: 3px;
  /* 定位在左下角，与滑轨边缘保持间距 */
  background-color: var(--current-bg);
  /* 背景色使用当前背景色 */
  box-shadow: 0 1px 2px rgba(var(--current-text-primary-rgb), 0.2);
  /* 添加柔和阴影 */
  transition: transform var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
  /* 添加变形过渡 */
}

/* 开关打开 (checked) 状态下滑轨的背景颜色 */
.lumina-switch input:checked+.slider {
  background-color: var(--current-accent-light);
  /* 背景色变为光强调色 */
}

/* 开关打开 (checked) 状态下滑块的位置 */
.lumina-switch input:checked+.slider:before {
  transform: translateX(24px);
  /* 水平位移24px，移动到右侧 */
}

/* 开关聚焦状态的轮廓 */
.lumina-switch input:focus+.slider {
  box-shadow: 0 0 0 2px rgba(var(--current-accent-light-rgb), 0.3);
  /* 添加聚焦轮廓 */
}


/* ==========================================================================
   [ 16. Toast Notifications ]
   显示和管理Toast通知的样式。
   ========================================================================== */

/* Toast通知容器，管理Toast的布局和位置 */
.toast-container {
  position: fixed;
  /* 固定定位 */
  top: calc(var(--header-height) + var(--spacing-unit) * 1.5);
  right: calc(var(--spacing-unit) * 1.5);
  /* 定位在右上角，位于头部下方 */
  z-index: var(--z-index-toast);
  /* 堆叠顺序，高于模态框 */
  display: flex;
  /* 使用Flexbox布局 */
  flex-direction: column;
  /* Toast垂直堆叠 */
  gap: calc(var(--spacing-unit) * 1.2);
  /* Toast之间的间距 */
  max-width: 380px;
  /* 最大宽度 */
}

/* 单条Toast通知面板样式，应用 Lumina 面板基础样式并调整 */
.toast.lumina-panel {
  padding: calc(var(--spacing-unit) * 1.4) calc(var(--spacing-unit) * 1.8);
  /* 内边距 */
  border-left-width: var(--lumina-line-weight-bold);
  /* 左侧使用粗边框作为状态指示条 */
  display: flex;
  /* 使用Flexbox布局 */
  align-items: flex-start;
  /* 内容顶部对齐 */
  gap: calc(var(--spacing-unit) * 1.2);
  /* 图标与文本间距 */
  animation-duration: var(--transition-duration-ink-subtle) !important;
  /* 覆盖可能的默认动画时长 */
  border-radius: var(--border-radius-slight);
  /* 应用小圆角 */
  background-image: none;
  /* 移除面板背景纹理 */
  position: relative;
  /* 开启定位上下文，用于关闭按钮 */
  /* 继承了面板的背景、边框、阴影、backdrop-filter等基础样式 */
}

/* Toast 图标样式 */
.toast.lumina-panel .toast-icon {
  font-size: calc(var(--base-font-size) * 1.35);
  /* 图标大小 */
  margin-top: 1px;
  /* 微调位置 */
  flex-shrink: 0;
  /* 防止图标被压缩 */
}

/* Toast 消息文本样式 */
.toast.lumina-panel .toast-message {
  flex-grow: 1;
  /* 填充剩余空间 */
  font-size: calc(var(--base-font-size) * 0.92);
  /* 字体大小 */
  line-height: 1.5;
  /* 行高 */
  color: var(--current-text-primary);
  /* 文本颜色使用主要文本色 */
  padding-right: calc(var(--spacing-unit) * 3);
  /* 右侧内边距，为关闭按钮留出空间 */
}

/* Toast 关闭按钮样式 */
.toast.lumina-panel .toast-close {
  position: absolute;
  /* 绝对定位 */
  top: calc(var(--spacing-unit) * 0.75);
  right: calc(var(--spacing-unit) * 0.75);
  /* 定位在右上角 */
  padding: calc(var(--spacing-unit) * 0.5);
  /* 内边距，增加点击区域 */
  font-size: 0.9em;
  /* 字体大小 */
  color: var(--current-text-secondary);
  /* 默认颜色使用辅助文本色 */
  background: transparent;
  /* 背景透明 */
  border: none;
  /* 无边框 */
  line-height: 1;
  /* 行高 */
}

/* Toast 关闭按钮悬停状态的样式 */
.toast.lumina-panel .toast-close:hover {
  color: var(--current-text-primary);
  /* 颜色变为主要文本色 */
  background-color: rgba(var(--current-text-primary-rgb), 0.1);
  /* 添加半透明背景 */
}

/* Toast 不同状态的颜色标记线和图标颜色 */
.toast.lumina-panel.toast-info {
  border-left-color: var(--current-accent-light);
  /* 信息状态：左侧边框颜色为光强调色 */
}

.toast.lumina-panel.toast-info .toast-icon {
  color: var(--current-accent-light);
  /* 信息状态：图标颜色为光强调色 */
}

.toast.lumina-panel.toast-success {
  border-left-color: var(--lumina-success-color);
  /* 成功状态：左侧边框颜色为成功色 */
}

.toast.lumina-panel.toast-success .toast-icon {
  color: var(--lumina-success-color);
  /* 成功状态：图标颜色为成功色 */
}

.toast.lumina-panel.toast-warning {
  border-left-color: var(--current-accent-ink);
  /* 警告状态：左侧边框颜色为墨迹强调色 */
}

.toast.lumina-panel.toast-warning .toast-icon {
  color: var(--current-accent-ink);
  /* 警告状态：图标颜色为墨迹强调色 */
}

.toast.lumina-panel.toast-error {
  border-left-color: var(--lumina-error-color);
  /* 错误状态：左侧边框颜色为错误色 */
}

.toast.lumina-panel.toast-error .toast-icon {
  color: var(--lumina-error-color);
  /* 错误状态：图标颜色为错误色 */
}


/* ==========================================================================
   [ 17. Loader ]
   加载动画的样式。
   ========================================================================== */

/* 加载遮罩层容器 */
.loader-container {
  background-color: var(--current-bg);
  /* 背景色使用当前背景色 */
  opacity: 1;
  /* 初始完全不透明 */
  transition: opacity var(--transition-duration-ink-flow) var(--transition-timing-function-lumina);
  /* 添加透明度过渡，用于隐藏加载器 */
  position: fixed;
  /* 固定定位，覆盖整个视口 */
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  /* 占满整个视口 */
  display: flex;
  /* 使用Flexbox布局 */
  flex-direction: column;
  /* 内部元素垂直排列 */
  align-items: center;
  justify-content: center;
  /* 水平垂直居中 */
  z-index: var(--z-index-loader);
  /* 堆叠顺序最高 */
}

/* Loader隐藏状态，透明度为0且不响应鼠标事件 */
.loader-container.hidden {
  opacity: 0;
  pointer-events: none;
}

/* Lumina Loader Core (旋转光环与脉动核心的容器) */
.lumina-loader-core {
  width: 100px;
  height: 100px;
  /* 固定宽高 */
  position: relative;
  /* 开启定位上下文 */
  margin-bottom: calc(var(--spacing-unit) * 3.5);
  /* 底部外边距 */
}

/* 光环伪元素 (用于创建旋转圆环) */
.lumina-loader-core::before,
.lumina-loader-core::after {
  content: '';
  /* 生成伪元素 */
  position: absolute;
  /* 绝对定位 */
  border-radius: 50%;
  /* 圆形 */
  border-style: solid;
  /* 边框样式 */
  border-color: transparent;
  /* 默认边框颜色透明 */
  animation: luminaLoaderSpin 2.5s linear infinite;
  /* 应用旋转动画 */
}

/* 外环伪元素样式 */
.lumina-loader-core::before {
  width: 100%;
  height: 100%;
  /* 占满父容器 */
  border-width: var(--lumina-line-weight-bold);
  /* 边框使用粗线 */
  border-top-color: var(--current-accent-light);
  border-left-color: var(--current-accent-light);
  /* 顶部和左侧边框颜色使用光强调色，形成旋转的光环感 */
  opacity: 0.8;
  /* 降低透明度 */
}

/* 内环伪元素样式 */
.lumina-loader-core::after {
  width: 70%;
  height: 70%;
  /* 相对于父容器的宽高 */
  top: 15%;
  left: 15%;
  /* 居中定位 */
  border-width: var(--lumina-line-weight-medium);
  /* 边框使用中等粗细 */
  border-bottom-color: var(--current-accent-ink);
  border-right-color: var(--current-accent-ink);
  /* 底部和右侧边框颜色使用墨迹强调色，与外环颜色不同 */
  animation-direction: reverse;
  /* 反向旋转 */
  animation-duration: 2s;
  /* 动画时长略短 */
  opacity: 0.7;
  /* 降低透明度 */
}

/* 中心脉动光点样式 */
.lumina-loader-center-pulse {
  position: absolute;
  /* 绝对定位 */
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  /* 精确居中 */
  width: 12px;
  height: 12px;
  /* 固定宽高 */
  background-color: var(--current-accent-light);
  /* 背景色使用光强调色 */
  border-radius: 50%;
  /* 圆形 */
  box-shadow: 0 0 15px 3px var(--current-glow);
  /* 添加辉光效果 */
  animation: luminaLoaderPulse 1.5s infinite ease-in-out;
  /* 应用脉动动画 */
}

/* Fatal Error Loader 状态下的样式覆盖 */
.loader-container.loader-fatal-error .lumina-loader-core::before {
  border-top-color: var(--lumina-error-color);
  border-left-color: var(--lumina-error-color);
  /* 边框颜色变为错误色 */
  animation: luminaLoaderSpin 3s linear infinite, luminaErrorPulseBorder 1.5s infinite ease-in-out;
  /* 添加错误状态边框脉动动画 */
}

.loader-container.loader-fatal-error .lumina-loader-core::after {
  border-bottom-color: var(--lumina-error-color);
  border-right-color: var(--lumina-error-color);
  /* 边框颜色变为错误色 */
  opacity: 0.5;
  /* 降低透明度 */
}

.loader-container.loader-fatal-error .lumina-loader-center-pulse {
  background-color: var(--lumina-error-color);
  /* 背景色变为错误色 */
  box-shadow: 0 0 15px 3px var(--lumina-error-glow);
  /* 辉光颜色变为错误状态辉光色 */
}

/* Loader Logo 文本样式 */
.loader-logo-text {
  font-family: var(--font-family-title);
  /* 应用标题字体 */
  font-size: calc(var(--base-font-size) * 2.2);
  /* 字体大小 */
  font-weight: 500;
  /* 字体粗细 */
  color: var(--current-text-primary);
  /* 颜色使用主要文本色 */
  letter-spacing: 1.5px;
  /* 增加字符间距 */
  margin-bottom: calc(var(--spacing-unit) * 3.5); /* 增加底部外边距 */
  text-shadow: 0 1px 1px rgba(var(--current-bg-rgb), 0.5);
  /* 添加微妙文本阴影 */
}

/* Loader Logo 文本中强调部分的样式 */
.loader-logo-text span {
  color: var(--current-accent-light);
  /* 颜色使用光强调色 */
  font-weight: 700;
  /* 字体加粗 */
}

/* Loader Logo 版本标识样式 */
.loader-logo-text .loader-version-pro {
  font-size: 0.55em;
  /* 字体大小 */
  margin-left: 4px;
  /* 左侧外边距 */
  vertical-align: super;
  /* 上标对齐 */
  color: var(--current-accent-ink);
  /* 颜色使用墨迹强调色 */
  opacity: 0.9;
  /* 降低透明度 */
}

/* 加载文本样式 */
.loading-text {
  font-family: var(--font-family-body);
  /* 应用主体文本字体 */
  font-size: var(--base-font-size);
  /* 字体大小 */
  color: var(--current-text-secondary);
  /* 颜色使用辅助文本色 */
  letter-spacing: 0.5px;
  /* 字符间距 */
  opacity: 0.85;
  /* 降低透明度 */
}

/* Fatal Error 状态下的特定文本颜色覆盖 */
.loader-container.loader-fatal-error .loader-logo-text {
  color: var(--lumina-error-color);
  /* 颜色变为错误色 */
}

.loader-container.loader-fatal-error .loading-text {
  color: var(--current-text-primary);
  /* 颜色变为主要文本色 */
}

.loader-container.loader-fatal-error .error-details-text {
  color: var(--current-text-secondary);
  /* 颜色使用辅助文本色 */
}

/* Fatal Error 状态下刷新按钮的顶部外边距 */
.loader-container.loader-fatal-error .refresh-button {
  margin-top: calc(var(--spacing-unit) * 2.5);
}


/* ==========================================================================
   [ 18. Agent Process Log Sidebar Layout Fix ]
   优化Agent执行轨迹侧栏条目布局，使图标和主文本同排。
   ========================================================================== */

/* Agent执行轨迹侧栏内容区域 */
.process-log-content {
  /* 确保内容区域可以滚动 */
  overflow-y: auto;
  padding: calc(var(--spacing-unit) * 1.5);
  /* 内边距 */
  display: flex;
  flex-direction: column;
  gap: calc(var(--spacing-unit) * 1.5);
  /* 条目之间的间距 */
}

/* 单个日志条目 */
.process-log-content .log-item {
  display: flex; /* 使用 flex 布局 */
  align-items: flex-start; /* 条目顶部对齐 */
  gap: calc(var(--spacing-unit) * 1); /* 图标与内容区域之间的间距 */
  padding: calc(var(--spacing-unit) * 0.8) calc(var(--spacing-unit) * 1); /* 调整条目内边距 */
  border-radius: var(--border-radius-slight); /* 轻微圆角 */
  border: 1px solid transparent; /* 默认透明边框，用于状态高亮 */
  transition: all var(--transition-duration-light-pulse) ease; /* 过渡效果 */
  word-break: break-word; /* 防止长单词溢出 */
  overflow-wrap: break-word; /* 防止长单词溢出 */
}

/* 日志条目图标 */
.process-log-content .log-item > i.fas,
.process-log-content .log-item > i.far {
  flex-shrink: 0; /* 防止图标被压缩 */
  font-size: calc(var(--base-font-size) * 1.1); /* 图标大小 */
  margin-top: 2px; /* 微调图标位置使其与文本基线对齐 */
  text-shadow: none; /* 移除通用图标阴影 */
  color: var(--current-text-secondary); /* 默认图标颜色使用辅助文本色 */
}

/* 根据状态调整图标颜色 */
.process-log-content .log-item > i.log-info { color: var(--current-accent-light); } /* 信息 */
.process-log-content .log-item > i.log-processing { color: var(--current-accent-ink); } /* 处理中 */
.process-log-content .log-item > i.log-success { color: var(--lumina-success-color); } /* 成功 */
.process-log-content .log-item > i.log-warning { color: var(--current-accent-ink); } /* 警告 */
.process-log-content .log-item > i.log-error { color: var(--lumina-error-color); } /* 错误 */
.process-log-content .log-item > i.log-muted { color: var(--current-text-secondary); opacity: 0.7; } /* 静音/忽略 */
.process-log-content .log-item > i.log-think { color: var(--current-accent-light); } /* 思考过程图标 */


/* 日志条目主要内容区域 (包含主文本和详细信息) */
.process-log-content .log-item-content-area {
  display: flex; /* 使用 flex 布局 */
  flex-direction: column; /* 子元素垂直堆叠 */
  flex-grow: 1; /* 填充剩余水平空间 */
  gap: calc(var(--spacing-unit) * 0.8); /* 主文本与详细信息之间的间距 */
}

/* 日志条目主消息文本 */
.process-log-content .log-item-message {
  font-size: calc(var(--base-font-size) * 0.9); /* 字体大小 */
  color: var(--current-text-primary); /* 文本颜色使用主要文本色 */
  line-height: 1.4; /* 行高 */
  opacity: 0.9; /* 降低透明度 */
}

/* 日志条目详细信息区域 */
.process-log-content .log-item-details,
.process-log-content .log-think-content { /* 也包括思考内容 */
  margin-top: calc(var(--spacing-unit) * 0.8); /* 顶部外边距 */
  padding: calc(var(--spacing-unit) * 1); /* 内边距 */
  background-color: rgba(var(--current-panel-bg-rgb), 0.4); /* 半透明背景 */
  border: 1px dashed rgba(var(--current-panel-border-rgb), 0.6); /* 虚线边框 */
  border-radius: var(--border-radius-slight); /* 轻微圆角 */
  font-size: 0.85em; /* 字体大小 */
  color: var(--current-text-secondary); /* 文本颜色使用辅助文本色 */
  line-height: 1.5; /* 行高 */
  word-break: break-all; /* 强制长单词或URL换行 */
  overflow-wrap: break-word; /* 强制长单词或URL换行 */
}

/* 详细信息中的键 */
.log-item-details strong.log-detail-key,
.log-think-content strong {
    font-family: var(--font-family-title); /* 应用标题字体 */
    font-weight: 500; /* 字体粗细 */
    color: var(--current-accent-ink); /* 颜色使用墨迹强调色 */
    margin-right: calc(var(--spacing-unit) * 0.5); /* 键与值之间间距 */
}

/* 详细信息中的值 */
.log-item-details span.log-detail-value {
    color: var(--current-text-primary); /* 颜色使用主要文本色 */
    opacity: 0.9; /* 降低透明度 */
}

/* 详细信息中的对象头部 */
.log-item-details .log-detail-object-header {
    margin-top: calc(var(--spacing-unit) * 0.5); /* 顶部外边距 */
    margin-bottom: calc(var(--spacing-unit) * 0.5); /* 底部外边距 */
}

/* 详细信息中的原始 JSON/代码块 */
.log-item-details pre.log-detail-raw-json,
.log-think-content pre code {
    background-color: rgba(var(--current-bg-rgb), 0.3); /* 半透明背景 */
    padding: calc(var(--spacing-unit) * 0.8); /* 内边距 */
    border-radius: var(--border-radius-slight); /* 轻微圆角 */
    margin-top: calc(var(--spacing-unit) * 0.8); /* 顶部外边距 */
    font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; /* 等宽字体 */
    font-size: 0.9em; /* 字体大小 */
    color: var(--current-text-secondary); /* 文本颜色使用辅助文本色 */
    border: 1px solid rgba(var(--current-panel-border-rgb), 0.3); /* 细边框 */
    white-space: pre-wrap; /* 允许换行 */
    word-break: break-all; /* 强制长单词或 URL 换行 */
    overflow-x: auto; /* 水平滚动条 */
}

/* 详细信息中的错误 JSON/代码块 */
.log-item-details pre.log-detail-raw-json.error,
.log-think-content pre code.error {
    color: var(--lumina-error-color); /* 错误颜色 */
    border-color: var(--lumina-error-color); /* 边框颜色 */
}

/* 删除旧的头部 flex 样式 */
.process-log-content .log-item-header-flex {
    /* Removed - no longer needed with the new flex structure */
    display: none; /* Ensure it's hidden if it somehow still appears */
}


/* ==========================================================================
   [ 19. Utility Styles ]
   一些通用的辅助类和特殊元素的样式，如滚动条。
   ========================================================================== */

/* 动画级别控制：full 级别应用完整动画时长 */
body[data-animation-level=full] .animate__animated {
  --animate-duration: var(--transition-duration-ink-flow);
}

/* 动画级别控制：basic 级别应用较短动画时长 */
body[data-animation-level=basic] .animate__animated {
  --animate-duration: var(--transition-duration-ink-subtle);
}

/* 动画级别控制：none 级别移除所有动画和过渡 */
body[data-animation-level=none] .animate__animated {
  animation: none !important;
  transition: none !important;
}

/* 自定义滚动条样式 (Webkit browsers: Chrome, Safari, Edge) */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
  /* 滚动条宽度和高度 */
}

/* 滚动条轨道样式 (Webkit) */
::-webkit-scrollbar-track {
  background: rgba(var(--current-panel-border-rgb), 0.1);
  /* 轨道背景使用半透明面板边框色 */
  border-radius: 4px;
  /* 轨道圆角 */
}

/* 滚动条滑块样式 (Webkit) */
::-webkit-scrollbar-thumb {
  background: rgba(var(--current-text-secondary-rgb), 0.4);
  /* 滑块背景使用半透明辅助文本色 */
  border-radius: 4px;
  /* 滑块圆角 */
  transition: background-color var(--transition-duration-light-pulse) ease;
  /* 添加背景色过渡 */
}

/* 滚动条滑块悬停样式 (Webkit) */
::-webkit-scrollbar-thumb:hover {
  background: rgba(var(--current-text-secondary-rgb), 0.6);
  /* 悬停时背景色加深 */
}

/* 自定义滚动条样式 (Firefox) */
* {
  scrollbar-width: thin;
  /* 滚动条宽度为细 */
  scrollbar-color: rgba(var(--current-text-secondary-rgb), 0.4) rgba(var(--current-panel-border-rgb), 0.1);
  /* 滑块颜色 轨道颜色 */
}


/* ==========================================================================
   [ 20. Animations Keyframes ]
   所有CSS动画的关键帧定义。
   ========================================================================== */

/* 文本纹理背景图的微妙偏移动画 */
@keyframes subtleTextureShift {
  to {
    background-position: 400px 400px;
    /* 背景图位置偏移 */
  }
}

/* Lumina粒子漂浮动画 */
@keyframes floatLuminaParticle {
  0% {
    transform: translate(0, 0) scale(0.5);
    opacity: 0.1;
    /* 初始状态 */
  }

  25% {
    opacity: 0.6;
    /* 中间状态透明度增加 */
  }

  50% {
    transform: translate(35px, -45px) scale(1.2);
    opacity: 0.8;
    /* 中间状态位移、放大、透明度更高 */
  }

  75% {
    opacity: 0.5;
    /* 后期透明度降低 */
  }

  100% {
    transform: translate(-25px, 30px) scale(0.6);
    opacity: 0.15;
    /* 结束状态位移、缩小、透明度再次降低 */
  }
}

/* Loader核心旋转动画 */
@keyframes luminaLoaderSpin {
  to {
    transform: rotate(360deg);
    /* 旋转一周 */
  }
}

/* Loader中心点脉动动画 */
@keyframes luminaLoaderPulse {

  0%,
  100% {
    transform: translate(-50%, -50%) scale(0.8);
    opacity: 0.7;
    /* 初始和结束状态缩小、降低透明度 */
  }

  50% {
    transform: translate(-50%, -50%) scale(1.2);
    opacity: 1;
    /* 中间状态放大、完全不透明 */
  }
}

/* Fatal Error 状态下边框脉动动画 */
@keyframes luminaErrorPulseBorder {

  0%,
  100% {
    opacity: 0.6;
    /* 初始和结束状态降低透明度 */
  }

  50% {
    opacity: 1;
    /* 中间状态完全不透明 */
  }
}

/* 打字指示器点跳动动画 */
@keyframes luminaTypingDotBounce {

  0%,
  70%,
  100% {
    transform: translateY(0) scale(1);
    opacity: 0.6;
    /* 初始、中部、结束状态恢复原位、原大小、降低透明度 */
  }

  35% {
    transform: translateY(-5px) scale(1.1);
    opacity: 1;
    /* 中间状态向上跳跃、放大、完全不透明 */
  }
}

/* 发送按钮处理中动画 */
@keyframes luminaSendButtonProcessing {

  0%,
  100% {
    box-shadow: 0 0 10px rgba(var(--current-accent-ink-rgb), 0.3);
    transform: scale(1);
    /* 初始和结束状态，常规阴影和大小 */
  }

  50% {
    box-shadow: 0 0 20px rgba(var(--current-accent-ink-rgb), 0.5);
    transform: scale(1.08);
    /* 中间状态，更强的阴影和轻微放大 */
  }
}


/* ==========================================================================
   [ 21. Three.js / Black Hole Visuals (CSS Layers) ]
   控制和管理Three.js渲染的3D黑洞特效容器的CSS层视觉样式。
   ( थ्री.जेएस ब्लैक होल विज़ुअल्स (सीएसएस लेयर्स) )
   ========================================================================== */

/* Main container for the black hole effect - base styles */
#idtTechComponentWrapper.black-hole-container {
  position: fixed;
  top: var(--idt-offset-top-percentage, 2.5%);
  left: var(--idt-offset-left-percentage, 1.8%);
  width: var(--idt-component-width, 280px);
  height: var(--idt-component-height, 280px);
  z-index: var(--z-index-component-wrapper);
  transition: opacity var(--transition-duration-ink-flow) var(--transition-timing-function-lumina),
    transform var(--transition-duration-ink-flow) var(--transition-timing-function-lumina);
  opacity: 0; /* Initial state, controlled by .is-visible */
  transform: scale(0.6) rotate(-15deg); /* Initial state */
  cursor: grab;
  /* Allow glow/star to extend beyond the main circle slightly */
  overflow: visible;
  border-radius: 50%; /* Main circular shape */
  background-color: #05050a; /* Very dark background */
  box-shadow: 0 0 60px 10px rgba(30, 30, 50, 0.2); /* Faint outer space shadow */
}

/* Common styles for all inner effect layers */
#idtTechComponentWrapper.black-hole-container .bh-effect {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%); /* Center the layers */
  border-radius: 50%; /* Make them circular */
  box-sizing: border-box;
  pointer-events: none; /* Layers should not interfere with mouse events */
}

/* Outer glow / Gravitational lensing hint layer */
.bh-outer-glow {
  width: 110%; /* Slightly larger than the main container */
  height: 110%;
  box-shadow: 0 0 40px 15px rgba(100, 100, 120, 0.15), /* Faint blueish glow */
              0 0 80px 30px rgba(50, 50, 70, 0.1);   /* More diffuse outer glow */
  z-index: 1; /* Farthest back CSS layer */
  animation: subtle-glow-pulse 6s infinite ease-in-out;
}

/* CSS Accretion Disk Layers */
.bh-accretion-disk-outer,
.bh-accretion-disk-middle,
.bh-accretion-disk-inner {
   /* Common disk layer styles */
   box-shadow: 0 0 1px 1px rgba(255,255,255,0.1); /* Base subtle shimmer */
   opacity: 0.7;
   /* Ensure layers are above outer glow but below the simulated star */
   z-index: 3;
   animation-timing-function: linear; /* Constant speed for rotation */
   animation-iteration-count: infinite; /* Repeat indefinitely */
}

/* Outer disk layer - cooler colors */
.bh-accretion-disk-outer {
  width: 95%;
  height: 95%;
  box-shadow:
    0 0 20px 8px rgba(100, 100, 255, 0.3),  /* Blue glow */
    0 0 35px 12px rgba(50, 50, 180, 0.2),   /* Deeper blue diffuse */
    inset 0 0 8px 3px rgba(150, 150, 255, 0.2); /* Inner blue highlight */
  animation-name: spin-clockwise, pulse-disk-outer;
  animation-duration: 20s, 5s;
}

/* Middle disk layer - oranges/yellows */
.bh-accretion-disk-middle {
  width: 80%;
  height: 80%;
  box-shadow:
    0 0 15px 6px rgba(255, 165, 0, 0.6),   /* Orange glow */
    0 0 30px 10px rgba(255, 140, 0, 0.4),   /* Darker orange diffuse */
    inset 0 0 10px 4px rgba(255, 190, 50, 0.4); /* Inner yellow-orange highlight */
   /* Add a subtle tilt for perspective */
   transform: translate(-50%, -50%) rotateX(10deg);
  animation-name: spin-counter-clockwise, pulse-disk-middle;
  animation-duration: 15s, 4s;
}

/* Inner disk layer - hottest colors, yellows/whites */
.bh-accretion-disk-inner {
  width: 65%;
  height: 65%;
  box-shadow:
    0 0 10px 5px rgba(255, 255, 200, 0.8),  /* Bright Yellow */
    0 0 20px 8px rgba(255, 255, 150, 0.6),   /* Yellow diffuse */
    inset 0 0 12px 5px rgba(255, 255, 255, 0.7); /* Inner white highlight */
   /* Add a subtle tilt for perspective */
   transform: translate(-50%, -50%) rotateX(-15deg);
  animation-name: spin-clockwise, pulse-disk-inner;
  animation-duration: 10s, 3s;
}

/* Core shadow layer - reinforces the black hole's darkness */
.bh-core-shadow {
  width: 40%; /* Roughly the size of the event horizon */
  height: 40%;
  background-color: #000; /* Pure black */
  /* Add a subtle shadow to give it depth */
  box-shadow: 0 0 20px 10px rgba(0, 0, 0, 0.8);
  z-index: 4; /* Above accretion disks */
}


/* Simulated Orbiting Star */
.bh-orbiting-star {
  width: 6px; /* Size of the star */
  height: 6px;
  background-color: #fff; /* White star color */
  border-radius: 50%;
  /* White glow effect */
  box-shadow: 0 0 8px 3px rgba(255, 255, 255, 0.7);
  z-index: 5; /* Above core shadow */
  animation: orbit-around-bh 18s linear infinite, pulse-star 2s infinite ease-in-out;
}


/* Ensure the dynamically added canvas is on top of these CSS layers */
/* The Three.js canvas contains the actual 3D models */
#idtTechComponentWrapper.black-hole-container > canvas {
  position: absolute; /* Position it on top of the CSS layers */
  top: 0;
  left: 0;
  width: 100% !important;
  height: 100% !important;
  z-index: 10; /* Highest z-index to appear on top */
  /* Three.js renderer should be configured with alpha: true */
  background-color: transparent !important; /* Ensure canvas background is transparent */
  border-radius: inherit; /* Inherit border radius from container */
}

#idtTechComponentWrapper.black-hole-container.is-visible {
  opacity: 1;
  transform: scale(1) rotate(0deg);
  /* 如果需要，这里还可以添加其他针对可见状态的样式或过渡效果 */
}

/* Keyframe animations */
/* Subtle outer glow pulse */
@keyframes subtle-glow-pulse {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 0.9; }
}

/* Spin animations (used by multiple layers) */
@keyframes spin-clockwise {
  from { transform: translate(-50%, -50%) rotate(0deg); }
  to { transform: translate(-50%, -50%) rotate(360deg); }
}

@keyframes spin-counter-clockwise {
  from { transform: translate(-50%, -50%) rotate(0deg); }
  to { transform: translate(-50%, -50%) rotate(-360deg); }
}

/* Pulsing animations for disk layers */
@keyframes pulse-disk-outer {
  0%, 100% { box-shadow: 0 0 20px 8px rgba(100, 100, 255, 0.3), 0 0 35px 12px rgba(50, 50, 180, 0.2), inset 0 0 8px 3px rgba(150, 150, 255, 0.2); }
  50% { box-shadow: 0 0 30px 12px rgba(120, 120, 255, 0.4), 0 0 50px 18px rgba(70, 70, 200, 0.3), inset 0 0 12px 5px rgba(180, 180, 255, 0.3); }
}
@keyframes pulse-disk-middle {
  0%, 100% { box-shadow: 0 0 15px 6px rgba(255, 165, 0, 0.6), 0 0 30px 10px rgba(255, 140, 0, 0.4), inset 0 0 10px 4px rgba(255, 190, 50, 0.4); }
  50% { box-shadow: 0 0 22px 9px rgba(255, 180, 30, 0.7), 0 0 40px 14px rgba(255, 150, 10, 0.5), inset 0 0 14px 6px rgba(255, 200, 60, 0.5); }
}
@keyframes pulse-disk-inner {
  0%, 100% { box-shadow: 0 0 10px 5px rgba(255, 255, 200, 0.8), 0 0 20px 8px rgba(255, 255, 150, 0.6), inset 0 0 12px 5px rgba(255, 255, 255, 0.7); }
  50% { box-shadow: 0 0 15px 7px rgba(255, 255, 220, 0.9), 0 0 25px 10px rgba(255, 255, 180, 0.7), inset 0 0 16px 7px rgba(255, 255, 255, 0.9); }
}

/* Star orbiting animation */
@keyframes orbit-around-bh {
  0% { transform: translate(-50%, -50%) rotate(0deg) translateX(140px) rotate(0deg); } /* Start at 140px right */
  100% { transform: translate(-50%, -50%) rotate(360deg) translateX(140px) rotate(-360deg); } /* Orbit full circle and rotate */
}

/* Star pulse animation */
@keyframes pulse-star {
  0%, 100% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.2); opacity: 0.8; } /* Star gets slightly bigger and less opaque */
}

/* === [ End of REVISED Three.js / Black Hole Visuals (CSS Layers) ] === */


/* ==========================================================================
   [ END OF FILE style.css ]
   ========================================================================== */

--- END: static/style.css ---

--- START: static/css/style.css ---
/* ==========================================================================
   [ START OF FILE style.css / main.css ]
   CircuitManus Pro - Lumina Script / 光绘墨迹 主题 - CSS 入口文件
   版本: 1.1.7_LogLayoutFix_BlackHoleRevise_RefactoredCSS
   描述: 此文件通过 @import 规则引入所有模块化的CSS文件。
   ========================================================================== */

/* 基础与全局样式 */
@import url("base/_reset.css");
@import url("base/_variables.css");
@import url("base/_typography.css");
@import url("base/_theme_application.css");

/* 布局样式 */
@import url("layout/_main_layout.css");
@import url("layout/_header.css");
@import url("layout/_sidebar.css");
@import url("layout/_chat_area.css");
@import url("layout/_process_log_sidebar.css");
@import url("layout/_file_preview.css");

/* 组件样式 */
@import url("components/_panels.css"); /* 面板基础样式需要较早引入 */
@import url("components/_buttons.css");
@import url("components/_modals.css");
@import url("components/_loader.css");
@import url("components/_toast.css");
@import url("components/_messages.css");
@import url("components/_forms.css");

/* 动画与特效 */
@import url("animations/_keyframes.css");
@import url("animations/_visual_effects.css"); /* 包含黑洞等视觉特效 */

/* 工具类 (如果将来有) */
/* @import url("utils/_utilities.css"); */

/* ==========================================================================
   [ END OF FILE style.css / main.css ]
   ========================================================================== */
--- END: static/css/style.css ---

--- START: static/css/animations/_keyframes.css ---
/* ==========================================================================
   [ START OF FILE animations/_keyframes.css ]
   CSS Animation Keyframes
   ========================================================================== */

@keyframes subtleTextureShift {
  to { background-position: 400px 400px; }
}

@keyframes floatLuminaParticle { /* Example, if used */
  0% { transform: translate(0, 0) scale(0.5); opacity: 0.1; }
  25% { opacity: 0.6; }
  50% { transform: translate(35px, -45px) scale(1.2); opacity: 0.8; }
  75% { opacity: 0.5; }
  100% { transform: translate(-25px, 30px) scale(0.6); opacity: 0.15; }
}

@keyframes luminaLoaderSpin {
  to { transform: rotate(360deg); }
}

@keyframes luminaLoaderPulse {
  0%, 100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.7; }
  50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
}

@keyframes luminaErrorPulseBorder {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}

@keyframes luminaTypingDotBounce {
  0%, 70%, 100% { transform: translateY(0) scale(1); opacity: 0.6; }
  35% { transform: translateY(-5px) scale(1.1); opacity: 1; }
}

@keyframes luminaSendButtonProcessing {
  0%, 100% { box-shadow: 0 0 10px rgba(var(--current-accent-ink-rgb), 0.3); transform: scale(1); }
  50% { box-shadow: 0 0 20px rgba(var(--current-accent-ink-rgb), 0.5); transform: scale(1.08); }
}

/* Black Hole CSS Layer Animations (from visual_effects, but keyframes are global) */
@keyframes subtle-glow-pulse { /* For outer glow */
  0%, 100% { opacity: 0.6; }
  50% { opacity: 0.9; }
}

@keyframes spin-clockwise {
  from { transform: translate(-50%, -50%) rotate(0deg); }
  to { transform: translate(-50%, -50%) rotate(360deg); }
}

@keyframes spin-counter-clockwise {
  from { transform: translate(-50%, -50%) rotate(0deg); }
  to { transform: translate(-50%, -50%) rotate(-360deg); }
}

@keyframes pulse-disk-outer {
  0%, 100% { box-shadow: 0 0 20px 8px rgba(100, 100, 255, 0.3), 0 0 35px 12px rgba(50, 50, 180, 0.2), inset 0 0 8px 3px rgba(150, 150, 255, 0.2); }
  50% { box-shadow: 0 0 30px 12px rgba(120, 120, 255, 0.4), 0 0 50px 18px rgba(70, 70, 200, 0.3), inset 0 0 12px 5px rgba(180, 180, 255, 0.3); }
}
@keyframes pulse-disk-middle {
  0%, 100% { box-shadow: 0 0 15px 6px rgba(255, 165, 0, 0.6), 0 0 30px 10px rgba(255, 140, 0, 0.4), inset 0 0 10px 4px rgba(255, 190, 50, 0.4); }
  50% { box-shadow: 0 0 22px 9px rgba(255, 180, 30, 0.7), 0 0 40px 14px rgba(255, 150, 10, 0.5), inset 0 0 14px 6px rgba(255, 200, 60, 0.5); }
}
@keyframes pulse-disk-inner {
  0%, 100% { box-shadow: 0 0 10px 5px rgba(255, 255, 200, 0.8), 0 0 20px 8px rgba(255, 255, 150, 0.6), inset 0 0 12px 5px rgba(255, 255, 255, 0.7); }
  50% { box-shadow: 0 0 15px 7px rgba(255, 255, 220, 0.9), 0 0 25px 10px rgba(255, 255, 180, 0.7), inset 0 0 16px 7px rgba(255, 255, 255, 0.9); }
}

@keyframes orbit-around-bh {
  0% { transform: translate(-50%, -50%) rotate(0deg) translateX(140px) rotate(0deg); }
  100% { transform: translate(-50%, -50%) rotate(360deg) translateX(140px) rotate(-360deg); }
}

@keyframes pulse-star {
  0%, 100% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.2); opacity: 0.8; }
}
/* ==========================================================================
   [ END OF FILE animations/_keyframes.css ]
   ========================================================================== */
--- END: static/css/animations/_keyframes.css ---

--- START: static/css/animations/_visual_effects.css ---
/* ==========================================================================
   [ START OF FILE animations/_visual_effects.css ]
   3D组件 (黑洞) CSS层叠视觉样式
   ========================================================================== */

#idtTechComponentWrapper.black-hole-container {
  position: fixed;
  top: var(--idt-offset-top-percentage, 2.5%);
  left: var(--idt-offset-left-percentage, 1.8%);
  width: var(--idt-component-width, 280px);
  height: var(--idt-component-height, 280px);
  z-index: var(--z-index-component-wrapper);
  transition: opacity var(--transition-duration-ink-flow) var(--transition-timing-function-lumina),
              transform var(--transition-duration-ink-flow) var(--transition-timing-function-lumina);
  opacity: 0; /* Initial: hidden */
  transform: scale(0.6) rotate(-15deg); /* Initial: small and tilted */
  cursor: grab;
  overflow: visible; /* Allow glow/star to extend */
  border-radius: 50%; /* Main circular shape */
  background-color: #05050a; /* Very dark core for the black hole */
  box-shadow: 0 0 60px 10px rgba(30, 30, 50, 0.2); /* Faint outer space shadow */
}

#idtTechComponentWrapper.black-hole-container.is-visible {
  opacity: 1;
  transform: scale(1) rotate(0deg);
}

/* Common styles for all inner effect layers */
#idtTechComponentWrapper.black-hole-container .bh-effect {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%); /* Center the layers */
  border-radius: 50%; /* Make them circular */
  box-sizing: border-box;
  pointer-events: none; /* Layers should not interfere with mouse events */
}

/* Outer glow / Gravitational lensing hint layer */
.bh-outer-glow {
  width: 110%;
  height: 110%;
  box-shadow: 0 0 40px 15px rgba(100, 100, 120, 0.15), /* Faint blueish glow */
              0 0 80px 30px rgba(50, 50, 70, 0.1);   /* More diffuse outer glow */
  z-index: 1; /* Farthest back CSS layer */
  animation: subtle-glow-pulse 6s infinite ease-in-out;
}

/* CSS Accretion Disk Layers */
.bh-accretion-disk-outer,
.bh-accretion-disk-middle,
.bh-accretion-disk-inner {
   box-shadow: 0 0 1px 1px rgba(255,255,255,0.1); /* Base subtle shimmer */
   opacity: 0.7;
   z-index: 3; /* Above outer glow but below core/star */
   animation-timing-function: linear;
   animation-iteration-count: infinite;
}

.bh-accretion-disk-outer {
  width: 95%; height: 95%;
  box-shadow:
    0 0 20px 8px rgba(100, 100, 255, 0.3),
    0 0 35px 12px rgba(50, 50, 180, 0.2),
    inset 0 0 8px 3px rgba(150, 150, 255, 0.2);
  animation-name: spin-clockwise, pulse-disk-outer;
  animation-duration: 20s, 5s;
}

.bh-accretion-disk-middle {
  width: 80%; height: 80%;
  box-shadow:
    0 0 15px 6px rgba(255, 165, 0, 0.6),
    0 0 30px 10px rgba(255, 140, 0, 0.4),
    inset 0 0 10px 4px rgba(255, 190, 50, 0.4);
   transform: translate(-50%, -50%) rotateX(10deg); /* Slight tilt */
  animation-name: spin-counter-clockwise, pulse-disk-middle;
  animation-duration: 15s, 4s;
}

.bh-accretion-disk-inner {
  width: 65%; height: 65%;
  box-shadow:
    0 0 10px 5px rgba(255, 255, 200, 0.8),
    0 0 20px 8px rgba(255, 255, 150, 0.6),
    inset 0 0 12px 5px rgba(255, 255, 255, 0.7);
   transform: translate(-50%, -50%) rotateX(-15deg); /* Different tilt */
  animation-name: spin-clockwise, pulse-disk-inner;
  animation-duration: 10s, 3s;
}

/* Core shadow layer - reinforces the black hole's darkness */
.bh-core-shadow {
  width: 40%;
  height: 40%;
  background-color: #000; /* Pure black */
  box-shadow: 0 0 20px 10px rgba(0, 0, 0, 0.8); /* Shadow for depth */
  z-index: 4; /* Above accretion disks */
}

/* Simulated Orbiting Star */
.bh-orbiting-star {
  width: 6px; height: 6px;
  background-color: #fff;
  border-radius: 50%;
  box-shadow: 0 0 8px 3px rgba(255, 255, 255, 0.7); /* White glow */
  z-index: 5; /* Above core shadow */
  animation: orbit-around-bh 18s linear infinite, pulse-star 2s infinite ease-in-out;
}

/* Three.js canvas (if used for more complex effects on top of CSS layers) */
#idtTechComponentWrapper.black-hole-container > canvas {
  position: absolute;
  top: 0; left: 0;
  width: 100% !important; /* Override any Three.js internal sizing */
  height: 100% !important;
  z-index: 10; /* Highest layer if 3D models are used */
  background-color: transparent !important; /* Ensure canvas is transparent */
  border-radius: inherit; /* Match container shape */
}
/* ==========================================================================
   [ END OF FILE animations/_visual_effects.css ]
   ========================================================================== */
--- END: static/css/animations/_visual_effects.css ---

--- START: static/css/base/_reset.css ---
/* ==========================================================================
   [ START OF FILE base/_reset.css ]
   CSS Reset - 统一浏览器默认样式
   ========================================================================== */

*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  border: 0 solid transparent; /* 更现代的重置，所有边框默认为透明实体，需要时再显式定义 */
}

html {
  font-size: var(--base-font-size, 16px); /* Fallback if variable not loaded */
  line-height: var(--line-height-base, 1.5);
  -webkit-text-size-adjust: 100%; /* 防止iOS设备旋转时字体大小变化 */
  -moz-tab-size: 4; /* 设置tab键宽度为4个空格 */
  tab-size: 4;
  scroll-behavior: smooth;
}

body {
  font-family: var(--font-family-body, sans-serif); /* Fallback if variable not loaded */
  background-color: var(--current-bg, #fff);
  color: var(--current-text-primary, #000);
  overflow-x: hidden; /* 通常只在body上隐藏水平滚动条 */
  overflow-y: auto; /* body层面允许垂直滚动，但通常内容会由内部容器控制滚动 */
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

img,
picture,
video,
canvas,
svg {
  display: block; /* 移除图片等元素底部的空白间隙 */
  max-width: 100%; /* 防止图片等元素超出容器 */
}

input,
button,
textarea,
select {
  font: inherit; /* 继承父元素的字体样式 */
  color: inherit; /* 继承父元素的文本颜色 */
  background-color: transparent; /* 默认透明背景 */
  border-radius: 0; /* 移除默认圆角 */
}

button {
  cursor: pointer; /* 鼠标悬停时显示手型光标 */
  outline: none; /* 移除默认轮廓 */
}

textarea {
  resize: vertical; /* 通常只允许垂直方向调整大小 */
  overflow: auto; /* 确保内容过多时可以滚动 */
}

table {
  border-collapse: collapse; /* 合并表格边框 */
  border-spacing: 0; /* 移除单元格间距 */
}

ul,
ol {
  list-style: none; /* 移除列表默认标记 */
}

a {
  text-decoration: none; /* 移除链接下划线 */
  color: inherit; /* 继承父元素的文本颜色 */
}

/* 隐藏屏幕阅读器不可见的元素 */
[hidden] {
  display: none !important;
}
/* ==========================================================================
   [ END OF FILE base/_reset.css ]
   ========================================================================== */
--- END: static/css/base/_reset.css ---

--- START: static/css/base/_theme_application.css ---
/* ==========================================================================
   [ START OF FILE base/_theme_application.css ]
   Theme Application Logic - 将Lumina变量映射到通用的 --current-* 变量
   ========================================================================== */

body[data-theme='light-crystal'],
body[data-theme="auto-crystal"].light-crystal-active {
  --current-bg: var(--lumina-bg-light);
  --current-panel-bg: var(--lumina-panel-bg-light);
  --current-panel-border: var(--lumina-panel-border-light);
  --current-text-primary: var(--lumina-text-primary-light);
  --current-text-secondary: var(--lumina-text-secondary-light);
  --current-accent-ink: var(--lumina-accent-ink-light);
  --current-accent-light: var(--lumina-accent-light-light);
  --current-glow: var(--lumina-glow-light);
  --current-ink-texture: var(--lumina-ink-texture-light);

  --current-bg-rgb: var(--lumina-bg-light-rgb);
  --current-panel-bg-rgb: var(--lumina-panel-bg-light-rgb);
  --current-panel-border-rgb: var(--lumina-panel-border-light-rgb);
  --current-text-primary-rgb: var(--lumina-text-primary-light-rgb);
  --current-text-secondary-rgb: var(--lumina-text-secondary-light-rgb);
  --current-accent-ink-rgb: var(--lumina-accent-ink-light-rgb);
  --current-accent-light-rgb: var(--lumina-accent-light-light-rgb);
  --current-error-color-rgb: var(--lumina-error-color-rgb);
  --current-success-color-rgb: var(--lumina-success-color-rgb);
}

body[data-theme='dark-crystal'],
body[data-theme="auto-crystal"].dark-crystal-active {
  --current-bg: var(--lumina-bg-dark);
  --current-panel-bg: var(--lumina-panel-bg-dark);
  --current-panel-border: var(--lumina-panel-border-dark);
  --current-text-primary: var(--lumina-text-primary-dark);
  --current-text-secondary: var(--lumina-text-secondary-dark);
  --current-accent-ink: var(--lumina-accent-ink-dark);
  --current-accent-light: var(--lumina-accent-light-dark);
  --current-glow: var(--lumina-glow-dark);
  --current-ink-texture: var(--lumina-ink-texture-dark);

  --current-bg-rgb: var(--lumina-bg-dark-rgb);
  --current-panel-bg-rgb: var(--lumina-panel-bg-dark-rgb);
  --current-panel-border-rgb: var(--lumina-panel-border-dark-rgb);
  --current-text-primary-rgb: var(--lumina-text-primary-dark-rgb);
  --current-text-secondary-rgb: var(--lumina-text-secondary-dark-rgb);
  --current-accent-ink-rgb: var(--lumina-accent-ink-dark-rgb);
  --current-accent-light-rgb: var(--lumina-accent-light-dark-rgb);
  --current-error-color-rgb: var(--lumina-error-color-rgb);
  --current-success-color-rgb: var(--lumina-success-color-rgb);
}

/* 全局背景和文本颜色过渡，用于主题切换 */
body {
  background-color: var(--current-bg);
  color: var(--current-text-primary);
  transition: background-color var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
              color var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
}

/* 动态水晶背景的全局样式 */
.dynamic-crystal-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -2; /* 确保在所有内容之下 */
    overflow: hidden;
    background-color: var(--current-bg); /* 确保背景有底色 */
    transition: background-color var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
}

.background-grid-pattern {
    position: absolute;
    top: 0;
    left: 0;
    width: 200%; /* 放大网格以允许动画 */
    height: 200%;
    background-image:
        linear-gradient(to right, rgba(var(--current-panel-border-rgb), 0.08) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(var(--current-panel-border-rgb), 0.08) 1px, transparent 1px);
    background-size: 40px 40px; /* 网格大小 */
    animation: subtleTextureShift 60s linear infinite; /* 应用微妙的偏移动画 */
    opacity: 0.7;
    z-index: -1; /* 在粒子之下 */
}
/* ==========================================================================
   [ END OF FILE base/_theme_application.css ]
   ========================================================================== */
--- END: static/css/base/_theme_application.css ---

--- START: static/css/base/_typography.css ---
/* ==========================================================================
   [ START OF FILE base/_typography.css ]
   基础排版样式 - 标题、链接、图标等
   ========================================================================== */

h1, h2, h3, h4, h5, h6 {
  font-family: var(--font-family-title);
  color: var(--current-text-primary);
  font-weight: 500;
  letter-spacing: 0.8px;
  text-shadow: 0 0 10px rgba(var(--current-accent-light-rgb), 0.15),
               0 0 1px rgba(var(--current-text-primary-rgb), 0.2);
  margin-bottom: calc(var(--spacing-unit) * 1.5); /* 默认标题下边距 */
}

h1 { font-size: calc(var(--base-font-size) * 2); }
h2 { font-size: calc(var(--base-font-size) * 1.75); }
h3 { font-size: calc(var(--base-font-size) * 1.5); }
h4 { font-size: calc(var(--base-font-size) * 1.25); }
h5 { font-size: calc(var(--base-font-size) * 1.1); }
h6 { font-size: var(--base-font-size); }

p {
  margin-bottom: var(--spacing-unit); /* 段落下边距 */
  line-height: var(--line-height-base);
}

a {
  color: var(--current-accent-light);
  text-decoration: none;
  transition: color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
              filter var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
  font-weight: 500;
}

a:hover,
a:focus {
  color: color-mix(in srgb, var(--current-accent-light) 80%, var(--current-text-primary));
  text-decoration: none;
  filter: brightness(1.15);
  outline: none;
}

a:focus-visible {
  outline: 2px dashed var(--current-accent-ink);
  outline-offset: 2px;
}

/* Font Awesome 图标基础样式 */
i.fas, i.far, i.fal, i.fad, i.fab {
  text-shadow: 0 0 6px rgba(var(--current-accent-light-rgb), 0.25);
  transition: color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
              text-shadow var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
              transform var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
  display: inline-block;
  vertical-align: middle;
}

code, pre {
  font-family: var(--font-family-code);
  font-size: 0.9em;
  background-color: rgba(var(--current-panel-bg-rgb), 0.5); /* 统一代码块背景 */
  border: 1px solid rgba(var(--current-panel-border-rgb), 0.3);
  border-radius: var(--border-radius-slight);
  padding: calc(var(--spacing-unit) * 0.25) calc(var(--spacing-unit) * 0.75);
}

pre {
  padding: var(--spacing-unit);
  overflow-x: auto; /* 允许水平滚动 */
  white-space: pre-wrap; /* 允许自动换行 */
  word-break: break-all; /* 强制长单词换行 */
}

blockquote {
  margin: var(--spacing-unit) 0 var(--spacing-unit) calc(var(--spacing-unit) * 2);
  padding-left: calc(var(--spacing-unit) * 1.5);
  border-left: 3px solid var(--current-accent-ink);
  color: var(--current-text-secondary);
  font-style: italic;
}
/* ==========================================================================
   [ END OF FILE base/_typography.css ]
   ========================================================================== */
--- END: static/css/base/_typography.css ---

--- START: static/css/base/_variables.css ---
/* ==========================================================================
   [ START OF FILE base/_variables.css ]
   CSS Custom Properties (Variables) - Lumina Theme
   ========================================================================== */

:root {
  /* Lumina Script - 浅色模式 (月白宣纸 / Moon White Rice Paper) 变量定义 */
  --lumina-bg-light: #F9F8F6;
  --lumina-panel-bg-light: rgba(251, 250, 248, 0.9);
  --lumina-panel-border-light: rgba(120, 115, 110, 0.25);
  --lumina-text-primary-light: #4A4642;
  --lumina-text-secondary-light: #88827C;
  --lumina-accent-ink-light: #A0522D; /* 赭石色/印章红 */
  --lumina-accent-light-light: #5E8BC9; /* 天青蓝 */
  --lumina-glow-light: rgba(94, 139, 201, 0.35); /* 天青蓝辉光 */
  --lumina-ink-texture-light: url("data:image/svg+xml,%3Csvg width='80' height='80' viewBox='0 0 80 80' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseTextureLight'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='1' stitchTiles='stitch'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 .2 0 0 0 0 .19 0 0 0 0 .18 0 0 0 .015 0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseTextureLight)' opacity='0.3'/%3E%3C/svg%3E");
  --lumina-bg-light-rgb: 249, 248, 246;
  --lumina-panel-bg-light-rgb: 251, 250, 248;
  --lumina-panel-border-light-rgb: 120, 115, 110;
  --lumina-text-primary-light-rgb: 74, 70, 66;
  --lumina-text-secondary-light-rgb: 136, 130, 124;
  --lumina-accent-ink-light-rgb: 160, 82, 45;
  --lumina-accent-light-light-rgb: 94, 139, 201;

  /* Lumina Script - 深色模式 (墨黑星空 / Ink Black Starry Sky) 变量定义 */
  --lumina-bg-dark: #16181D;
  --lumina-panel-bg-dark: rgba(22, 24, 29, 0.88);
  --lumina-panel-border-dark: rgba(180, 195, 230, 0.3);
  --lumina-text-primary-dark: #E0D8CE;
  --lumina-text-secondary-dark: #A09A90;
  --lumina-accent-ink-dark: #E6C37F; /* 璨金色 */
  --lumina-accent-light-dark: #7AB8F5; /* 星河蓝 */
  --lumina-glow-dark: rgba(122, 184, 245, 0.4); /* 星河蓝辉光 */
  --lumina-ink-texture-dark: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseTextureDark'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='2' stitchTiles='stitch'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 .9 0 0 0 0 .85 0 0 0 0 .8 0 0 0 .02 0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseTextureDark)' opacity='0.4'/%3E%3C/svg%3E");
  --lumina-bg-dark-rgb: 22, 24, 29;
  --lumina-panel-bg-dark-rgb: 22, 24, 29; /* Note: panel is also dark, but slightly transparent */
  --lumina-panel-border-dark-rgb: 180, 195, 230;
  --lumina-text-primary-dark-rgb: 224, 216, 206;
  --lumina-text-secondary-dark-rgb: 160, 154, 144;
  --lumina-accent-ink-dark-rgb: 230, 195, 127;
  --lumina-accent-light-dark-rgb: 122, 184, 245;

  /* 字体定义 */
  --font-family-title: "Orbitron", "Noto Sans SC", system-ui, -apple-system, sans-serif;
  --font-family-body: "Roboto", "Noto Sans SC", system-ui, -apple-system, sans-serif;
  --font-family-code: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;

  /* 尺寸与间距基础单位 */
  --base-font-size: 16px; /* 主脚本会从localStorage加载并覆盖此值 */
  --line-height-base: 1.75;
  --spacing-unit: 8px;

  /* 圆角定义 */
  --border-radius-soft: 12px;
  --border-radius-slight: 6px;

  /* 过渡与动画时长及缓动函数 */
  --transition-duration-ink-subtle: 0.45s;
  --transition-duration-ink-flow: 0.65s;
  --transition-duration-light-pulse: 0.35s;
  --transition-timing-function-lumina: cubic-bezier(0.35, 0, 0.25, 1);

  /* Z-轴层级定义 */
  --z-index-loader: 1000;
  --z-index-modal: 900;
  --z-index-toast: 950;
  --z-index-sidebar: 100;
  --z-index-header: 150;
  --z-index-component-wrapper: 50;
  --z-index-process-log: 60;
  --z-index-file-preview: 55;

  /* 组件特定尺寸定义 */
  --idt-offset-top-percentage: 2.5%; /* 主脚本会从localStorage加载并覆盖 */
  --idt-offset-left-percentage: 1.8%; /* 主脚本会从localStorage加载并覆盖 */
  --idt-component-width: 280px;
  --idt-component-height: 280px;
  --header-height: 70px;
  --process-log-sidebar-width: 350px;
  --process-log-sidebar-width-collapsed: 55px;
  --input-area-height: 75px; /* 主脚本会动态更新此值 */

  /* 光绘线条粗细定义 */
  --lumina-line-weight-thin: 1px;
  --lumina-line-weight-medium: 1.5px;
  --lumina-line-weight-bold: 2.5px;

  /* 错误与成功状态颜色 (通用，不带主题后缀) */
  --lumina-error-color: #D9534F;
  --lumina-error-glow: rgba(217, 83, 79, 0.4);
  --lumina-success-color: #5CB85C;
  --lumina-success-glow: rgba(92, 184, 92, 0.4);
  --lumina-error-color-rgb: 217, 83, 79;
  --lumina-success-color-rgb: 92, 184, 92;
}
/* ==========================================================================
   [ END OF FILE base/_variables.css ]
   ========================================================================== */
--- END: static/css/base/_variables.css ---

--- START: static/css/components/_buttons.css ---
/* ==========================================================================
   [ START OF FILE components/_buttons.css ]
   按钮样式 - 通用图标按钮和Lumina风格按钮
   ========================================================================== */

button { /* Base reset if not already in _reset.css */
  font-family: inherit;
  cursor: pointer;
  border: none;
  background: none;
  padding: 0;
  color: inherit;
  outline: none; /* Common to remove default outline */
}

/* Generic Icon Button */
.icon-btn {
  color: var(--current-text-secondary);
  padding: calc(var(--spacing-unit) * 0.85);
  font-size: calc(var(--base-font-size) * 1.25);
  line-height: 1;
  border-radius: 50%;
  width: calc(var(--base-font-size) * 2.5);
  height: calc(var(--base-font-size) * 2.5);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  transition: color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
              background-color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
              transform var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
              box-shadow var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
}

.icon-btn:hover,
.icon-btn:focus {
  color: var(--current-accent-light);
  background-color: rgba(var(--current-accent-light-rgb), 0.1);
  transform: scale(1.1);
  box-shadow: 0 0 12px rgba(var(--current-accent-light-rgb), 0.2);
}

.icon-btn:focus-visible {
  outline: 2px dashed var(--current-accent-ink);
  outline-offset: 2px;
}

.icon-btn i { /* Ensure icon inside doesn't have the global icon shadow if not desired */
  text-shadow: none;
}

/* Lumina Button Family */
.lumina-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: calc(var(--spacing-unit) * 1.1) calc(var(--spacing-unit) * 2.2);
  font-family: var(--font-family-title);
  font-size: calc(var(--base-font-size) * 0.92);
  font-weight: 500;
  border-radius: var(--border-radius-slight);
  cursor: pointer;
  text-decoration: none;
  letter-spacing: 1px;
  position: relative;
  overflow: hidden;
  transition: all var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
  border: var(--lumina-line-weight-thin) solid var(--current-accent-light);
  color: var(--current-accent-light);
  background-color: transparent;
  box-shadow: inset 0 0 0 0 rgba(var(--current-accent-light-rgb), 0.15); /* For hover effect */
}

.lumina-button i {
  margin-right: calc(var(--spacing-unit) * 0.8);
  font-size: calc(var(--base-font-size) * 1.05);
  line-height: 1;
}

.lumina-button::before { /* Glow effect */
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  background-color: rgba(var(--current-accent-light-rgb), 0.2);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  opacity: 0;
  transition: width var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
              height var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
              opacity var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
}

.lumina-button:hover,
.lumina-button:focus {
  color: var(--current-text-primary);
  border-color: var(--current-accent-light);
  box-shadow: 0 0 15px rgba(var(--current-accent-light-rgb), 0.3),
              inset 0 0 10px rgba(var(--current-accent-light-rgb), 0.1);
  transform: translateY(-2px);
}

body[data-theme='dark-crystal'] .lumina-button:hover,
body[data-theme="auto-crystal"].dark-crystal-active .lumina-button:hover,
body[data-theme='dark-crystal'] .lumina-button:focus,
body[data-theme="auto-crystal"].dark-crystal-active .lumina-button:focus {
    color: var(--current-bg); /* Text color becomes background on dark for contrast */
}

.lumina-button:hover::before {
  width: 250%;
  height: 250%;
  opacity: 1;
}

.lumina-button:active {
  transform: translateY(0px) scale(0.98);
  box-shadow: inset 0 2px 5px rgba(var(--current-text-primary-rgb), 0.15);
}

.lumina-button:disabled,
.lumina-button.disabled {
  border-color: var(--current-text-secondary);
  color: var(--current-text-secondary);
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
  background-color: transparent;
}
.lumina-button:disabled::before,
.lumina-button.disabled::before {
  display: none;
}

/* Lumina Primary Button (Accent Ink) */
.lumina-button-primary {
  border-color: var(--current-accent-ink);
  color: var(--current-accent-ink);
  font-weight: 700;
  box-shadow: 0 1px 3px rgba(var(--current-accent-ink-rgb), 0.2);
}

.lumina-button-primary::before {
  background-color: rgba(var(--current-accent-ink-rgb), 0.2);
}

.lumina-button-primary:hover,
.lumina-button-primary:focus {
  color: var(--current-text-primary); /* Default hover text color */
  border-color: var(--current-accent-ink);
  box-shadow: 0 0 18px rgba(var(--current-accent-ink-rgb), 0.35),
              inset 0 0 12px rgba(var(--current-accent-ink-rgb), 0.1);
  transform: none; /* Primary buttons usually don't "lift" as much */
}

body[data-theme='dark-crystal'] .lumina-button-primary:hover,
body[data-theme="auto-crystal"].dark-crystal-active .lumina-button-primary:hover,
body[data-theme='dark-crystal'] .lumina-button-primary:focus,
body[data-theme="auto-crystal"].dark-crystal-active .lumina-button-primary:focus {
    color: var(--current-bg); /* Text color becomes background on dark */
}

/* Lumina Sidebar Button */
.lumina-button-sidebar {
  justify-content: flex-start;
  text-transform: none;
  font-size: var(--base-font-size);
  font-weight: 400;
  border: none;
  color: var(--current-text-secondary);
  padding: calc(var(--spacing-unit) * 1.2) calc(var(--spacing-unit) * 1.8);
  width: 100%;
  border-radius: var(--border-radius-slight);
  transition: background-color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
              color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
              transform var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
              box-shadow var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
}

.lumina-button-sidebar i {
  margin-right: calc(var(--spacing-unit) * 1.5);
  width: 22px; /* For alignment */
  text-align: center;
  color: var(--current-accent-light);
  transition: transform var(--transition-duration-light-pulse) ease;
}

.lumina-button-sidebar:hover,
.lumina-button-sidebar:focus {
  background-color: rgba(var(--current-accent-light-rgb), 0.08);
  color: var(--current-text-primary);
  transform: translateX(4px);
  box-shadow: -4px 0 0 0 var(--current-accent-light) inset;
}

.lumina-button-sidebar:hover i,
.lumina-button-sidebar:focus i {
  transform: scale(1.15);
}

.lumina-button-sidebar.active {
  background-color: rgba(var(--current-accent-light-rgb), 0.15);
  color: var(--current-text-primary);
  font-weight: 500;
  box-shadow: -5px 0 0 0 var(--current-accent-light) inset,
              0 0 10px rgba(var(--current-accent-light-rgb), 0.1);
}

.lumina-button-sidebar.active i {
  color: var(--current-accent-light);
  transform: scale(1.1);
}

/* Fixed Bottom Button (used for Create New Session) */
.lumina-button-fixed-bottom {
    /* Base styles will be combined with .lumina-button-primary */
    /* Specific positioning and sizing handled in _sidebar.css or _layout.css */
}
/* ==========================================================================
   [ END OF FILE components/_buttons.css ]
   ========================================================================== */
--- END: static/css/components/_buttons.css ---

--- START: static/css/components/_forms.css ---
/* ==========================================================================
   [ START OF FILE components/_forms.css ]
   表单元素样式 - 输入框、文本域、下拉框、滑块、开关
   ========================================================================== */

/* Generic input, textarea, select styles (can also be in _typography or _base) */
input, textarea, select {
  font-family: var(--font-family-body);
  background-color: rgba(var(--current-bg-rgb), 0.5);
  border: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  color: var(--current-text-primary);
  padding: calc(var(--spacing-unit) * 1.35) calc(var(--spacing-unit) * 1.5);
  border-radius: var(--border-radius-slight);
  transition: border-color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
              box-shadow var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
  width: 100%; /* Default to full width within their container */
}

input:focus,
textarea:focus,
select:focus {
  outline: none;
  border-color: var(--current-accent-light);
  box-shadow: 0 0 0 var(--lumina-line-weight-bold) rgba(var(--current-accent-light-rgb), 0.3),
              0 0 8px rgba(var(--current-accent-light-rgb), 0.2);
}

/* User Input Textarea (specific for chat input) */
textarea#user-input {
  border-width: var(--lumina-line-weight-medium);
  background-color: transparent; /* Default for chat input */
  min-height: 56px; /* Align with send button */
  max-height: 180px; /* Prevent excessive height */
  padding-right: calc(var(--spacing-unit) * 9); /* Space for overlay buttons */
  line-height: 1.6;
  font-size: var(--base-font-size);
  resize: none; /* Disable manual resize */
  overflow-y: hidden; /* Default, JS will manage */
}

textarea#user-input:focus {
  background-color: rgba(var(--current-panel-bg-rgb), 0.3); /* Focus background */
}

/* Select (Dropdown) specific styling for Lumina theme */
.lumina-select {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' class='bi bi-chevron-down' viewBox='0 0 16 16'%3E%3Cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right calc(var(--spacing-unit) * 1.5) center;
  background-size: 1em;
  padding-right: calc(var(--spacing-unit) * 4); /* Space for arrow */
}
/* For settings modal select, use the container's styles */
.setting-item .lumina-select {
    /* Uses the .setting-item .lumina-select defined in _modals.css */
}

/* Range Slider (input type=range) specific styling */
.lumina-range { /* Apply to the input[type=range] directly */
  -webkit-appearance: none; -moz-appearance: none; appearance: none;
  width: 100%;
  height: 6px;
  background: rgba(var(--current-panel-border-rgb), 0.5);
  border-radius: 3px;
  outline: none;
  border: none; /* Already reset, but ensure */
  padding: 0; /* Override general input padding */
}
.lumina-range::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none;
  width: 18px; height: 18px;
  background: var(--current-accent-light);
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 8px rgba(var(--current-accent-light-rgb), 0.4);
  border: 2px solid var(--current-panel-bg); /* Match panel bg for cutout effect */
  transition: transform var(--transition-duration-light-pulse) ease;
  margin-top: -6px; /* Vertical centering */
}
.lumina-range::-webkit-slider-thumb:hover {
  transform: scale(1.1);
}
.lumina-range::-moz-range-thumb {
  width: 18px; height: 18px;
  background: var(--current-accent-light);
  border-radius: 50%;
  cursor: pointer;
  border: none;
  box-shadow: 0 0 8px rgba(var(--current-accent-light-rgb), 0.4);
  border: 2px solid var(--current-panel-bg);
}
.lumina-range::-moz-range-thumb:hover {
  transform: scale(1.1);
}

/* Switch (Toggle) specific styling */
.lumina-switch { /* The label container */
  position: relative;
  display: inline-block;
  width: 48px;
  height: 24px;
}
.lumina-switch input { /* Hide the actual checkbox */
  opacity: 0;
  width: 0;
  height: 0;
}
.lumina-switch .slider { /* The track */
  position: absolute;
  cursor: pointer;
  top: 0; left: 0; right: 0; bottom: 0;
  background-color: rgba(var(--current-panel-border-rgb), 0.6);
  transition: background-color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
}
.lumina-switch .slider.round {
  border-radius: 24px;
}
.lumina-switch .slider.round:before { /* The knob */
  border-radius: 50%;
}
.lumina-switch .slider:before { /* The knob */
  content: "";
  position: absolute;
  height: 18px; width: 18px;
  left: 3px; bottom: 3px;
  background-color: var(--current-bg);
  box-shadow: 0 1px 2px rgba(var(--current-text-primary-rgb), 0.2);
  transition: transform var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
}
.lumina-switch input:checked + .slider {
  background-color: var(--current-accent-light);
}
.lumina-switch input:checked + .slider:before {
  transform: translateX(24px);
}
.lumina-switch input:focus + .slider { /* Focus ring for accessibility */
  box-shadow: 0 0 0 2px rgba(var(--current-accent-light-rgb), 0.3);
}

/* File input is visually hidden, triggered by a button */
#file-input {
  display: none;
}

/* ==========================================================================
   [ END OF FILE components/_forms.css ]
   ========================================================================== */
--- END: static/css/components/_forms.css ---

--- START: static/css/components/_loader.css ---
/* ==========================================================================
   [ START OF FILE components/_loader.css ]
   加载动画样式
   ========================================================================== */

.loader-container {
  background-color: var(--current-bg);
  opacity: 1;
  transition: opacity var(--transition-duration-ink-flow) var(--transition-timing-function-lumina);
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: var(--z-index-loader);
}

.loader-container.hidden {
  opacity: 0;
  pointer-events: none;
}

.lumina-loader-core {
  width: 100px;
  height: 100px;
  position: relative;
  margin-bottom: calc(var(--spacing-unit) * 3.5);
}

.lumina-loader-core::before,
.lumina-loader-core::after {
  content: '';
  position: absolute;
  border-radius: 50%;
  border-style: solid;
  border-color: transparent;
  animation: luminaLoaderSpin 2.5s linear infinite;
}

.lumina-loader-core::before {
  width: 100%; height: 100%;
  border-width: var(--lumina-line-weight-bold);
  border-top-color: var(--current-accent-light);
  border-left-color: var(--current-accent-light);
  opacity: 0.8;
}

.lumina-loader-core::after {
  width: 70%; height: 70%;
  top: 15%; left: 15%;
  border-width: var(--lumina-line-weight-medium);
  border-bottom-color: var(--current-accent-ink);
  border-right-color: var(--current-accent-ink);
  animation-direction: reverse;
  animation-duration: 2s;
  opacity: 0.7;
}

.lumina-loader-center-pulse {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  width: 12px; height: 12px;
  background-color: var(--current-accent-light);
  border-radius: 50%;
  box-shadow: 0 0 15px 3px var(--current-glow);
  animation: luminaLoaderPulse 1.5s infinite ease-in-out;
}

/* Fatal Error Loader */
.loader-container.loader-fatal-error .lumina-loader-core::before {
  border-top-color: var(--lumina-error-color);
  border-left-color: var(--lumina-error-color);
  animation: luminaLoaderSpin 3s linear infinite, luminaErrorPulseBorder 1.5s infinite ease-in-out;
}
.loader-container.loader-fatal-error .lumina-loader-core::after {
  border-bottom-color: var(--lumina-error-color);
  border-right-color: var(--lumina-error-color);
  opacity: 0.5;
}
.loader-container.loader-fatal-error .lumina-loader-center-pulse {
  background-color: var(--lumina-error-color);
  box-shadow: 0 0 15px 3px var(--lumina-error-glow);
}

.loader-logo-text {
  font-family: var(--font-family-title);
  font-size: calc(var(--base-font-size) * 2.2);
  font-weight: 500;
  color: var(--current-text-primary);
  letter-spacing: 1.5px;
  margin-bottom: calc(var(--spacing-unit) * 3.5);
  text-shadow: 0 1px 1px rgba(var(--current-bg-rgb), 0.5);
}

.loader-logo-text span { /* "CIRCUIT" */
  color: var(--current-accent-light);
  font-weight: 700;
}
.loader-logo-text .loader-version-pro { /* "PRO" */
  font-size: 0.55em;
  margin-left: 4px;
  vertical-align: super;
  color: var(--current-accent-ink);
  opacity: 0.9;
}

.loading-text {
  font-family: var(--font-family-body);
  font-size: var(--base-font-size);
  color: var(--current-text-secondary);
  letter-spacing: 0.5px;
  opacity: 0.85;
}

.loader-container.loader-fatal-error .loader-logo-text {
  color: var(--lumina-error-color);
}
.loader-container.loader-fatal-error .loading-text { /* Main error heading */
  color: var(--current-text-primary);
}
.loader-container.loader-fatal-error .error-details-text { /* Sub-details */
  color: var(--current-text-secondary);
  font-size: 0.9em;
  margin-top: var(--spacing-unit);
  max-width: 80%;
  text-align: center;
  line-height: 1.5;
}
.loader-container.loader-fatal-error .refresh-button {
  margin-top: calc(var(--spacing-unit) * 2.5);
}

/* ==========================================================================
   [ END OF FILE components/_loader.css ]
   ========================================================================== */
--- END: static/css/components/_loader.css ---

--- START: static/css/components/_messages.css ---
/* ==========================================================================
   [ START OF FILE components/_messages.css ]
   聊天消息气泡和相关元素样式
   ========================================================================== */

.chat-box .message {
  display: flex;
  align-items: flex-start; /* Avatar and bubble top-aligned */
  max-width: 90%;
}

.chat-box .message.message-user {
  align-self: flex-end; /* User messages on the right */
  flex-direction: row-reverse; /* Avatar on the right */
}

.chat-box .message.message-agent {
  align-self: flex-start; /* Agent messages on the left */
}

.chat-box .message.system-message {
  align-self: center;
  max-width: 85%;
  width: fit-content;
  font-size: calc(var(--base-font-size) * 0.88);
  text-align: center;
  color: var(--current-text-secondary);
  opacity: 0.8;
  display: block; /* Not part of the flex flow for user/agent */
}

.chat-box .message.system-message-initial.lumina-panel {
  align-self: stretch;
  width: auto; /* Let content decide */
  max-width: 95%;
  margin: var(--spacing-unit) auto;
  text-align: left;
  opacity: 1;
}

.chat-box .message .message-bubble {
  background-color: var(--current-panel-bg);
  border-radius: var(--border-radius-soft);
  padding: calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 2);
  box-shadow: 0 3px 10px rgba(var(--current-text-primary-rgb), 0.04),
              0 1px 2px rgba(var(--current-text-primary-rgb), 0.02);
  border: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  max-width: 100%;
  word-break: break-word;
  overflow-wrap: break-word;
  position: relative; /* For copy button */
  background-blend-mode: multiply; /* Or overlay, depending on texture */
  transition: transform var(--transition-duration-light-pulse) ease,
              box-shadow var(--transition-duration-light-pulse) ease;
  flex-grow: 0; /* Don't grow */
  flex-shrink: 1; /* Allow to shrink */
}

.chat-box .message:hover .message-bubble {
  transform: translateY(-1px);
  box-shadow: 0 5px 15px rgba(var(--current-text-primary-rgb), 0.06),
              0 2px 5px rgba(var(--current-text-primary-rgb), 0.03);
}

.chat-box .message.message-user .message-bubble {
  background-color: rgba(var(--current-accent-light-rgb), 0.12);
  border-color: rgba(var(--current-accent-light-rgb), 0.3);
  color: var(--current-text-primary);
}
.chat-box .message.message-user .message-bubble a {
  color: var(--current-accent-light);
}

.chat-box .message.system-message .message-bubble {
  background-color: transparent;
  border: var(--lumina-line-weight-thin) dashed rgba(var(--current-panel-border-rgb), 0.6);
  box-shadow: none;
  padding: calc(var(--spacing-unit) * 1.2);
}
.chat-box .message.system-message.error-message .message-bubble {
  border-color: var(--lumina-error-color);
  color: var(--lumina-error-color);
}

.chat-box .message .message-avatar {
  width: 38px; height: 38px;
  border-radius: 50%;
  background-color: var(--current-panel-border);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  margin-right: calc(var(--spacing-unit) * 1.25); /* For agent messages */
  box-shadow: 0 1px 3px rgba(var(--current-text-primary-rgb), 0.08);
  transition: transform var(--transition-duration-light-pulse) ease;
}
.chat-box .message:hover .message-avatar {
  transform: scale(1.05);
}
.chat-box .message .message-avatar i {
  font-size: calc(var(--base-font-size) * 1.2);
  color: var(--current-text-secondary);
}

.chat-box .message.message-user .message-avatar {
  margin-right: 0;
  margin-left: calc(var(--spacing-unit) * 1.25);
  background-color: var(--current-accent-light);
}
.chat-box .message.message-user .message-avatar i {
  color: var(--current-bg);
}

.chat-box .message.message-agent .message-avatar {
  background-color: var(--current-accent-ink);
}
.chat-box .message.message-agent .message-avatar i {
  color: var(--current-bg);
}

.chat-box .message.system-message .message-avatar {
  display: none;
}

.chat-box .message .message-content-wrapper {
  display: flex;
  flex-direction: column;
  gap: calc(var(--spacing-unit) * 1.5);
}

.chat-box .message .message-thought-prefix {
  margin-bottom: calc(var(--spacing-unit) * 1.5);
  padding: calc(var(--spacing-unit) * 1.2);
  background-color: rgba(var(--current-panel-bg-rgb), 0.4);
  border-radius: var(--border-radius-slight);
  border: var(--lumina-line-weight-thin) dashed rgba(var(--current-panel-border-rgb), 0.7);
  font-size: 0.88em;
  color: var(--current-text-secondary);
}
.chat-box .message .message-thought-prefix strong {
  display: block;
  margin-bottom: calc(var(--spacing-unit) * 0.75);
  font-family: var(--font-family-title);
  color: var(--current-accent-ink);
  font-weight: 500;
}
.chat-box .message .message-thought-prefix strong i {
  margin-right: var(--spacing-unit);
}
.chat-box .message .message-thought-prefix .think-bubble-content {
  line-height: 1.5;
  max-height: 200px; /* Allow scrolling for long thoughts */
  overflow-y: auto;
  padding-right: var(--spacing-unit); /* Space for scrollbar */
}
.chat-box .message .message-thought-prefix .think-bubble-content pre.embedded-json {
  background-color: rgba(var(--current-bg-rgb), 0.3);
  padding: calc(var(--spacing-unit) * 1);
  border-radius: var(--border-radius-slight);
  margin-top: var(--spacing-unit);
  font-family: var(--font-family-code);
  font-size: 0.92em;
  color: var(--current-text-secondary);
  border: 1px solid rgba(var(--current-panel-border-rgb), 0.3);
  white-space: pre-wrap;
  word-break: break-all;
}
.chat-box .message .message-thought-prefix .think-bubble-content pre.embedded-json.error {
  color: var(--lumina-error-color);
  border-color: var(--lumina-error-color);
}

.chat-box .message .message-text-content {
  line-height: 1.65;
}
.chat-box .message .message-text-content a.external-link i {
  font-size: 0.82em;
  margin-right: 4px;
  opacity: 0.75;
}

/* Attachments in messages */
.chat-box .message .message-attachments-summary {
  margin-top: calc(var(--spacing-unit) * 1.2);
  font-size: 0.82em;
  opacity: 0.85;
  color: var(--current-text-secondary);
}
.chat-box .message .message-attachments-summary i {
  margin-right: calc(var(--spacing-unit) * 0.6);
}
.chat-box .message .message-attachments-summary .filename-chip {
  display: inline-block;
  background-color: rgba(var(--current-panel-border-rgb), 0.5);
  color: var(--current-text-secondary);
  padding: 3px calc(var(--spacing-unit) * 0.75);
  border-radius: 12px; /* Chip-like */
  font-size: 0.92em;
  margin-right: calc(var(--spacing-unit) * 0.5);
  margin-bottom: calc(var(--spacing-unit) * 0.5); /* Allow wrapping */
}

/* Welcome Message Specifics */
.chat-box .message.system-message-initial.lumina-panel {
  padding: calc(var(--spacing-unit) * 2.5) calc(var(--spacing-unit) * 3);
  border-width: var(--lumina-line-weight-medium);
}
.chat-box .message.system-message-initial.lumina-panel .welcome-header {
  display: flex;
  align-items: center;
  margin-bottom: calc(var(--spacing-unit) * 1.5);
}
.chat-box .message.system-message-initial.lumina-panel .welcome-header .robot-icon {
  color: var(--current-accent-light);
  font-size: calc(var(--base-font-size) * 2.8);
  margin-right: calc(var(--spacing-unit) * 1.5);
  text-shadow: 0 0 12px var(--current-glow);
}
.chat-box .message.system-message-initial.lumina-panel .welcome-header h2 {
  font-size: calc(var(--base-font-size) * 1.9);
  margin-bottom: 0; /* Reset for header */
  font-weight: 700;
}
.chat-box .message.system-message-initial.lumina-panel .welcome-header h2 .version-pro {
  font-size: 0.6em;
  color: var(--current-accent-ink);
}
.chat-box .message.system-message-initial.lumina-panel .welcome-header h2 .version-number {
  opacity: 0.8;
}
.chat-box .message.system-message-initial.lumina-panel .welcome-subtitle {
    font-size: calc(var(--base-font-size) * 0.95);
    color: var(--current-text-secondary);
    margin-bottom: calc(var(--spacing-unit) * 2);
}
.chat-box .message.system-message-initial.lumina-panel .capabilities {
  display: flex;
  flex-wrap: wrap;
  gap: calc(var(--spacing-unit) * 1.2);
  margin-bottom: calc(var(--spacing-unit) * 2.5);
}
.chat-box .message.system-message-initial.lumina-panel .capabilities .capability {
  background-color: rgba(var(--current-accent-light-rgb), 0.06);
  border: var(--lumina-line-weight-thin) solid rgba(var(--current-accent-light-rgb), 0.2);
  padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 1.2);
  border-radius: 18px;
  font-size: 0.88em;
  display: inline-flex;
  align-items: center;
  color: var(--current-text-secondary);
  transition: all var(--transition-duration-light-pulse) ease;
}
.chat-box .message.system-message-initial.lumina-panel .capabilities .capability:hover {
  background-color: rgba(var(--current-accent-light-rgb), 0.12);
  color: var(--current-text-primary);
  transform: translateY(-1px);
  box-shadow: 0 2px 5px rgba(var(--current-accent-light-rgb), 0.1);
}
.chat-box .message.system-message-initial.lumina-panel .capabilities .capability i {
  color: var(--current-accent-light);
  margin-right: calc(var(--spacing-unit) * 0.75);
}

.chat-box .message.system-message-initial.lumina-panel .quick-actions p {
  font-weight: 500;
  margin-bottom: calc(var(--spacing-unit) * 1.2);
  color: var(--current-text-primary);
}
.chat-box .message.system-message-initial.lumina-panel .quick-actions ul {
  list-style: none; padding: 0;
  display: flex; flex-wrap: wrap;
  gap: calc(var(--spacing-unit) * 1);
}
.chat-box .message.system-message-initial.lumina-panel .quick-actions ul li a.quick-action-btn.lumina-button {
  padding: calc(var(--spacing-unit) * 0.8) calc(var(--spacing-unit) * 1.5);
  font-size: calc(var(--base-font-size) * 0.85);
}


/* Typing Indicator */
.chat-box .typing-indicator {
  display: flex;
  align-items: flex-start;
}
.chat-box .typing-indicator .message-bubble {
  background-color: var(--current-panel-bg);
  padding: calc(var(--spacing-unit) * 1.2) calc(var(--spacing-unit) * 1.8);
}
.chat-box .typing-indicator .message-bubble .typing-dots {
  display: inline-flex;
  align-items: center;
}
.chat-box .typing-indicator .message-bubble .typing-dots .typing-dot {
  background-color: var(--current-accent-ink);
  width: 7px; height: 7px;
  border-radius: 50%;
  margin: 0 3px;
  animation: luminaTypingDotBounce 1.3s infinite ease-in-out;
}
.chat-box .typing-indicator .message-bubble .typing-dots .typing-dot:nth-child(2) { animation-delay: 0.22s; }
.chat-box .typing-indicator .message-bubble .typing-dots .typing-dot:nth-child(3) { animation-delay: 0.44s; }

/* Copy Button */
.message-bubble .copy-llm-response-btn {
  position: absolute;
  top: calc(var(--spacing-unit) * 1);
  right: calc(var(--spacing-unit) * 1);
  opacity: 0;
  visibility: hidden;
  transition: opacity var(--transition-duration-light-pulse) ease-in-out,
              visibility 0s var(--transition-duration-light-pulse) ease-in-out, /* Delay visibility until opacity starts */
              background-color var(--transition-duration-light-pulse) ease-in-out;
  z-index: 10; /* Above message content */
  cursor: pointer;
}
.message-bubble:hover .copy-llm-response-btn {
  opacity: 1;
  visibility: visible;
  transition-delay: 0s, 0s; /* Remove delay on hover */
}
.message-bubble .copy-llm-response-btn:hover {
  background-color: rgba(var(--current-text-primary-rgb), 0.1);
  color: var(--current-text-primary);
}
.message-bubble .copy-llm-response-btn i {
  pointer-events: none; /* Ensure icon click goes to button */
}

/* Suggestions in final response */
.final-response-suggestions {
    margin-top: calc(var(--spacing-unit) * 1.5);
    padding-top: calc(var(--spacing-unit) * 1.5);
    border-top: 1px dashed rgba(var(--current-panel-border-rgb), 0.5);
}
.final-response-suggestions strong {
    display: block;
    margin-bottom: var(--spacing-unit);
    font-family: var(--font-family-title);
    color: var(--current-accent-ink);
}
.final-response-suggestions ul {
    list-style: none;
    padding: 0;
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-unit);
}
.final-response-suggestions ul li a.quick-action-btn.lumina-button {
    padding: calc(var(--spacing-unit) * 0.7) var(--spacing-unit);
    font-size: calc(var(--base-font-size) * 0.8);
}
/* ==========================================================================
   [ END OF FILE components/_messages.css ]
   ========================================================================== */
--- END: static/css/components/_messages.css ---

--- START: static/css/components/_modals.css ---
/* ==========================================================================
   [ START OF FILE components/_modals.css ]
   设置模态框及内部控件样式
   ========================================================================== */

/* 模态框背景遮罩层 */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(var(--lumina-bg-dark-rgb, 22, 24, 29), 0.65); /* Fallback for dark var */
  backdrop-filter: blur(10px) brightness(0.8);
  -webkit-backdrop-filter: blur(10px) brightness(0.8);
  display: none; /* Initially hidden, shown by JS */
  align-items: center;
  justify-content: center;
  z-index: var(--z-index-modal);
}

/* 模态框内容容器，应用 Lumina 面板样式 */
.modal .modal-content.lumina-panel {
  max-width: 680px;
  width: 92%;
  max-height: 85vh; /* Prevent modal from being too tall on smaller screens */
  display: flex;
  flex-direction: column;
  overflow: hidden; /* Content scrolling is handled by modal-body */
  box-shadow: 0 10px 40px rgba(var(--current-text-primary-rgb), 0.1),
              0 0 0 1px rgba(var(--current-panel-border-rgb), 0.5); /* Subtle border */
}

/* 模态框头部样式 */
.modal .modal-content.lumina-panel .modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: calc(var(--spacing-unit) * 1.8) calc(var(--spacing-unit) * 2.5);
  border-bottom: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  flex-shrink: 0; /* Prevent header from shrinking */
}

.modal .modal-content.lumina-panel .modal-header h2 {
  font-size: calc(var(--base-font-size) * 1.35);
  margin: 0;
  font-weight: 500;
  color: var(--current-text-primary);
}

.modal .modal-content.lumina-panel .modal-header h2 i {
  color: var(--current-accent-light);
  margin-right: calc(var(--spacing-unit) * 1.2);
}

/* 模态框头部关闭按钮 (继承 .icon-btn 样式) */
.modal .modal-content.lumina-panel .modal-header #close-settings.icon-btn {
  /* Specific overrides if needed, but .icon-btn should cover most */
  color: var(--current-text-secondary);
}


/* 模态框主体内容区域样式 */
.modal .modal-content.lumina-panel .modal-body {
  padding: calc(var(--spacing-unit) * 2.5);
  overflow-y: auto; /* Allow body to scroll if content overflows */
  flex-grow: 1; /* Take remaining vertical space */
}

/* 设置分组容器样式 */
.modal .modal-content.lumina-panel .modal-body .setting-group {
  margin-bottom: calc(var(--spacing-unit) * 3);
}
.modal .modal-content.lumina-panel .modal-body .setting-group:last-child {
  margin-bottom: 0;
}

.modal .modal-content.lumina-panel .modal-body .setting-group h3 {
  font-size: calc(var(--base-font-size) * 1.1);
  border-bottom: var(--lumina-line-weight-thin) solid rgba(var(--current-panel-border-rgb), 0.7);
  padding-bottom: calc(var(--spacing-unit) * 1.2);
  margin-bottom: calc(var(--spacing-unit) * 1.8);
  color: var(--current-text-primary);
  font-weight: 500;
}

.modal .modal-content.lumina-panel .modal-body .setting-group h3 i {
  color: var(--current-accent-ink); /* Default icon color for setting group titles */
  margin-right: var(--spacing-unit);
}

/* AI核心配置组的特定图标颜色 (如果需要区分) */
.modal .modal-content.lumina-panel .modal-body .setting-group h3 i.fa-cogs {
  /* color: var(--current-accent-light); */ /* Example: use light accent for this group */
  color: var(--current-accent-ink); /* Default icon color for setting group titles */
}


/* 单个设置项容器样式 */
.modal .modal-content.lumina-panel .modal-body .setting-item {
  display: flex;
  justify-content: space-between; /* Label on left, control on right */
  align-items: center;
  padding: calc(var(--spacing-unit) * 1) 0; /* Vertical padding for each item */
  font-size: calc(var(--base-font-size) * 0.92);
  color: var(--current-text-secondary);
  border-bottom: 1px solid rgba(var(--current-panel-border-rgb), 0.15); /* Subtle separator */
}
.modal .modal-content.lumina-panel .modal-body .setting-item:last-child {
  border-bottom: none; /* No separator for the last item in a group */
  margin-bottom: 0; /* Ensure no extra margin for last item if using margin instead of padding for spacing */
}


/* 设置项中的标签 (label) 的样式 */
.modal .modal-content.lumina-panel .modal-body .setting-item label:first-child {
  flex-basis: auto; /* Allow label width to be content-based */
  min-width: 180px; /* Ensure a minimum width for alignment */
  margin-right: var(--spacing-unit);
  color: var(--current-text-primary);
  line-height: 1.4; /* For better vertical alignment with controls */
  padding-right: var(--spacing-unit); /* Space between label and control */
}

/* 设置项中的控件容器通用样式 (select, range-container, switch-container) */
.modal .modal-content.lumina-panel .modal-body .setting-item .lumina-select,
.modal .modal-content.lumina-panel .modal-body .setting-item .lumina-range-container,
.modal .modal-content.lumina-panel .modal-body .setting-item .lumina-switch-container {
  flex-grow: 1; /* Allow control to take up remaining space if label is short */
  max-width: 240px; /* Max width for controls for consistency */
  flex-basis: 240px; /* Suggest a base width, can shrink if needed */
  flex-shrink: 0;    /* Prevent shrinking beyond flex-basis if possible */
  margin-left: auto; /* Push control to the right if label is short and control is not flex-grow:1 */
  /* Styling for control wrappers (like border, padding) that are not input elements themselves */
  border: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  border-radius: var(--border-radius-slight);
  padding: calc(var(--spacing-unit) * 0.9);
  background-color: rgba(var(--current-bg-rgb), 0.4); /* Slight background for control area */
}

/* Specific overrides for switch container as it's just a wrapper */
.modal .modal-content.lumina-panel .modal-body .setting-item .lumina-switch-container {
  border: none;
  padding: 0;
  background-color: transparent;
  display: flex; /* Needed to align switch within it */
  justify-content: flex-end; /* Align switch to the right of its container */
}

/* Range slider container specific adjustments */
.modal .modal-content.lumina-panel .modal-body .setting-item .lumina-range-container {
  display: flex;
  align-items: center;
  padding-right: 0; /* Value text is separate */
}

.modal .modal-content.lumina-panel .modal-body .setting-item .lumina-range-container #font-size-value {
  margin-left: var(--spacing-unit);
  width: 40px; /* Fixed width for value display */
  text-align: right;
  color: var(--current-text-primary);
  font-size: 0.9em;
}

/* LLM Model Select specific styling */
.modal .modal-content.lumina-panel .modal-body .setting-item #llm-model-select.lumina-select {
  min-width: 200px; /* Ensure dropdown has enough width */
  /* Inherits .lumina-select styles from _forms.css */
}

.modal .modal-content.lumina-panel .modal-body .setting-item #llm-model-select option:disabled {
  color: var(--current-text-secondary);
  background-color: rgba(var(--current-panel-border-rgb), 0.15);
  font-style: italic;
}

/* Chinese Deep Thinking Toggle setting item container */
.modal .modal-content.lumina-panel .modal-body .setting-item#chinese-deep-thinking-setting-item {
  transition: opacity var(--transition-duration-light-pulse) ease, 
              max-height 0.3s ease-out,
              padding var(--transition-duration-light-pulse) ease,
              margin var(--transition-duration-light-pulse) ease; /* Added padding/margin for smooth hide */
  overflow: hidden;
}

/* Style for when it's globally disabled and hidden by JS setting display:none or a class */
.modal .modal-content.lumina-panel .modal-body .setting-item#chinese-deep-thinking-setting-item.hidden-by-global-flag {
    max-height: 0 !important;
    opacity: 0 !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    margin-bottom: 0 !important; /* Collapse margin too */
    border-bottom: none !important; /* Hide separator if it was the last visible item */
    pointer-events: none;
}

/* Disabled switch styling */
.modal .modal-content.lumina-panel .modal-body .setting-item .lumina-switch-container input[type="checkbox"]:disabled + .slider {
    cursor: not-allowed;
    background-color: rgba(var(--current-panel-border-rgb), 0.4);
}
.modal .modal-content.lumina-panel .modal-body .setting-item .lumina-switch-container input[type="checkbox"]:disabled + .slider:before {
    background-color: rgba(var(--current-bg-rgb), 0.7);
}


/* Modal Footer */
.modal .modal-content.lumina-panel .modal-footer {
  display: flex;
  justify-content: flex-end; /* Align buttons to the right */
  gap: var(--spacing-unit); /* Space between buttons */
  padding: calc(var(--spacing-unit) * 1.8) calc(var(--spacing-unit) * 2.5);
  border-top: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  flex-shrink: 0;
}

/* Ensure footer buttons use lumina-button styles */
.modal .modal-content.lumina-panel .modal-footer #reset-settings.lumina-button,
.modal .modal-content.lumina-panel .modal-footer #save-settings.lumina-button-primary {
  /* Styles are inherited from _buttons.css via their classes */
  padding: calc(var(--spacing-unit) * 1.2) calc(var(--spacing-unit) * 2.5);
}

/* ==========================================================================
   [ END OF FILE components/_modals.css ]
   ========================================================================== */

--- END: static/css/components/_modals.css ---

--- START: static/css/components/_panels.css ---
/* ==========================================================================
   [ START OF FILE components/_panels.css ]
   Lumina Panel基础样式
   ========================================================================== */

.lumina-panel {
  background-color: var(--current-panel-bg);
  border: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  border-radius: var(--border-radius-soft);
  box-shadow: 0 5px 25px rgba(var(--current-text-primary-rgb), 0.05),
              0 1px 3px rgba(var(--current-text-primary-rgb), 0.03);
  backdrop-filter: blur(18px) saturate(120%);
  -webkit-backdrop-filter: blur(18px) saturate(120%);
  transition: background-color var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
              border-color var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
              box-shadow var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
  position: relative; /* For ::before pseudo-element */
  background-image: var(--current-ink-texture);
  background-blend-mode: overlay;
}

.lumina-panel::before {
  content: "";
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  border-radius: inherit;
  box-shadow: inset 0 0 12px rgba(var(--current-accent-light-rgb), 0.12),
              inset 0 0 1px 1px rgba(var(--current-panel-bg-rgb), 0.7);
  pointer-events: none;
  z-index: 0; /* Behind content */
  opacity: 0.8;
}
/* ==========================================================================
   [ END OF FILE components/_panels.css ]
   ========================================================================== */
--- END: static/css/components/_panels.css ---

--- START: static/css/components/_toast.css ---
/* ==========================================================================
   [ START OF FILE components/_toast.css ]
   Toast通知样式
   ========================================================================== */

.toast-container {
  position: fixed;
  top: calc(var(--header-height) + var(--spacing-unit) * 1.5);
  right: calc(var(--spacing-unit) * 1.5);
  z-index: var(--z-index-toast);
  display: flex;
  flex-direction: column;
  gap: calc(var(--spacing-unit) * 1.2);
  max-width: 380px;
}

.toast.lumina-panel {
  padding: calc(var(--spacing-unit) * 1.4) calc(var(--spacing-unit) * 1.8);
  border-left-width: var(--lumina-line-weight-bold);
  display: flex;
  align-items: flex-start;
  gap: calc(var(--spacing-unit) * 1.2);
  animation-duration: var(--transition-duration-ink-subtle) !important; /* Override Animate.css default */
  border-radius: var(--border-radius-slight);
  background-image: none; /* Toasts typically don't need texture */
  position: relative; /* For close button */
}

.toast.lumina-panel .toast-icon {
  font-size: calc(var(--base-font-size) * 1.35);
  margin-top: 1px; /* Fine-tune alignment */
  flex-shrink: 0;
}

.toast.lumina-panel .toast-message {
  flex-grow: 1;
  font-size: calc(var(--base-font-size) * 0.92);
  line-height: 1.5;
  color: var(--current-text-primary);
  padding-right: calc(var(--spacing-unit) * 3); /* Space for close button */
}

.toast.lumina-panel .toast-close {
  position: absolute;
  top: calc(var(--spacing-unit) * 0.75);
  right: calc(var(--spacing-unit) * 0.75);
  padding: calc(var(--spacing-unit) * 0.5);
  font-size: 0.9em;
  color: var(--current-text-secondary);
  background: transparent;
  border: none;
  line-height: 1;
}
.toast.lumina-panel .toast-close:hover {
  color: var(--current-text-primary);
  background-color: rgba(var(--current-text-primary-rgb), 0.1);
}

/* Toast types */
.toast.lumina-panel.toast-info { border-left-color: var(--current-accent-light); }
.toast.lumina-panel.toast-info .toast-icon { color: var(--current-accent-light); }

.toast.lumina-panel.toast-success { border-left-color: var(--lumina-success-color); }
.toast.lumina-panel.toast-success .toast-icon { color: var(--lumina-success-color); }

.toast.lumina-panel.toast-warning { border-left-color: var(--current-accent-ink); }
.toast.lumina-panel.toast-warning .toast-icon { color: var(--current-accent-ink); }

.toast.lumina-panel.toast-error { border-left-color: var(--lumina-error-color); }
.toast.lumina-panel.toast-error .toast-icon { color: var(--lumina-error-color); }

/* ==========================================================================
   [ END OF FILE components/_toast.css ]
   ========================================================================== */
--- END: static/css/components/_toast.css ---

--- START: static/css/layout/_chat_area.css ---
/* ==========================================================================
   [ START OF FILE layout/_chat_area.css ]
   聊天区域布局和主要面板样式
   ========================================================================== */

.chat-area {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  transition: margin-right var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
}

.chat-area-content.lumina-panel.main-chat-panel {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative; /* For file preview absolute positioning */
}

.chat-area-content.lumina-panel.main-chat-panel .chat-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--spacing-unit) calc(var(--spacing-unit) * 2.5);
  border-bottom: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  flex-shrink: 0;
  height: calc(var(--header-height) * 0.8);
}

.chat-area-content.lumina-panel.main-chat-panel .chat-header h2 {
  font-size: calc(var(--base-font-size) * 1.15);
  margin: 0;
  font-weight: 500;
  color: var(--current-text-primary);
  flex-grow: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-shadow: none;
}

.chat-box {
  flex-grow: 1;
  padding: calc(var(--spacing-unit) * 2.5);
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: calc(var(--spacing-unit) * 2.5); /* Space between messages */
  position: relative; /* For potential absolute positioned elements within */
}

/* Input Area */
.input-area.lumina-panel {
  border-radius: var(--border-radius-soft);
  padding: calc(var(--spacing-unit) * 1.5);
  display: flex;
  align-items: flex-end; /* Align items to the bottom */
  flex-shrink: 0;
  z-index: 5;
  border-top-width: var(--lumina-line-weight-thin);
  position: relative; /* For file preview and other potential overlays */
}

.input-area.lumina-panel .input-action-btn {
  margin-right: calc(var(--spacing-unit) * 1);
  align-self: flex-end; /* Keep it at the bottom */
  margin-bottom: calc(var(--spacing-unit) * 0.35); /* Align with textarea bottom */
}

.input-area.lumina-panel .input-wrapper {
  flex-grow: 1;
  position: relative;
  display: flex;
  flex-direction: column;
}

.input-area.lumina-panel .send-button.lumina-button-primary {
  width: 56px;
  height: 56px;
  align-self: flex-end;
  margin-left: var(--spacing-unit);
  border-radius: 50%; /* Make it circular */
  padding: 0; /* Reset padding for icon-only button */
}

.input-area.lumina-panel .send-button.lumina-button-primary .send-icon {
  width: 26px;
  height: 26px;
  fill: var(--current-bg); /* Match text color logic for primary button */
}

.input-area.lumina-panel .send-button.lumina-button-primary .send-loading-icon {
  font-size: 22px;
  color: var(--current-bg);
}

.input-area.lumina-panel .send-button.lumina-button-primary.processing-active {
    animation: luminaSendButtonProcessing 1.8s infinite ease-in-out;
}

/* Input Actions Overlay (mic, char counter) */
.input-area.lumina-panel .input-actions-overlay {
  position: absolute;
  right: calc(var(--spacing-unit) * 1.25);
  bottom: calc(var(--spacing-unit) * 1);
  display: flex;
  align-items: center;
  gap: calc(var(--spacing-unit) * 0.75);
}

.input-area.lumina-panel .input-actions-overlay .overlay-btn {
  padding: calc(var(--spacing-unit) * 0.6);
  font-size: calc(var(--base-font-size) * 1.05);
  color: var(--current-text-secondary);
  opacity: 0.65;
  background-color: transparent;
  border-radius: var(--border-radius-slight);
}
.input-area.lumina-panel .input-actions-overlay .overlay-btn:hover {
  opacity: 1;
  color: var(--current-accent-light);
  background-color: rgba(var(--current-accent-light-rgb), 0.08);
}

.input-area.lumina-panel .input-actions-overlay .char-counter {
  font-size: 0.78em;
  color: var(--current-text-secondary);
  opacity: 0.55;
  margin-right: var(--spacing-unit);
}
.input-area.lumina-panel .input-actions-overlay .char-counter.warn {
  color: var(--current-accent-ink);
  opacity: 0.8;
}
.input-area.lumina-panel .input-actions-overlay .char-counter.error {
  color: var(--lumina-error-color);
  opacity: 1;
  font-weight: 500;
}

/* When input area is processing, visually indicate */
.input-area.lumina-panel.processing textarea#user-input {
  background-color: rgba(var(--current-panel-bg-rgb), 0.2); /* More subdued background */
  cursor: wait;
}

/* ==========================================================================
   [ END OF FILE layout/_chat_area.css ]
   ========================================================================== */
--- END: static/css/layout/_chat_area.css ---

--- START: static/css/layout/_file_preview.css ---
/* ==========================================================================
   [ START OF FILE layout/_file_preview.css ]
   文件预览区域样式
   ========================================================================== */

.file-preview.lumina-panel {
  position: absolute;
  bottom: calc(100% + var(--spacing-unit) * 1.25); /* Position above input area */
  left: 0;
  right: 0;
  max-height: 160px;
  display: none; /* Initially hidden */
  flex-direction: column;
  z-index: var(--z-index-file-preview);
  overflow: hidden;
  border-bottom-left-radius: 0; /* Align with input area */
  border-bottom-right-radius: 0;
  border-bottom-width: 0; /* No bottom border as it sits on top of input area */
}

.file-preview.lumina-panel.active {
  display: flex;
}

.file-preview.lumina-panel .file-preview-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: calc(var(--spacing-unit) * 1) calc(var(--spacing-unit) * 1.5);
  border-bottom: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  flex-shrink: 0;
}

.file-preview.lumina-panel .file-preview-header h3 {
  font-size: 0.95em;
  margin: 0;
  font-family: var(--font-family-title);
  color: var(--current-text-primary);
  font-weight: 500;
}

.file-preview.lumina-panel .file-preview-header h3 i {
  color: var(--current-accent-light);
  margin-right: var(--spacing-unit);
}

.file-preview.lumina-panel .file-preview-content {
  flex-grow: 1;
  overflow-y: auto;
  padding: calc(var(--spacing-unit) * 1.25);
  display: flex;
  flex-wrap: wrap;
  gap: calc(var(--spacing-unit) * 1);
}

.file-preview.lumina-panel .file-item {
  background-color: rgba(var(--current-bg-rgb), 0.5);
  border: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  border-radius: 18px; /* Chip-like */
  padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 1.2);
  display: inline-flex;
  align-items: center;
  font-size: 0.85em;
  color: var(--current-text-secondary);
  transition: all var(--transition-duration-light-pulse) ease;
}

.file-preview.lumina-panel .file-item:hover {
  border-color: var(--current-accent-light);
  color: var(--current-text-primary);
  box-shadow: 0 1px 4px rgba(var(--current-accent-light-rgb), 0.1);
}

.file-preview.lumina-panel .file-item .file-icon {
  color: var(--current-accent-light);
  margin-right: calc(var(--spacing-unit) * 0.75);
  font-size: 1.1em;
}

.file-preview.lumina-panel .file-item .file-name {
  max-width: 160px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.file-preview.lumina-panel .file-item .file-remove {
  font-size: 1em;
  color: var(--lumina-error-color);
  margin-left: calc(var(--spacing-unit) * 0.8);
  opacity: 0.7;
  padding: 2px; /* Increase clickable area */
}

.file-preview.lumina-panel .file-item .file-remove:hover,
.file-preview.lumina-panel .file-item .file-remove:focus {
  opacity: 1;
  background-color: rgba(var(--lumina-error-color-rgb), 0.1);
}
/* ==========================================================================
   [ END OF FILE layout/_file_preview.css ]
   ========================================================================== */
--- END: static/css/layout/_file_preview.css ---

--- START: static/css/layout/_header.css ---
/* ==========================================================================
   [ START OF FILE layout/_header.css ]
   头部区域样式
   ========================================================================== */

.header.lumina-panel {
  border-radius: 0 0 var(--border-radius-soft) var(--border-radius-soft);
  border-width: 0 0 var(--lumina-line-weight-thin) 0;
  border-bottom-color: var(--current-panel-border);
  padding: 0 calc(var(--spacing-unit) * 2.5);
  z-index: var(--z-index-header);
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
  height: var(--header-height);
  position: relative; /* For ::before pseudo-element */
}

.header.lumina-panel .logo {
  display: flex;
  align-items: center;
}

.header.lumina-panel .logo .logo-icon i {
  color: var(--current-accent-light);
  font-size: calc(var(--base-font-size) * 1.9);
  margin-right: calc(var(--spacing-unit) * 1.2);
  text-shadow: 0 0 8px var(--current-glow);
}

.header.lumina-panel .logo h1 {
  font-size: calc(var(--base-font-size) * 1.6);
  color: var(--current-text-primary);
  font-weight: 700;
  margin: 0;
  text-shadow: none;
}

.header.lumina-panel .logo h1 .version-pro {
  font-size: 0.65em;
  color: var(--current-accent-ink);
  margin-left: var(--spacing-unit);
  font-weight: 500;
}

.header.lumina-panel .logo h1 .version-pro .version-number {
  font-size: 0.9em;
  opacity: 0.85;
}

.header.lumina-panel .header-buttons {
  display: flex;
  gap: calc(var(--spacing-unit) * 0.75);
}

.header.lumina-panel .header-buttons .header-btn.icon-btn {
  width: calc(var(--header-height) * 0.6);
  height: calc(var(--header-height) * 0.6);
  font-size: calc(var(--base-font-size) * 1.15);
}

.header.lumina-panel .header-buttons .header-btn.icon-btn span {
  display: none; /* Hide text in header icon buttons */
}
/* ==========================================================================
   [ END OF FILE layout/_header.css ]
   ========================================================================== */
--- END: static/css/layout/_header.css ---

--- START: static/css/layout/_main_layout.css ---
/* ==========================================================================
   [ START OF FILE layout/_main_layout.css ]
   主要布局容器和结构样式
   ========================================================================== */

.main-container {
  opacity: 0;
  transform: translateY(15px);
  transition: opacity var(--transition-duration-ink-flow) var(--transition-timing-function-lumina),
              transform var(--transition-duration-ink-flow) var(--transition-timing-function-lumina);
  display: flex;
  flex-direction: column;
  height: 100vh;
  width: 100vw;
}

.main-container.loaded {
  opacity: 1;
  transform: translateY(0);
}

.app-body-container {
  display: flex;
  flex-grow: 1;
  overflow: hidden;
  position: relative;
  padding: var(--spacing-unit);
  gap: var(--spacing-unit);
}

/* 当日志侧边栏打开时，调整聊天区域的右边距 */
.app-body-container.with-process-log-open .chat-area {
  margin-right: calc(var(--process-log-sidebar-width) + var(--spacing-unit));
  transition: margin-right var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
}

/* 当日志侧边栏折叠时，调整聊天区域的右边距 */
.app-body-container.with-process-log-open.log-sidebar-collapsed .chat-area {
  margin-right: calc(var(--process-log-sidebar-width-collapsed) + var(--spacing-unit));
}

/* ==========================================================================
   [ END OF FILE layout/_main_layout.css ]
   ========================================================================== */
--- END: static/css/layout/_main_layout.css ---

--- START: static/css/layout/_process_log_sidebar.css ---
/* ==========================================================================
   [ START OF FILE layout/_process_log_sidebar.css ]
   右侧Agent执行轨迹侧边栏样式
   ========================================================================== */

.process-log-sidebar.lumina-panel {
  position: fixed;
  top: calc(var(--header-height) + var(--spacing-unit));
  right: var(--spacing-unit);
  /* bottom: calc(var(--input-area-height) + var(--spacing-unit) * 2); Dynamically set by JS or CSS calc potentially */
  /* The 'bottom' needs to react to input-area-height. This can be complex with pure CSS if input-area-height is dynamic.
     JS solution is in place (updateInputAreaHeightVar), ensure CSS can use it or has a fallback.
     For pure CSS, if input-area-height is set as a CSS var, we can use it.
  */
  bottom: calc(var(--input-area-height, 75px) + var(--spacing-unit) * 2); /* Fallback to 75px if var not set */
  width: var(--process-log-sidebar-width);
  z-index: var(--z-index-process-log);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  transform: translateX(calc(100% + var(--spacing-unit) * 2)); /* Initially off-screen */
  opacity: 0;
  transition: transform var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
              opacity var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
              width var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
}

.process-log-sidebar.lumina-panel.visible {
  transform: translateX(0);
  opacity: 1;
}

.process-log-sidebar.lumina-panel.collapsed {
  width: var(--process-log-sidebar-width-collapsed);
}

.process-log-sidebar.lumina-panel .process-log-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: calc(var(--spacing-unit) * 1.2) calc(var(--spacing-unit) * 1.5);
  border-bottom: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  flex-shrink: 0;
  font-family: var(--font-family-title);
  color: var(--current-text-primary);
  font-size: calc(var(--base-font-size) * 0.95);
}

.process-log-sidebar.lumina-panel .process-log-header span i {
  margin-right: calc(var(--spacing-unit) * 0.8);
  color: var(--current-accent-ink);
}

.process-log-sidebar.lumina-panel .process-log-header .icon-btn {
  font-size: calc(var(--base-font-size) * 1); /* Slightly smaller icons */
  width: calc(var(--base-font-size) * 2);
  height: calc(var(--base-font-size) * 2);
}

.process-log-sidebar.lumina-panel.collapsed .process-log-content,
.process-log-sidebar.lumina-panel.collapsed .process-log-header span {
  display: none;
}

.process-log-sidebar.lumina-panel.collapsed .process-log-header {
  justify-content: center;
}

/* Icon rotation for collapse toggle */
.process-log-sidebar.lumina-panel.collapsed #toggle-process-log-sidebar-collapse i.fa-chevron-left {
  transform: rotate(180deg);
}
.process-log-sidebar.lumina-panel.collapsed #toggle-process-log-sidebar-collapse i.fa-chevron-right {
  transform: rotate(0deg);
}
.process-log-sidebar.lumina-panel:not(.collapsed) #toggle-process-log-sidebar-collapse i.fa-chevron-left {
  transform: rotate(0deg);
}
.process-log-sidebar.lumina-panel:not(.collapsed) #toggle-process-log-sidebar-collapse i.fa-chevron-right {
  transform: rotate(180deg);
}


/* Process Log Content and Items */
.process-log-content {
  overflow-y: auto;
  padding: calc(var(--spacing-unit) * 1.5);
  display: flex;
  flex-direction: column;
  gap: calc(var(--spacing-unit) * 1.5); /* Space between log items */
  flex-grow: 1; /* Fill available space */
}

.process-log-content .log-item {
  display: flex;
  align-items: flex-start;
  gap: calc(var(--spacing-unit) * 1);
  padding: calc(var(--spacing-unit) * 0.8) calc(var(--spacing-unit) * 1);
  border-radius: var(--border-radius-slight);
  border: 1px solid transparent; /* For status highlighting */
  transition: all var(--transition-duration-light-pulse) ease;
  word-break: break-word;
  overflow-wrap: break-word;
}

.process-log-content .log-item > i.fas,
.process-log-content .log-item > i.far {
  flex-shrink: 0;
  font-size: calc(var(--base-font-size) * 1.1);
  margin-top: 2px;
  text-shadow: none;
  color: var(--current-text-secondary);
}

/* Status specific icon colors */
.process-log-content .log-item.status-started > i,
.process-log-content .log-item.status-running > i,
.process-log-content .log-item.status-retrying > i,
.process-log-content .log-item.status-llm_retry_needed > i,
.process-log-content .log-item.status-llm_error_retrying > i {
  color: var(--current-accent-ink);
}

.process-log-content .log-item.status-completed > i,
.process-log-content .log-item.status-succeeded > i,
.process-log-content .log-item.status-received > i,
.process-log-content .log-item.status-completed_and_validated > i {
  color: var(--lumina-success-color);
}

.process-log-content .log-item.status-failed > i,
.process-log-content .log-item.status-error > i,
.process-log-content .log-item.status-failed_after_llm_retries > i,
.process-log-content .log-item.status-tool_failure_detected > i,
.process-log-content .log-item.status-fatal_error_handler > i,
.process-log-content .log-item.status-fatal_error_capture > i,
.process-log-content .log-item.status-aborted_due_to_previous_failure > i {
  color: var(--lumina-error-color);
}

.process-log-content .log-item.status-ignored > i,
.process-log-content .log-item.status-muted > i {
  color: var(--current-text-secondary);
  opacity: 0.7;
}

.process-log-content .log-item.type-thinking_log > i {
  color: var(--current-accent-light);
}

.process-log-content .log-item-content-area {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  gap: calc(var(--spacing-unit) * 0.8);
}

.process-log-content .log-item-message {
  font-size: calc(var(--base-font-size) * 0.9);
  color: var(--current-text-primary);
  line-height: 1.4;
  opacity: 0.9;
}

.process-log-content .log-item-details,
.process-log-content .log-think-content {
  margin-top: calc(var(--spacing-unit) * 0.8);
  padding: calc(var(--spacing-unit) * 1);
  background-color: rgba(var(--current-panel-bg-rgb), 0.4);
  border: 1px dashed rgba(var(--current-panel-border-rgb), 0.6);
  border-radius: var(--border-radius-slight);
  font-size: 0.85em;
  color: var(--current-text-secondary);
  line-height: 1.5;
  word-break: break-all;
  overflow-wrap: break-word;
}

.process-log-content .log-item-details strong.log-detail-key,
.process-log-content .log-think-content strong {
  font-family: var(--font-family-title);
  font-weight: 500;
  color: var(--current-accent-ink);
  margin-right: calc(var(--spacing-unit) * 0.5);
}

.process-log-content .log-item-details span.log-detail-value {
  color: var(--current-text-primary);
  opacity: 0.9;
}
.process-log-content .log-item-details .log-detail-object-header {
    margin-top: calc(var(--spacing-unit) * 0.5);
    margin-bottom: calc(var(--spacing-unit) * 0.5);
}

.process-log-content .log-item-details pre.log-detail-raw-json,
.process-log-content .log-think-content pre code { /* Combined for thinking log embedded JSON */
    background-color: rgba(var(--current-bg-rgb), 0.3);
    padding: calc(var(--spacing-unit) * 0.8);
    border-radius: var(--border-radius-slight);
    margin-top: calc(var(--spacing-unit) * 0.8);
    font-family: var(--font-family-code);
    font-size: 0.9em;
    color: var(--current-text-secondary);
    border: 1px solid rgba(var(--current-panel-border-rgb), 0.3);
    white-space: pre-wrap;
    word-break: break-all;
    overflow-x: auto;
}

.process-log-content .log-item-details pre.log-detail-raw-json.error,
.process-log-content .log-think-content pre code.error {
    color: var(--lumina-error-color);
    border-color: var(--lumina-error-color);
}

.process-log-content .log-item-details em.log-arg-key {
    font-style: normal;
    font-weight: 500;
    color: var(--current-accent-light);
}


/* ==========================================================================
   [ END OF FILE layout/_process_log_sidebar.css ]
   ========================================================================== */
--- END: static/css/layout/_process_log_sidebar.css ---

--- START: static/css/layout/_sidebar.css ---
/* ==========================================================================
   [ START OF FILE layout/_sidebar.css ]
   左侧边栏样式
   ========================================================================== */

.sidebar.lumina-panel.left-sidebar {
  border-radius: var(--border-radius-soft);
  width: 280px;
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
  padding: calc(var(--spacing-unit) * 2) calc(var(--spacing-unit) * 1.5);
  transition: width var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
              padding var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
  overflow: hidden;
  z-index: var(--z-index-sidebar);
  position: relative; /* For fixed bottom button */
  padding-bottom: calc(var(--spacing-unit) * 8); /* Space for fixed bottom button */
}

.sidebar.lumina-panel.left-sidebar:not(.expanded) {
  width: calc(var(--header-height) - var(--spacing-unit));
  padding: calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 0.75);
}

.sidebar.lumina-panel.left-sidebar:not(.expanded) .sidebar-button span,
.sidebar.lumina-panel.left-sidebar:not(.expanded) .session-manager-header span,
.sidebar.lumina-panel.left-sidebar:not(.expanded) #create-new-session span,
.sidebar.lumina-panel.left-sidebar:not(.expanded) .session-list {
  display: none;
}

.sidebar.lumina-panel.left-sidebar:not(.expanded) .sidebar-button i {
  margin-right: 0;
}

.sidebar-toggle-btn {
  margin-bottom: calc(var(--spacing-unit) * 2);
  align-self: flex-start;
}

.sidebar.left-sidebar:not(.expanded) .sidebar-toggle-btn {
  align-self: center;
}

.sidebar.lumina-panel.left-sidebar .sidebar-content-wrapper {
  display: flex;
  flex-direction: column;
  gap: calc(var(--spacing-unit) * 2.5);
  flex-grow: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: calc(var(--spacing-unit) * 0.5); /* For custom scrollbar */
  margin-right: calc(var(--spacing-unit) * -0.5); /* Offset padding */
}

.sidebar.lumina-panel.left-sidebar .sidebar-main-actions {
  display: flex;
  flex-direction: column;
  gap: calc(var(--spacing-unit) * 0.75);
}

.sidebar.lumina-panel.left-sidebar .session-manager .session-manager-header {
  color: var(--current-text-primary);
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: calc(var(--spacing-unit) * 1.2) 0;
  cursor: pointer;
  font-family: var(--font-family-title);
  font-size: calc(var(--base-font-size) * 1.05);
  border-bottom: var(--lumina-line-weight-thin) solid var(--current-panel-border);
  margin-bottom: var(--spacing-unit);
  transition: color var(--transition-duration-light-pulse) ease;
}

.sidebar.lumina-panel.left-sidebar .session-manager .session-manager-header:hover {
  color: var(--current-accent-light);
}

.sidebar.lumina-panel.left-sidebar .session-manager .session-manager-header span i {
  margin-right: var(--spacing-unit);
  color: var(--current-accent-ink);
}

.sidebar.lumina-panel.left-sidebar .session-manager .session-manager-header .toggle-icon {
  transition: transform var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
  color: var(--current-text-secondary);
}

.sidebar.lumina-panel.left-sidebar .session-manager.collapsed .session-manager-header .toggle-icon.fa-caret-down {
  transform: rotate(-90deg);
}
.sidebar.lumina-panel.left-sidebar .session-manager:not(.collapsed) .session-manager-header .toggle-icon.fa-caret-right {
  transform: rotate(0deg); /* Ensure it resets if class was added then removed */
}


.sidebar.lumina-panel.left-sidebar .session-list-container {
  max-height: 280px;
  overflow-y: auto;
  transition: max-height var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
              padding var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina),
              opacity var(--transition-duration-ink-subtle) var(--transition-timing-function-lumina);
  padding-bottom: var(--spacing-unit);
}

.sidebar.lumina-panel.left-sidebar .session-manager.collapsed .session-list-container {
  max-height: 0;
  padding-bottom: 0;
  opacity: 0;
}

.sidebar.lumina-panel.left-sidebar .session-list {
  list-style: none;
  padding: 0;
}

.sidebar.lumina-panel.left-sidebar .session-list-item {
  color: var(--current-text-secondary);
  padding: calc(var(--spacing-unit) * 1) calc(var(--spacing-unit) * 1.2);
  border-radius: var(--border-radius-slight);
  margin-bottom: calc(var(--spacing-unit) * 0.6);
  cursor: pointer;
  transition: background-color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
              color var(--transition-duration-light-pulse) var(--transition-timing-function-lumina),
              box-shadow var(--transition-duration-light-pulse) var(--transition-timing-function-lumina);
  font-size: calc(var(--base-font-size) * 0.88);
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative;
}

.sidebar.lumina-panel.left-sidebar .session-list-item::before {
  content: '';
  position: absolute;
  left: 0;
  top: 15%;
  bottom: 15%;
  width: 3px;
  background-color: var(--current-accent-ink);
  border-radius: 0 2px 2px 0;
  opacity: 0;
  transform: scaleX(0);
  transform-origin: left;
  transition: opacity var(--transition-duration-light-pulse) ease, transform var(--transition-duration-light-pulse) ease;
}

.sidebar.lumina-panel.left-sidebar .session-list-item:hover {
  background-color: rgba(var(--current-panel-bg-rgb), 0.6);
  color: var(--current-text-primary);
  box-shadow: 0 2px 8px rgba(var(--current-text-primary-rgb), 0.05);
}

.sidebar.lumina-panel.left-sidebar .session-list-item:hover::before {
  opacity: 0.7;
  transform: scaleX(1);
}

.sidebar.lumina-panel.left-sidebar .session-list-item.active-session {
  background-color: rgba(var(--current-accent-light-rgb), 0.1);
  color: var(--current-text-primary);
  font-weight: 500;
}

.sidebar.lumina-panel.left-sidebar .session-list-item.active-session::before {
  background-color: var(--current-accent-light);
  opacity: 1;
  transform: scaleX(1);
  box-shadow: 0 0 5px var(--current-glow);
}

.sidebar.lumina-panel.left-sidebar .session-list-item .session-item-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  overflow: hidden;
  margin-right: var(--spacing-unit);
}

.sidebar.lumina-panel.left-sidebar .session-list-item .session-name {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-weight: 500;
}

.sidebar.lumina-panel.left-sidebar .session-list-item .session-time {
  font-size: 0.82em;
  opacity: 0.75;
}

.sidebar.lumina-panel.left-sidebar .session-list-item .session-delete-btn {
  color: var(--lumina-error-color);
  opacity: 0.6;
  width: auto; height: auto;
  font-size: calc(var(--base-font-size) * 0.95);
  padding: calc(var(--spacing-unit) * 0.5);
}

.sidebar.lumina-panel.left-sidebar .session-list-item .session-delete-btn:hover,
.sidebar.lumina-panel.left-sidebar .session-list-item .session-delete-btn:focus {
  opacity: 1;
  background-color: rgba(var(--lumina-error-color-rgb), 0.1);
  color: var(--lumina-error-color);
}

.sidebar.lumina-panel.left-sidebar .session-list-item.session-list-empty {
  text-align: center;
  opacity: 0.6;
  cursor: default;
  font-style: italic;
}
.sidebar.lumina-panel.left-sidebar .session-list-item.session-list-empty i {
  margin-right: var(--spacing-unit);
}
.sidebar.lumina-panel.left-sidebar .session-list-item.session-list-empty:hover {
  background-color: transparent;
}
.sidebar.lumina-panel.left-sidebar .session-list-item.session-list-empty::before {
  display: none;
}

#create-new-session.lumina-button-primary.lumina-button-fixed-bottom {
  position: absolute;
  bottom: calc(var(--spacing-unit) * 2);
  left: calc(var(--spacing-unit) * 1.5);
  right: calc(var(--spacing-unit) * 1.5);
  width: auto; /* Let flexbox or parent width dictate */
  max-width: calc(100% - var(--spacing-unit) * 3); /* ensure it fits */
  z-index: 10;
  box-shadow: 0 3px 10px rgba(var(--current-accent-ink-rgb), 0.25),
              0 0 8px rgba(var(--current-accent-ink-rgb), 0.15);
  padding-top: calc(var(--spacing-unit) * 1.25);
  padding-bottom: calc(var(--spacing-unit) * 1.25);
  margin-top: 0; /* override any default */
}

/* Light Theme: Create Session Button */
body[data-theme="light-crystal"] #create-new-session.lumina-button-primary.lumina-button-fixed-bottom,
body[data-theme="auto-crystal"].light-crystal-active #create-new-session.lumina-button-primary.lumina-button-fixed-bottom {
  background-color: var(--current-accent-ink);
  color: var(--lumina-bg-light);
  border-color: var(--current-accent-ink);
}

/* Dark Theme: Create Session Button */
body[data-theme="dark-crystal"] #create-new-session.lumina-button-primary.lumina-button-fixed-bottom,
body[data-theme="auto-crystal"].dark-crystal-active #create-new-session.lumina-button-primary.lumina-button-fixed-bottom {
  background-color: var(--current-accent-ink);
  color: var(--lumina-bg-dark);
  border-color: var(--current-accent-ink);
}


#create-new-session.lumina-button-primary.lumina-button-fixed-bottom:hover,
#create-new-session.lumina-button-primary.lumina-button-fixed-bottom:focus {
  filter: brightness(1.1);
  transform: translateY(-1px) scale(1.02);
  box-shadow: 0 4px 12px rgba(var(--current-accent-ink-rgb), 0.35),
              0 0 15px rgba(var(--current-accent-ink-rgb), 0.25);
}

.sidebar.lumina-panel.left-sidebar:not(.expanded) #create-new-session.lumina-button-fixed-bottom {
  width: calc(100% - var(--spacing-unit) * 1.5);
  left: calc(var(--spacing-unit) * 0.75);
  right: calc(var(--spacing-unit) * 0.75);
  bottom: calc(var(--spacing-unit) * 1.5);
  padding: calc(var(--spacing-unit) * 1);
}

.sidebar.lumina-panel.left-sidebar:not(.expanded) #create-new-session.lumina-button-fixed-bottom span {
  display: none;
}
.sidebar.lumina-panel.left-sidebar:not(.expanded) #create-new-session.lumina-button-fixed-bottom i {
  margin-right: 0;
}
/* ==========================================================================
   [ END OF FILE layout/_sidebar.css ]
   ========================================================================== */
--- END: static/css/layout/_sidebar.css ---

--- START: static/js/app.js ---
// ==========================================================================
// [ START OF FILE app.js ]
// Main Application Entry Point - Initializes and coordinates all modules.
// ==========================================================================

import dom from './utils/dom_elements.js';
import state, { loadPersistentSettings, savePersistentSettings } from './core/state.js'; 
import { connectWebSocket } from './core/websocket_manager.js';
import { setupEventListeners } from './core/event_listener_setup.js';
import { adjustTextareaHeight, updateCharCounter } from './core/ui_updater.js'; 
import { applyCurrentTheme, applyFontSize, applyAnimationLevel } from './modules/theme_handler.js';
import { initializeCurrentSessionUI } from './modules/session_handler.js';
// 导入 settings_handler.js 中的 openSettingsModal, populateLLMModelSelect, updateChineseDeepThinkingToggleState
import { openSettingsModal, populateLLMModelSelect, updateChineseDeepThinkingToggleState } from './modules/settings_handler.js'; 
import { updateSidebarState, updateSessionManagerState, applyFixedLogSidebarLayout, updateProcessLogSidebarCollapseState, showProcessLogSidebar, hideProcessLogSidebar, updateInputAreaHeightVar } from './modules/layout_handler.js';
import { toggleThreeBlackHoleVisibility } from './modules/three_visuals.js';
import { attachQuickActionButtonListeners } from './modules/quick_actions_handler.js';
import { APP_PREFIX } from './utils/helpers.js';


document.addEventListener('DOMContentLoaded', () => {
    initializeApp();
});

function initializeApp() {
    console.log("CircuitManus Pro - 光绘墨迹终端 (V1.1.0 Lumina Multi-LLM) 初始化..."); // 版本更新

    loadPersistentSettings(); // 加载持久化设置到 state 对象

    applyCurrentTheme(); 
    applyFontSize(localStorage.getItem(APP_PREFIX + 'fontSize') || '16'); 
    applyAnimationLevel(state.animationLevel); 

    setupEventListeners(); 

    adjustTextareaHeight();
    updateCharCounter();
    updateInputAreaHeightVar();

    updateSidebarState(state.isSidebarExpanded, true); 
    updateSessionManagerState(state.isSessionManagerCollapsed, true); 

    applyFixedLogSidebarLayout();
    updateProcessLogSidebarCollapseState(state.isProcessLogSidebarCollapsed, true);
    if (state.isProcessLogSidebarVisible) {
        showProcessLogSidebar(false); 
    } else {
        hideProcessLogSidebar();
    }

    toggleThreeBlackHoleVisibility(state.isIdtComponentVisible);
    dom.idtComponentToggleBtn.setAttribute('title', state.isIdtComponentVisible ? '停用核心投影' : '激活核心投影');
    const idtIcon = dom.idtComponentToggleBtn.querySelector('i');
    if (idtIcon) idtIcon.className = state.isIdtComponentVisible ? 'fas fa-eye-slash' : 'fas fa-atom';

    // 重要：在连接WebSocket之前，确保与设置相关的UI（尤其是依赖后端数据的）已准备好被填充
    // populateLLMModelSelect 和 updateChineseDeepThinkingToggleState 会在 WebSocket 的 init_success 中被调用，
    // 因为它们依赖于从后端获取的 agentDefaultSettings。
    // 所以此处不需要显式调用它们。

    initializeCurrentSessionUI(true); 

    connectWebSocket(); 


    console.log("光绘墨迹终端 系统就绪. 等待数据流.");

    setTimeout(() => {
        if (dom.loader && !dom.loader.classList.contains('loader-fatal-error')) {
            dom.loader.classList.add('hidden');
        }
        if (dom.mainContainer) {
            dom.mainContainer.classList.add('loaded');
        }
    }, 500); 
}
// ==========================================================================
// [ END OF FILE app.js ]
// ==========================================================================

--- END: static/js/app.js ---

--- START: static/js/core/event_listener_setup.js ---
// ==========================================================================
// [ START OF FILE core/event_listener_setup.js ]
// Setup for all primary DOM event listeners.
// ==========================================================================

import dom from '../utils/dom_elements.js';
import state from './state.js';
import { sendWebSocketMessage } from './websocket_manager.js';
import { adjustTextareaHeight, updateCharCounter, showToast, setLoadingState, appendWelcomeMessage, appendMessage } from './ui_updater.js';
import { applyTheme, applyAnimationLevel, applyFontSize } from '../modules/theme_handler.js';
import { openSettingsModal, closeSettingsModal, collectAndSaveSettings, resetToDefaultSettings } from '../modules/settings_handler.js';
// 修正：从 session_handler.js 导入会话管理函数
import { createNewSession, handleEditSessionName, saveSessions, renderSessionList, addMessageToCurrentSession } from '../modules/session_handler.js';
import { updateSidebarState, updateSessionManagerState, updateInputAreaHeightVar, applyFixedLogSidebarLayout, toggleProcessLogSidebarCollapse, hideProcessLogSidebar, showProcessLogSidebar } from '../modules/layout_handler.js';
import { handleFileSelection, closeFilePreview } from '../modules/file_handler.js';
import { toggleThreeBlackHoleVisibility, handleComponentMouseDown } from '../modules/three_visuals.js';
import { handleChatBoxMouseOver, handleChatBoxMouseOut } from '../modules/copy_handler.js';
// APP_PREFIX 现在从 helpers.js 导入
import { generateClientRequestId, getThemeDisplayName, getModeDisplayName, APP_PREFIX } from '../utils/helpers.js';


export function setupEventListeners() {
    dom.sendButton.addEventListener('click', handleSendMessage);
    dom.userInput.addEventListener('keypress', handleUserInputKeypress);
    dom.userInput.addEventListener('input', () => {
        adjustTextareaHeight();
        updateCharCounter();
        updateInputAreaHeightVar();
    });

    dom.themeToggleButton.addEventListener('click', () => {
        const themes = ['auto-crystal', 'light-crystal', 'dark-crystal'];
        const currentIndex = themes.indexOf(state.currentTheme);
        const nextTheme = themes[(currentIndex + 1) % themes.length];
        applyTheme(nextTheme);
        showToast(`显示模式已切换至: ${getThemeDisplayName(state.currentTheme)}`, 'info');
    });

    dom.clearChatButton.addEventListener('click', handleClearCurrentChat);
    if (dom.leftSidebarToggle) {
        dom.leftSidebarToggle.addEventListener('click', () => updateSidebarState(!state.isSidebarExpanded));
    }
    dom.toggleProcessLogVisibilityButton.addEventListener('click', () => {
        if (state.isProcessLogSidebarVisible) hideProcessLogSidebar();
        else showProcessLogSidebar(false);
    });

    dom.sidebarButtons.forEach(button => {
        button.addEventListener('click', () => {
            const mode = button.dataset.mode;
            if (mode === 'settings') openSettingsModal();
            else handleModeChange(mode);
        });
    });

    dom.sessionManagerToggle.addEventListener('click', () => updateSessionManagerState(!state.isSessionManagerCollapsed));
    dom.createNewSessionButton.addEventListener('click', () => createNewSession());
    dom.editSessionNameButton.addEventListener('click', handleEditSessionName);

    dom.attachButton.addEventListener('click', () => dom.fileInput.click());
    dom.fileInput.addEventListener('change', handleFileSelection);
    dom.closeFilePreviewButton.addEventListener('click', closeFilePreview);
    dom.micButton.addEventListener('click', () => showToast('语音墨迹: 校准中...', 'info'));

    if (dom.closeSettingsButton) dom.closeSettingsButton.addEventListener('click', () => closeSettingsModal(true));
    if (dom.saveSettingsButton) dom.saveSettingsButton.addEventListener('click', () => {
        collectAndSaveSettings();
        closeSettingsModal(false);
        showToast('系统参数已同步!', 'success');
    });
    if (dom.resetSettingsButton) dom.resetSettingsButton.addEventListener('click', resetToDefaultSettings);

    if (dom.fontSizeInput) {
        dom.fontSizeInput.addEventListener('input', () => {
            const newSize = dom.fontSizeInput.value;
            if (dom.fontSizeValue) dom.fontSizeValue.textContent = `${newSize}px`;
            applyFontSize(newSize);
        });
    }
    if (dom.animationLevelSelect) dom.animationLevelSelect.addEventListener('change', (e) => applyAnimationLevel(e.target.value));
    if (dom.autoScrollToggle) dom.autoScrollToggle.addEventListener('change', (e) => { state.autoScroll = e.target.checked; });
    if (dom.soundEnabledToggle) dom.soundEnabledToggle.addEventListener('change', (e) => { state.soundEnabled = e.target.checked; });
    if (dom.showChatBubblesThinkToggle) dom.showChatBubblesThinkToggle.addEventListener('change', (e) => { state.showChatBubblesThink = e.target.checked; });
    if (dom.showLogBubblesThinkToggle) dom.showLogBubblesThinkToggle.addEventListener('change', (e) => { state.showLogBubblesThink = e.target.checked; });
    if (dom.autoSubmitQuickActionsToggle) dom.autoSubmitQuickActionsToggle.addEventListener('change', (e) => { state.autoSubmitQuickActions = e.target.checked; });

    if (dom.componentVisibilityToggle) dom.componentVisibilityToggle.addEventListener('change', (e) => {
        state.isIdtComponentVisible = e.target.checked;
        toggleThreeBlackHoleVisibility(state.isIdtComponentVisible);
        dom.idtComponentToggleBtn.setAttribute('title', state.isIdtComponentVisible ? '停用核心投影' : '激活核心投影');
        const idtIcon = dom.idtComponentToggleBtn.querySelector('i');
        if (idtIcon) idtIcon.className = state.isIdtComponentVisible ? 'fas fa-eye-slash' : 'fas fa-atom';
        // Persist this specific setting
        localStorage.setItem(APP_PREFIX + 'isIdtComponentVisible', state.isIdtComponentVisible.toString());
    });

    if (dom.settingsModal) dom.settingsModal.addEventListener('click', (e) => {
        if (e.target === dom.settingsModal) closeSettingsModal(true);
    });

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        if (state.currentTheme === 'auto-crystal') applyTheme(state.currentTheme, true);
    });

    if (dom.toggleProcessLogSidebarCollapseButton) dom.toggleProcessLogSidebarCollapseButton.addEventListener('click', () => toggleProcessLogSidebarCollapse());
    if (dom.closeProcessLogSidebarButton) dom.closeProcessLogSidebarButton.addEventListener('click', () => hideProcessLogSidebar());

    if (dom.idtComponentToggleBtn && dom.idtComponentWrapper) {
        dom.idtComponentToggleBtn.addEventListener('click', () => {
            state.isIdtComponentVisible = !dom.idtComponentWrapper.classList.contains('is-visible');
            toggleThreeBlackHoleVisibility(state.isIdtComponentVisible);
            dom.idtComponentToggleBtn.setAttribute('title', state.isIdtComponentVisible ? '停用核心投影' : '激活核心投影');
            const idtIcon = dom.idtComponentToggleBtn.querySelector('i');
            if (idtIcon) idtIcon.className = state.isIdtComponentVisible ? 'fas fa-eye-slash' : 'fas fa-atom';
            if (dom.componentVisibilityToggle) dom.componentVisibilityToggle.checked = state.isIdtComponentVisible;
            localStorage.setItem(APP_PREFIX + 'isIdtComponentVisible', state.isIdtComponentVisible.toString());
        });
    }
    if (dom.idtComponentWrapper) {
        dom.idtComponentWrapper.addEventListener('mousedown', handleComponentMouseDown);
    }

    window.addEventListener('resize', () => {
        updateInputAreaHeightVar();
        applyFixedLogSidebarLayout();
        if (state.threeJsInitialized && state.threeJsCamera && state.threeJsRenderer && dom.idtComponentWrapper) {
            const Rcontainer = dom.idtComponentWrapper;
            state.threeJsCamera.aspect = Rcontainer.clientWidth / Rcontainer.clientHeight;
            state.threeJsCamera.updateProjectionMatrix();
            state.threeJsRenderer.setSize(Rcontainer.clientWidth, Rcontainer.clientHeight);
        }
    });

    dom.chatBox.addEventListener('mouseover', handleChatBoxMouseOver);
    dom.chatBox.addEventListener('mouseout', handleChatBoxMouseOut);
}

// Moved from script.js main body, now part of event_listener_setup.js's scope
function handleSendMessage() {
    if (state.isLoading) {
        showToast("Lumina核心正在处理上一指令. 请稍候...", "warning");
        return;
    }
    const messageText = dom.userInput.value.trim();
    const filesToSend = [...state.uploadedFiles];

    if (messageText === '' && filesToSend.length === 0) {
        showToast("需要指令. 请输入指令或附加数据模块.", "warning");
        return;
    }
    if (dom.userInput.value.length > state.maxInputChars) {
        showToast(`指令缓冲区溢出. 最大 ${state.maxInputChars} 字符.`, "error");
        return;
    }

    setLoadingState(true);
    state.currentClientRequestId = generateClientRequestId();
    state.lastResponseThinking = null;

    const currentUserMessage = {
        content: messageText,
        sender: 'user',
        timestamp: Date.now(),
        isHTML: false,
        attachments: filesToSend.map(f => ({ name: f.name, size: f.size, type: f.type }))
    };
    addMessageToCurrentSession(currentUserMessage);
    appendMessage(messageText, 'user', false, null, false, currentUserMessage.attachments);

    const currentSession = state.sessions[state.currentSessionId];
    if (currentSession && currentSession.name.startsWith("光绘墨迹项目 ") && currentSession.messages.filter(m => m.sender === 'user').length === 1) {
        const autoName = messageText.substring(0, 40).trim() || "新墨迹";
        currentSession.name = autoName + (messageText.length > 40 ? "..." : "");
        dom.currentSessionNameDisplay.textContent = currentSession.name;
        renderSessionList();
    }

    dom.userInput.value = '';
    adjustTextareaHeight();
    updateCharCounter();
    closeFilePreview();
    state.uploadedFiles = [];

    if (dom.processLogSidebarContent) dom.processLogSidebarContent.innerHTML = '';
    showProcessLogSidebar(true);

    let backendMessageContent = messageText;
    if (filesToSend.length > 0) {
        backendMessageContent += `\n[用户已附加数据模块: ${filesToSend.map(f => f.name).join(', ')}. 请基于这些模块名称处理指令.]`;
    }

    sendWebSocketMessage({
        type: 'message',
        session_id: state.currentSessionId,
        request_id: state.currentClientRequestId,
        content: backendMessageContent,
        mode: state.currentMode
    });
}

function handleUserInputKeypress(event) {
    if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        handleSendMessage();
    }
}

function handleClearCurrentChat() {
    if (!state.currentSessionId || !state.sessions[state.currentSessionId]) return;
    if (!confirm(`清空当前光绘墨迹项目 "${state.sessions[state.currentSessionId].name}"? 这将清除所有消息记录.`)) {
        return;
    }
    state.sessions[state.currentSessionId].messages = [];
    state.sessions[state.currentSessionId].lastActivity = Date.now();
    saveSessions(); // saveSessions from session_handler
    dom.chatBox.innerHTML = '';
    appendWelcomeMessage(); // appendWelcomeMessage from ui_updater
    if (dom.processLogSidebarContent) dom.processLogSidebarContent.innerHTML = '';
    if (state.isProcessLogSidebarVisible) {
        showProcessLogSidebar(false);
    } else {
        hideProcessLogSidebar();
    }
    showToast('当前光绘墨迹项目已清空!', 'info');
    renderSessionList(); // renderSessionList from session_handler
}

function handleModeChange(newMode) {
    if (state.currentMode === newMode) return;

    dom.sidebarButtons.forEach(button =>
        button.classList.toggle('active', button.dataset.mode === newMode)
    );
    state.currentMode = newMode;
    console.log(`模式已切换至: ${newMode}`);
    showToast(`已切换至 ${getModeDisplayName(newMode)} 领域`, 'info');
    const sessionNameForPlaceholder = state.sessions[state.currentSessionId]?.name || '当前项目';
    dom.userInput.placeholder = `向Lumina核心发送指令 (${getModeDisplayName(state.currentMode)}模式，当前项目: ${sessionNameForPlaceholder})...`;
}
// ==========================================================================
// [ END OF FILE core/event_listener_setup.js ]
// ==========================================================================
--- END: static/js/core/event_listener_setup.js ---

--- START: static/js/core/state.js ---
// ==========================================================================
// [ START OF FILE core/state.js ]
// Application State Management and Persistence
// ==========================================================================

import { APP_PREFIX } from '../utils/helpers.js'; 

let state = {
    sessions: {}, 
    currentSessionId: null,
    currentTheme: 'auto-crystal', 
    autoScroll: true, 
    soundEnabled: false, 
    showChatBubblesThink: true, 
    showLogBubblesThink: true, 
    animationLevel: 'full', 
    currentMode: 'chat', 
    uploadedFiles: [], 
    isAgentTyping: false, 
    isLoading: false, 
    isSidebarExpanded: window.innerWidth > 1024, 
    isSessionManagerCollapsed: false, 
    isProcessLogSidebarVisible: false, 
    isProcessLogSidebarCollapsed: true, 
    maxInputChars: 8000,
    currentClientRequestId: null, 
    lastResponseThinking: null, 
    autoSubmitQuickActions: true, 
    isIdtComponentVisible: true, 
    isDraggingComponent: false,
    componentDragStartX: 0,
    componentDragStartY: 0,
    componentInitialTopPx: 0,
    componentInitialLeftPx: 0,
    threeJsScene: null, 
    threeJsRenderer: null, 
    threeJsCamera: null, 
    threeJsAnimationId: null, 
    threeJsInitialized: false, 
    threeBlackHoleGroup: null, 
    threeAccretionDiskOuter: null, 
    threeAccretionDiskMiddle: null, 
    threeAccretionDiskInner: null, 
    threeStarField: null, 
    pendingToolCalls: {}, 

    selectedLLM: 'zhipu-ai', 
    enableChineseDeepThinking: false, 
    
    agentDefaultSettings: {
        default_llm_identifier: 'zhipu-ai', 
        default_enable_chinese_thinking: false, 
        globally_enable_chinese_thinking: true, 
        // 【修改】键名改为 detailed_available_llms，并期望其值为对象数组
        detailed_available_llms: [ 
            // { id: "zhipu-ai", name: "智谱清言 (GLM)", available: true }, // 示例结构
            // { id: "deepseek", name: "DeepSeek 大模型", available: false }
        ]
    }
};

export function savePersistentSettings() {
    try {
        localStorage.setItem(APP_PREFIX + 'theme', state.currentTheme);
        const effectiveFontSize = document.documentElement.style.getPropertyValue('--base-font-size').replace('px', '');
        localStorage.setItem(APP_PREFIX + 'fontSize', effectiveFontSize || '16');
        localStorage.setItem(APP_PREFIX + 'animationLevel', state.animationLevel);
        localStorage.setItem(APP_PREFIX + 'autoScroll', state.autoScroll.toString());
        localStorage.setItem(APP_PREFIX + 'soundEnabled', state.soundEnabled.toString());
        localStorage.setItem(APP_PREFIX + 'showChatBubblesThink', state.showChatBubblesThink.toString());
        localStorage.setItem(APP_PREFIX + 'showLogBubblesThink', state.showLogBubblesThink.toString());
        localStorage.setItem(APP_PREFIX + 'sidebarExpanded', state.isSidebarExpanded.toString());
        localStorage.setItem(APP_PREFIX + 'sessionManagerCollapsed', state.isSessionManagerCollapsed.toString());
        localStorage.setItem(APP_PREFIX + 'isProcessLogSidebarVisible', state.isProcessLogSidebarVisible.toString());
        localStorage.setItem(APP_PREFIX + 'isProcessLogSidebarCollapsed', state.isProcessLogSidebarCollapsed.toString());
        localStorage.setItem(APP_PREFIX + 'autoSubmitQuickActions', state.autoSubmitQuickActions.toString());
        localStorage.setItem(APP_PREFIX + 'currentMode', state.currentMode);
        localStorage.setItem(APP_PREFIX + 'isIdtComponentVisible', state.isIdtComponentVisible.toString());
        localStorage.setItem(APP_PREFIX + 'idtComponentTopPercent', document.documentElement.style.getPropertyValue('--idt-offset-top-percentage'));
        localStorage.setItem(APP_PREFIX + 'idtComponentLeftPercent', document.documentElement.style.getPropertyValue('--idt-offset-left-percentage'));
        localStorage.setItem(APP_PREFIX + 'selectedLLM', state.selectedLLM);
        localStorage.setItem(APP_PREFIX + 'enableChineseDeepThinking', state.enableChineseDeepThinking.toString());

        console.log("系统参数数据已保存到归档 (localStorage).");
    } catch (e) {
        console.error("保存设置到localStorage失败:", e);
    }
}

export function loadPersistentSettings() {
    state.currentTheme = localStorage.getItem(APP_PREFIX + 'theme') || state.currentTheme;
    state.animationLevel = localStorage.getItem(APP_PREFIX + 'animationLevel') || state.animationLevel;
    state.autoScroll = (localStorage.getItem(APP_PREFIX + 'autoScroll') || state.autoScroll.toString()) === 'true';
    state.soundEnabled = (localStorage.getItem(APP_PREFIX + 'soundEnabled') || state.soundEnabled.toString()) === 'true';
    state.showChatBubblesThink = (localStorage.getItem(APP_PREFIX + 'showChatBubblesThink') || state.showChatBubblesThink.toString()) === 'true';
    state.showLogBubblesThink = (localStorage.getItem(APP_PREFIX + 'showLogBubblesThink') || state.showLogBubblesThink.toString()) === 'true';
    state.isSidebarExpanded = (localStorage.getItem(APP_PREFIX + 'sidebarExpanded') || state.isSidebarExpanded.toString()) === 'true';
    state.isSessionManagerCollapsed = (localStorage.getItem(APP_PREFIX + 'sessionManagerCollapsed') || state.isSessionManagerCollapsed.toString()) === 'true';
    state.isProcessLogSidebarVisible = (localStorage.getItem(APP_PREFIX + 'isProcessLogSidebarVisible') || state.isProcessLogSidebarVisible.toString()) === 'true';
    state.isProcessLogSidebarCollapsed = (localStorage.getItem(APP_PREFIX + 'isProcessLogSidebarCollapsed') || state.isProcessLogSidebarCollapsed.toString()) === 'true';
    state.autoSubmitQuickActions = (localStorage.getItem(APP_PREFIX + 'autoSubmitQuickActions') || state.autoSubmitQuickActions.toString()) === 'true';
    state.currentMode = localStorage.getItem(APP_PREFIX + 'currentMode') || state.currentMode;
    state.isIdtComponentVisible = (localStorage.getItem(APP_PREFIX + 'isIdtComponentVisible') || state.isIdtComponentVisible.toString()) === 'true';

    const savedTopPercent = localStorage.getItem(APP_PREFIX + 'idtComponentTopPercent');
    const savedLeftPercent = localStorage.getItem(APP_PREFIX + 'idtComponentLeftPercent');
    if (savedTopPercent !== null) document.documentElement.style.setProperty('--idt-offset-top-percentage', savedTopPercent);
    if (savedLeftPercent !== null) document.documentElement.style.setProperty('--idt-offset-left-percentage', savedLeftPercent);
    
    const savedFontSize = localStorage.getItem(APP_PREFIX + 'fontSize') || '16'; 
    document.documentElement.style.setProperty('--base-font-size', `${savedFontSize}px`);

    // 加载 selectedLLM 和 enableChineseDeepThinking 时，使用 agentDefaultSettings 中的默认值作为后备
    // 注意：agentDefaultSettings 此刻可能还未被后端数据填充，所以这里的 || state.agentDefaultSettings... 仍然会是JS层面最初始的定义
    // 真正的后端默认值会在 init_success 消息处理时覆盖这些。
    state.selectedLLM = localStorage.getItem(APP_PREFIX + 'selectedLLM') || state.agentDefaultSettings.default_llm_identifier; 
    state.enableChineseDeepThinking = (localStorage.getItem(APP_PREFIX + 'enableChineseDeepThinking') || state.agentDefaultSettings.default_enable_chinese_thinking.toString()) === 'true';

    console.log("从localStorage加载了用户偏好设置到应用状态。");
}

export default state;
// ==========================================================================
// [ END OF FILE core/state.js ]
// ==========================================================================

--- END: static/js/core/state.js ---

--- START: static/js/core/ui_updater.js ---
// ==========================================================================
// [ START OF FILE core/ui_updater.js ]
// UI Update Functions - DOM manipulation for displaying data and states.
// ==========================================================================

import dom from '../utils/dom_elements.js';
import state from './state.js'; // Access to global state
import { attachQuickActionButtonListeners } from '../modules/quick_actions_handler.js'; // For welcome message & final response suggestions
import { formatLogDetails, parseItemClasses } from '../utils/helpers.js'; // Helper for formatting log details

/**
 * Appends a new message to the chat box.
 * @param {string} content - The message content.
 * @param {string} sender - 'user', 'agent', 'system-info', 'error-system'.
 * @param {boolean} [isHTML=false] - Is the content HTML?
 * @param {string|null} [thinkContent=null] - Agent's thinking process.
 * @param {boolean} [isSwitchingSession=false] - Is this for loading history?
 * @param {Array} [attachments=[]] - Message attachments.
 * @param {string|null} [errorType=null] - Specific error type for styling.
 */
export function appendMessage(content, sender, isHTML = false, thinkContent = null, isSwitchingSession = false, attachments = [], errorType = null) {
    const messageDiv = document.createElement('div');
    const messageSenderClass = `message-${sender}`;
    messageDiv.classList.add('message', messageSenderClass);
    if (errorType) {
        const errorClassSuffix = errorType.toLowerCase().replace(/\s+/g, '-');
        messageDiv.classList.add(`message-error-type-${errorClassSuffix}`);
    }
    if (sender === 'system-info' || sender === 'error-system') {
        messageDiv.classList.add('system-message');
        if (sender === 'error-system') messageDiv.classList.add('error-message');
    }

    if (!isSwitchingSession && state.animationLevel !== 'none') {
        const animationClass = state.animationLevel === 'full' ? 'animate__fadeInUp' : (state.animationLevel === 'basic' ? 'animate__fadeIn' : '');
        if (animationClass) {
            messageDiv.classList.add('animate__animated', animationClass);
            messageDiv.style.setProperty('--animate-duration', state.animationLevel === 'full' ? '0.45s' : '0.35s');
        }
    }

    const avatarDiv = document.createElement('div');
    avatarDiv.classList.add('message-avatar');
    let avatarIcon = 'fas fa-question-circle';
    if (sender === 'user') avatarIcon = 'fas fa-user-pen';
    else if (sender === 'agent') avatarIcon = 'fas fa-lightbulb';
    else if (sender === 'system-info') avatarIcon = 'fas fa-info-circle';
    else if (sender === 'error-system') avatarIcon = 'fas fa-exclamation-triangle';
    avatarDiv.innerHTML = `<i class="${avatarIcon}"></i>`;

    if (sender === 'agent' || sender === 'system-info' || sender === 'error-system') {
        messageDiv.appendChild(avatarDiv);
    }

    const messageBubbleDiv = document.createElement('div');
    messageBubbleDiv.classList.add('message-bubble');

    const messageContentWrapper = document.createElement('div');
    messageContentWrapper.classList.add('message-content-wrapper');

    if (sender === 'agent' && thinkContent && state.showChatBubblesThink) {
        const thinkPrefixDiv = document.createElement('div');
        thinkPrefixDiv.classList.add('message-thought-prefix');
        let formattedThink = String(thinkContent).replace(/\n/g, '<br>');
        const jsonBlockRegex = /```json\s*([\s\S]*?)\s*```/gi;
        formattedThink = formattedThink.replace(jsonBlockRegex, (match, jsonContentStr) => {
            const trimmedJson = jsonContentStr.trim();
            try {
                const parsedJson = JSON.parse(trimmedJson);
                const escapedJsonString = JSON.stringify(parsedJson, null, 2)
                    .replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">");
                return `<pre class="embedded-json"><code>${escapedJsonString}</code></pre>`;
            } catch (e) {
                console.warn("Chat bubble: JSON parsing for pretty print failed within thought:", e);
                const escapedOriginalJson = trimmedJson.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">");
                return `<pre class="embedded-json error"><code>${escapedOriginalJson}<br>(无效JSON投影)</code></pre>`;
            }
        });
        thinkPrefixDiv.innerHTML = `<strong><i class="fas fa-brain"></i> AI思维墨迹:</strong><div class="think-bubble-content">${formattedThink}</div>`;
        messageContentWrapper.appendChild(thinkPrefixDiv);
    }

    const textContentDiv = document.createElement('div');
    textContentDiv.classList.add('message-text-content');
    if (isHTML) {
        textContentDiv.innerHTML = content;
    } else {
        const urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
        const linkedContent = String(content)
            .replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">")
            .replace(/"/g, "'").replace(/'/g, "'")
            .replace(/\n/g, '<br>')
            .replace(urlRegex, (url) => `<a href="${url}" target="_blank" rel="noopener noreferrer" class="external-link"><i class="fas fa-external-link-alt"></i> ${url}</a>`);
        textContentDiv.innerHTML = linkedContent;
    }
    messageContentWrapper.appendChild(textContentDiv);

    if (attachments && attachments.length > 0) {
        const attachmentsDiv = document.createElement('div');
        attachmentsDiv.classList.add('message-attachments-summary');
        attachmentsDiv.innerHTML = `<i class="fas fa-paperclip"></i> 数据模块已附加 (${attachments.length}): `;
        attachments.forEach(file => {
            const fileChip = document.createElement('span');
            fileChip.classList.add('filename-chip');
            fileChip.textContent = file.name;
            fileChip.title = `${file.name} (${(file.size / 1024).toFixed(1)}KB, 类型: ${file.type || '未知'})`;
            attachmentsDiv.appendChild(fileChip);
        });
        messageContentWrapper.appendChild(attachmentsDiv);
    }

    messageBubbleDiv.appendChild(messageContentWrapper);
    messageDiv.appendChild(messageBubbleDiv);

    if (sender === 'user') {
        messageDiv.appendChild(avatarDiv);
    }

    dom.chatBox.appendChild(messageDiv);
    attachQuickActionButtonListeners(messageDiv); // For suggestions in agent messages
    if (!isSwitchingSession) { scrollToBottom(); }
}


/**
 * Appends the initial welcome message to the chat box.
 */
export function appendWelcomeMessage() {
    const lastMessage = dom.chatBox.lastElementChild;
    if (lastMessage && lastMessage.classList.contains('system-message-initial')) { return; }

    const welcomeHTML = `
        <div class="message-content">
            <div class="welcome-header">
                <i class="fas fa-dna robot-icon animate__animated animate__pulse animate__infinite" style="--animate-duration: 3.5s;"></i>
                <h2>CircuitManus <span class="version-pro">Lumina <span class="version-number">v1.0.0</span></span></h2>
            </div>
            <p class="welcome-subtitle">您的光绘墨迹交互界面，赋能创意与构想。Lumina核心已激活，请挥洒您的灵感。</p>
            <div class="capabilities">
                <div class="capability"><i class="fas fa-lightbulb"></i><span>灵感激发</span></div>
                <div class="capability"><i class="fas fa-drafting-compass"></i><span>草图勾勒</span></div>
                <div class="capability"><i class="fas fa-palette"></i><span>色彩构想</span></div>
                <div class="capability"><i class="fas fa-code"></i><span>代码生成</span></div>
                <div class="capability"><i class="fas fa-microchip"></i><span>电路设计</span></div>
                <div class="capability"><i class="fas fa-project-diagram"></i><span>流程规划</span></div>
                <div class="capability"><i class="fas fa-feather-alt"></i><span>文本创作</span></div>
                <div class="capability"><i class="fas fa-search"></i><span>信息检索</span></div>
            </div>
             <div class="quick-actions">
                <p>开始您的创作或选择预设指令:</p>
                <ul>
                    <li><a href="#" class="quick-action-btn lumina-button" data-message="设计一个简约的LOGO"><i class="fas fa-signature"></i> 设计LOGO</a></li>
                    <li><a href="#" class="quick-action-btn lumina-button" data-message="写一首关于星空的短诗"><i class="fas fa-moon"></i> 星空诗篇</a></li>
                    <li><a href="#" class="quick-action-btn lumina-button" data-message="帮我规划一个旅行日程"><i class="fas fa-map-signs"></i> 旅行规划</a></li>
                    <li><a href="#" class="quick-action-btn lumina-button" data-message="描述当前的电路状态"><i class="fas fa-eye"></i> 查看电路</a></li>
                    <li><a href="#" class="quick-action-btn lumina-button" data-message="清空所有元件和连接"><i class="fas fa-eraser"></i> 清空画布</a></li>
                    <li><a href="#" class="quick-action-btn lumina-button" data-message="解释什么是人工智能"><i class="fas fa-brain"></i> AI释义</a></li>
                    <li><a href="#" class="quick-action-btn lumina-button" data-message="新建一个光绘项目"><i class="fas fa-plus-square"></i> 新建项目</a></li>
                    <li><a href="#" class="quick-action-btn lumina-button" data-message="切换到代码绘卷模式"><i class="fas fa-laptop-code"></i> 代码模式</a></li>
                </ul>
             </div>
        </div>
    `;
    const welcomeDiv = document.createElement('div');
    const animClass = state.animationLevel !== 'none' ? (state.animationLevel === 'full' ? 'animate__fadeInUp' : 'animate__fadeIn') : '';
    welcomeDiv.className = `message system-message system-message-initial lumina-panel ${animClass ? 'animate__animated ' + animClass : ''}`;
    if (animClass) welcomeDiv.style.setProperty('--animate-duration', '0.65s');
    welcomeDiv.innerHTML = welcomeHTML;
    dom.chatBox.appendChild(welcomeDiv);
    attachQuickActionButtonListeners(welcomeDiv);
}

/**
 * Scrolls the chat box to the bottom.
 * @param {boolean} [instant=false] - Scroll instantly.
 */
export function scrollToBottom(instant = false) {
    if (state.autoScroll) {
        const behavior = instant || state.animationLevel === 'none' ? 'auto' : 'smooth';
        dom.chatBox.scrollTo({ top: dom.chatBox.scrollHeight, behavior: behavior });
    }
}

/**
 * Shows the typing indicator.
 */
export function showTypingIndicator() {
    if (state.isAgentTyping) return;
    state.isAgentTyping = true;

    const typingDiv = document.createElement('div');
    typingDiv.id = 'typing-indicator';
    const animationClass = state.animationLevel !== 'none' ? 'animate__fadeInUp' : '';
    typingDiv.classList.add('message', 'message-agent', 'typing-indicator');
    if (animationClass) {
        typingDiv.classList.add('animate__animated', animationClass);
        typingDiv.style.setProperty('--animate-duration', '0.4s');
    }

    const avatarDiv = document.createElement('div');
    avatarDiv.classList.add('message-avatar');
    avatarDiv.innerHTML = '<i class="fas fa-lightbulb fa-beat"></i>';

    const bubbleDiv = document.createElement('div');
    bubbleDiv.classList.add('message-bubble');
    const contentWrapper = document.createElement('div');
    contentWrapper.classList.add('message-content-wrapper');
    const textContent = document.createElement('div');
    textContent.classList.add('message-text-content');
    let dotsHTML = Array(3).fill('<span class="typing-dot"></span>').join('');
    textContent.innerHTML = `Lumina核心构思中<span class="typing-dots">${dotsHTML}</span>`;

    contentWrapper.appendChild(textContent);
    bubbleDiv.appendChild(contentWrapper);
    typingDiv.appendChild(avatarDiv);
    typingDiv.appendChild(bubbleDiv);
    dom.chatBox.appendChild(typingDiv);
    scrollToBottom();
}

/**
 * Hides the typing indicator.
 */
export function hideTypingIndicator() {
    if (!state.isAgentTyping) return;
    state.isAgentTyping = false;
    const typingElement = document.getElementById('typing-indicator');
    if (typingElement) {
        if (state.animationLevel !== 'none') {
            const animationOutClass = state.animationLevel === 'full' ? 'animate__fadeOutDown' : 'animate__fadeOut';
            typingElement.classList.remove('animate__fadeInUp', 'animate__fadeIn');
            typingElement.classList.add('animate__animated', animationOutClass);
            typingElement.style.setProperty('--animate-duration', '0.3s');
            typingElement.addEventListener('animationend', () => typingElement.remove(), { once: true });
        } else {
            typingElement.remove();
        }
    }
}

/**
 * Adjusts the height of the user input textarea.
 */
export function adjustTextareaHeight() {
    dom.userInput.style.height = 'auto';
    let scrollHeight = dom.userInput.scrollHeight;
    const maxHeight = parseInt(getComputedStyle(dom.userInput).maxHeight, 10) || 200;
    const minHeight = parseInt(getComputedStyle(dom.userInput).minHeight, 10) || 52;
    const singleLinePadding = 5;

    if (dom.userInput.value.split('\n').length <= 1 && scrollHeight < minHeight + singleLinePadding * 2) {
        scrollHeight += singleLinePadding;
    }

    if (scrollHeight > maxHeight) {
        dom.userInput.style.height = maxHeight + 'px';
        dom.userInput.style.overflowY = 'auto';
    } else {
        dom.userInput.style.height = Math.max(scrollHeight, minHeight) + 'px';
        dom.userInput.style.overflowY = 'hidden';
    }
}

/**
 * Updates the character counter.
 */
export function updateCharCounter() {
    const currentLength = dom.userInput.value.length;
    dom.charCounter.textContent = `${currentLength}/${state.maxInputChars}`;
    dom.charCounter.classList.remove('warn', 'error');
    if (currentLength > state.maxInputChars) {
        dom.charCounter.classList.add('error');
    } else if (currentLength > state.maxInputChars * 0.9) {
        dom.charCounter.classList.add('warn');
    }
}


/**
 * Displays a Toast notification.
 * @param {string} message - The message text.
 * @param {string} [type='info'] - 'info', 'success', 'warning', 'error'.
 * @param {number} [duration=3500] - Duration in ms, 0 for no auto-dismiss.
 */
export function showToast(message, type = 'info', duration = 3500) {
    if (!dom.toastContainer) { console.error("Toast container element not found."); return; }

    const toast = document.createElement('div');
    toast.classList.add('toast', 'lumina-panel', `toast-${type}`);

    const animIn = state.animationLevel !== 'none' ? (state.animationLevel === 'full' ? 'animate__fadeInRight' : 'animate__fadeIn') : '';
    const animOut = state.animationLevel !== 'none' ? (state.animationLevel === 'full' ? 'animate__fadeOutRight' : 'animate__fadeOut') : '';

    if (state.animationLevel !== 'none' && animIn) {
        toast.classList.add('animate__animated', animIn);
        toast.style.setProperty('--animate-duration', '0.45s');
    }

    const icons = { 'info': 'fa-info-circle', 'success': 'fa-check-circle', 'warning': 'fa-exclamation-triangle', 'error': 'fa-times-circle' };
    const iconClass = icons[type] || 'fa-info-circle';

    const messageSpan = document.createElement('span');
    messageSpan.className = 'toast-message';
    messageSpan.textContent = message;

    toast.innerHTML = `<i class="fas ${iconClass} toast-icon"></i>`;
    toast.appendChild(messageSpan);

    const closeButton = document.createElement('button');
    closeButton.className = 'toast-close icon-btn';
    closeButton.innerHTML = '<i class="fas fa-times"></i>';
    closeButton.setAttribute('title', '关闭通知');
    closeButton.addEventListener('click', () => removeToast(toast, animOut, true));
    toast.appendChild(closeButton);

    dom.toastContainer.appendChild(toast);

    if (duration > 0) {
        const timeoutId = setTimeout(() => {
            removeToast(toast, animOut, false);
        }, duration);
        toast.dataset.timeoutId = timeoutId.toString();
    }
}

/**
 * Removes a Toast notification.
 * @param {HTMLElement} toast - The Toast DOM element.
 * @param {string} animOut - The animation class for fading out.
 * @param {boolean} [isManualClose=false] - If closed manually.
 */
export function removeToast(toast, animOut, isManualClose = false) {
    if (toast.parentElement) {
        if (isManualClose && toast.dataset.timeoutId) {
            clearTimeout(parseInt(toast.dataset.timeoutId, 10));
        }
        if (state.animationLevel !== 'none' && animOut && toast.classList.contains('animate__animated')) {
            toast.classList.remove('animate__fadeInRight', 'animate__fadeIn');
            toast.classList.add(animOut);
            toast.style.setProperty('--animate-duration', '0.3s');
            toast.addEventListener('animationend', () => {
                if (toast.parentElement) toast.remove();
            }, { once: true });
        } else {
            toast.remove();
        }
    }
}

/**
 * Sets the global loading state of the application.
 * @param {boolean} isLoading - True if loading, false otherwise.
 */
export function setLoadingState(isLoading) {
    state.isLoading = isLoading;
    if (dom.sendButton) dom.sendButton.disabled = isLoading;
    if (dom.userInput) dom.userInput.disabled = isLoading;
    if (dom.sendIcon) dom.sendIcon.style.display = isLoading ? 'none' : 'inline-block';
    if (dom.sendLoadingIcon) dom.sendLoadingIcon.style.display = isLoading ? 'inline-block' : 'none';
    if (dom.sendButton) dom.sendButton.title = isLoading ? "墨迹传输中..." : "发送指令";
    if (dom.inputArea) dom.inputArea.classList.toggle('processing', isLoading);
    if (dom.sendButton) dom.sendButton.classList.toggle('processing-active', isLoading);
}


/**
 * Appends a new log item to the process log sidebar.
 * @param {string} messageText - Main text for the log item.
 * @param {string} iconClass - FontAwesome icon class.
 * @param {string} [itemClasses=''] - Additional CSS classes for the item.
 * @param {object|null} [details=null] - Details object to display.
 * @returns {HTMLElement|null} The created log item element or null.
 */
export function appendLogItem(messageText, iconClass, itemClasses = '', details = null) {
    if (!dom.processLogSidebarContent) {
        console.error("日志侧栏内容元素 (processLogSidebarContent) 未找到。");
        return null;
    }
    const logItemDiv = document.createElement('div');
    logItemDiv.className = 'log-item animate__animated animate__fadeInUp';
    logItemDiv.style.setProperty('--animate-duration', '0.3s');
    if (itemClasses) {
        logItemDiv.classList.add(...itemClasses.split(' ').filter(cls => cls));
    }

    const iconEl = document.createElement('i');
    iconEl.className = iconClass; // This will be like 'fas fa-info-circle log-info'
    logItemDiv.appendChild(iconEl);

    const contentAreaWrapper = document.createElement('div');
    contentAreaWrapper.classList.add('log-item-content-area');

    const messageEl = document.createElement('span');
    messageEl.className = 'log-item-message';
    messageEl.textContent = messageText;
    contentAreaWrapper.appendChild(messageEl);

    if (details && Object.keys(details).length > 0) {
        const detailsEl = document.createElement('div');
        detailsEl.className = 'log-item-details';
        const { type: logType, stage: logStage, status: logStatus } = parseItemClasses(logItemDiv.className);
        const formattedDetailsHtml = formatLogDetails(details, logType, logStage, logStatus);

        if (formattedDetailsHtml) {
            detailsEl.innerHTML = formattedDetailsHtml;
        } else {
             detailsEl.innerHTML = `<span class="log-detail-item"><strong class="log-detail-key">详细信息:</strong> <span class="log-detail-value">(无或格式化失败)</span></span>`;
            try {
                let rawDetailsStr = typeof details === 'object' ? JSON.stringify(details, null, 2) : String(details);
                detailsEl.innerHTML += `<pre class="log-detail-raw-json error"><code>${rawDetailsStr.replace(/</g, "<").replace(/>/g, ">")}<br>(原始数据)</code></pre>`;
            } catch (e_raw) {
                 detailsEl.innerHTML += `<span class="log-detail-item error"><strong class="log-detail-key">原始数据错误:</strong> <span class="log-detail-value">${e_raw.message}</span></span>`;
            }
        }
        contentAreaWrapper.appendChild(detailsEl);
    }
    logItemDiv.appendChild(contentAreaWrapper);
    dom.processLogSidebarContent.appendChild(logItemDiv);
    scrollToProcessLogBottom();
    return logItemDiv;
}

/**
 * Appends a log item with a dedicated thinking process bubble.
 * @param {string} headerText - Header text for the log item.
 * @param {string} headerIconClass - FontAwesome icon class for the header.
 * @param {string} itemClasses - Additional CSS classes for the item.
 * @param {string} thinkContent - The thinking process content.
 * @param {string} [thinkBubbleLabel="详细思考投影"] - Label for the thinking bubble.
 * @returns {HTMLElement|null} The created log item element or null.
 */
export function appendLogItemWithThink(headerText, headerIconClass, itemClasses, thinkContent, thinkBubbleLabel = "详细思考投影") {
    if (!dom.processLogSidebarContent) {
        console.error("日志侧栏内容元素 (processLogSidebarContent) 未找到。");
        return null;
    }
    const logItemDiv = document.createElement('div');
    logItemDiv.className = 'log-item animate__animated animate__fadeInUp';
    logItemDiv.style.setProperty('--animate-duration', '0.3s');
    if (itemClasses) logItemDiv.classList.add(...itemClasses.split(' '));

    const iconEl = document.createElement('i');
    iconEl.className = headerIconClass;
    logItemDiv.appendChild(iconEl);

    const contentAreaWrapper = document.createElement('div');
    contentAreaWrapper.classList.add('log-item-content-area');

    const messageEl = document.createElement('span');
    messageEl.className = 'log-item-message';
    messageEl.textContent = headerText;
    contentAreaWrapper.appendChild(messageEl);

    if (thinkContent) {
        const thinkDiv = document.createElement('div');
        thinkDiv.classList.add('log-think-content'); // For specific styling of the think bubble
        let formattedThink = String(thinkContent).replace(/\n/g, '<br>');
        const jsonBlockRegex = /```json\s*([\s\S]*?)\s*```/gi;
        formattedThink = formattedThink.replace(jsonBlockRegex, (match, jsonContentStr) => {
            const trimmedJson = jsonContentStr.trim();
            try {
                const parsedJson = JSON.parse(trimmedJson);
                const escapedJsonString = JSON.stringify(parsedJson, null, 2)
                    .replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">");
                return `<pre class="log-detail-raw-json"><code>${escapedJsonString}</code></pre>`;
            } catch (jsonErr) {
                console.warn("Log item with think: JSON parsing for pretty print failed within thought:", jsonErr);
                const escapedOriginalJson = trimmedJson.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">");
                return `<pre class="log-detail-raw-json error"><code>${escapedOriginalJson}<br>(无效JSON投影)</code></pre>`;
            }
        });
        thinkDiv.innerHTML = `<strong><i class="fas fa-brain"></i> ${thinkBubbleLabel}:</strong><div class="think-bubble">${formattedThink}</div>`;
        contentAreaWrapper.appendChild(thinkDiv);
    }
    logItemDiv.appendChild(contentAreaWrapper);
    dom.processLogSidebarContent.appendChild(logItemDiv);
    scrollToProcessLogBottom();
    return logItemDiv;
}

/**
 * Scrolls the process log sidebar to the bottom.
 * @param {boolean} [instant=false] - Scroll instantly.
 */
export function scrollToProcessLogBottom(instant = false) {
    if (!dom.processLogSidebarContent) {
        console.error("日志侧栏内容元素 (processLogSidebarContent) 未找到，无法滚动。");
        return;
    }
    const container = dom.processLogSidebarContent;
    const behavior = instant || state.animationLevel === 'none' ? 'auto' : 'smooth';
    container.scrollTo({ top: container.scrollHeight, behavior: behavior });
}

    /**
     * 格式化日志项的详细信息对象为HTML字符串。
     * @param {object} details - 包含详细信息的对象。
     * @param {string|null} type - 日志项类型。
     * @param {string|null} stage - 日志项阶段。
     * @param {string|null} status - 日志项状态。
     * @returns {string|null} 格式化后的HTML字符串，如果无有效细节则返回null。
     */

// ==========================================================================
// [ END OF FILE core/ui_updater.js ]
// ==========================================================================
--- END: static/js/core/ui_updater.js ---

--- START: static/js/core/websocket_manager.js ---
// ==========================================================================
// [ START OF FILE core/websocket_manager.js ]
// WebSocket Connection and Message Handling
// ==========================================================================

import dom from '../utils/dom_elements.js';
import state from './state.js';
// 从 session_handler.js 导入会话管理函数 (确保 saveSessions 导入为 saveSessionData 以避免与 state.js 中的冲突，如果那里也有的话)
import { initializeCurrentSessionUI, addMessageToCurrentSession, renderSessionList, saveSessions as saveSessionData } from '../modules/session_handler.js'; 
import { appendMessage, appendWelcomeMessage, showToast, hideTypingIndicator, setLoadingState, appendLogItem, appendLogItemWithThink } from './ui_updater.js';
import { showProcessLogSidebar } from '../modules/layout_handler.js';
// 从 helpers.js 导入 APP_PREFIX 和其他辅助函数，包括 formatLogDetails
import { generateClientRequestId, summarizeArguments, parseItemClasses, APP_PREFIX, formatLogDetails } from '../utils/helpers.js'; 
// 从 settings_handler.js 导入 populateLLMModelSelect 和 updateChineseDeepThinkingToggleState
import { populateLLMModelSelect, updateChineseDeepThinkingToggleState } from '../modules/settings_handler.js';


let websocket = null;
const websocketUrl = `ws://${window.location.host}/ws/chat`;
let wsReconnectAttempts = 0;
const MAX_WS_RECONNECT_ATTEMPTS = 3; 
const WS_RECONNECT_INTERVAL = 3000; // ms

export function connectWebSocket() {
    if (websocket && (websocket.readyState === WebSocket.OPEN || websocket.readyState === WebSocket.CONNECTING)) {
        console.log("WebSocket: 已连接或正在连接中。");
        return;
    }
    console.log(`WebSocket: 尝试连接 (第 ${wsReconnectAttempts + 1} 次) 到 ${websocketUrl}`);
    if (dom.loader && wsReconnectAttempts === 0 && !dom.loader.classList.contains('loader-fatal-error')) {
        const loadingText = dom.loader.querySelector('.loading-text');
        if (loadingText) loadingText.textContent = "同步光绘墨迹流 (V1.1.1 Lumina)..."; // 版本更新
    }

    websocket = new WebSocket(websocketUrl);

    websocket.onopen = (event) => {
        console.log("WebSocket: 连接已建立。", event);
        wsReconnectAttempts = 0;
        showToast("光绘墨迹数据流 ACTIVE (V1.1.1 Lumina).", "success", 4000); // 版本更新
        sendWebSocketMessage({
            type: 'init',
            session_id: state.currentSessionId 
        });
        if (dom.loader && !dom.loader.classList.contains('loader-fatal-error')) dom.loader.classList.add('hidden');
        if (dom.mainContainer) dom.mainContainer.classList.add('loaded');
    };

    websocket.onmessage = (event) => {
        try {
            const message = JSON.parse(event.data);
            console.log("WS RX:", message);
            handleWebSocketMessage(message);
        } catch (e) {
            console.error("WebSocket: 解析消息失败。", e, "原始数据:", event.data);
            showToast("收到损坏的数据包流 (JSON解析失败).", "error");
        }
    };

    websocket.onerror = (event) => {
        console.error("WebSocket: 发生错误。", event);
    };

    websocket.onclose = (event) => {
        console.log("WebSocket: 连接已关闭。", event);
        hideTypingIndicator();
        setLoadingState(false);
        
        const reason = event.reason ? `原因: ${event.reason}` : (event.wasClean ? '连接正常关闭.' : '连接异常断开.');
        const codeMsg = `(代码: ${event.code})`;

        if (!event.wasClean && wsReconnectAttempts < MAX_WS_RECONNECT_ATTEMPTS) {
            wsReconnectAttempts++;
            showToast(`墨迹数据链接不稳定. 尝试重新校准 (${wsReconnectAttempts}/${MAX_WS_RECONNECT_ATTEMPTS})... ${codeMsg}`, "warning", WS_RECONNECT_INTERVAL + 500);
            setTimeout(connectWebSocket, WS_RECONNECT_INTERVAL);
        } else if (!event.wasClean) {
            websocket = null; 
            if (dom.mainContainer) dom.mainContainer.style.display = 'none';
            if (dom.toastContainer) dom.toastContainer.innerHTML = '';
            if (dom.loader) {
                dom.loader.classList.add('loader-fatal-error');
                dom.loader.classList.remove('hidden');
                dom.loader.innerHTML = ''; 

                const fatalErrorCore = document.createElement('div');
                fatalErrorCore.className = 'lumina-loader-core error-state';
                fatalErrorCore.innerHTML = `<div class="lumina-loader-center-pulse"></div>`;

                const fatalErrorLogo = document.createElement('div');
                fatalErrorLogo.className = 'loader-logo-text';
                fatalErrorLogo.innerHTML = `<span>CIRCUIT</span>MANUS<span class="loader-version-pro">PRO</span> - 链接故障`;

                const fatalErrorHeading = document.createElement('p');
                fatalErrorHeading.className = 'loading-text';
                fatalErrorHeading.textContent = "通信链接已断开且无法恢复";

                const fatalErrorDetails = document.createElement('p');
                fatalErrorDetails.className = 'error-details-text';
                fatalErrorDetails.textContent = `与后端核心的连接已彻底中断 (${MAX_WS_RECONNECT_ATTEMPTS} 次校准尝试失败)。请检查您的网络连接或服务器状态。${codeMsg} ${reason}`;

                const refreshButton = document.createElement('button');
                refreshButton.id = 'refresh-page-button';
                refreshButton.className = 'lumina-button lumina-button-primary refresh-button';
                refreshButton.innerHTML = '<i class="fas fa-sync-alt"></i> 刷新页面';
                refreshButton.onclick = () => window.location.reload();

                dom.loader.appendChild(fatalErrorCore);
                dom.loader.appendChild(fatalErrorLogo);
                dom.loader.appendChild(fatalErrorHeading);
                dom.loader.appendChild(fatalErrorDetails);
                dom.loader.appendChild(refreshButton);
            }
        } else { 
            websocket = null; 
            showToast(`通信链接已终止. ${codeMsg} ${reason}`, "info", 6000);
        }
    };
}

export function sendWebSocketMessage(message) {
    // 当发送用户聊天消息 (type: 'message') 时，自动附加当前选择的LLM和语言偏好
    if (message.type === 'message') {
        message.selected_llm = state.selectedLLM; // 从全局 state 获取
        message.enable_chinese_thinking = state.enableChineseDeepThinking; // 从全局 state 获取
    }

    if (websocket && websocket.readyState === WebSocket.OPEN) {
        const messageStr = JSON.stringify(message);
        console.log("WS TX:", message); 
        websocket.send(messageStr);
    } else {
        console.error("WebSocket: 连接未打开。无法发送消息:", message);
        showToast("通信链接不活跃. 尝试重新建立链接...", "warning");
        if (!websocket || websocket.readyState === WebSocket.CLOSED || websocket.readyState === WebSocket.CLOSING) {
            if (wsReconnectAttempts < MAX_WS_RECONNECT_ATTEMPTS) {
                connectWebSocket(); 
            } else {
                showToast("无法发送: 达到最大重连尝试次数. 请刷新页面.", "error");
            }
        }
    }
}

function handleWebSocketMessage(message) {
    try {
        switch (message.type) {
            case 'init_success':
                try {
                    state.currentSessionId = message.session_id;
                    localStorage.setItem(APP_PREFIX + 'lastSessionId', state.currentSessionId);

                    if (message.agent_default_settings) {
                        // 合并后端传来的默认设置到 state.agentDefaultSettings
                        // 后端传来的 detailed_available_llms 会被正确设置
                        state.agentDefaultSettings = { ...state.agentDefaultSettings, ...message.agent_default_settings };
                        
                        // 使用后端传来的默认值或localStorage中的值来初始化当前选择
                        state.selectedLLM = localStorage.getItem(APP_PREFIX + 'selectedLLM') || state.agentDefaultSettings.default_llm_identifier;
                        
                        if (state.agentDefaultSettings.globally_enable_chinese_thinking === false) {
                            state.enableChineseDeepThinking = false;
                        } else {
                            state.enableChineseDeepThinking = (localStorage.getItem(APP_PREFIX + 'enableChineseDeepThinking') || state.agentDefaultSettings.default_enable_chinese_thinking.toString()) === 'true';
                        }
                        console.log("从后端同步了Agent默认设置: ", JSON.parse(JSON.stringify(state.agentDefaultSettings))); // 深拷贝打印
                        console.log("初始化后当前选择的模型:", state.selectedLLM, "中文思考:", state.enableChineseDeepThinking);

                        // 【关键】调用这两个函数来更新设置模态框中的UI
                        populateLLMModelSelect(); // 这个函数现在会使用 state.agentDefaultSettings.detailed_available_llms
                        updateChineseDeepThinkingToggleState(); // 这个函数会使用 state.agentDefaultSettings.globally_enable_chinese_thinking 和 state.enableChineseDeepThinking
                    }
                    
                    const agentStatusMessage = message.agent_available === false
                        ? 'Lumina AI核心 OFFLINE. 功能受限. (V1.1.1 Lumina)' // 版本更新
                        : 'Lumina核心 (V1.1.1 Lumina) 已同步到光绘网络!'; // 版本更新
                    const agentStatusType = message.agent_available === false ? 'warning' : 'success';
                    showToast(agentStatusMessage, agentStatusType, message.agent_available ? 4500 : 8000);

                    if (!state.sessions[state.currentSessionId]) {
                        const now = Date.now();
                        state.sessions[state.currentSessionId] = {
                            id: state.currentSessionId,
                            name: `光绘墨迹项目 ${Object.keys(state.sessions).length + 1}`,
                            messages: [],
                            createdAt: now,
                            lastActivity: now,
                        };
                        saveSessionData(); 
                    }
                    initializeCurrentSessionUI(true); 
                } catch (e) {
                    console.error(`处理 init_success 消息时出错:`, e, message); 
                    showToast(`处理初始化成功消息时出错: ${e.message}`, 'error');
                }
                break;
            case 'init_error':
                try {
                    showToast(`AI核心同步失败: ${message.message}`, 'error', 10000);
                    if (dom.loader && !dom.loader.classList.contains('loader-fatal-error')) dom.loader.classList.add('hidden');
                    if (dom.mainContainer) dom.mainContainer.classList.add('loaded');
                    if (message.agent_available === false) {
                        appendMessage("CRITICAL SYSTEM ALERT: Lumina AI核心未能初始化. 子系统无响应. (V1.1.1 Lumina)", 'error-system', false, null, false, [], "System Error");
                    }
                    setLoadingState(false);
                } catch (e) {
                    console.error(`处理 init_error 消息时出错:`, e, message);
                    showToast(`处理初始化错误消息时出错: ${e.message}`, 'error');
                }
                break;
            case 'error': 
                try {
                    console.error("服务器报告错误:", message);
                    showToast(`服务器异常: ${message.message}`, 'error', 7000);
                    if (message.details) {
                        appendMessage(`SERVER ERROR (${message.message}): ${message.details}`, 'error-system', false, null, false, [], "Server Error");
                    }
                    setLoadingState(false);
                } catch (e) {
                    console.error(`处理服务器 'error' 消息时出错:`, e, message);
                    showToast(`处理服务器错误报告时出错: ${e.message}`, 'error');
                }
                break;
            case 'general_status': handleGeneralStatus(message); break;
            case 'llm_communication_status': handleLlmCommStatus(message); break;
            case 'thinking_log': handleThinkingLog(message); break;
            case 'plan_details': handlePlanDetails(message); break;
            case 'tool_status_update': handleToolStatusUpdate(message); break;
            case 'interim_response': handleInterimResponse(message); break;
            case 'final_response':
                try {
                    handleFinalResponse(message);
                } catch (e_final_resp) {
                    console.error(`处理 final_response 时发生错误:`, e_final_resp, message);
                    showToast(`处理最终响应时发生内部错误: ${e_final_resp.message}`, 'error');
                    hideTypingIndicator();
                    setLoadingState(false);
                }
                break;
            default:
                console.warn("收到未知数据包类型:", message.type, message);
                showToast(`未知数据包类型: ${message.type}`, 'warning');
        }
    } catch (e_outer_switch) {
        console.error("处理WebSocket消息switch逻辑时发生严重错误。", e_outer_switch, "原始消息:", message);
        showToast("处理服务器消息时发生严重内部错误。", "error");
        hideTypingIndicator();
        setLoadingState(false);
    }
}

function handleGeneralStatus(msg) {
    const { stage, status, message: msgText, details } = msg;
    let logIconClass = 'fas fa-info-circle log-info';
    let logItemClasses = `type-general_status stage-${stage} status-${status}`;

    if (status === 'started' || status === 'llm_retry_needed' || status === 'llm_error_retrying') logIconClass = 'fas fa-sync-alt fa-spin log-processing';
    else if (status === 'completed' || status === 'received' || status === 'completed_and_validated') logIconClass = 'fas fa-check-circle log-success';
    else if (status === 'error' || status === 'failed' || status === 'failed_after_llm_retries' || status === 'tool_failure_detected' || status === 'fatal_error_handler' || status === 'fatal_error_capture' || status === 'llm_selection_override') { // Added llm_selection_override
        logIconClass = 'fas fa-exclamation-triangle log-error';
        if (status === 'llm_selection_override') logIconClass = 'fas fa-random log-warning'; // Or a warning icon for override
    }
    else if (status === 'ignored') logIconClass = 'fas fa-eye-slash log-muted';

    appendLogItem(msgText, logIconClass, logItemClasses, details);
    if (!state.isProcessLogSidebarVisible) showProcessLogSidebar(false);
}

function handleLlmCommStatus(msg) {
    const { llm_phase, status, message: msgText, details } = msg;
    let logIconClass = 'fas fa-brain log-processing';
    let logItemClasses = `type-llm_communication_status phase-${llm_phase} status-${status}`;

    if (status === 'started') logIconClass = 'fas fa-brain fa-beat-fade log-processing';
    else if (status === 'completed') logIconClass = 'fas fa-check log-success';
    else if (status === 'error') logIconClass = 'fas fa-bolt log-error';

    appendLogItem(msgText, logIconClass, logItemClasses, details);
    if (!state.isProcessLogSidebarVisible) showProcessLogSidebar(false);
}

function handleThinkingLog(msg) {
    const { stage, content, llm_interaction_id } = msg;
    if (content) {
        state.lastResponseThinking = content;
    }
    if (state.showLogBubblesThink) {
        const thinkLabel = `AI思维墨迹 (${stage.replace(/_/g, ' ').toUpperCase()})`;
        appendLogItemWithThink(thinkLabel, 'fas fa-lightbulb log-think', `type-thinking_log stage-${stage} llm-id-${llm_interaction_id}`, content, "详细思考投影:");
    } else {
        appendLogItem(`思维墨迹收到 (${stage}, LLM_ID: ${llm_interaction_id}) - ${String(content).substring(0, 80)}...`, 'fas fa-comment-dots log-muted', `type-thinking_log stage-${stage} muted`);
    }
    if (!state.isProcessLogSidebarVisible) showProcessLogSidebar(false);
}

function handlePlanDetails(msg) {
    const { plan } = msg;
    state.pendingToolCalls = {}; 
    if (Array.isArray(plan)) { 
        plan.forEach(toolCall => {
            const toolCallId = toolCall.toolCallId || toolCall.tool_call_id; 
            const toolName = toolCall.toolName || toolCall.tool_name;     
            const toolArguments = toolCall.toolArguments || toolCall.tool_arguments || {}; 
            const uiHints = toolCall.uiHints || toolCall.ui_hints || {};
            const order = toolCall.order;

            if (!toolCallId || !toolName) {
                  console.warn("Plan details missing essential fields (toolCallId/tool_call_id or toolName/tool_name), skipping:", toolCall);
                  appendLogItem(
                      `收到无效计划项 (缺少ID或名称). Original: ${JSON.stringify(toolCall).substring(0,100)}...`, 
                      'fas fa-exclamation-circle log-warning',
                      'type-plan_details status-invalid',
                      toolCall 
                  );
                  return; 
             }
            state.pendingToolCalls[toolCallId] = {
                name: toolName, 
                args_summary: summarizeArguments(toolArguments), 
                ui_hints: uiHints, 
                order: order 
            };
            const displayName = uiHints.displayNameForTool || String(toolName).replace(/_tool$/, "").replace(/_/g, " ").replace(/\b\w/g, l => l.toUpperCase());
            const logMessageText = `执行节点 #${order}: ${displayName} (ID: ${toolCallId}) - 状态: QUEUED`;
            const logItem = appendLogItem(
                logMessageText, 
                'fas fa-tasks log-info', 
                // 确保tool-call-id-xxx类也被添加，用于后续查找
                `type-plan_details tool-${toolName} status-pending tool-call-id-${toolCallId}`, 
                { arguments: toolArguments, tool_call_id: toolCallId, ui_hints: uiHints } 
            );
            if (logItem) logItem.dataset.toolCallId = toolCallId; 
        });
    } else {
        console.warn("Received plan_details message with non-array plan property:", plan);
        appendLogItem(
           `收到无效计划详情 (Plan不是数组).`,
           'fas fa-exclamation-circle log-error',
           'type-plan_details status-invalid',
           { raw_plan_data: plan }
       );
    }
    showProcessLogSidebar(true); 
}


function handleToolStatusUpdate(msg) {
    const { tool_call_id, tool_name, status, message: msgText, details } = msg;
    if (!tool_call_id || !tool_name || status === undefined || msgText === undefined) {
         console.warn("Received invalid tool_status_update message (missing essential fields):", msg);
          appendLogItem(
             `收到无效工具状态更新 (缺少ID,名称,状态或消息).`,
             'fas fa-exclamation-circle log-error',
             'type-tool_status_update status-invalid',
             msg
         );
        return;
    }

    let logIconClass = 'fas fa-cog log-info';
    let itemStatusClass = `status-${status}`;

    if (status === 'running') logIconClass = 'fas fa-cogs fa-spin log-processing';
    else if (status === 'retrying') logIconClass = 'fas fa-history fa-spin log-processing';
    else if (status === 'succeeded') logIconClass = 'fas fa-check-double log-success';
    else if (status === 'failed') logIconClass = 'fas fa-times-circle log-error';
    else if (status === 'aborted_due_to_previous_failure') {
        logIconClass = 'fas fa-ban log-warning';
        itemStatusClass = 'status-aborted';
    }

    const pendingToolInfo = state.pendingToolCalls[tool_call_id];
    const displayName = pendingToolInfo?.ui_hints?.displayNameForTool || String(tool_name).replace(/_tool$/, "").replace(/_/g, " ").replace(/\b\w/g, l => l.toUpperCase());
    let fullLogMessage = `工具模块: ${displayName} (ID: ${tool_call_id}) - ${status.replace(/_/g, ' ').toUpperCase()}: ${msgText}`;

    let existingLogItem = dom.processLogSidebarContent.querySelector(`.log-item[data-tool-call-id="${tool_call_id}"]`);

    if (existingLogItem) {
        // 更新类时，确保包含 tool-call-id-xxx 用于后续查找
        existingLogItem.className = `log-item animate__animated type-tool_status_update tool-${tool_name} ${itemStatusClass} tool-call-id-${tool_call_id}`; 
        existingLogItem.dataset.toolCallId = tool_call_id; 
        existingLogItem.style.setProperty('--animate-duration', '0.5s');

        const iconEl = existingLogItem.querySelector('i:first-child');
        if (iconEl) iconEl.className = logIconClass;

        const messageEl = existingLogItem.querySelector('.log-item-message');
        if (messageEl) messageEl.textContent = fullLogMessage;
        
        const contentAreaWrapper = existingLogItem.querySelector('.log-item-content-area');
        if (contentAreaWrapper) {
             let detailsEl = contentAreaWrapper.querySelector('.log-item-details') || contentAreaWrapper.querySelector('.log-think-content');
             if (details && Object.keys(details).length > 0) {
                 if (!detailsEl) {
                      detailsEl = document.createElement('div');
                      contentAreaWrapper.appendChild(detailsEl);
                 }
                 detailsEl.classList.remove('log-think-content'); 
                 detailsEl.classList.add('log-item-details');

                 const { type, stage, status: parsedStatus } = parseItemClasses(existingLogItem.className);
                 detailsEl.innerHTML = formatLogDetails(details, type, stage, parsedStatus) || ''; 
                 if (!detailsEl.innerHTML) { 
                      detailsEl.innerHTML = `<span class="log-detail-item"><strong class="log-detail-key">详细信息:</strong> <span class="log-detail-value">(无或格式化失败)</span></span>`;
                      try {
                          let rawDetailsStr = typeof details === 'object' ? JSON.stringify(details, null, 2) : String(details);
                          detailsEl.innerHTML += `<pre class="log-detail-raw-json error"><code>${rawDetailsStr.replace(/</g, "<").replace(/>/g, ">")}<br>(原始数据)</code></pre>`;
                      } catch (e_raw) { /* Ignore */ }
                  }
             } else if (detailsEl) {
                 detailsEl.remove();
             }
        } else {
             console.error("Tool status update: Cannot find content area wrapper for details update.");
        }

        existingLogItem.classList.remove('animate__flash', 'animate__headShake', 'animate__pulse');
        if (status === 'failed') existingLogItem.classList.add('animate__headShake');
        else if (status === 'succeeded') existingLogItem.classList.add('animate__pulse');
        else existingLogItem.classList.add('animate__flash');

    } else {
        // 新建时也添加 tool-call-id-xxx 类
        const logItemDiv = appendLogItem(fullLogMessage, logIconClass, `type-tool_status_update tool-${tool_name} ${itemStatusClass} tool-call-id-${tool_call_id}`, details);
        if (logItemDiv) logItemDiv.dataset.toolCallId = tool_call_id; 

        if (logItemDiv) { 
             logItemDiv.classList.remove('animate__fadeInUp'); 
             logItemDiv.classList.add('animate__animated'); 
             if (status === 'failed') logItemDiv.classList.add('animate__headShake');
             else if (status === 'succeeded') logItemDiv.classList.add('animate__pulse');
             else logItemDiv.classList.add('animate__flash');
            logItemDiv.style.setProperty('--animate-duration', '0.5s');
        }
    }

    if (!state.isProcessLogSidebarVisible) showProcessLogSidebar(false);

    if (status === 'succeeded' || status === 'failed' || status === 'aborted_due_to_previous_failure') {
        if (state.pendingToolCalls[tool_call_id]) {
            delete state.pendingToolCalls[tool_call_id];
        }
    }
}

function handleInterimResponse(msg) {
    const { content, llm_interaction_id } = msg;
    appendLogItem(
        `AI意图墨迹: "${String(content).substring(0, 180)}${String(content).length > 180 ? '...' : ''}"`,
        'fas fa-feather-alt log-info',
        'type-agent_intention',
        { llm_interaction_id: llm_interaction_id, full_content: content }
    );
    if (!state.isProcessLogSidebarVisible) showProcessLogSidebar(false);
}

function handleFinalResponse(msg) {
    hideTypingIndicator();
    setLoadingState(false);
    state.currentClientRequestId = null;
    state.pendingToolCalls = {};

    const { content, llm_interaction_id } = msg;
    // 【修改】兼容后端可能发送的 v1.3.2 或通用 final_camelcase_json_if_success
    const finalCamelCaseJson = msg.final_camelcase_json_if_success || msg.final_v1_3_2_camelcase_json_if_success;


    let thinkingForBubble = null;
    let actualContentForBubble = content;

    if (finalCamelCaseJson && typeof finalCamelCaseJson === 'object' && finalCamelCaseJson.status === 'success') {
        if (finalCamelCaseJson.thoughtProcess) {
            thinkingForBubble = finalCamelCaseJson.thoughtProcess;
        }
        if (finalCamelCaseJson.decision && typeof finalCamelCaseJson.decision === 'object' &&
            finalCamelCaseJson.decision.responseToUser && typeof finalCamelCaseJson.decision.responseToUser === 'object' &&
            finalCamelCaseJson.decision.responseToUser.content !== undefined
        ) {
            actualContentForBubble = finalCamelCaseJson.decision.responseToUser.content || "";

            const suggestions = finalCamelCaseJson.decision.responseToUser.suggestionsForNextSteps;
            if (suggestions && Array.isArray(suggestions) && suggestions.length > 0) {
                let suggestionsText = "\n\n<div class=\"final-response-suggestions\"><strong>下一步行动投影:</strong><ul>";
                suggestions.forEach(sugg => {
                    if (sugg.textForUser) {
                        const escapedMessage = String(sugg.textForUser).replace(/"/g, '"'); 
                        const escapedTextForUser = String(sugg.textForUser).replace(/</g, "<").replace(/>/g, ">");
                        suggestionsText += `<li><a href="#" class="quick-action-btn lumina-button" data-message="${escapedMessage}"><i class="fas fa-arrow-right"></i> ${escapedTextForUser}</a></li>`;
                    }
                });
                suggestionsText += "</ul></div>";
                actualContentForBubble += suggestionsText;
                appendMessage(actualContentForBubble, 'agent', true, thinkingForBubble, false, [], null);
            } else {
                if (!actualContentForBubble.trim()) {
                     actualContentForBubble = "(Agent返回的回复内容为空)";
                     console.warn("Final response JSON has empty content and no suggestions. Using fallback message.");
                }
                appendMessage(actualContentForBubble, 'agent', false, thinkingForBubble, false, [], null);
            }
        } else {
            console.warn("Final response JSON structure missing decision.responseToUser.content or nested objects are invalid. Using fallback content.", finalCamelCaseJson);
            appendMessage(content || "(Agent返回的原始内容为空)", 'agent', false, thinkingForBubble, false, [], "ContentMissingIn_V1_PCP_JSON_Or_Structure_Invalid");
            actualContentForBubble = content || "(Agent返回的原始内容为空)";
        }
    } else {
        thinkingForBubble = state.lastResponseThinking;
        const reasonForFallback = finalCamelCaseJson
            ? `JSON status is not 'success' (is '${finalCamelCaseJson.status}') or JSON is not an object (is '${typeof finalCamelCaseJson}').`
            : "final_camelcase_json_if_success (or versioned key) is missing.";
        console.warn(`Final response: ${reasonForFallback} Using fallback content and cached thinking. Raw message content: "${content}"`, finalCamelCaseJson);
        appendMessage(content || "(Agent返回的原始内容为空)", 'agent', false, thinkingForBubble, false, [], `ErrorResponseOrNo_V1_PCP_JSON_Reason:_${reasonForFallback.replace(/\s/g, '_').substring(0, 50)}`);
        actualContentForBubble = content || "(Agent返回的原始内容为空)";
    }

    addMessageToCurrentSession({ 
        content: actualContentForBubble,
        sender: 'agent',
        timestamp: Date.now(),
        isHTML: (actualContentForBubble.includes('<div class="final-response-suggestions">')),
        // 【修改】使用与后端一致的键名 (如果后端发送的是 final_v1_3_2_camelcase_json_if_success，则这里应该对应)
        // 为了通用性，可以检查 message 对象中哪个键存在
        rawResponseV1_PCP_CamelCase: finalCamelCaseJson, 
        thinking: thinkingForBubble,
    });
    state.lastResponseThinking = null;

    if (state.sessions[state.currentSessionId]) {
        state.sessions[state.currentSessionId].lastActivity = Date.now();
    }
    saveSessionData(); 
    renderSessionList(); 

    const llmIdForLog = (finalCamelCaseJson && finalCamelCaseJson.llmInteractionId) ? finalCamelCaseJson.llmInteractionId : (llm_interaction_id || 'N/A_Final');
    appendLogItem(`AI最终回复已渲染 (LLM_ID: ${llmIdForLog})`, 'fas fa-flag-checkered log-success', 'type-final_response',
        finalCamelCaseJson ? { summary: (actualContentForBubble.includes('<div class="final-response-suggestions">') ? actualContentForBubble.substring(0, 120).split('<br>')[0] : actualContentForBubble.substring(0, 120)) + "...", raw_response_v1_pcp: finalCamelCaseJson } : { error_details: "响应生成指示失败或缺少有效JSON.", fallback_content_preview: (content || "(空)").substring(0,120) + "..."}
    );
    if (!state.isProcessLogSidebarVisible) showProcessLogSidebar(false);
    else if (state.isProcessLogSidebarCollapsed) showProcessLogSidebar(false);
    else showProcessLogSidebar(true);
}

// ==========================================================================
// [ END OF FILE core/websocket_manager.js ]
// ==========================================================================

--- END: static/js/core/websocket_manager.js ---

--- START: static/js/modules/copy_handler.js ---
// ==========================================================================
// [ START OF FILE modules/copy_handler.js ]
// Message Copy Functionality
// ==========================================================================

import dom from '../utils/dom_elements.js';
import { showToast } from '../core/ui_updater.js'; // For feedback

/**
 * Handles mouseover on chat messages to show copy button.
 * @param {MouseEvent} event
 */
export function handleChatBoxMouseOver(event) {
    const targetMessageBubble = event.target.closest('.message-agent .message-bubble');
    if (targetMessageBubble) {
        let copyButton = targetMessageBubble.querySelector('.copy-llm-response-btn');
        if (!copyButton) {
            copyButton = document.createElement('button');
            copyButton.className = 'copy-llm-response-btn icon-btn';
            copyButton.innerHTML = '<i class="fas fa-copy"></i>';
            copyButton.title = '复制回复内容';
            copyButton.addEventListener('click', handleCopyLlmResponse);
            targetMessageBubble.appendChild(copyButton);
        }
        copyButton.style.opacity = '1';
        copyButton.style.visibility = 'visible';
    }
}

/**
 * Handles mouseout from chat messages to hide copy button.
 * @param {MouseEvent} event
 */
export function handleChatBoxMouseOut(event) {
    const targetMessageBubble = event.target.closest('.message-agent .message-bubble');
    if (targetMessageBubble) {
        const copyButton = targetMessageBubble.querySelector('.copy-llm-response-btn');
        // Check if relatedTarget is not the button itself or a child of the button
        if (copyButton && !targetMessageBubble.contains(event.relatedTarget) &&
            event.relatedTarget !== copyButton && !copyButton.contains(event.relatedTarget)
        ) {
            copyButton.style.opacity = '0';
            copyButton.style.visibility = 'hidden';
        }
    } else {
        // If mouse left the chatBox entirely, hide all copy buttons
        dom.chatBox.querySelectorAll('.message-agent .message-bubble .copy-llm-response-btn').forEach(btn => {
            btn.style.opacity = '0';
            btn.style.visibility = 'hidden';
        });
    }
}

/**
 * Handles click on the copy button to copy message content.
 * @param {MouseEvent} event
 */
export function handleCopyLlmResponse(event) {
    event.stopPropagation(); // Prevent bubble click if any
    const button = event.currentTarget;
    const messageBubble = button.closest('.message-bubble');
    const textContentDiv = messageBubble.querySelector('.message-text-content');

    if (textContentDiv) {
        let textToCopy = textContentDiv.innerHTML.replace(/<br\s*\/?>/gi, '\n'); // Convert <br> to newlines
        // Strip other HTML tags to get plain text
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = textToCopy;
        textToCopy = tempDiv.textContent || tempDiv.innerText || "";

        // Remove "下一步行动投影:" section if present
        const suggestionIndex = textToCopy.indexOf("下一步行动投影:");
        if (suggestionIndex !== -1) {
            textToCopy = textToCopy.substring(0, suggestionIndex).trim();
        }

        navigator.clipboard.writeText(textToCopy.trim())
            .then(() => {
                showToast('回复已复制到剪贴板!', 'success', 2000);
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => { button.innerHTML = '<i class="fas fa-copy"></i>'; }, 1500);
            })
            .catch(err => {
                console.error('无法复制文本: ', err);
                showToast('复制失败!', 'error');
            });
    }
}
// ==========================================================================
// [ END OF FILE modules/copy_handler.js ]
// ==========================================================================
--- END: static/js/modules/copy_handler.js ---

--- START: static/js/modules/file_handler.js ---
// ==========================================================================
// [ START OF FILE modules/file_handler.js ]
// File Handling - Selection, Preview, Removal
// ==========================================================================

import dom from '../utils/dom_elements.js';
import state from '../core/state.js';
import { showToast } from '../core/ui_updater.js';
import { getFileIconClass } from '../utils/helpers.js';

/**
 * Handles file selection from the input element.
 * @param {Event} event - The file input change event.
 */
export function handleFileSelection(event) {
    const files = Array.from(event.target.files);
    if (files.length === 0) return;

    const MAX_FILES = 5;
    const MAX_SIZE_MB = 2;

    files.forEach(file => {
        if (state.uploadedFiles.length >= MAX_FILES) {
            showToast(`每次传输最多允许 ${MAX_FILES} 个数据卷轴.`, 'warning');
            return; // Exits forEach iteration for this file, but continues for others if any
        }
        if (file.size > MAX_SIZE_MB * 1024 * 1024) {
            showToast(`数据卷轴 "${file.name}" 大小超过 ${MAX_SIZE_MB}MB 限制.`, 'warning');
            return; // Skip this file
        }
        if (!state.uploadedFiles.find(f => f.name === file.name && f.size === file.size)) {
            state.uploadedFiles.push(file);
            addFileToPreview(file);
        } else {
            showToast(`数据卷轴 "${file.name}" 已在队列中.`, 'info');
        }
    });

    if (state.uploadedFiles.length > 0) {
        dom.filePreviewArea.classList.add('active');
    }
    dom.fileInput.value = ''; // Reset file input to allow selecting the same file again
}

/**
 * Adds a file to the UI preview area.
 * @param {File} file - The file object to add.
 */
export function addFileToPreview(file) {
    const fileItem = document.createElement('div');
    fileItem.classList.add('file-item');
    if (state.animationLevel !== 'none') {
        fileItem.classList.add('animate__animated', 'animate__bounceIn');
        fileItem.style.setProperty('--animate-duration', '0.4s');
    }
    fileItem.dataset.fileName = file.name;
    fileItem.dataset.fileSize = file.size;

    const iconClass = getFileIconClass(file.type, file.name);
    fileItem.innerHTML = `
        <i class="fas ${iconClass} file-icon"></i>
        <span class="file-name" title="${file.name} (${(file.size / 1024).toFixed(1)}KB, 类型: ${file.type || '未知'})">${file.name}</span>
        <button class="file-remove icon-btn" title="移除数据卷轴"><i class="fas fa-times-circle"></i></button>`;

    fileItem.querySelector('.file-remove').addEventListener('click', (e) => {
        e.stopPropagation();
        removeFileFromPreview(file.name, file.size);
    });
    dom.filePreviewContent.appendChild(fileItem);
}

/**
 * Removes a file from the preview area and the upload list.
 * @param {string} fileName - Name of the file to remove.
 * @param {number} fileSize - Size of the file to remove (for disambiguation).
 */
export function removeFileFromPreview(fileName, fileSize) {
    state.uploadedFiles = state.uploadedFiles.filter(f => !(f.name === fileName && f.size === fileSize));
    const fileItemElement = dom.filePreviewContent.querySelector(`.file-item[data-file-name="${CSS.escape(fileName)}"][data-file-size="${fileSize}"]`);

    if (fileItemElement) {
        if (state.animationLevel !== 'none') {
            fileItemElement.classList.remove('animate__bounceIn');
            fileItemElement.classList.add('animate__animated', 'animate__bounceOut');
            fileItemElement.addEventListener('animationend', () => {
                if (fileItemElement.parentElement) {
                     fileItemElement.remove();
                     if (state.uploadedFiles.length === 0) closeFilePreview();
                }
            }, { once: true });
        } else {
            fileItemElement.remove();
            if (state.uploadedFiles.length === 0) closeFilePreview();
        }
    }
}

/**
 * Closes (hides) the file preview area.
 */
export function closeFilePreview() {
    dom.filePreviewArea.classList.remove('active');
}

// ==========================================================================
// [ END OF FILE modules/file_handler.js ]
// ==========================================================================
--- END: static/js/modules/file_handler.js ---

--- START: static/js/modules/layout_handler.js ---
// ==========================================================================
// [ START OF FILE modules/layout_handler.js ]
// Dynamic Layout Adjustment Functions
// ==========================================================================

import dom from '../utils/dom_elements.js';
import state from '../core/state.js';

/**
 * Updates the expanded/collapsed state of the left sidebar.
 * @param {boolean} expand - True to expand, false to collapse.
 * @param {boolean} [instant=false] - True for instant update without animation.
 */
export function updateSidebarState(expand, instant = false) {
    state.isSidebarExpanded = expand;
    dom.sidebar.classList.toggle('expanded', state.isSidebarExpanded);
    if (dom.leftSidebarToggle) {
        dom.leftSidebarToggle.setAttribute('aria-expanded', state.isSidebarExpanded.toString());
        const toggleIcon = dom.leftSidebarToggle.querySelector('i');
        if (toggleIcon) {
            toggleIcon.className = state.isSidebarExpanded ? 'fas fa-times' : 'fas fa-bars';
        }
    }
    // If sidebar is collapsed and session manager is expanded, collapse session manager
    if (!state.isSidebarExpanded && !state.isSessionManagerCollapsed) {
        updateSessionManagerState(true, instant);
    }
    // Persist this state if needed (e.g., in settings_handler or directly)
    // localStorage.setItem(APP_PREFIX + 'sidebarExpanded', state.isSidebarExpanded.toString());
}

/**
 * Updates the collapsed/expanded state of the session manager within the sidebar.
 * @param {boolean} collapse - True to collapse, false to expand.
 * @param {boolean} [instant=false] - True for instant update.
 */
export function updateSessionManagerState(collapse, instant = false) {
    state.isSessionManagerCollapsed = collapse;
    dom.sessionManager.classList.toggle('collapsed', state.isSessionManagerCollapsed);
    dom.sessionManagerToggle.setAttribute('aria-expanded', (!state.isSessionManagerCollapsed).toString());
    const sessionToggleIcon = dom.sessionManagerToggle.querySelector('.toggle-icon');
    if (sessionToggleIcon) {
        sessionToggleIcon.className = state.isSessionManagerCollapsed ? 'fas fa-caret-right' : 'fas fa-caret-down';
    }
    // Persist this state
    // localStorage.setItem(APP_PREFIX + 'sessionManagerCollapsed', state.isSessionManagerCollapsed.toString());
}

/**
 * Updates the CSS variable for input area height.
 */
export function updateInputAreaHeightVar() {
    if (dom.inputArea) {
        const heightPx = dom.inputArea.offsetHeight;
        document.documentElement.style.setProperty('--input-area-height', `${heightPx}px`);
    }
}


/**
 * Applies layout adjustments for the fixed right process log sidebar.
 */
export function applyFixedLogSidebarLayout() {
    if (!dom.processLogSidebarContainer || !dom.chatArea) return;
    const logSidebarFixedWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--process-log-sidebar-width').replace('px', '')) || 350;
    const logSidebarCollapsedWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--process-log-sidebar-width-collapsed').replace('px', '')) || 55;

    if (state.isProcessLogSidebarVisible) {
        if (state.isProcessLogSidebarCollapsed) {
            dom.chatArea.style.marginRight = `${logSidebarCollapsedWidth + parseInt(getComputedStyle(dom.chatArea).paddingRight || '0', 10)}px`;
            dom.processLogSidebarContainer.style.width = `${logSidebarCollapsedWidth}px`;
            if(dom.closeProcessLogSidebarButton) dom.closeProcessLogSidebarButton.style.display = 'none';
            if(dom.toggleProcessLogSidebarCollapseButton) dom.toggleProcessLogSidebarCollapseButton.style.display = 'flex';
        } else {
            dom.chatArea.style.marginRight = `${logSidebarFixedWidth + parseInt(getComputedStyle(dom.chatArea).paddingRight || '0', 10)}px`;
            dom.processLogSidebarContainer.style.width = `${logSidebarFixedWidth}px`;
            if(dom.closeProcessLogSidebarButton) dom.closeProcessLogSidebarButton.style.display = 'flex';
            if(dom.toggleProcessLogSidebarCollapseButton) dom.toggleProcessLogSidebarCollapseButton.style.display = 'flex';
        }
    } else {
        dom.chatArea.style.marginRight = ''; // Revert to default
        if(dom.closeProcessLogSidebarButton) dom.closeProcessLogSidebarButton.style.display = 'none';
        // Keep collapse button visible for consistency even if sidebar is hidden
        if(dom.toggleProcessLogSidebarCollapseButton) dom.toggleProcessLogSidebarCollapseButton.style.display = 'flex';
    }
}

/**
 * Updates the collapsed/expanded state of the right process log sidebar.
 * @param {boolean} collapse - True to collapse.
 * @param {boolean} [instant=false] - True for instant update.
 */
export function updateProcessLogSidebarCollapseState(collapse, instant = false) {
    state.isProcessLogSidebarCollapsed = collapse;
    if (dom.processLogSidebarContainer) {
        dom.processLogSidebarContainer.classList.toggle('collapsed', state.isProcessLogSidebarCollapsed);
        const iconElement = dom.toggleProcessLogSidebarCollapseButton.querySelector('i');
        if (iconElement) {
            iconElement.className = state.isProcessLogSidebarCollapsed ? 'fas fa-chevron-right' : 'fas fa-chevron-left';
        }
    }
    applyFixedLogSidebarLayout();
    // localStorage.setItem(APP_PREFIX + 'isProcessLogSidebarCollapsed', state.isProcessLogSidebarCollapsed.toString());
}

/**
 * Hides the right process log sidebar.
 */
export function hideProcessLogSidebar() {
    if (!dom.processLogSidebarContainer) return;
    state.isProcessLogSidebarVisible = false;
    dom.processLogSidebarContainer.classList.remove('visible');
    if (dom.appBodyContainer) {
        dom.appBodyContainer.classList.remove('with-process-log-open', 'log-sidebar-collapsed');
    }
    applyFixedLogSidebarLayout();
    // localStorage.setItem(APP_PREFIX + 'isProcessLogSidebarVisible', state.isProcessLogSidebarVisible.toString());
    console.log("右侧日志侧栏已隐藏。");
}

/**
 * Shows the right process log sidebar.
 * @param {boolean} [ensureExpanded=false] - If true and sidebar is collapsed, expand it.
 */
export function showProcessLogSidebar(ensureExpanded = false) {
    if (!dom.processLogSidebarContainer) return;
    state.isProcessLogSidebarVisible = true;
    dom.processLogSidebarContainer.classList.add('visible');

    if (dom.appBodyContainer) {
        dom.appBodyContainer.classList.add('with-process-log-open');
        dom.appBodyContainer.classList.toggle('log-sidebar-collapsed', state.isProcessLogSidebarCollapsed);
    }

    if (ensureExpanded && state.isProcessLogSidebarCollapsed) {
        toggleProcessLogSidebarCollapse(false); // false to expand
    } else {
        applyFixedLogSidebarLayout();
    }
    // localStorage.setItem(APP_PREFIX + 'isProcessLogSidebarVisible', state.isProcessLogSidebarVisible.toString());
    console.log(`右侧日志侧栏已显示 (强制展开: ${ensureExpanded}, 当前折叠状态: ${state.isProcessLogSidebarCollapsed}).`);
}

/**
 * Toggles the collapsed/expanded state of the right process log sidebar.
 * @param {boolean} [instant=false] - True for instant update.
 */
export function toggleProcessLogSidebarCollapse(instant = false) {
    if (!dom.processLogSidebarContainer || !dom.toggleProcessLogSidebarCollapseButton) return;
    updateProcessLogSidebarCollapseState(!state.isProcessLogSidebarCollapsed, instant);
    console.log(`右侧日志侧栏折叠状态切换为: ${state.isProcessLogSidebarCollapsed ? '已折叠' : '已展开'}`);
}


// ==========================================================================
// [ END OF FILE modules/layout_handler.js ]
// ==========================================================================
--- END: static/js/modules/layout_handler.js ---

--- START: static/js/modules/quick_actions_handler.js ---
// ==========================================================================
// [ START OF FILE modules/quick_actions_handler.js ]
// Quick Action Button Handling
// ==========================================================================

import dom from '../utils/dom_elements.js';
import state from '../core/state.js';
// handleSendMessage 不再需要从其他地方导入或假设全局存在
import { adjustTextareaHeight, updateCharCounter } from '../core/ui_updater.js';

/**
 * Attaches click event listeners to quick action buttons within a container.
 * @param {HTMLElement} container - The parent element containing quick action buttons.
 */
export function attachQuickActionButtonListeners(container) {
    container.querySelectorAll('.quick-action-btn').forEach(button => {
        button.removeEventListener('click', handleQuickActionButtonClick);
        button.addEventListener('click', handleQuickActionButtonClick);
    });
}

/**
 * Handles the click event of a quick action button.
 * Fills the user input with the button's message and optionally auto-submits by clicking the send button.
 * @param {MouseEvent} e - The click event.
 */
function handleQuickActionButtonClick(e) {
    e.preventDefault();
    const messageToSend = e.target.closest('.quick-action-btn').dataset.message;
    if (messageToSend) {
        dom.userInput.value = messageToSend;
        adjustTextareaHeight();
        updateCharCounter();
        dom.userInput.focus();
        if (state.autoSubmitQuickActions) {
            // 直接触发发送按钮的点击事件
            if(dom.sendButton) {
                dom.sendButton.click(); // 模拟点击发送按钮
            } else {
                console.error("发送按钮 (dom.sendButton) 未找到，无法自动提交快捷操作。");
            }
        }
    }
}

// ==========================================================================
// [ END OF FILE modules/quick_actions_handler.js ]
// ==========================================================================

--- END: static/js/modules/quick_actions_handler.js ---

--- START: static/js/modules/session_handler.js ---
// ==========================================================================
// [ START OF FILE modules/session_handler.js ]
// Session Management - Create, Switch, Delete, Load, Save, Render List
// ==========================================================================

import dom from '../utils/dom_elements.js';
import state from '../core/state.js';
import { sendWebSocketMessage } from '../core/websocket_manager.js';
import { appendMessage, appendWelcomeMessage, scrollToBottom, showToast } from '../core/ui_updater.js';
// APP_PREFIX 从 helpers.js 导入
import { generateSessionId, formatTimeSince, getModeDisplayName, APP_PREFIX } from '../utils/helpers.js';
import { updateSidebarState, updateSessionManagerState, showProcessLogSidebar, hideProcessLogSidebar } from './layout_handler.js';


export function initializeCurrentSessionUI(isInitialLoadOrConnect = false) {
    // 使用导入的 APP_PREFIX
    const lastSessionId = localStorage.getItem(APP_PREFIX + 'lastSessionId');
    let targetSessionId = state.currentSessionId;

    if (!targetSessionId) {
        if (lastSessionId && state.sessions[lastSessionId]) {
            targetSessionId = lastSessionId;
        } else if (Object.keys(state.sessions).length > 0) {
            const sortedSessions = Object.values(state.sessions).sort((a, b) => b.lastActivity - a.lastActivity);
            targetSessionId = sortedSessions[0].id;
        }
    }

    if (!targetSessionId || !state.sessions[targetSessionId]) {
        targetSessionId = createNewSession(true);
    }
    switchSession(targetSessionId, isInitialLoadOrConnect);
}

export function createNewSession(isInitialCreation = false) {
    const newId = generateSessionId();
    const now = Date.now();
    const sessionCount = Object.keys(state.sessions).length + 1;
    state.sessions[newId] = {
        id: newId,
        name: `光绘墨迹项目 ${sessionCount}`,
        messages: [],
        createdAt: now,
        lastActivity: now,
    };
    saveSessions();
    if (!isInitialCreation) {
        switchSession(newId, false);
        showToast('新光绘墨迹项目已创建!', 'success');
        if (!state.isSidebarExpanded) updateSidebarState(true);
        if (state.isSessionManagerCollapsed) updateSessionManagerState(false);
    }
    return newId;
}

export function switchSession(sessionId, isInitialLoadOrConnect = false) {
    if (!state.sessions[sessionId]) {
        console.error(`尝试切换到不存在的会话: ${sessionId}. 创建一个 fallback 会话.`);
        const fallbackId = createNewSession(true);
        state.currentSessionId = fallbackId;
    } else {
        state.currentSessionId = sessionId;
    }

    if (!isInitialLoadOrConnect) {
        sendWebSocketMessage({ type: 'init', session_id: state.currentSessionId });
    }

    // 使用导入的 APP_PREFIX
    localStorage.setItem(APP_PREFIX + 'lastSessionId', state.currentSessionId);
    if (state.sessions[state.currentSessionId]) {
        state.sessions[state.currentSessionId].lastActivity = Date.now();
    }
    saveSessions();

    dom.currentSessionNameDisplay.textContent = state.sessions[state.currentSessionId]?.name || "初始化墨迹...";
    dom.chatBox.innerHTML = '';

    if (state.sessions[state.currentSessionId]?.messages.length === 0) {
        appendWelcomeMessage();
    } else {
        state.sessions[state.currentSessionId]?.messages.forEach(msg => {
            appendMessage(msg.content, msg.sender, msg.isHTML, msg.thinking, true, msg.attachments, msg.errorType);
        });
    }
    scrollToBottom(true);
    renderSessionList();
    dom.userInput.focus();

    if (dom.processLogSidebarContent) dom.processLogSidebarContent.innerHTML = '';
    if (state.isProcessLogSidebarVisible) {
        showProcessLogSidebar(false);
    } else {
        hideProcessLogSidebar();
    }

    console.log(`切换到光绘墨迹项目: ${state.sessions[state.currentSessionId]?.name} (ID: ${state.currentSessionId})`);
    const currentSessionNameForPlaceholder = state.sessions[state.currentSessionId]?.name || '当前项目';
    dom.userInput.placeholder = `向Lumina核心发送指令 (${getModeDisplayName(state.currentMode)}模式，当前项目: ${currentSessionNameForPlaceholder})...`;
}

export function deleteSession(sessionId, event) {
    if (event) event.stopPropagation();
    if (!state.sessions[sessionId]) return;

    const sessionName = state.sessions[sessionId].name;
    if (!confirm(`归档光绘墨迹项目 "${sessionName}" (ID: ${sessionId})? 此操作不可逆转.`)) {
        return;
    }

    const listItem = dom.sessionList.querySelector(`li[data-session-id="${sessionId}"]`);
    if (listItem) {
        if (state.animationLevel !== 'none') {
            listItem.classList.add('animate__animated', 'animate__zoomOutLeft');
            listItem.style.setProperty('--animate-duration', '0.4s');
            listItem.addEventListener('animationend', () => listItem.remove(), { once: true });
        } else {
            listItem.remove();
        }
    }

    delete state.sessions[sessionId];

    if (state.currentSessionId === sessionId) {
        const remainingSessions = Object.values(state.sessions).sort((a, b) => b.lastActivity - a.lastActivity);
        if (remainingSessions.length > 0) {
            switchSession(remainingSessions[0].id, false);
        } else {
            const newFallbackId = createNewSession(true);
            switchSession(newFallbackId, false);
        }
    } else {
        saveSessions();
        renderSessionList();
    }
    showToast(`光绘墨迹项目 "${sessionName}" 已归档.`, 'info');
    if (Object.keys(state.sessions).length === 0 && dom.sessionList) renderSessionList();
}

export function handleEditSessionName() {
    const currentSession = state.sessions[state.currentSessionId];
    if (!currentSession) return;

    const newName = prompt(`重命名光绘墨迹项目 "${currentSession.name}":`, currentSession.name);
    if (newName && newName.trim() !== "" && newName.trim() !== currentSession.name) {
        currentSession.name = newName.trim().substring(0, 70);
        currentSession.lastActivity = Date.now();
        dom.currentSessionNameDisplay.textContent = currentSession.name;
        saveSessions();
        renderSessionList();
        showToast("光绘墨迹项目名称已更新.", "success");
        const currentSessionNameForPlaceholder = state.sessions[state.currentSessionId]?.name || '当前项目';
        dom.userInput.placeholder = `向Lumina核心发送指令 (${getModeDisplayName(state.currentMode)}模式，当前项目: ${currentSessionNameForPlaceholder})...`;
    }
}

export function renderSessionList() {
    if (!dom.sessionList) return;
    dom.sessionList.innerHTML = '';
    const sortedSessions = Object.values(state.sessions)
        .sort((a, b) => b.lastActivity - a.lastActivity);

    if (sortedSessions.length === 0) {
        const emptyItem = document.createElement('li');
        emptyItem.classList.add('session-list-empty');
        emptyItem.innerHTML = '<i class="fas fa-folder-open"></i> 无光绘项目';
        dom.sessionList.appendChild(emptyItem);
        return;
    }

    sortedSessions.forEach(session => {
        const listItem = document.createElement('li');
        listItem.classList.add('session-list-item');
        if (session.id === state.currentSessionId) {
            listItem.classList.add('active-session');
        }
        listItem.dataset.sessionId = session.id;

        const timeSinceLastActivity = formatTimeSince(session.lastActivity);
        const lastActivityDate = new Date(session.lastActivity);
        const createdDate = new Date(session.createdAt);
        listItem.title = `最后修改: ${timeSinceLastActivity} (${lastActivityDate.toLocaleString()})\n创建于: ${createdDate.toLocaleDateString()}`;

        const contentWrapper = document.createElement('div');
        contentWrapper.classList.add('session-item-content');
        const nameSpan = document.createElement('span');
        nameSpan.classList.add('session-name');
        nameSpan.textContent = session.name;
        const timeSpan = document.createElement('span');
        timeSpan.classList.add('session-time');
        timeSpan.textContent = timeSinceLastActivity;
        contentWrapper.appendChild(nameSpan);
        contentWrapper.appendChild(timeSpan);

        const deleteBtn = document.createElement('button');
        deleteBtn.classList.add('session-delete-btn', 'icon-btn');
        deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
        deleteBtn.title = "归档此光绘项目";
        deleteBtn.addEventListener('click', (e) => deleteSession(session.id, e));

        listItem.appendChild(contentWrapper);
        listItem.appendChild(deleteBtn);
        listItem.addEventListener('click', () => {
            if (state.currentSessionId !== session.id) switchSession(session.id, false);
        });
        dom.sessionList.appendChild(listItem);
    });
}

export function saveSessions() {
    try {
        // 使用导入的 APP_PREFIX
        localStorage.setItem(APP_PREFIX + 'sessions', JSON.stringify(state.sessions));
    } catch (e) {
        console.error("保存会话数据失败:", e);
        showToast("未能持久化会话数据. 归档异常.", "error");
    }
}

export function loadSessions() {
    // 使用导入的 APP_PREFIX
    const storedSessions = localStorage.getItem(APP_PREFIX + 'sessions');
    state.sessions = {};
    if (storedSessions) {
        try {
            const parsedSessions = JSON.parse(storedSessions);
            Object.keys(parsedSessions).forEach(id => {
                const s = parsedSessions[id];
                if (s && typeof s.id === 'string' && typeof s.name === 'string' && Array.isArray(s.messages)) {
                    state.sessions[id] = {
                        id: s.id,
                        name: s.name || "已归档项目",
                        messages: s.messages.map(m => ({
                            content: m.content || "",
                            sender: m.sender || "system",
                            timestamp: m.timestamp || Date.now(),
                            isHTML: m.isHTML || false,
                            attachments: m.attachments || [],
                            thinking: m.thinking || null,
                            rawResponseV1_PCP_CamelCase: m.rawResponseV1_PCP_CamelCase || m.rawResponseV1_3_2_CamelCase,
                            errorType: m.errorType,
                        })),
                        createdAt: s.createdAt || Date.now(),
                        lastActivity: s.lastActivity || Date.now(),
                    };
                } else {
                    console.warn("发现损坏的光绘墨迹归档数据, 已跳过:", id, s);
                }
            });
        } catch (e) {
            console.error("加载或解析会话数据失败 (归档损坏):", e);
            state.sessions = {};
            localStorage.removeItem(APP_PREFIX + 'sessions'); // 使用导入的 APP_PREFIX
            showToast("加载归档数据失败. 数据可能已损坏.", "error");
        }
    }
}

export function addMessageToCurrentSession(messageObject) {
    if (state.sessions[state.currentSessionId]) {
        if (messageObject.sender !== 'agent') {
            delete messageObject.rawResponseV1_PCP_CamelCase;
            delete messageObject.thinking;
        }
        if (messageObject.errorType === undefined || messageObject.errorType === null) {
            delete messageObject.errorType;
        }
        state.sessions[state.currentSessionId].messages.push(messageObject);
        saveSessions();
    } else {
        console.error("尝试向不存在的会话添加消息:", state.currentSessionId);
    }
}
// ==========================================================================
// [ END OF FILE modules/session_handler.js ]
// ==========================================================================
--- END: static/js/modules/session_handler.js ---

--- START: static/js/modules/settings_handler.js ---
// ==========================================================================
// [ START OF FILE modules/settings_handler.js ]
// Settings Modal Logic - Opening, Closing, Saving, Resetting
// ==========================================================================

import dom from '../utils/dom_elements.js';
import state, { savePersistentSettings, loadPersistentSettings } from '../core/state.js';
import { applyTheme, applyFontSize, applyAnimationLevel } from './theme_handler.js';
import { toggleThreeBlackHoleVisibility } from './three_visuals.js';
import { getThemeDisplayName, getModeDisplayName, APP_PREFIX } from '../utils/helpers.js'; 
import { updateSidebarState, updateSessionManagerState, applyFixedLogSidebarLayout, updateProcessLogSidebarCollapseState, showProcessLogSidebar, hideProcessLogSidebar } from './layout_handler.js';
import { showToast } from '../core/ui_updater.js';


/**
 * Populates the LLM model selection dropdown based on availability from backend.
 */
export function populateLLMModelSelect() { 
    if (!dom.llmModelSelect) {
        console.warn("LLM模型选择下拉框元素 (llm-model-select) 未找到。");
        return;
    }

    dom.llmModelSelect.innerHTML = ''; // 清空现有选项

    // 从 state.agentDefaultSettings 中获取包含可用性信息的模型列表
    const detailedLLMs = state.agentDefaultSettings?.detailed_available_llms;
    
    if (!detailedLLMs || !Array.isArray(detailedLLMs) || detailedLLMs.length === 0) {
        // 如果没有可用的模型信息，或者格式不正确，可以显示一个默认的或提示信息
        const defaultOption = document.createElement('option');
        defaultOption.value = state.agentDefaultSettings?.default_llm_identifier || "zhipu-ai";
        defaultOption.textContent = `默认 (${defaultOption.value === "zhipu-ai" ? "智谱GLM" : "未知"}) - 模型列表加载失败`;
        defaultOption.disabled = true; // 因为列表加载失败，所以禁用
        dom.llmModelSelect.appendChild(defaultOption);
        console.warn("未能从后端获取详细的可用LLM列表，或列表为空。");
        return;
    }
    
    detailedLLMs.forEach(modelInfo => {
        const option = document.createElement('option');
        option.value = modelInfo.id; 
        // 使用后端提供的 name 作为显示文本
        option.textContent = modelInfo.name || modelInfo.id; 
        
        if (modelInfo.available === false) { // 严格检查布尔值 false
            option.disabled = true;
            option.textContent += " (API Key未配置或不可用)"; // 附加提示信息
        } else {
            option.disabled = false;
        }
        dom.llmModelSelect.appendChild(option); 
    });

    // 设置下拉框的当前选中值为 state.selectedLLM 
    // 确保 state.selectedLLM 的值在可用且未禁用的选项中，否则选择第一个可用的
    let foundSelected = false;
    for (let i = 0; i < dom.llmModelSelect.options.length; i++) {
        if (dom.llmModelSelect.options[i].value === state.selectedLLM && !dom.llmModelSelect.options[i].disabled) {
            dom.llmModelSelect.value = state.selectedLLM;
            foundSelected = true;
            break;
        }
    }
    if (!foundSelected) { // 如果当前选中的模型不可用，则尝试选择默认模型，如果默认模型也不可用，则选第一个可用的
        let fallbackToDefault = false;
        const defaultIdentifier = state.agentDefaultSettings?.default_llm_identifier;
        for (let i = 0; i < dom.llmModelSelect.options.length; i++) {
            if (dom.llmModelSelect.options[i].value === defaultIdentifier && !dom.llmModelSelect.options[i].disabled) {
                dom.llmModelSelect.value = defaultIdentifier;
                state.selectedLLM = defaultIdentifier; // 更新state以反映实际选择
                fallbackToDefault = true;
                break;
            }
        }
        if (!fallbackToDefault) { // 如果默认模型也不可用，选择第一个可用的
            for (let i = 0; i < dom.llmModelSelect.options.length; i++) {
                if (!dom.llmModelSelect.options[i].disabled) {
                    dom.llmModelSelect.value = dom.llmModelSelect.options[i].value;
                    state.selectedLLM = dom.llmModelSelect.options[i].value; // 更新state
                    break;
                }
            }
        }
    }
    console.log(`模型选择UI已更新，当前选中: ${state.selectedLLM}`);
}


export function updateChineseDeepThinkingToggleState() { 
    const settingItem = document.getElementById('chinese-deep-thinking-setting-item');
    if (!settingItem || !dom.enableChineseDeepThinkingToggle) return;

    const globallyEnabled = state.agentDefaultSettings?.globally_enable_chinese_thinking;

    if (globallyEnabled === false) { 
        settingItem.style.display = 'none'; 
        settingItem.setAttribute('aria-hidden', 'true'); // For accessibility
        state.enableChineseDeepThinking = false; 
        dom.enableChineseDeepThinkingToggle.checked = false;
        dom.enableChineseDeepThinkingToggle.disabled = true; 
    } else {
        settingItem.style.display = 'flex'; 
        settingItem.setAttribute('aria-hidden', 'false');
        dom.enableChineseDeepThinkingToggle.disabled = false; 
        dom.enableChineseDeepThinkingToggle.checked = state.enableChineseDeepThinking;
    }
    console.log(`中文深度思考UI已更新，全局启用: ${globallyEnabled}, 当前用户偏好(开关状态): ${dom.enableChineseDeepThinkingToggle.checked}`);
}


export function openSettingsModal() {
    // 先从 state 中加载当前值到 UI 控件 (这些是localStorage加载或之前状态)
    if (dom.themeSelect) dom.themeSelect.value = state.currentTheme;
    const currentFontSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-font-size').replace('px', '')) || 16;
    if (dom.fontSizeInput) dom.fontSizeInput.value = currentFontSize;
    if (dom.fontSizeValue) dom.fontSizeValue.textContent = `${currentFontSize.toFixed(0)}px`;
    if (dom.animationLevelSelect) dom.animationLevelSelect.value = state.animationLevel;
    if (dom.autoScrollToggle) dom.autoScrollToggle.checked = state.autoScroll;
    if (dom.soundEnabledToggle) dom.soundEnabledToggle.checked = state.soundEnabled;
    if (dom.showChatBubblesThinkToggle) dom.showChatBubblesThinkToggle.checked = state.showChatBubblesThink;
    if (dom.showLogBubblesThinkToggle) dom.showLogBubblesThinkToggle.checked = state.showLogBubblesThink;
    if (dom.autoSubmitQuickActionsToggle) dom.autoSubmitQuickActionsToggle.checked = state.autoSubmitQuickActions;
    if (dom.componentVisibilityToggle) dom.componentVisibilityToggle.checked = state.isIdtComponentVisible;

    // 再调用这两个函数，它们会使用 state.agentDefaultSettings (由init_success填充) 和 state.selectedLLM/enableChineseDeepThinking 来正确设置UI
    populateLLMModelSelect(); 
    updateChineseDeepThinkingToggleState(); 

    dom.settingsModal.style.display = 'flex';
    const modalContent = dom.settingsModal.querySelector('.modal-content');
    modalContent.classList.remove('animate__fadeOutDown', 'animate__zoomOut', 'animate__fadeOut');
    const animIn = state.animationLevel !== 'none' ? (state.animationLevel === 'full' ? 'animate__zoomIn' : 'animate__fadeIn') : '';
    if (animIn) {
        modalContent.classList.add('animate__animated', animIn);
        modalContent.style.setProperty('--animate-duration', '0.45s');
    }
}

export function closeSettingsModal(revertChanges = true) {
    if (revertChanges) {
        loadPersistentSettings(); // 这会从localStorage加载，并可能覆盖当前的state值

        // 应用加载回来的设置到UI
        applyTheme(state.currentTheme, true); 
        applyFontSize(localStorage.getItem(APP_PREFIX + 'fontSize') || '16');
        applyAnimationLevel(state.animationLevel);

        if (dom.autoScrollToggle) dom.autoScrollToggle.checked = state.autoScroll;
        if (dom.soundEnabledToggle) dom.soundEnabledToggle.checked = state.soundEnabled;
        if (dom.showChatBubblesThinkToggle) dom.showChatBubblesThinkToggle.checked = state.showChatBubblesThink;
        if (dom.showLogBubblesThinkToggle) dom.showLogBubblesThinkToggle.checked = state.showLogBubblesThink;
        if (dom.autoSubmitQuickActionsToggle) dom.autoSubmitQuickActionsToggle.checked = state.autoSubmitQuickActions;
        if (dom.componentVisibilityToggle) dom.componentVisibilityToggle.checked = state.isIdtComponentVisible;
        
        // 确保模型和中文思考UI也恢复到保存的状态
        // loadPersistentSettings 已经更新了 state.selectedLLM 和 state.enableChineseDeepThinking
        populateLLMModelSelect();
        updateChineseDeepThinkingToggleState();

        toggleThreeBlackHoleVisibility(state.isIdtComponentVisible);
        const idtIcon = dom.idtComponentToggleBtn.querySelector('i');
        if (idtIcon) idtIcon.className = state.isIdtComponentVisible ? 'fas fa-eye-slash' : 'fas fa-atom';
    }

    const modalContent = dom.settingsModal.querySelector('.modal-content');
    modalContent.classList.remove('animate__zoomIn', 'animate__fadeIn');
    const animOut = state.animationLevel !== 'none' ? (state.animationLevel === 'full' ? 'animate__zoomOut' : 'animate__fadeOut') : '';

    const animationEndHandler = () => {
        dom.settingsModal.style.display = 'none';
        if (animOut) modalContent.classList.remove('animate__animated', animOut);
    };

    if (state.animationLevel !== 'none' && animOut) {
        modalContent.classList.add('animate__animated', animOut);
        modalContent.style.setProperty('--animate-duration', '0.35s');
        modalContent.addEventListener('animationend', animationEndHandler, { once: true });
    } else {
        animationEndHandler();
    }
}

export function collectAndSaveSettings() {
    applyTheme(dom.themeSelect.value); 
    applyFontSize(dom.fontSizeInput.value); 
    applyAnimationLevel(dom.animationLevelSelect.value); 

    state.autoScroll = dom.autoScrollToggle.checked;
    state.soundEnabled = dom.soundEnabledToggle.checked;
    state.showChatBubblesThink = dom.showChatBubblesThinkToggle.checked;
    state.showLogBubblesThink = dom.showLogBubblesThinkToggle.checked;
    state.autoSubmitQuickActions = dom.autoSubmitQuickActionsToggle.checked;
    state.isIdtComponentVisible = dom.componentVisibilityToggle.checked;
    toggleThreeBlackHoleVisibility(state.isIdtComponentVisible);

    dom.idtComponentToggleBtn.setAttribute('title', state.isIdtComponentVisible ? '停用核心投影' : '激活核心投影');
    const idtIcon = dom.idtComponentToggleBtn.querySelector('i');
    if (idtIcon) idtIcon.className = state.isIdtComponentVisible ? 'fas fa-eye-slash' : 'fas fa-atom';

    if (dom.llmModelSelect) {
        state.selectedLLM = dom.llmModelSelect.value;
    }
    if (dom.enableChineseDeepThinkingToggle) {
        if (state.agentDefaultSettings?.globally_enable_chinese_thinking !== false) {
            state.enableChineseDeepThinking = dom.enableChineseDeepThinkingToggle.checked;
        } else {
            state.enableChineseDeepThinking = false; 
        }
    }
    
    savePersistentSettings(); 
}

export function resetToDefaultSettings() {
    const defaults = {
        theme: 'auto-crystal',
        fontSize: '16',      
        animationLevel: 'full',
        autoScroll: true,
        soundEnabled: false,
        showChatBubblesThink: true,
        showLogBubblesThink: true,
        sidebarExpanded: window.innerWidth > 1024,
        sessionManagerCollapsed: false,
        isProcessLogSidebarVisible: false,
        isProcessLogSidebarCollapsed: true,
        autoSubmitQuickActions: true,
        currentMode: 'chat', 
        isIdtComponentVisible: true,
        idtComponentTopPercent: '2.5%',
        idtComponentLeftPercent: '1.8%',
        // 使用 agentDefaultSettings 中的值作为重置目标
        selectedLLM: state.agentDefaultSettings?.default_llm_identifier || 'zhipu-ai',
        enableChineseDeepThinking: state.agentDefaultSettings?.default_enable_chinese_thinking || false,
    };

    // 应用所有默认设置到 state 和 UI
    applyTheme(defaults.theme);
    applyFontSize(defaults.fontSize);
    applyAnimationLevel(defaults.animationLevel);
    state.autoScroll = defaults.autoScroll;
    state.soundEnabled = defaults.soundEnabled;
    state.showChatBubblesThink = defaults.showChatBubblesThink;
    state.showLogBubblesThink = defaults.showLogBubblesThink;
    state.autoSubmitQuickActions = defaults.autoSubmitQuickActions;
    state.currentMode = defaults.currentMode;
    state.isIdtComponentVisible = defaults.isIdtComponentVisible;
    toggleThreeBlackHoleVisibility(state.isIdtComponentVisible);

    updateSidebarState(defaults.sidebarExpanded, true);
    updateSessionManagerState(defaults.sessionManagerCollapsed, true);
    state.isProcessLogSidebarVisible = defaults.isProcessLogSidebarVisible;
    state.isProcessLogSidebarCollapsed = defaults.isProcessLogSidebarCollapsed;
    applyFixedLogSidebarLayout();
    updateProcessLogSidebarCollapseState(state.isProcessLogSidebarCollapsed, true);
    if (state.isProcessLogSidebarVisible) showProcessLogSidebar(false); else hideProcessLogSidebar();

    dom.idtComponentToggleBtn.setAttribute('title', state.isIdtComponentVisible ? '停用核心投影' : '激活核心投影');
    const idtIcon = dom.idtComponentToggleBtn.querySelector('i');
    if (idtIcon) idtIcon.className = state.isIdtComponentVisible ? 'fas fa-eye-slash' : 'fas fa-atom';

    document.documentElement.style.setProperty('--idt-offset-top-percentage', defaults.idtComponentTopPercent);
    document.documentElement.style.setProperty('--idt-offset-left-percentage', defaults.idtComponentLeftPercent);

    // 更新UI控件以反映默认值
    if (dom.themeSelect) dom.themeSelect.value = defaults.theme;
    if (dom.fontSizeInput) dom.fontSizeInput.value = defaults.fontSize;
    if (dom.fontSizeValue) dom.fontSizeValue.textContent = `${defaults.fontSize}px`;
    if (dom.animationLevelSelect) dom.animationLevelSelect.value = defaults.animationLevel;
    if (dom.autoScrollToggle) dom.autoScrollToggle.checked = defaults.autoScroll;
    if (dom.soundEnabledToggle) dom.soundEnabledToggle.checked = defaults.soundEnabled;
    if (dom.showChatBubblesThinkToggle) dom.showChatBubblesThinkToggle.checked = defaults.showChatBubblesThink;
    if (dom.showLogBubblesThinkToggle) dom.showLogBubblesThinkToggle.checked = defaults.showLogBubblesThink;
    if (dom.autoSubmitQuickActionsToggle) dom.autoSubmitQuickActionsToggle.checked = defaults.autoSubmitQuickActions;
    if (dom.componentVisibilityToggle) dom.componentVisibilityToggle.checked = defaults.isIdtComponentVisible;

    // 重置模型选择和中文思考的状态和UI
    state.selectedLLM = defaults.selectedLLM;
    state.enableChineseDeepThinking = defaults.enableChineseDeepThinking;
    populateLLMModelSelect(); // 这会根据新的 state.selectedLLM 和 agentDefaultSettings.detailed_available_llms 更新UI
    updateChineseDeepThinkingToggleState(); // 这会根据新的 state.enableChineseDeepThinking 和全局设置更新UI

    dom.sidebarButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.mode === defaults.currentMode));
    const sessionNameForPlaceholder = state.sessions[state.currentSessionId]?.name || '当前项目';
    dom.userInput.placeholder = `向Lumina核心发送指令 (${getModeDisplayName(state.currentMode)}模式，当前项目: ${sessionNameForPlaceholder})...`;

    savePersistentSettings();
    showToast('系统参数已恢复为默认光绘配置!', 'success');
}
// ==========================================================================
// [ END OF FILE modules/settings_handler.js ]
// ==========================================================================
--- END: static/js/modules/settings_handler.js ---

--- START: static/js/modules/theme_handler.js ---
// ==========================================================================
// [ START OF FILE modules/theme_handler.js ]
// Theme, Font Size, and Animation Level Management
// ==========================================================================

import dom from '../utils/dom_elements.js';
import state from '../core/state.js';
import { savePersistentSettings } from '../core/state.js'; // For saving after user interaction if not initial load
import { getThemeDisplayName } from '../utils/helpers.js'; // For toast messages

/**
 * Applies the specified theme.
 * @param {string} themeName - 'light-crystal', 'dark-crystal', 'auto-crystal'.
 * @param {boolean} [initialLoad=false] - Is this the initial load?
 */
export function applyTheme(themeName, initialLoad = false) {
    const body = document.body;
    body.classList.remove('light-crystal-active', 'dark-crystal-active');
    const themeIcon = dom.themeToggleButton.querySelector('i');

    if (themeName === 'auto-crystal') {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            body.classList.add('dark-crystal-active');
        } else {
            body.classList.add('light-crystal-active');
        }
        if (themeIcon) themeIcon.className = 'fas fa-magic';
    } else if (themeName === 'dark-crystal') {
        body.classList.add('dark-crystal-active');
        if (themeIcon) themeIcon.className = 'fas fa-sun';
    } else { // light-crystal
        body.classList.add('light-crystal-active');
        if (themeIcon) themeIcon.className = 'fas fa-moon';
    }
    body.dataset.theme = themeName;
    state.currentTheme = themeName;
    if (dom.themeSelect) dom.themeSelect.value = themeName;

    if (!initialLoad) savePersistentSettings(); // Save if user changed it
    console.log(`显示模式已设定为: ${themeName} (实际生效类: ${body.className.match(/(light|dark)-crystal-active/)?.[0] || '无特定激活类'})`);
}

/**
 * Applies the current theme based on state.
 * Convenience function for initial load or when theme name isn't directly passed.
 */
export function applyCurrentTheme() {
    applyTheme(state.currentTheme, true); // true for initial load
}


/**
 * Applies the specified font size.
 * @param {string|number} size - Font size value (e.g., '16').
 */
export function applyFontSize(size) {
    const newSize = parseInt(size, 10);
    if (isNaN(newSize) || newSize < 12 || newSize > 20) {
        document.documentElement.style.setProperty('--base-font-size', '16px');
        if (dom.fontSizeInput) dom.fontSizeInput.value = '16';
        if (dom.fontSizeValue) dom.fontSizeValue.textContent = '16px';
        return;
    }
    document.documentElement.style.setProperty('--base-font-size', `${newSize}px`);
    if (dom.fontSizeInput) dom.fontSizeInput.value = newSize;
    if (dom.fontSizeValue) dom.fontSizeValue.textContent = `${newSize.toFixed(0)}px`;
}

/**
 * Applies the specified animation level.
 * @param {string} level - 'full', 'basic', 'none'.
 */
export function applyAnimationLevel(level) {
    document.body.dataset.animationLevel = level;
    state.animationLevel = level;
    if (dom.animationLevelSelect && dom.animationLevelSelect.value !== level) {
        dom.animationLevelSelect.value = level;
    }
    console.log(`动态效果等级已设定为: ${level}`);
}

// ==========================================================================
// [ END OF FILE modules/theme_handler.js ]
// ==========================================================================
--- END: static/js/modules/theme_handler.js ---

--- START: static/js/modules/three_visuals.js ---
// ==========================================================================
// [ START OF FILE modules/three_visuals.js ]
// Three.js Black Hole Visual Effect Management and Dragging
// ==========================================================================

import dom from '../utils/dom_elements.js';
import state from '../core/state.js';
import { showToast } from '../core/ui_updater.js'; // For error reporting

const APP_PREFIX = 'CircuitManusPro_LuminaScript_';

/**
 * Initializes the Three.js black hole effect.
 * @param {HTMLElement} container - The DOM element for the Three.js canvas.
 */
export function initThreeBlackHole(container) {
    if (state.threeJsInitialized) {
        if (!state.threeJsAnimationId && state.isIdtComponentVisible) {
            animateThreeBlackHole(); // Restart animation if component is visible
        }
        return;
    }
    if (!container) {
        console.error("Three.js: Container element not found for black hole.");
        return;
    }
    if (typeof THREE === 'undefined') {
        console.error("Three.js library is not loaded.");
        showToast("错误: 3D核心组件库未能加载。", "error", 5000);
        return;
    }

    state.threeJsScene = new THREE.Scene();
    state.threeJsCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 2000);
    state.threeJsCamera.position.z = 60;

    state.threeJsRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    state.threeJsRenderer.setSize(container.clientWidth, container.clientHeight);
    state.threeJsRenderer.setPixelRatio(window.devicePixelRatio);
    container.querySelectorAll('canvas').forEach(canvas => canvas.remove()); // Clear previous
    container.appendChild(state.threeJsRenderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xaaaaaa, 0.5);
    state.threeJsScene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 1, 500);
    pointLight.position.set(0, 20, 30);
    state.threeJsScene.add(pointLight);

    state.threeBlackHoleGroup = new THREE.Group();
    const sphereRadius = 12;
    const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 48, 48);
    const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.8, metalness: 0.1 });
    const eventHorizon = new THREE.Mesh(sphereGeometry, sphereMaterial);
    state.threeBlackHoleGroup.add(eventHorizon);

    const diskColors = [0xff6600, 0xff9933, 0xffcc66];
    const diskOpacities = [0.6, 0.7, 0.8];
    const diskRadii = [sphereRadius + 7, sphereRadius + 14, sphereRadius + 21];
    const diskTubeRadii = [2.5, 3.5, 4.5];
    const diskRotationSpeeds = [0.01, -0.008, 0.012];

    // Initialize with dummy objects to avoid null checks later if creation fails
    state.threeAccretionDiskOuter = new THREE.Mesh();
    state.threeAccretionDiskMiddle = new THREE.Mesh();
    state.threeAccretionDiskInner = new THREE.Mesh();

    [state.threeAccretionDiskOuter, state.threeAccretionDiskMiddle, state.threeAccretionDiskInner] = diskRadii.map((radius, i) => {
        const diskMaterial = new THREE.MeshPhongMaterial({
            color: diskColors[i],
            emissive: new THREE.Color(diskColors[i]).multiplyScalar(0.5),
            specular: 0x333333, shininess: 20,
            side: THREE.DoubleSide, transparent: true, opacity: diskOpacities[i],
            blending: THREE.AdditiveBlending
        });
        const disk = new THREE.Mesh(new THREE.TorusGeometry(radius, diskTubeRadii[i], 16, 60), diskMaterial);
        disk.rotation.x = Math.PI / 1.8;
        disk.userData.rotationSpeed = diskRotationSpeeds[i];
        state.threeBlackHoleGroup.add(disk);
        return disk;
    });

    const starGeometry = new THREE.BufferGeometry();
    const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff, size: 0.25, transparent: true, opacity: 0.7,
        sizeAttenuation: true, blending: THREE.AdditiveBlending
    });
    const starVertices = [];
    for (let i = 0; i < 3000; i++) {
        const x = THREE.MathUtils.randFloatSpread(500);
        const y = THREE.MathUtils.randFloatSpread(500);
        const z = THREE.MathUtils.randFloatSpread(500);
        starVertices.push(x, y, z);
    }
    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
    state.threeStarField = new THREE.Points(starGeometry, starMaterial);
    state.threeJsScene.add(state.threeStarField);

    state.threeJsScene.add(state.threeBlackHoleGroup);
    state.threeJsInitialized = true;
    animateThreeBlackHole();
    console.log("Three.js black hole initialized successfully.");
}

/**
 * Animation loop for the Three.js black hole.
 */
export function animateThreeBlackHole() {
    if (!state.threeJsInitialized || !state.isIdtComponentVisible) {
        if (state.threeJsAnimationId) cancelAnimationFrame(state.threeJsAnimationId);
        state.threeJsAnimationId = null;
        return;
    }
    state.threeJsAnimationId = requestAnimationFrame(animateThreeBlackHole);

    if (state.threeBlackHoleGroup) {
        state.threeBlackHoleGroup.rotation.y += 0.0015;
        state.threeBlackHoleGroup.rotation.x += 0.0007;
    }
    if (state.threeAccretionDiskOuter) state.threeAccretionDiskOuter.rotation.z += state.threeAccretionDiskOuter.userData.rotationSpeed;
    if (state.threeAccretionDiskMiddle) state.threeAccretionDiskMiddle.rotation.z += state.threeAccretionDiskMiddle.userData.rotationSpeed;
    if (state.threeAccretionDiskInner) state.threeAccretionDiskInner.rotation.z += state.threeAccretionDiskInner.userData.rotationSpeed;
    if (state.threeStarField) {
        state.threeStarField.rotation.x += 0.0001;
        state.threeStarField.rotation.y += 0.00015;
    }

    if (state.threeJsRenderer && state.threeJsScene && state.threeJsCamera) {
        state.threeJsRenderer.render(state.threeJsScene, state.threeJsCamera);
    }
}

/**
 * Toggles the visibility of the Three.js scene and animation.
 * @param {boolean} isVisible - True to show, false to hide.
 */
export function toggleThreeBlackHoleVisibility(isVisible) {
    if (!dom.idtComponentWrapper) return;
    dom.idtComponentWrapper.classList.toggle('is-visible', isVisible);
    state.isIdtComponentVisible = isVisible; // Update state

    if (isVisible) {
        if (!state.threeJsInitialized) {
            initThreeBlackHole(dom.idtComponentWrapper);
        } else if (!state.threeJsAnimationId) { // Already initialized, but animation might be stopped
            animateThreeBlackHole();
        }
    } else { // Hiding
        if (state.threeJsAnimationId) {
            cancelAnimationFrame(state.threeJsAnimationId);
            state.threeJsAnimationId = null;
        }
    }
    // Persisting isIdtComponentVisible is handled by settings_handler or event_listener_setup
}


/**
 * Handles mousedown on the 3D component for dragging.
 * @param {MouseEvent} e
 */
export function handleComponentMouseDown(e) {
    if (!dom.idtComponentWrapper.classList.contains('is-visible') || e.button !== 0) { return; }
    state.isDraggingComponent = true;
    dom.idtComponentWrapper.style.cursor = 'grabbing';
    document.body.style.userSelect = 'none';

    const styles = getComputedStyle(document.documentElement);
    const currentTopPercent = parseFloat(styles.getPropertyValue('--idt-offset-top-percentage').replace('%','')) || 0;
    const currentLeftPercent = parseFloat(styles.getPropertyValue('--idt-offset-left-percentage').replace('%','')) || 0;

    state.componentInitialTopPx = (dom.idtComponentWrapper.style.top && dom.idtComponentWrapper.style.top.endsWith('px'))
        ? parseFloat(dom.idtComponentWrapper.style.top)
        : (currentTopPercent / 100) * window.innerHeight;
    state.componentInitialLeftPx = (dom.idtComponentWrapper.style.left && dom.idtComponentWrapper.style.left.endsWith('px'))
        ? parseFloat(dom.idtComponentWrapper.style.left)
        : (currentLeftPercent / 100) * window.innerWidth;

    state.componentDragStartX = e.clientX;
    state.componentDragStartY = e.clientY;

    document.addEventListener('mousemove', handleComponentMouseMove);
    document.addEventListener('mouseup', handleComponentMouseUp);
    document.addEventListener('mouseleave', handleComponentMouseUp); // If mouse leaves window
    e.preventDefault();
}

/**
 * Handles mousemove during 3D component dragging.
 * @param {MouseEvent} e
 */
export function handleComponentMouseMove(e) {
    if (!state.isDraggingComponent) return;
    const deltaX = e.clientX - state.componentDragStartX;
    const deltaY = e.clientY - state.componentDragStartY;

    let newTopPx = state.componentInitialTopPx + deltaY;
    let newLeftPx = state.componentInitialLeftPx + deltaX;

    const componentRect = dom.idtComponentWrapper.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    newTopPx = Math.max(0, Math.min(newTopPx, viewportHeight - componentRect.height));
    newLeftPx = Math.max(0, Math.min(newLeftPx, viewportWidth - componentRect.width));

    dom.idtComponentWrapper.style.top = `${newTopPx}px`;
    dom.idtComponentWrapper.style.left = `${newLeftPx}px`;
}

/**
 * Handles mouseup to end 3D component dragging.
 */
export function handleComponentMouseUp() {
    if (!state.isDraggingComponent) return;
    state.isDraggingComponent = false;
    dom.idtComponentWrapper.style.cursor = 'grab';
    document.body.style.userSelect = '';
    document.removeEventListener('mousemove', handleComponentMouseMove);
    document.removeEventListener('mouseup', handleComponentMouseUp);
    document.removeEventListener('mouseleave', handleComponentMouseUp);

    // Convert final pixel position to percentage and store
    const finalTopPx = parseFloat(dom.idtComponentWrapper.style.top) || 0;
    const finalLeftPx = parseFloat(dom.idtComponentWrapper.style.left) || 0;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    const componentWidthPercent = (dom.idtComponentWrapper.offsetWidth / viewportWidth) * 100;
    const componentHeightPercent = (dom.idtComponentWrapper.offsetHeight / viewportHeight) * 100;

    let newTopPercent = (finalTopPx / viewportHeight) * 100;
    let newLeftPercent = (finalLeftPx / viewportWidth) * 100;

    // Re-clamp percentages
    newTopPercent = Math.max(0, Math.min(newTopPercent, 100 - componentHeightPercent));
    newLeftPercent = Math.max(0, Math.min(newLeftPercent, 100 - componentWidthPercent));

    document.documentElement.style.setProperty('--idt-offset-top-percentage', `${newTopPercent.toFixed(2)}%`);
    document.documentElement.style.setProperty('--idt-offset-left-percentage', `${newLeftPercent.toFixed(2)}%`);

    // Clear inline styles so CSS vars take over
    dom.idtComponentWrapper.style.top = '';
    dom.idtComponentWrapper.style.left = '';

    localStorage.setItem(APP_PREFIX + 'idtComponentTopPercent', `${newTopPercent.toFixed(2)}%`);
    localStorage.setItem(APP_PREFIX + 'idtComponentLeftPercent', `${newLeftPercent.toFixed(2)}%`);
}


// ==========================================================================
// [ END OF FILE modules/three_visuals.js ]
// ==========================================================================
--- END: static/js/modules/three_visuals.js ---

--- START: static/js/utils/dom_elements.js ---
// ==========================================================================
// [ START OF FILE utils/dom_elements.js ]
// DOM Element Cache - 集中获取和管理所有DOM元素的引用。
// ==========================================================================

// 使用 const 声明 dom 对象，确保其在模块作用域内不被意外重新赋值。
// 立即执行函数 (IIFE) 用于封装DOM查询逻辑，确保在模块加载时执行一次。
const domElements = (() => {
    // 返回一个包含所有DOM元素引用的对象
    return {
        // 动态背景相关
        dynamicBackground: document.querySelector('.dynamic-crystal-background'),
        // 加载动画相关
        loader: document.getElementById('loader'),
        loaderCore: document.querySelector('.lumina-loader-core'),
        mainContainer: document.getElementById('main-container'),
        appBodyContainer: document.getElementById('appBodyContainer'),
        // 聊天核心区域
        chatArea: document.getElementById('chat-area'),
        chatBox: document.getElementById('chat-box'),
        userInput: document.getElementById('user-input'),
        sendButton: document.getElementById('send-button'),
        sendIcon: document.querySelector('.send-icon'),
        sendLoadingIcon: document.querySelector('.send-loading-icon'),
        // 头部与主题
        appHeader: document.getElementById('app-header'),
        themeToggleButton: document.getElementById('theme-toggle'),
        themeToggleIcon: document.querySelector('#theme-toggle i'),
        clearChatButton: document.getElementById('clear-chat'),
        leftSidebarToggle: document.getElementById('left-sidebar-toggle'),
        toggleProcessLogVisibilityButton: document.getElementById('toggle-process-log-visibility'),
        // 侧边栏与会话管理 (左侧边栏)
        sidebar: document.getElementById('sidebar'),
        sidebarButtons: document.querySelectorAll('.sidebar-button'),
        sessionManager: document.getElementById('session-manager'),
        sessionManagerToggle: document.getElementById('session-manager-toggle'),
        sessionListContainer: document.getElementById('session-list-container'),
        sessionList: document.getElementById('session-list'),
        createNewSessionButton: document.getElementById('create-new-session'),
        currentSessionNameDisplay: document.getElementById('current-session-name'),
        editSessionNameButton: document.getElementById('edit-session-name-btn'),
        // 输入区域与文件上传
        inputArea: document.getElementById('input-area'),
        attachButton: document.getElementById('attach-button'),
        micButton: document.getElementById('mic-button'),
        charCounter: document.getElementById('char-counter'),
        fileInput: document.getElementById('file-input'),
        filePreviewArea: document.getElementById('file-preview'),
        filePreviewContent: document.getElementById('file-preview-content'),
        closeFilePreviewButton: document.getElementById('close-preview'),
        // Toast 通知
        toastContainer: document.getElementById('toast-container'),
        // Agent 处理过程日志区域 (右侧悬浮侧栏)
        processLogSidebarContainer: document.getElementById('agent-process-sidebar'),
        processLogSidebarHeader: document.querySelector('#agent-process-sidebar .process-log-header'),
        processLogSidebarContent: document.getElementById('process-log-content-sidebar'),
        toggleProcessLogSidebarCollapseButton: document.getElementById('toggle-process-log-sidebar-collapse'),
        closeProcessLogSidebarButton: document.getElementById('close-process-log-sidebar'),
        // 设置模态框相关
        settingsModal: document.getElementById('settings-modal'),
        openSettingsButton: document.querySelector('.sidebar-button[data-mode="settings"]'),
        closeSettingsButton: document.getElementById('close-settings'),
        themeSelect: document.getElementById('theme-select'),
        fontSizeInput: document.getElementById('font-size'),
        fontSizeValue: document.getElementById('font-size-value'),
        animationLevelSelect: document.getElementById('animation-level'),
        autoScrollToggle: document.getElementById('auto-scroll'),
        soundEnabledToggle: document.getElementById('sound-enabled'),
        showChatBubblesThinkToggle: document.getElementById('show-chat-bubbles-think'),
        showLogBubblesThinkToggle: document.getElementById('show-log-bubbles-think'),
        autoSubmitQuickActionsToggle: document.getElementById('auto-submit-quick-actions'),
        componentVisibilityToggle: document.getElementById('component-visibility-toggle'),
        resetSettingsButton: document.getElementById('reset-settings'),
        saveSettingsButton: document.getElementById('save-settings'),
        // 3D组件显示开关与包装器
        idtComponentToggleBtn: document.getElementById('toggleIdtComponentBtn'),
        idtComponentWrapper: document.getElementById('idtTechComponentWrapper')
    };
})();

// 默认导出 domElements 对象，以便其他模块可以导入和使用。
// 使用 ES6 模块导出语法。
export default domElements;
// ==========================================================================
// [ END OF FILE utils/dom_elements.js ]
// ==========================================================================
--- END: static/js/utils/dom_elements.js ---

--- START: static/js/utils/helpers.js ---
// ==========================================================================
// [ START OF FILE utils/helpers.js ]
// 通用辅助函数库
// ==========================================================================

// 定义并导出应用前缀常量 - 这是 APP_PREFIX 的唯一真实来源
export const APP_PREFIX = 'CircuitManusPro_LuminaScript_';

/**
 * 生成唯一的会话ID。
 * @returns {string} 生成的会话ID。
 */
export function generateSessionId() {
    return `session_lumina_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 12)}`;
}

/**
 * 生成唯一的客户端请求ID。
 * @returns {string} 生成的请求ID。
 */
export function generateClientRequestId() {
    return `creq_lumina_proc_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 10)}`;
}

/**
 * 格式化时间戳为用户友好的相对时间字符串。
 * @param {number} dateTimestamp - 时间戳。
 * @returns {string} 格式化后的时间字符串。
 */
export function formatTimeSince(dateTimestamp) {
    const now = new Date();
    const secondsPast = (now.getTime() - dateTimestamp) / 1000;

    if (secondsPast < 60) return '刚刚';
    if (secondsPast < 3600) return `${Math.round(secondsPast / 60)}分前`;
    if (secondsPast <= 86400) return `${Math.round(secondsPast / 3600)}时前`;

    const daysPast = Math.round(secondsPast / 86400);
    if (daysPast === 1) return '昨天';
    if (daysPast < 7) return `${daysPast}天前`;

    const date = new Date(dateTimestamp);
    if (now.getFullYear() === date.getFullYear()) {
        return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
    }
    return date.toLocaleDateString(undefined, { year: '2-digit', month: 'short', day: 'numeric' });
}

/**
 * 根据文件类型和名称获取对应的FontAwesome图标类。
 * @param {string} fileType - 文件的MIME类型。
 * @param {string} fileName - 文件名。
 * @returns {string} FontAwesome图标类名。
 */
export function getFileIconClass(fileType, fileName) {
    if (fileType.startsWith('image/')) return 'fa-file-image';
    if (fileType.startsWith('audio/')) return 'fa-file-audio';
    if (fileType.startsWith('video/')) return 'fa-file-video';
    if (fileType === 'application/pdf') return 'fa-file-pdf';
    if (fileType === 'application/zip' || fileName.endsWith('.zip') || fileName.endsWith('.rar') || fileName.endsWith('.7z')) return 'fa-file-archive';

    const ext = fileName.slice(fileName.lastIndexOf(".")).toLowerCase();
    const codeExtensions = ['.js', '.ts', '.py', '.java', '.c', '.cpp', '.h', '.hpp', '.cs', '.html', '.css', '.json', '.xml', '.yaml', '.yml', '.sh', '.bat', '.v', '.sv', '.vhd', '.md', '.txt', '.log', '.sch', '.brd', '.cir', '.net', '.vhd'];
    if (codeExtensions.includes(ext) || fileType.includes('text')) return 'fa-file-code';
    if (['.doc', '.docx'].includes(ext)) return 'fa-file-word';
    if (['.xls', '.xlsx', '.csv'].includes(ext)) return 'fa-file-excel';
    if (['.ppt', '.pptx'].includes(ext)) return 'fa-file-powerpoint';
    if (['.dwg', '.dxf'].includes(ext)) return 'fa-drafting-compass';
    return 'fa-file-alt'; // Default icon
}

/**
 * 总结工具调用的参数对象，用于日志显示。
 * @param {object} argsObj - 工具参数对象。
 * @returns {string} 参数的简短字符串表示。
 */
export function summarizeArguments(argsObj) {
    if (!argsObj || typeof argsObj !== 'object' || Object.keys(argsObj).length === 0) {
        return "(无参数)";
    }
    try {
        return JSON.stringify(argsObj, (key, value) => {
            if (typeof value === 'string' && value.length > 40) {
                return value.substring(0, 37) + "...";
            }
            return value;
        }).substring(0, 200);
    } catch (e) {
        console.warn("总结参数时发生错误:", e);
        return "(参数总结出错)";
    }
}

/**
 * 解析日志项的CSS类字符串，提取类型、阶段和状态。
 * @param {string} itemClassesStr - 包含多个CSS类的字符串。
 * @returns {object} 解析后的对象，包含 type, stage, status 属性。
 */
export function parseItemClasses(itemClassesStr) {
    const classes = itemClassesStr ? itemClassesStr.split(' ') : [];
    const parsed = { type: null, stage: null, status: null };
    classes.forEach(cls => {
        if (cls.startsWith('type-')) parsed.type = cls.substring(5);
        else if (cls.startsWith('stage-')) parsed.stage = cls.substring(6);
        else if (cls.startsWith('status-')) parsed.status = cls.substring(7);
        else if (cls.startsWith('phase-')) parsed.stage = cls.substring(6); // Compatibility
    });
    return parsed;
}

/**
 * 获取当前模式的用户友好显示名称。
 * @param {string} mode - 模式的内部标识符。
 * @returns {string} 模式的显示名称。
 */
export function getModeDisplayName(mode) {
    const names = { chat: '灵感交流', code: '代码绘卷', circuit: '电路拓印', settings: '参数调校' };
    return names[mode] || '未知领域';
}

/**
 * 获取当前主题的用户友好显示名称。
 * @param {string} theme - 主题的内部标识符。
 * @returns {string} 主题的显示名称。
 */
export function getThemeDisplayName(theme) {
    const names = {
        'light-crystal': '月白宣纸 (Light)',
        'dark-crystal': '墨黑星空 (Dark)',
        'auto-crystal': '随境而变 (Auto)'
    };
    return names[theme] || '未知意境';
}

/**
 * 格式化日志项的详细信息对象为HTML字符串。
 * @param {object} details - 包含详细信息的对象。
 * @param {string|null} type - 日志项类型。
 * @param {string|null} stage - 日志项阶段。
 * @param {string|null} status - 日志项状态。
 * @returns {string|null} 格式化后的HTML字符串，如果无有效细节则返回null。
 */
export function formatLogDetails(details, type, stage, status) {
    if (!details || typeof details !== 'object' || Object.keys(details).length === 0) {
        return null;
    }
    let html = '';
    const formatRecursive = (obj, currentType, currentStage, currentStatus, indentLevel = 0) => {
        let partHtml = '';
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                const value = obj[key];
                const displayKey = key
                    .replace(/([A-Z])/g, " $1")
                    .replace(/_/g, ' ')
                    .trim()
                    .replace(/\b\w/g, char => char.toUpperCase());
                const paddingLeftStyle = `padding-left: ${indentLevel * 10}px;`;

                if ((type === 'plan_details' || type === 'tool_status_update') && key === 'tool_call_id') {
                    continue;
                }

                if (key === 'uiHints' && typeof value === 'object' && value !== null) {
                    const dn = String(value.displayNameForTool || 'N/A').replace(/</g, "<").replace(/>/g, ">");
                    const ed = String(value.estimatedDurationCategory || 'N/A').replace(/</g, "<").replace(/>/g, ">");
                    const spg = value.showProgressGranularly !== undefined ? `, 细粒度进度: ${value.showProgressGranularly ? '是' : '否'}` : '';
                    partHtml += `<div class="log-detail-item" style="${paddingLeftStyle}"><strong class="log-detail-key">UI投影:</strong> <span class="log-detail-value">显示: ${dn}, 时长: ${ed}${spg}</span></div>`;
                } else if (key === 'result_data_preview' && typeof value === 'string') {
                    let previewContent = String(value).replace(/</g, "<").replace(/>/g, ">");
                    partHtml += `<div class="log-detail-item" style="${paddingLeftStyle}"><strong class="log-detail-key">结果预览:</strong> <pre class="log-detail-raw-json"><code>${previewContent}</code></pre></div>`;
                } else if ((type === 'plan_details' || type === 'tool_status_update') && (key === 'arguments' || key === 'toolArguments') && typeof value === 'object' && value !== null) {
                    let argItems = [];
                    for (const argKey in value) {
                        const formattedArgKey = argKey.replace(/_/g, ' ').replace(/\b\w/g, char => char.toUpperCase());
                        const argValue = value[argKey];
                        let formattedArgValue;
                        if (typeof argValue === 'object' && argValue !== null) {
                            try { formattedArgValue = JSON.stringify(argValue).replace(/</g, "<").replace(/>/g, ">"); }
                            catch (e) { formattedArgValue = String(argValue).replace(/</g, "<").replace(/>/g, ">") + " (JSON error)"; }
                        } else {
                            formattedArgValue = String(argValue).replace(/</g, "<").replace(/>/g, ">");
                        }
                        argItems.push(`<em class="log-arg-key">${formattedArgKey}</em>: ${formattedArgValue}`);
                    }
                    partHtml += `<div class="log-detail-item" style="${paddingLeftStyle}"><strong class="log-detail-key">${displayKey}:</strong> <span class="log-detail-value">${argItems.join('; ')}</span></div>`;
                } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                    partHtml += `<div class="log-detail-item log-detail-object-header" style="${paddingLeftStyle}"><strong class="log-detail-key">${displayKey}:</strong></div>`;
                    partHtml += formatRecursive(value, currentType, currentStage, currentStatus, indentLevel + 1);
                } else if (Array.isArray(value)) {
                    const arrayItems = value.map(item => {
                        if (typeof item === 'object' && item !== null) return JSON.stringify(item).replace(/</g, "<").replace(/>/g, ">");
                        return String(item).replace(/</g, "<").replace(/>/g, ">");
                    });
                    partHtml += `<div class="log-detail-item" style="${paddingLeftStyle}"><strong class="log-detail-key">${displayKey}:</strong> <span class="log-detail-value log-detail-array">[${arrayItems.join(', ')}]</span></div>`;
                } else {
                    const sanitizedValue = String(value).replace(/</g, "<").replace(/>/g, ">");
                    partHtml += `<div class="log-detail-item" style="${paddingLeftStyle}"><strong class="log-detail-key">${displayKey}:</strong> <span class="log-detail-value">${sanitizedValue}</span></div>`;
                }
            }
        }
        return partHtml;
    };
    html = formatRecursive(details, type, stage, status, 0);
    return html || null;
}
// ==========================================================================
// [ END OF FILE utils/helpers.js ]
// ==========================================================================
--- END: static/js/utils/helpers.js ---

--- START: tests/test_agent.py ---

--- END: tests/test_agent.py ---

--- START: tests/test_circuit_tools.py ---

--- END: tests/test_circuit_tools.py ---

--- START: tests/__init__.py ---
# IDT_AGENT_Pro/tests/__init__.py
# This file makes Python treat the `tests` directory as a package.
--- END: tests/__init__.py ---

